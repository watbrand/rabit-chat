var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// shared/ads-schema.ts
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp, integer, bigint, boolean, unique, index, pgEnum, real, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var advertiserStatusEnum, advertiserVerificationStatusEnum, campaignObjectiveEnum, campaignStatusEnum, adGroupStatusEnum, adStatusEnum, adFormatEnum, adPlacementEnum, billingModelEnum, budgetTypeEnum, pacingTypeEnum, reviewActionEnum, walletTransactionTypeEnum, walletTransactionStatusEnum, adEventTypeEnum, conversionTypeEnum, attributionModelEnum, audienceTypeEnum, diagnosticIssueEnum, achievementTypeEnum, adAuditActionEnum, adDisputeStatusEnum, adDisputeTypeEnum, advertisingTerms, adPolicies, advertisers, advertiserTermsAcceptance, adWalletAccounts, adWalletTransactions, adPromoCodes, adPromoCodeRedemptions, adCampaigns, adGroups, ads, adEvents, adStatsDaily, adCustomAudiences, adAudienceMembers, adReviewHistory, userAdPreferences, userAdInteractions, adFrequencyTracking, adDeliveryDiagnostics, advertiserAchievements, adAuditLogs, adSystemSettings, adConversionPixels, adWebhooks, adDisputes, insertAdvertiserSchema, insertCampaignSchema, insertAdGroupSchema, insertAdSchema, insertAdEventSchema;
var init_ads_schema = __esm({
  "shared/ads-schema.ts"() {
    "use strict";
    advertiserStatusEnum = pgEnum("advertiser_status", [
      "PENDING_VERIFICATION",
      "ACTIVE",
      "SUSPENDED",
      "BANNED",
      "DEACTIVATED"
    ]);
    advertiserVerificationStatusEnum = pgEnum("advertiser_verification_status", [
      "NOT_SUBMITTED",
      "PENDING",
      "UNDER_REVIEW",
      "APPROVED",
      "REJECTED",
      "MORE_INFO_NEEDED"
    ]);
    campaignObjectiveEnum = pgEnum("campaign_objective", [
      "AWARENESS",
      "TRAFFIC",
      "ENGAGEMENT",
      "LEADS",
      "SALES",
      "APP_PROMOTION",
      "VIDEO_VIEWS",
      "COMMUNITY_GROWTH",
      "BOOST_POST"
    ]);
    campaignStatusEnum = pgEnum("campaign_status", [
      "DRAFT",
      "PENDING_REVIEW",
      "IN_REVIEW",
      "APPROVED",
      "REJECTED",
      "ACTIVE",
      "PAUSED",
      "COMPLETED",
      "DISABLED",
      "ARCHIVED"
    ]);
    adGroupStatusEnum = pgEnum("ad_group_status", [
      "DRAFT",
      "ACTIVE",
      "PAUSED",
      "COMPLETED",
      "DISABLED"
    ]);
    adStatusEnum = pgEnum("ad_status", [
      "DRAFT",
      "PENDING_REVIEW",
      "IN_REVIEW",
      "APPROVED",
      "REJECTED",
      "ACTIVE",
      "PAUSED",
      "COMPLETED",
      "DISABLED"
    ]);
    adFormatEnum = pgEnum("ad_format", [
      "IMAGE",
      "VIDEO",
      "CAROUSEL",
      "STORIES",
      "COLLECTION",
      "VOICE",
      "POLL",
      "CONVERSATION",
      "DARK_POST"
    ]);
    adPlacementEnum = pgEnum("ad_placement", [
      "FEED",
      "DISCOVER",
      "STORIES",
      "REELS",
      "VOICE_REELS",
      "SEARCH",
      "PROFILE_SUGGESTIONS",
      "MESSAGES"
    ]);
    billingModelEnum = pgEnum("billing_model", [
      "CPM",
      "CPC",
      "CPV",
      "CPA"
    ]);
    budgetTypeEnum = pgEnum("budget_type", [
      "DAILY",
      "LIFETIME"
    ]);
    pacingTypeEnum = pgEnum("pacing_type", [
      "EVEN",
      "ACCELERATED",
      "SMART"
    ]);
    reviewActionEnum = pgEnum("review_action", [
      "APPROVE",
      "REJECT",
      "REQUEST_CHANGES",
      "ESCALATE"
    ]);
    walletTransactionTypeEnum = pgEnum("wallet_transaction_type", [
      "TOP_UP",
      "AD_SPEND",
      "REFUND",
      "ADJUSTMENT",
      "PROMO_CREDIT",
      "REFERRAL_CREDIT",
      "ADMIN_CREDIT",
      "ADMIN_DEBIT"
    ]);
    walletTransactionStatusEnum = pgEnum("wallet_transaction_status", [
      "PENDING",
      "COMPLETED",
      "FAILED",
      "CANCELLED",
      "REFUNDED"
    ]);
    adEventTypeEnum = pgEnum("ad_event_type", [
      "IMPRESSION",
      "VIEWABLE_IMPRESSION",
      "CLICK",
      "VIDEO_START",
      "VIDEO_25",
      "VIDEO_50",
      "VIDEO_75",
      "VIDEO_COMPLETE",
      "VOICE_START",
      "VOICE_COMPLETE",
      "POLL_VOTE",
      "CONVERSION",
      "HIDE",
      "REPORT",
      "SAVE"
    ]);
    conversionTypeEnum = pgEnum("conversion_type", [
      "PURCHASE",
      "LEAD",
      "SIGNUP",
      "FOLLOW",
      "MESSAGE",
      "APP_INSTALL",
      "ADD_TO_CART",
      "CUSTOM"
    ]);
    attributionModelEnum = pgEnum("attribution_model", [
      "LAST_CLICK",
      "FIRST_CLICK",
      "LINEAR",
      "TIME_DECAY"
    ]);
    audienceTypeEnum = pgEnum("audience_type", [
      "CUSTOM",
      "SAVED",
      "LOOKALIKE",
      "RETARGETING"
    ]);
    diagnosticIssueEnum = pgEnum("diagnostic_issue", [
      "LOW_BALANCE",
      "ZERO_BALANCE",
      "BUDGET_EXHAUSTED",
      "SCHEDULE_NOT_STARTED",
      "SCHEDULE_ENDED",
      "TARGETING_TOO_NARROW",
      "LOW_BID",
      "AD_REJECTED",
      "CAMPAIGN_PAUSED",
      "FREQUENCY_CAP_REACHED",
      "LOW_QUALITY_SCORE",
      "POLICY_VIOLATION",
      "PENDING_REVIEW",
      "NO_ELIGIBLE_USERS"
    ]);
    achievementTypeEnum = pgEnum("achievement_type", [
      "FIRST_CAMPAIGN",
      "FIRST_CONVERSION",
      "SPEND_MILESTONE",
      "ROAS_MILESTONE",
      "IMPRESSION_MILESTONE",
      "ENGAGEMENT_MILESTONE",
      "STREAK_7_DAYS",
      "STREAK_30_DAYS",
      "TOP_PERFORMER",
      "VERIFIED_ADVERTISER"
    ]);
    adAuditActionEnum = pgEnum("ad_audit_action", [
      "ADVERTISER_CREATED",
      "ADVERTISER_VERIFIED",
      "ADVERTISER_SUSPENDED",
      "ADVERTISER_BANNED",
      "CAMPAIGN_CREATED",
      "CAMPAIGN_UPDATED",
      "CAMPAIGN_PAUSED",
      "CAMPAIGN_ACTIVATED",
      "CAMPAIGN_DELETED",
      "AD_GROUP_CREATED",
      "AD_GROUP_UPDATED",
      "AD_GROUP_PAUSED",
      "AD_GROUP_DELETED",
      "AD_CREATED",
      "AD_UPDATED",
      "AD_SUBMITTED",
      "AD_APPROVED",
      "AD_REJECTED",
      "AD_PAUSED",
      "AD_DELETED",
      "WALLET_TOP_UP",
      "WALLET_SPEND",
      "WALLET_REFUND",
      "WALLET_ADJUSTMENT",
      "SPEND_CAP_SET",
      "SPEND_CAP_UPDATED",
      "ALGORITHM_TUNED",
      "POLICY_UPDATED",
      "TERMS_UPDATED",
      "POST_BOOSTED"
    ]);
    adDisputeStatusEnum = pgEnum("ad_dispute_status", [
      "PENDING",
      "UNDER_REVIEW",
      "RESOLVED_APPROVED",
      "RESOLVED_DENIED",
      "CANCELLED"
    ]);
    adDisputeTypeEnum = pgEnum("ad_dispute_type", [
      "BILLING_ERROR",
      "UNDER_DELIVERY",
      "POLICY_VIOLATION",
      "TECHNICAL_ISSUE",
      "REFUND_REQUEST",
      "OTHER"
    ]);
    advertisingTerms = pgTable("advertising_terms", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      version: varchar("version", { length: 20 }).notNull().unique(),
      title: text("title").notNull(),
      content: text("content").notNull(),
      summary: text("summary"),
      effectiveDate: timestamp("effective_date").notNull(),
      isActive: boolean("is_active").default(false).notNull(),
      createdById: varchar("created_by_id"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("advertising_terms_active_idx").on(table.isActive),
      index("advertising_terms_effective_idx").on(table.effectiveDate)
    ]);
    adPolicies = pgTable("ad_policies", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      category: varchar("category", { length: 50 }).notNull(),
      name: varchar("name", { length: 200 }).notNull(),
      description: text("description").notNull(),
      violationSeverity: varchar("violation_severity", { length: 20 }).default("MODERATE"),
      autoReject: boolean("auto_reject").default(false).notNull(),
      keywords: jsonb("keywords").default([]),
      isActive: boolean("is_active").default(true).notNull(),
      sortOrder: integer("sort_order").default(0).notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("ad_policies_category_idx").on(table.category),
      index("ad_policies_active_idx").on(table.isActive)
    ]);
    advertisers = pgTable("advertisers", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().unique(),
      businessName: varchar("business_name", { length: 200 }),
      businessType: varchar("business_type", { length: 50 }),
      industry: varchar("industry", { length: 50 }),
      website: text("website"),
      phone: varchar("phone", { length: 30 }),
      address: text("address"),
      taxId: varchar("tax_id", { length: 50 }),
      status: advertiserStatusEnum("status").default("PENDING_VERIFICATION").notNull(),
      verificationStatus: advertiserVerificationStatusEnum("verification_status").default("NOT_SUBMITTED").notNull(),
      verificationDocuments: jsonb("verification_documents").default([]),
      verificationNotes: text("verification_notes"),
      verifiedAt: timestamp("verified_at"),
      verifiedById: varchar("verified_by_id"),
      termsAcceptedVersion: varchar("terms_accepted_version", { length: 20 }),
      termsAcceptedAt: timestamp("terms_accepted_at"),
      spendCapDaily: bigint("spend_cap_daily", { mode: "number" }),
      spendCapMonthly: bigint("spend_cap_monthly", { mode: "number" }),
      velocityLimitHourly: bigint("velocity_limit_hourly", { mode: "number" }),
      trustScore: integer("trust_score").default(50).notNull(),
      totalSpend: bigint("total_spend", { mode: "number" }).default(0).notNull(),
      totalCampaigns: integer("total_campaigns").default(0).notNull(),
      totalImpressions: bigint("total_impressions", { mode: "number" }).default(0).notNull(),
      totalClicks: bigint("total_clicks", { mode: "number" }).default(0).notNull(),
      totalConversions: bigint("total_conversions", { mode: "number" }).default(0).notNull(),
      avgCtr: real("avg_ctr").default(0),
      avgRoas: real("avg_roas").default(0),
      vipTier: varchar("vip_tier", { length: 20 }).default("BRONZE"),
      vipPoints: integer("vip_points").default(0).notNull(),
      suspendedAt: timestamp("suspended_at"),
      suspendedById: varchar("suspended_by_id"),
      suspendedReason: text("suspended_reason"),
      bannedAt: timestamp("banned_at"),
      bannedById: varchar("banned_by_id"),
      bannedReason: text("banned_reason"),
      twoFactorEnabled: boolean("two_factor_enabled").default(false).notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("advertisers_user_idx").on(table.userId),
      index("advertisers_status_idx").on(table.status),
      index("advertisers_verification_idx").on(table.verificationStatus),
      index("advertisers_vip_tier_idx").on(table.vipTier)
    ]);
    advertiserTermsAcceptance = pgTable("advertiser_terms_acceptance", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      advertiserId: varchar("advertiser_id").notNull(),
      termsId: varchar("terms_id").notNull(),
      termsVersion: varchar("terms_version", { length: 20 }).notNull(),
      ipAddress: varchar("ip_address", { length: 50 }),
      userAgent: text("user_agent"),
      acceptedAt: timestamp("accepted_at").defaultNow().notNull()
    }, (table) => [
      index("advertiser_terms_acceptance_advertiser_idx").on(table.advertiserId),
      unique("advertiser_terms_version_unique").on(table.advertiserId, table.termsVersion)
    ]);
    adWalletAccounts = pgTable("ad_wallet_accounts", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      advertiserId: varchar("advertiser_id").notNull().unique(),
      balance: bigint("balance", { mode: "number" }).default(0).notNull(),
      reservedAmount: bigint("reserved_amount", { mode: "number" }).default(0).notNull(),
      lifetimeDeposits: bigint("lifetime_deposits", { mode: "number" }).default(0).notNull(),
      lifetimeSpend: bigint("lifetime_spend", { mode: "number" }).default(0).notNull(),
      lifetimeRefunds: bigint("lifetime_refunds", { mode: "number" }).default(0).notNull(),
      currency: varchar("currency", { length: 3 }).default("ZAR").notNull(),
      autoTopUpEnabled: boolean("auto_top_up_enabled").default(false).notNull(),
      autoTopUpThreshold: bigint("auto_top_up_threshold", { mode: "number" }),
      autoTopUpAmount: bigint("auto_top_up_amount", { mode: "number" }),
      lowBalanceAlertThreshold: bigint("low_balance_alert_threshold", { mode: "number" }).default(1e4),
      lastLowBalanceAlertAt: timestamp("last_low_balance_alert_at"),
      isFrozen: boolean("is_frozen").default(false).notNull(),
      frozenReason: text("frozen_reason"),
      frozenAt: timestamp("frozen_at"),
      frozenById: varchar("frozen_by_id"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("ad_wallet_accounts_advertiser_idx").on(table.advertiserId),
      index("ad_wallet_accounts_balance_idx").on(table.balance)
    ]);
    adWalletTransactions = pgTable("ad_wallet_transactions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      walletId: varchar("wallet_id").notNull(),
      type: walletTransactionTypeEnum("type").notNull(),
      amount: bigint("amount", { mode: "number" }).notNull(),
      balanceBefore: bigint("balance_before", { mode: "number" }).notNull(),
      balanceAfter: bigint("balance_after", { mode: "number" }).notNull(),
      status: walletTransactionStatusEnum("status").default("PENDING").notNull(),
      reference: varchar("reference", { length: 100 }),
      description: text("description"),
      metadata: jsonb("metadata").default({}),
      campaignId: varchar("campaign_id"),
      promoCodeId: varchar("promo_code_id"),
      adminId: varchar("admin_id"),
      adminNotes: text("admin_notes"),
      payfastPaymentId: varchar("payfast_payment_id", { length: 100 }),
      invoiceNumber: varchar("invoice_number", { length: 50 }),
      invoiceUrl: text("invoice_url"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      completedAt: timestamp("completed_at")
    }, (table) => [
      index("ad_wallet_transactions_wallet_idx").on(table.walletId),
      index("ad_wallet_transactions_type_idx").on(table.type),
      index("ad_wallet_transactions_status_idx").on(table.status),
      index("ad_wallet_transactions_created_idx").on(table.createdAt),
      index("ad_wallet_transactions_campaign_idx").on(table.campaignId)
    ]);
    adPromoCodes = pgTable("ad_promo_codes", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      code: varchar("code", { length: 50 }).notNull().unique(),
      description: text("description"),
      amount: bigint("amount", { mode: "number" }).notNull(),
      percentage: real("percentage"),
      maxAmount: bigint("max_amount", { mode: "number" }),
      usageLimit: integer("usage_limit"),
      usageLimitPerUser: integer("usage_limit_per_user").default(1),
      usageCount: integer("usage_count").default(0).notNull(),
      minSpend: bigint("min_spend", { mode: "number" }),
      validFrom: timestamp("valid_from").defaultNow().notNull(),
      validUntil: timestamp("valid_until"),
      isActive: boolean("is_active").default(true).notNull(),
      newAdvertisersOnly: boolean("new_advertisers_only").default(false).notNull(),
      createdById: varchar("created_by_id"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("ad_promo_codes_code_idx").on(table.code),
      index("ad_promo_codes_active_idx").on(table.isActive)
    ]);
    adPromoCodeRedemptions = pgTable("ad_promo_code_redemptions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      promoCodeId: varchar("promo_code_id").notNull(),
      advertiserId: varchar("advertiser_id").notNull(),
      walletTransactionId: varchar("wallet_transaction_id"),
      amountCredited: bigint("amount_credited", { mode: "number" }).notNull(),
      redeemedAt: timestamp("redeemed_at").defaultNow().notNull()
    }, (table) => [
      index("ad_promo_redemptions_promo_idx").on(table.promoCodeId),
      index("ad_promo_redemptions_advertiser_idx").on(table.advertiserId),
      unique("ad_promo_redemption_unique").on(table.promoCodeId, table.advertiserId)
    ]);
    adCampaigns = pgTable("ad_campaigns", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      advertiserId: varchar("advertiser_id").notNull(),
      name: varchar("name", { length: 200 }).notNull(),
      objective: campaignObjectiveEnum("objective").notNull(),
      status: campaignStatusEnum("status").default("DRAFT").notNull(),
      budgetType: budgetTypeEnum("budget_type").default("DAILY").notNull(),
      budgetAmount: bigint("budget_amount", { mode: "number" }).notNull(),
      budgetSpent: bigint("budget_spent", { mode: "number" }).default(0).notNull(),
      budgetRemaining: bigint("budget_remaining", { mode: "number" }),
      lifetimeBudget: bigint("lifetime_budget", { mode: "number" }),
      pacing: pacingTypeEnum("pacing").default("EVEN").notNull(),
      bidStrategy: varchar("bid_strategy", { length: 50 }).default("AUTO"),
      bidAmount: bigint("bid_amount", { mode: "number" }),
      targetCpa: bigint("target_cpa", { mode: "number" }),
      startDate: timestamp("start_date"),
      endDate: timestamp("end_date"),
      timezone: varchar("timezone", { length: 50 }).default("Africa/Johannesburg"),
      dayparting: jsonb("dayparting").default({}),
      placements: jsonb("placements").default(["FEED"]),
      submittedAt: timestamp("submitted_at"),
      reviewStartedAt: timestamp("review_started_at"),
      reviewedAt: timestamp("reviewed_at"),
      reviewedById: varchar("reviewed_by_id"),
      rejectionReason: text("rejection_reason"),
      rejectionDetails: text("rejection_details"),
      impressions: bigint("impressions", { mode: "number" }).default(0).notNull(),
      clicks: bigint("clicks", { mode: "number" }).default(0).notNull(),
      conversions: bigint("conversions", { mode: "number" }).default(0).notNull(),
      conversionValue: bigint("conversion_value", { mode: "number" }).default(0).notNull(),
      reach: bigint("reach", { mode: "number" }).default(0).notNull(),
      frequency: real("frequency").default(0),
      ctr: real("ctr").default(0),
      cpc: real("cpc").default(0),
      cpm: real("cpm").default(0),
      roas: real("roas").default(0),
      qualityScore: real("quality_score").default(50),
      relevanceScore: real("relevance_score").default(50),
      isInLearningPhase: boolean("is_in_learning_phase").default(true).notNull(),
      learningPhaseEndsAt: timestamp("learning_phase_ends_at"),
      learningPhaseConversions: integer("learning_phase_conversions").default(0),
      tags: jsonb("tags").default([]),
      notes: text("notes"),
      isDarkPost: boolean("is_dark_post").default(false).notNull(),
      isClone: boolean("is_clone").default(false).notNull(),
      clonedFromId: varchar("cloned_from_id"),
      version: integer("version").default(1).notNull(),
      lastEditedAt: timestamp("last_edited_at"),
      lastEditedById: varchar("last_edited_by_id"),
      pausedAt: timestamp("paused_at"),
      pausedById: varchar("paused_by_id"),
      pausedReason: text("paused_reason"),
      metadata: jsonb("metadata").default({}),
      completedAt: timestamp("completed_at"),
      archivedAt: timestamp("archived_at"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("ad_campaigns_advertiser_idx").on(table.advertiserId),
      index("ad_campaigns_status_idx").on(table.status),
      index("ad_campaigns_objective_idx").on(table.objective),
      index("ad_campaigns_dates_idx").on(table.startDate, table.endDate),
      index("ad_campaigns_created_idx").on(table.createdAt)
    ]);
    adGroups = pgTable("ad_groups", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      campaignId: varchar("campaign_id").notNull(),
      name: varchar("name", { length: 200 }).notNull(),
      status: adGroupStatusEnum("status").default("DRAFT").notNull(),
      budgetAmount: bigint("budget_amount", { mode: "number" }),
      budgetSpent: bigint("budget_spent", { mode: "number" }).default(0).notNull(),
      bidAmount: bigint("bid_amount", { mode: "number" }),
      billingModel: billingModelEnum("billing_model").default("CPM").notNull(),
      placements: jsonb("placements").default([]),
      targeting: jsonb("targeting").default({}).notNull(),
      ageMin: integer("age_min").default(18),
      ageMax: integer("age_max").default(65),
      genders: jsonb("genders").default([]),
      countries: jsonb("countries").default([]),
      provinces: jsonb("provinces").default([]),
      cities: jsonb("cities").default([]),
      excludedLocations: jsonb("excluded_locations").default([]),
      netWorthTiers: jsonb("net_worth_tiers").default([]),
      minNetWorth: bigint("min_net_worth", { mode: "number" }),
      maxNetWorth: bigint("max_net_worth", { mode: "number" }),
      minInfluenceScore: integer("min_influence_score"),
      maxInfluenceScore: integer("max_influence_score"),
      interests: jsonb("interests").default([]),
      behaviors: jsonb("behaviors").default([]),
      industries: jsonb("industries").default([]),
      customAudienceIds: jsonb("custom_audience_ids").default([]),
      excludedAudienceIds: jsonb("excluded_audience_ids").default([]),
      deviceTypes: jsonb("device_types").default([]),
      platforms: jsonb("platforms").default([]),
      connectionTypes: jsonb("connection_types").default([]),
      frequencyCapImpressions: integer("frequency_cap_impressions").default(3),
      frequencyCapPeriodHours: integer("frequency_cap_period_hours").default(24),
      frequencyCapCooldownHours: integer("frequency_cap_cooldown_hours"),
      impressions: bigint("impressions", { mode: "number" }).default(0).notNull(),
      clicks: bigint("clicks", { mode: "number" }).default(0).notNull(),
      conversions: bigint("conversions", { mode: "number" }).default(0).notNull(),
      reach: bigint("reach", { mode: "number" }).default(0).notNull(),
      estimatedAudienceSize: bigint("estimated_audience_size", { mode: "number" }),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("ad_groups_campaign_idx").on(table.campaignId),
      index("ad_groups_status_idx").on(table.status)
    ]);
    ads = pgTable("ads", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      adNumber: varchar("ad_number", { length: 12 }).unique(),
      // Short reference code like AD-001234
      adGroupId: varchar("ad_group_id").notNull(),
      campaignId: varchar("campaign_id").notNull(),
      advertiserId: varchar("advertiser_id").notNull(),
      name: varchar("name", { length: 200 }).notNull(),
      format: adFormatEnum("format").default("IMAGE").notNull(),
      status: adStatusEnum("status").default("DRAFT").notNull(),
      headline: varchar("headline", { length: 125 }),
      description: text("description"),
      callToAction: varchar("call_to_action", { length: 50 }),
      destinationUrl: text("destination_url"),
      displayUrl: text("display_url"),
      primaryMediaUrl: text("primary_media_url"),
      primaryMediaThumbnail: text("primary_media_thumbnail"),
      primaryMediaType: varchar("primary_media_type", { length: 20 }),
      primaryMediaDuration: integer("primary_media_duration"),
      primaryMediaAspectRatio: real("primary_media_aspect_ratio"),
      carouselItems: jsonb("carousel_items").default([]),
      voiceUrl: text("voice_url"),
      voiceDuration: integer("voice_duration"),
      voiceTranscript: text("voice_transcript"),
      pollQuestion: text("poll_question"),
      pollOptions: jsonb("poll_options").default([]),
      placementCreatives: jsonb("placement_creatives").default({}),
      submittedAt: timestamp("submitted_at"),
      reviewStartedAt: timestamp("review_started_at"),
      reviewedAt: timestamp("reviewed_at"),
      reviewedById: varchar("reviewed_by_id"),
      rejectionReason: text("rejection_reason"),
      rejectionDetails: text("rejection_details"),
      policyViolations: jsonb("policy_violations").default([]),
      aiModerationScore: real("ai_moderation_score"),
      aiModerationFlags: jsonb("ai_moderation_flags").default([]),
      aiPerformancePrediction: real("ai_performance_prediction"),
      aiSuggestions: jsonb("ai_suggestions").default([]),
      qualityScore: real("quality_score").default(50),
      relevanceScore: real("relevance_score").default(50),
      engagementScore: real("engagement_score").default(50),
      feedbackPositive: integer("feedback_positive").default(0).notNull(),
      feedbackNegative: integer("feedback_negative").default(0).notNull(),
      impressions: bigint("impressions", { mode: "number" }).default(0).notNull(),
      clicks: bigint("clicks", { mode: "number" }).default(0).notNull(),
      conversions: bigint("conversions", { mode: "number" }).default(0).notNull(),
      spend: bigint("spend", { mode: "number" }).default(0).notNull(),
      ctr: real("ctr").default(0),
      isVariant: boolean("is_variant").default(false).notNull(),
      variantOf: varchar("variant_of"),
      variantLabel: varchar("variant_label", { length: 50 }),
      variantWeight: integer("variant_weight").default(50),
      linkedPostId: varchar("linked_post_id"),
      linkedMallItemId: varchar("linked_mall_item_id"),
      pausedAt: timestamp("paused_at"),
      pausedById: varchar("paused_by_id"),
      pausedReason: text("paused_reason"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("ads_ad_group_idx").on(table.adGroupId),
      index("ads_campaign_idx").on(table.campaignId),
      index("ads_advertiser_idx").on(table.advertiserId),
      index("ads_status_idx").on(table.status),
      index("ads_format_idx").on(table.format)
    ]);
    adEvents = pgTable("ad_events", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      adId: varchar("ad_id").notNull(),
      adGroupId: varchar("ad_group_id").notNull(),
      campaignId: varchar("campaign_id").notNull(),
      advertiserId: varchar("advertiser_id").notNull(),
      userId: varchar("user_id"),
      eventType: adEventTypeEnum("event_type").notNull(),
      placement: adPlacementEnum("placement").notNull(),
      sessionId: varchar("session_id", { length: 100 }),
      deviceId: varchar("device_id", { length: 100 }),
      ipAddress: varchar("ip_address", { length: 50 }),
      userAgent: text("user_agent"),
      platform: varchar("platform", { length: 20 }),
      costAmount: bigint("cost_amount", { mode: "number" }).default(0),
      bidAmount: bigint("bid_amount", { mode: "number" }),
      watchTimeMs: integer("watch_time_ms"),
      percentWatched: real("percent_watched"),
      soundOn: boolean("sound_on"),
      conversionType: conversionTypeEnum("conversion_type"),
      conversionValue: bigint("conversion_value", { mode: "number" }),
      conversionCurrency: varchar("conversion_currency", { length: 3 }),
      referrer: text("referrer"),
      metadata: jsonb("metadata").default({}),
      eventHash: varchar("event_hash", { length: 64 }),
      isDuplicate: boolean("is_duplicate").default(false).notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("ad_events_ad_idx").on(table.adId),
      index("ad_events_campaign_idx").on(table.campaignId),
      index("ad_events_user_idx").on(table.userId),
      index("ad_events_type_idx").on(table.eventType),
      index("ad_events_created_idx").on(table.createdAt),
      index("ad_events_hash_idx").on(table.eventHash)
    ]);
    adStatsDaily = pgTable("ad_stats_daily", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      date: timestamp("date").notNull(),
      adId: varchar("ad_id"),
      adGroupId: varchar("ad_group_id"),
      campaignId: varchar("campaign_id"),
      advertiserId: varchar("advertiser_id").notNull(),
      placement: adPlacementEnum("placement"),
      impressions: bigint("impressions", { mode: "number" }).default(0).notNull(),
      clicks: bigint("clicks", { mode: "number" }).default(0).notNull(),
      conversions: bigint("conversions", { mode: "number" }).default(0).notNull(),
      conversionValue: bigint("conversion_value", { mode: "number" }).default(0).notNull(),
      reach: bigint("reach", { mode: "number" }).default(0).notNull(),
      frequency: real("frequency").default(0),
      spend: bigint("spend", { mode: "number" }).default(0).notNull(),
      ctr: real("ctr").default(0),
      cpc: real("cpc").default(0),
      cpm: real("cpm").default(0),
      cpa: real("cpa").default(0),
      roas: real("roas").default(0),
      videoViews: bigint("video_views", { mode: "number" }).default(0),
      videoViews25: bigint("video_views_25", { mode: "number" }).default(0),
      videoViews50: bigint("video_views_50", { mode: "number" }).default(0),
      videoViews75: bigint("video_views_75", { mode: "number" }).default(0),
      videoViews100: bigint("video_views_100", { mode: "number" }).default(0),
      avgWatchTimeMs: real("avg_watch_time_ms").default(0),
      saves: bigint("saves", { mode: "number" }).default(0),
      hides: bigint("hides", { mode: "number" }).default(0),
      reports: bigint("reports", { mode: "number" }).default(0),
      breakdowns: jsonb("breakdowns").default({}),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("ad_stats_daily_date_idx").on(table.date),
      index("ad_stats_daily_ad_idx").on(table.adId),
      index("ad_stats_daily_campaign_idx").on(table.campaignId),
      index("ad_stats_daily_advertiser_idx").on(table.advertiserId),
      unique("ad_stats_daily_unique").on(table.date, table.adId, table.placement)
    ]);
    adCustomAudiences = pgTable("ad_custom_audiences", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      advertiserId: varchar("advertiser_id").notNull(),
      name: varchar("name", { length: 200 }).notNull(),
      description: text("description"),
      type: audienceTypeEnum("type").default("CUSTOM").notNull(),
      sourceType: varchar("source_type", { length: 50 }),
      rules: jsonb("rules").default({}),
      estimatedSize: bigint("estimated_size", { mode: "number" }).default(0),
      actualSize: bigint("actual_size", { mode: "number" }).default(0),
      lastCalculatedAt: timestamp("last_calculated_at"),
      sourceAudienceId: varchar("source_audience_id"),
      lookalikeSimilarity: real("lookalike_similarity"),
      uploadedFileUrl: text("uploaded_file_url"),
      uploadedRecordCount: integer("uploaded_record_count"),
      matchedCount: integer("matched_count"),
      isActive: boolean("is_active").default(true).notNull(),
      isProcessing: boolean("is_processing").default(false).notNull(),
      processingError: text("processing_error"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("ad_custom_audiences_advertiser_idx").on(table.advertiserId),
      index("ad_custom_audiences_type_idx").on(table.type)
    ]);
    adAudienceMembers = pgTable("ad_audience_members", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      audienceId: varchar("audience_id").notNull(),
      userId: varchar("user_id").notNull(),
      addedAt: timestamp("added_at").defaultNow().notNull(),
      expiresAt: timestamp("expires_at")
    }, (table) => [
      index("ad_audience_members_audience_idx").on(table.audienceId),
      index("ad_audience_members_user_idx").on(table.userId),
      unique("ad_audience_members_unique").on(table.audienceId, table.userId)
    ]);
    adReviewHistory = pgTable("ad_review_history", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      adId: varchar("ad_id").notNull(),
      campaignId: varchar("campaign_id").notNull(),
      reviewerId: varchar("reviewer_id"),
      action: reviewActionEnum("action").notNull(),
      previousStatus: adStatusEnum("previous_status"),
      newStatus: adStatusEnum("new_status"),
      reason: text("reason"),
      details: text("details"),
      policyViolations: jsonb("policy_violations").default([]),
      reviewDurationMs: integer("review_duration_ms"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("ad_review_history_ad_idx").on(table.adId),
      index("ad_review_history_campaign_idx").on(table.campaignId),
      index("ad_review_history_reviewer_idx").on(table.reviewerId)
    ]);
    userAdPreferences = pgTable("user_ad_preferences", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().unique(),
      interestedCategories: jsonb("interested_categories").default([]),
      notInterestedCategories: jsonb("not_interested_categories").default([]),
      hiddenAdvertisers: jsonb("hidden_advertisers").default([]),
      preferVideoAds: boolean("prefer_video_ads").default(true),
      preferVoiceAds: boolean("prefer_voice_ads").default(true),
      preferInteractiveAds: boolean("prefer_interactive_ads").default(true),
      enablePersonalization: boolean("enable_personalization").default(true).notNull(),
      shareActivityForAds: boolean("share_activity_for_ads").default(true).notNull(),
      maxAdsPerSession: integer("max_ads_per_session").default(10),
      minPostsBetweenAds: integer("min_posts_between_ads").default(4),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("user_ad_preferences_user_idx").on(table.userId)
    ]);
    userAdInteractions = pgTable("user_ad_interactions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull(),
      adId: varchar("ad_id").notNull(),
      action: varchar("action", { length: 30 }).notNull(),
      reason: text("reason"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("user_ad_interactions_user_idx").on(table.userId),
      index("user_ad_interactions_ad_idx").on(table.adId),
      unique("user_ad_interactions_unique").on(table.userId, table.adId, table.action)
    ]);
    adFrequencyTracking = pgTable("ad_frequency_tracking", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull(),
      adId: varchar("ad_id").notNull(),
      adGroupId: varchar("ad_group_id").notNull(),
      campaignId: varchar("campaign_id").notNull(),
      impressionCount: integer("impression_count").default(0).notNull(),
      clickCount: integer("click_count").default(0).notNull(),
      lastImpressionAt: timestamp("last_impression_at"),
      lastClickAt: timestamp("last_click_at"),
      convertedAt: timestamp("converted_at"),
      cooldownUntil: timestamp("cooldown_until"),
      periodStartAt: timestamp("period_start_at").defaultNow().notNull()
    }, (table) => [
      index("ad_frequency_tracking_user_idx").on(table.userId),
      index("ad_frequency_tracking_ad_idx").on(table.adId),
      index("ad_frequency_tracking_campaign_idx").on(table.campaignId),
      unique("ad_frequency_tracking_unique").on(table.userId, table.adId)
    ]);
    adDeliveryDiagnostics = pgTable("ad_delivery_diagnostics", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      adId: varchar("ad_id"),
      campaignId: varchar("campaign_id").notNull(),
      issue: diagnosticIssueEnum("issue").notNull(),
      severity: varchar("severity", { length: 20 }).default("MEDIUM"),
      message: text("message").notNull(),
      suggestedFix: text("suggested_fix"),
      isResolved: boolean("is_resolved").default(false).notNull(),
      resolvedAt: timestamp("resolved_at"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("ad_delivery_diagnostics_ad_idx").on(table.adId),
      index("ad_delivery_diagnostics_campaign_idx").on(table.campaignId),
      index("ad_delivery_diagnostics_issue_idx").on(table.issue)
    ]);
    advertiserAchievements = pgTable("advertiser_achievements", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      advertiserId: varchar("advertiser_id").notNull(),
      type: achievementTypeEnum("type").notNull(),
      name: varchar("name", { length: 100 }).notNull(),
      description: text("description"),
      iconUrl: text("icon_url"),
      xpAwarded: integer("xp_awarded").default(0).notNull(),
      metadata: jsonb("metadata").default({}),
      earnedAt: timestamp("earned_at").defaultNow().notNull()
    }, (table) => [
      index("advertiser_achievements_advertiser_idx").on(table.advertiserId),
      index("advertiser_achievements_type_idx").on(table.type)
    ]);
    adAuditLogs = pgTable("ad_audit_logs", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      advertiserId: varchar("advertiser_id"),
      actorId: varchar("actor_id"),
      actorType: varchar("actor_type", { length: 20 }).notNull(),
      action: adAuditActionEnum("action").notNull(),
      entityType: varchar("entity_type", { length: 50 }).notNull(),
      entityId: varchar("entity_id", { length: 100 }),
      previousState: jsonb("previous_state"),
      newState: jsonb("new_state"),
      changesSummary: text("changes_summary"),
      ipAddress: varchar("ip_address", { length: 50 }),
      userAgent: text("user_agent"),
      metadata: jsonb("metadata").default({}),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("ad_audit_logs_advertiser_idx").on(table.advertiserId),
      index("ad_audit_logs_actor_idx").on(table.actorId),
      index("ad_audit_logs_action_idx").on(table.action),
      index("ad_audit_logs_entity_idx").on(table.entityType, table.entityId),
      index("ad_audit_logs_created_idx").on(table.createdAt)
    ]);
    adSystemSettings = pgTable("ad_system_settings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      key: varchar("key", { length: 100 }).notNull().unique(),
      value: jsonb("value").notNull(),
      description: text("description"),
      category: varchar("category", { length: 50 }),
      isPublic: boolean("is_public").default(false).notNull(),
      updatedById: varchar("updated_by_id"),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("ad_system_settings_key_idx").on(table.key),
      index("ad_system_settings_category_idx").on(table.category)
    ]);
    adConversionPixels = pgTable("ad_conversion_pixels", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      advertiserId: varchar("advertiser_id").notNull(),
      name: varchar("name", { length: 200 }).notNull(),
      pixelCode: varchar("pixel_code", { length: 50 }).notNull().unique(),
      conversionType: conversionTypeEnum("conversion_type").default("PURCHASE").notNull(),
      defaultValue: bigint("default_value", { mode: "number" }),
      defaultCurrency: varchar("default_currency", { length: 3 }).default("ZAR"),
      isActive: boolean("is_active").default(true).notNull(),
      totalFires: bigint("total_fires", { mode: "number" }).default(0).notNull(),
      lastFiredAt: timestamp("last_fired_at"),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("ad_conversion_pixels_advertiser_idx").on(table.advertiserId),
      index("ad_conversion_pixels_code_idx").on(table.pixelCode)
    ]);
    adWebhooks = pgTable("ad_webhooks", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      advertiserId: varchar("advertiser_id").notNull(),
      url: text("url").notNull(),
      secret: varchar("secret", { length: 100 }),
      events: jsonb("events").default([]),
      isActive: boolean("is_active").default(true).notNull(),
      lastTriggeredAt: timestamp("last_triggered_at"),
      lastStatus: integer("last_status"),
      failureCount: integer("failure_count").default(0).notNull(),
      createdAt: timestamp("created_at").defaultNow().notNull()
    }, (table) => [
      index("ad_webhooks_advertiser_idx").on(table.advertiserId)
    ]);
    adDisputes = pgTable("ad_disputes", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      advertiserId: varchar("advertiser_id").notNull(),
      campaignId: varchar("campaign_id"),
      disputeType: adDisputeTypeEnum("dispute_type").notNull(),
      status: adDisputeStatusEnum("status").default("PENDING").notNull(),
      subject: varchar("subject", { length: 200 }).notNull(),
      description: text("description").notNull(),
      requestedRefundAmount: bigint("requested_refund_amount", { mode: "number" }),
      approvedRefundAmount: bigint("approved_refund_amount", { mode: "number" }),
      attachments: jsonb("attachments").default([]),
      adminResponse: text("admin_response"),
      resolvedBy: varchar("resolved_by"),
      resolvedAt: timestamp("resolved_at"),
      createdAt: timestamp("created_at").defaultNow().notNull(),
      updatedAt: timestamp("updated_at").defaultNow().notNull()
    }, (table) => [
      index("ad_disputes_advertiser_idx").on(table.advertiserId),
      index("ad_disputes_campaign_idx").on(table.campaignId),
      index("ad_disputes_status_idx").on(table.status)
    ]);
    insertAdvertiserSchema = createInsertSchema(advertisers);
    insertCampaignSchema = createInsertSchema(adCampaigns);
    insertAdGroupSchema = createInsertSchema(adGroups);
    insertAdSchema = createInsertSchema(ads);
    insertAdEventSchema = createInsertSchema(adEvents);
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  accountBackups: () => accountBackups,
  achievementCategoryEnum: () => achievementCategoryEnum,
  achievementTypeEnum: () => achievementTypeEnum,
  achievements: () => achievements,
  adAudienceMembers: () => adAudienceMembers,
  adAuditActionEnum: () => adAuditActionEnum,
  adAuditLogs: () => adAuditLogs,
  adCampaigns: () => adCampaigns,
  adConversionPixels: () => adConversionPixels,
  adCustomAudiences: () => adCustomAudiences,
  adDeliveryDiagnostics: () => adDeliveryDiagnostics,
  adDisputeStatusEnum: () => adDisputeStatusEnum,
  adDisputeTypeEnum: () => adDisputeTypeEnum,
  adDisputes: () => adDisputes,
  adEventTypeEnum: () => adEventTypeEnum,
  adEvents: () => adEvents,
  adFormatEnum: () => adFormatEnum,
  adFrequencyTracking: () => adFrequencyTracking,
  adGroupStatusEnum: () => adGroupStatusEnum,
  adGroups: () => adGroups,
  adPlacementEnum: () => adPlacementEnum,
  adPolicies: () => adPolicies,
  adPromoCodeRedemptions: () => adPromoCodeRedemptions,
  adPromoCodes: () => adPromoCodes,
  adReviewHistory: () => adReviewHistory,
  adStatsDaily: () => adStatsDaily,
  adStatusEnum: () => adStatusEnum,
  adSystemSettings: () => adSystemSettings,
  adWalletAccounts: () => adWalletAccounts,
  adWalletTransactions: () => adWalletTransactions,
  adWebhooks: () => adWebhooks,
  adminKeywordFilterActionEnum: () => adminKeywordFilterActionEnum,
  adminKeywordFilters: () => adminKeywordFilters,
  adminKeywordFiltersRelations: () => adminKeywordFiltersRelations,
  adminUserNotes: () => adminUserNotes,
  adminUserNotesRelations: () => adminUserNotesRelations,
  ads: () => ads,
  advertiserAchievements: () => advertiserAchievements,
  advertiserStatusEnum: () => advertiserStatusEnum,
  advertiserTermsAcceptance: () => advertiserTermsAcceptance,
  advertiserVerificationStatusEnum: () => advertiserVerificationStatusEnum,
  advertisers: () => advertisers,
  advertisingTerms: () => advertisingTerms,
  aiAvatars: () => aiAvatars,
  aiTranslations: () => aiTranslations,
  anonGossipPosts: () => anonGossipPosts,
  anonGossipPostsRelations: () => anonGossipPostsRelations,
  anonGossipReactions: () => anonGossipReactions,
  anonGossipReactionsRelations: () => anonGossipReactionsRelations,
  anonGossipReplies: () => anonGossipReplies,
  anonGossipRepliesRelations: () => anonGossipRepliesRelations,
  anonGossipReplyReactions: () => anonGossipReplyReactions,
  anonGossipReplyReactionsRelations: () => anonGossipReplyReactionsRelations,
  anonGossipReports: () => anonGossipReports,
  anonGossipReportsRelations: () => anonGossipReportsRelations,
  anonReactionTypeEnum: () => anonReactionTypeEnum,
  anonReportStatusEnum: () => anonReportStatusEnum,
  apiAccessTokens: () => apiAccessTokens,
  appSettings: () => appSettings,
  appSettingsRelations: () => appSettingsRelations,
  arFilters: () => arFilters,
  attributionModelEnum: () => attributionModelEnum,
  audienceTypeEnum: () => audienceTypeEnum,
  auditActionEnum: () => auditActionEnum,
  auditLogs: () => auditLogs,
  auditLogsRelations: () => auditLogsRelations,
  backupCodes: () => backupCodes,
  battleParticipants: () => battleParticipants,
  battleStatusEnum: () => battleStatusEnum,
  bffStatus: () => bffStatus,
  billingModelEnum: () => billingModelEnum,
  blocks: () => blocks,
  blocksRelations: () => blocksRelations,
  bookmarks: () => bookmarks,
  bookmarksRelations: () => bookmarksRelations,
  broadcastChannelSubscribers: () => broadcastChannelSubscribers,
  broadcastChannels: () => broadcastChannels,
  broadcastMessages: () => broadcastMessages,
  budgetTypeEnum: () => budgetTypeEnum,
  businessCategoryEnum: () => businessCategoryEnum,
  callStatusEnum: () => callStatusEnum,
  callTypeEnum: () => callTypeEnum,
  campaignObjectiveEnum: () => campaignObjectiveEnum,
  campaignStatusEnum: () => campaignStatusEnum,
  chatFolderConversations: () => chatFolderConversations,
  chatFolders: () => chatFolders,
  checkIns: () => checkIns,
  closeFriends: () => closeFriends,
  closeFriendsRelations: () => closeFriendsRelations,
  coinBundles: () => coinBundles,
  coinPurchases: () => coinPurchases,
  coinTransactionTypeEnum: () => coinTransactionTypeEnum,
  coinTransactions: () => coinTransactions,
  commentReplies: () => commentReplies,
  comments: () => comments,
  commentsRelations: () => commentsRelations,
  contentCategories: () => contentCategories,
  contentCategoriesRelations: () => contentCategoriesRelations,
  contentFatigue: () => contentFatigue,
  contentInteractions: () => contentInteractions,
  contentTypeEnum: () => contentTypeEnum,
  contentVelocity: () => contentVelocity,
  conversationSettings: () => conversationSettings,
  conversationStatusEnum: () => conversationStatusEnum,
  conversations: () => conversations,
  conversationsRelations: () => conversationsRelations,
  conversionTypeEnum: () => conversionTypeEnum,
  countries: () => countries,
  creatorAffinities: () => creatorAffinities,
  creatorCategoryEnum: () => creatorCategoryEnum,
  creatorEarnings: () => creatorEarnings,
  dailyPostAnalytics: () => dailyPostAnalytics,
  dailyPostAnalyticsRelations: () => dailyPostAnalyticsRelations,
  dailyRewardConfig: () => dailyRewardConfig,
  dailyRewards: () => dailyRewards,
  dailyUserAnalytics: () => dailyUserAnalytics,
  dailyUserAnalyticsRelations: () => dailyUserAnalyticsRelations,
  dataExportRequests: () => dataExportRequests,
  dataExportRequestsRelations: () => dataExportRequestsRelations,
  diagnosticIssueEnum: () => diagnosticIssueEnum,
  drafts: () => drafts,
  draftsRelations: () => draftsRelations,
  duetStitchPosts: () => duetStitchPosts,
  duetStitchTypeEnum: () => duetStitchTypeEnum,
  earningsHistory: () => earningsHistory,
  economyConfig: () => economyConfig,
  emailVerificationTokens: () => emailVerificationTokens,
  eventRsvps: () => eventRsvps,
  eventStatusEnum: () => eventStatusEnum,
  eventTypeEnum: () => eventTypeEnum,
  events: () => events,
  exploreCategories: () => exploreCategories,
  exportStatusEnum: () => exportStatusEnum,
  featureFlags: () => featureFlags,
  featuredIntros: () => featuredIntros,
  featuredIntrosRelations: () => featuredIntrosRelations,
  focusModeSettings: () => focusModeSettings,
  follows: () => follows,
  followsRelations: () => followsRelations,
  fontSizeEnum: () => fontSizeEnum,
  genderEnum: () => genderEnum,
  giftStakes: () => giftStakes,
  giftTransactions: () => giftTransactions,
  giftTypes: () => giftTypes,
  gossipBlockedWords: () => gossipBlockedWords,
  gossipComments: () => gossipComments,
  gossipCommentsRelations: () => gossipCommentsRelations,
  gossipEngagementVelocity: () => gossipEngagementVelocity,
  gossipEngagementVelocityRelations: () => gossipEngagementVelocityRelations,
  gossipLikes: () => gossipLikes,
  gossipLikesRelations: () => gossipLikesRelations,
  gossipLocationStats: () => gossipLocationStats,
  gossipPosts: () => gossipPosts,
  gossipPostsRelations: () => gossipPostsRelations,
  gossipRetweets: () => gossipRetweets,
  gossipRetweetsRelations: () => gossipRetweetsRelations,
  gossipSettings: () => gossipSettings,
  gossipTypeEnum: () => gossipTypeEnum,
  groupConversationMemberRoleEnum: () => groupConversationMemberRoleEnum,
  groupConversationMembers: () => groupConversationMembers,
  groupConversations: () => groupConversations,
  groupJoinRequestStatusEnum: () => groupJoinRequestStatusEnum,
  groupJoinRequests: () => groupJoinRequests,
  groupMemberRoleEnum: () => groupMemberRoleEnum,
  groupMembers: () => groupMembers,
  groupMessages: () => groupMessages,
  groupPosts: () => groupPosts,
  groupPrivacyEnum: () => groupPrivacyEnum,
  groups: () => groups,
  hashtags: () => hashtags,
  hiddenPosts: () => hiddenPosts,
  hiddenPostsRelations: () => hiddenPostsRelations,
  hiddenWords: () => hiddenWords,
  inboxFolderEnum: () => inboxFolderEnum,
  industryEnum: () => industryEnum,
  insertAdEventSchema: () => insertAdEventSchema,
  insertAdGroupSchema: () => insertAdGroupSchema,
  insertAdSchema: () => insertAdSchema,
  insertAdvertiserSchema: () => insertAdvertiserSchema,
  insertCampaignSchema: () => insertCampaignSchema,
  insertCommentSchema: () => insertCommentSchema,
  insertDraftSchema: () => insertDraftSchema,
  insertMessageSchema: () => insertMessageSchema,
  insertPostSchema: () => insertPostSchema,
  insertScheduledPostSchema: () => insertScheduledPostSchema,
  insertStoryDraftSchema: () => insertStoryDraftSchema,
  insertStorySchema: () => insertStorySchema,
  insertUserSchema: () => insertUserSchema,
  interactionTypeEnum: () => interactionTypeEnum,
  interestCategories: () => interestCategories,
  keywordFilters: () => keywordFilters,
  keywordFiltersRelations: () => keywordFiltersRelations,
  kycStatusEnum: () => kycStatusEnum,
  likes: () => likes,
  likesRelations: () => likesRelations,
  linkIconTypeEnum: () => linkIconTypeEnum,
  linkedAccounts: () => linkedAccounts,
  liveStreamComments: () => liveStreamComments,
  liveStreamGifts: () => liveStreamGifts,
  liveStreamReactions: () => liveStreamReactions,
  liveStreamStatusEnum: () => liveStreamStatusEnum,
  liveStreamViewers: () => liveStreamViewers,
  liveStreams: () => liveStreams,
  locationSharingSettings: () => locationSharingSettings,
  loginSessions: () => loginSessions,
  loginSessionsRelations: () => loginSessionsRelations,
  mallCategories: () => mallCategories,
  mallCategoriesRelations: () => mallCategoriesRelations,
  mallItems: () => mallItems,
  mallItemsRelations: () => mallItemsRelations,
  mallPurchases: () => mallPurchases,
  mallPurchasesRelations: () => mallPurchasesRelations,
  mallReviews: () => mallReviews,
  mallWishlists: () => mallWishlists,
  messageReactions: () => messageReactions,
  messageStatusEnum: () => messageStatusEnum,
  messageTypeEnum: () => messageTypeEnum,
  messages: () => messages,
  messagesRelations: () => messagesRelations,
  mutedAccounts: () => mutedAccounts,
  mutedAccountsRelations: () => mutedAccountsRelations,
  netWorthLedger: () => netWorthLedger,
  netWorthLedgerRelations: () => netWorthLedgerRelations,
  netWorthReasonEnum: () => netWorthReasonEnum,
  netWorthTierEnum: () => netWorthTierEnum,
  notInterested: () => notInterested,
  notInterestedPosts: () => notInterestedPosts,
  notInterestedPostsRelations: () => notInterestedPostsRelations,
  notificationDefaults: () => notificationDefaults,
  notificationDefaultsRelations: () => notificationDefaultsRelations,
  notificationPreferences: () => notificationPreferences,
  notificationTypeEnum: () => notificationTypeEnum,
  notifications: () => notifications,
  notificationsRelations: () => notificationsRelations,
  pacingTypeEnum: () => pacingTypeEnum,
  passwordResetTokens: () => passwordResetTokens,
  payfastOrderStatusEnum: () => payfastOrderStatusEnum,
  payfastOrders: () => payfastOrders,
  pendingTagApprovals: () => pendingTagApprovals,
  pendingTagApprovalsRelations: () => pendingTagApprovalsRelations,
  permissions: () => permissions,
  permissionsRelations: () => permissionsRelations,
  phoneVerificationTokens: () => phoneVerificationTokens,
  pinnedMessages: () => pinnedMessages,
  pins: () => pins,
  pinsRelations: () => pinsRelations,
  platformBattles: () => platformBattles,
  platformConfig: () => platformConfig,
  platformImportStatusEnum: () => platformImportStatusEnum,
  platformImports: () => platformImports,
  platformRevenue: () => platformRevenue,
  platformRevenueSourceEnum: () => platformRevenueSourceEnum,
  platformStats: () => platformStats,
  playlistItems: () => playlistItems,
  playlistItemsRelations: () => playlistItemsRelations,
  playlistTypeEnum: () => playlistTypeEnum,
  playlists: () => playlists,
  playlistsRelations: () => playlistsRelations,
  pokes: () => pokes,
  policyEnum: () => policyEnum,
  postCollaborators: () => postCollaborators,
  postCollaboratorsRelations: () => postCollaboratorsRelations,
  postHashtags: () => postHashtags,
  postReactionTypeEnum: () => postReactionTypeEnum,
  postReactions: () => postReactions,
  postThreads: () => postThreads,
  postTypeEnum: () => postTypeEnum,
  postViews: () => postViews,
  postViewsRelations: () => postViewsRelations,
  posts: () => posts,
  postsRelations: () => postsRelations,
  profileViews: () => profileViews,
  profileViewsRelations: () => profileViewsRelations,
  pushTokens: () => pushTokens,
  relationshipStatusEnum: () => relationshipStatusEnum,
  reportStatusEnum: () => reportStatusEnum,
  reports: () => reports,
  reportsRelations: () => reportsRelations,
  restrictedAccounts: () => restrictedAccounts,
  restrictedAccountsRelations: () => restrictedAccountsRelations,
  reviewActionEnum: () => reviewActionEnum,
  rolePermissions: () => rolePermissions,
  rolePermissionsRelations: () => rolePermissionsRelations,
  roles: () => roles,
  rolesRelations: () => rolesRelations,
  rsvpStatusEnum: () => rsvpStatusEnum,
  savedPosts: () => savedPosts,
  savedPostsRelations: () => savedPostsRelations,
  scheduledMessages: () => scheduledMessages,
  scheduledPosts: () => scheduledPosts,
  scheduledPostsRelations: () => scheduledPostsRelations,
  scheduledStatusEnum: () => scheduledStatusEnum,
  securityCheckups: () => securityCheckups,
  seenContent: () => seenContent,
  seenProfiles: () => seenProfiles,
  shares: () => shares,
  sharesRelations: () => sharesRelations,
  stakeStatusEnum: () => stakeStatusEnum,
  stakingTiers: () => stakingTiers,
  stories: () => stories,
  storiesRelations: () => storiesRelations,
  storyCountdownSubscriptions: () => storyCountdownSubscriptions,
  storyDrafts: () => storyDrafts,
  storyDraftsRelations: () => storyDraftsRelations,
  storyFontEnum: () => storyFontEnum,
  storyHighlightItems: () => storyHighlightItems,
  storyHighlightItemsRelations: () => storyHighlightItemsRelations,
  storyHighlights: () => storyHighlights,
  storyHighlightsRelations: () => storyHighlightsRelations,
  storyInsights: () => storyInsights,
  storyInsightsRelations: () => storyInsightsRelations,
  storyMusicLibrary: () => storyMusicLibrary,
  storyReactionTypeEnum: () => storyReactionTypeEnum,
  storyReactions: () => storyReactions,
  storyReactionsRelations: () => storyReactionsRelations,
  storyReplies: () => storyReplies,
  storyRepliesRelations: () => storyRepliesRelations,
  storyReplySettingEnum: () => storyReplySettingEnum,
  storyStickerResponses: () => storyStickerResponses,
  storyStickerResponsesRelations: () => storyStickerResponsesRelations,
  storyStickerTypeEnum: () => storyStickerTypeEnum,
  storyStickers: () => storyStickers,
  storyStickersRelations: () => storyStickersRelations,
  storyStreaks: () => storyStreaks,
  storyStreaksRelations: () => storyStreaksRelations,
  storyTemplates: () => storyTemplates,
  storyTextAlignEnum: () => storyTextAlignEnum,
  storyTextAnimationEnum: () => storyTextAnimationEnum,
  storyTips: () => storyTips,
  storyTipsRelations: () => storyTipsRelations,
  storyTypeEnum: () => storyTypeEnum,
  storyViewerRestrictions: () => storyViewerRestrictions,
  storyViewerRestrictionsRelations: () => storyViewerRestrictionsRelations,
  storyViews: () => storyViews,
  storyViewsRelations: () => storyViewsRelations,
  subscriptionStatusEnum: () => subscriptionStatusEnum,
  subscriptionTiers: () => subscriptionTiers,
  subscriptions: () => subscriptions,
  supportTicketMessages: () => supportTicketMessages,
  supportTickets: () => supportTickets,
  themeStyleEnum: () => themeStyleEnum,
  threadPosts: () => threadPosts,
  ticketCategoryEnum: () => ticketCategoryEnum,
  ticketPriorityEnum: () => ticketPriorityEnum,
  ticketStatusEnum: () => ticketStatusEnum,
  totpSecrets: () => totpSecrets,
  trafficSourceEnum: () => trafficSourceEnum,
  trendsDaily: () => trendsDaily,
  trustedDevices: () => trustedDevices,
  trustedDevicesRelations: () => trustedDevicesRelations,
  typingIndicators: () => typingIndicators,
  usageStats: () => usageStats,
  userAchievements: () => userAchievements,
  userAdInteractions: () => userAdInteractions,
  userAdPreferences: () => userAdPreferences,
  userBankAccounts: () => userBankAccounts,
  userCategoryEnum: () => userCategoryEnum,
  userInterestProfiles: () => userInterestProfiles,
  userInterests: () => userInterests,
  userInterestsRelations: () => userInterestsRelations,
  userKyc: () => userKyc,
  userLinks: () => userLinks,
  userLinksRelations: () => userLinksRelations,
  userLocations: () => userLocations,
  userNotes: () => userNotes,
  userNotesRelations: () => userNotesRelations,
  userOnlineStatus: () => userOnlineStatus,
  userRoles: () => userRoles,
  userRolesRelations: () => userRolesRelations,
  userSettings: () => userSettings,
  userSettingsRelations: () => userSettingsRelations,
  userWealthClub: () => userWealthClub,
  users: () => users,
  usersRelations: () => usersRelations,
  vanishModeSettings: () => vanishModeSettings,
  venues: () => venues,
  verificationCategoryEnum: () => verificationCategoryEnum,
  verificationRequests: () => verificationRequests,
  verificationRequestsRelations: () => verificationRequestsRelations,
  verificationStatusEnum: () => verificationStatusEnum,
  videoCalls: () => videoCalls,
  visibilityEnum: () => visibilityEnum,
  walletTransactionStatusEnum: () => walletTransactionStatusEnum,
  walletTransactionTypeEnum: () => walletTransactionTypeEnum,
  wallets: () => wallets,
  watchEvents: () => watchEvents,
  watchEventsRelations: () => watchEventsRelations,
  wealthClubTierEnum: () => wealthClubTierEnum,
  wealthClubs: () => wealthClubs,
  webhookDeliveries: () => webhookDeliveries,
  webhooks: () => webhooks,
  withdrawalRequests: () => withdrawalRequests,
  withdrawalStatusEnum: () => withdrawalStatusEnum,
  wordFilterActionEnum: () => wordFilterActionEnum,
  wordFilters: () => wordFilters,
  wordFiltersRelations: () => wordFiltersRelations,
  zaLocations: () => zaLocations
});
import { sql as sql2, relations } from "drizzle-orm";
import { pgTable as pgTable2, text as text2, varchar as varchar2, timestamp as timestamp2, integer as integer2, bigint as bigint2, boolean as boolean2, unique as unique2, index as index2, pgEnum as pgEnum2, real as real2, jsonb as jsonb2, date } from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema2 } from "drizzle-zod";
var postTypeEnum, visibilityEnum, userCategoryEnum, policyEnum, playlistTypeEnum, verificationStatusEnum, verificationCategoryEnum, relationshipStatusEnum, themeStyleEnum, fontSizeEnum, exportStatusEnum, scheduledStatusEnum, linkIconTypeEnum, industryEnum, netWorthTierEnum, genderEnum, creatorCategoryEnum, businessCategoryEnum, users, usersRelations, posts, postsRelations, comments, commentsRelations, likes, likesRelations, savedPosts, savedPostsRelations, hiddenPosts, hiddenPostsRelations, notInterestedPosts, notInterestedPostsRelations, follows, followsRelations, conversations, conversationsRelations, conversationSettings, messageTypeEnum, messageStatusEnum, messages, messageReactions, userOnlineStatus, typingIndicators, messagesRelations, notificationTypeEnum, reportStatusEnum, blocks, blocksRelations, reports, reportsRelations, notifications, notificationsRelations, bookmarks, bookmarksRelations, shares, sharesRelations, postViews, postViewsRelations, userSettings, userSettingsRelations, verificationRequests, verificationRequestsRelations, trafficSourceEnum, profileViews, profileViewsRelations, watchEvents, watchEventsRelations, dailyUserAnalytics, dailyUserAnalyticsRelations, dailyPostAnalytics, dailyPostAnalyticsRelations, playlists, playlistsRelations, playlistItems, playlistItemsRelations, featuredIntros, featuredIntrosRelations, pins, pinsRelations, storyTypeEnum, storyFontEnum, storyTextAlignEnum, storyTextAnimationEnum, storyReplySettingEnum, storyStickerTypeEnum, storyReactionTypeEnum, stories, storiesRelations, storyViews, storyViewsRelations, storyHighlights, storyHighlightItems, storyHighlightsRelations, storyHighlightItemsRelations, storyStickers, storyStickersRelations, storyStickerResponses, storyStickerResponsesRelations, storyReactions, storyReactionsRelations, storyReplies, storyRepliesRelations, storyDrafts, storyDraftsRelations, storyInsights, storyInsightsRelations, storyStreaks, storyStreaksRelations, storyTemplates, storyMusicLibrary, storyTips, storyTipsRelations, storyCountdownSubscriptions, userNotes, userNotesRelations, userLinks, userLinksRelations, interestCategories, userInterests, userInterestsRelations, contentCategories, contentCategoriesRelations, loginSessions, loginSessionsRelations, trustedDevices, trustedDevicesRelations, restrictedAccounts, restrictedAccountsRelations, mutedAccounts, mutedAccountsRelations, keywordFilters, keywordFiltersRelations, drafts, draftsRelations, scheduledPosts, scheduledPostsRelations, postCollaborators, postCollaboratorsRelations, adminUserNotes, adminUserNotesRelations, closeFriends, closeFriendsRelations, storyViewerRestrictions, storyViewerRestrictionsRelations, dataExportRequests, dataExportRequestsRelations, pendingTagApprovals, pendingTagApprovalsRelations, roles, permissions, rolePermissions, userRoles, auditActionEnum, passwordResetTokens, emailVerificationTokens, phoneVerificationTokens, auditLogs, appSettings, rolesRelations, permissionsRelations, rolePermissionsRelations, userRolesRelations, auditLogsRelations, appSettingsRelations, wordFilterActionEnum, wordFilters, wordFiltersRelations, adminKeywordFilterActionEnum, adminKeywordFilters, adminKeywordFiltersRelations, notificationDefaults, notificationDefaultsRelations, conversationStatusEnum, inboxFolderEnum, gossipTypeEnum, gossipPosts, gossipLikes, gossipComments, gossipRetweets, anonReactionTypeEnum, anonReportStatusEnum, countries, zaLocations, anonGossipPosts, anonGossipReactions, anonGossipReplies, anonGossipReplyReactions, anonGossipReports, gossipSettings, gossipBlockedWords, gossipLocationStats, gossipEngagementVelocity, mallCategories, mallItems, mallPurchases, netWorthReasonEnum, netWorthLedger, trendsDaily, gossipPostsRelations, gossipLikesRelations, gossipCommentsRelations, gossipRetweetsRelations, mallCategoriesRelations, mallItemsRelations, mallPurchasesRelations, netWorthLedgerRelations, anonGossipPostsRelations, anonGossipReactionsRelations, anonGossipRepliesRelations, anonGossipReplyReactionsRelations, anonGossipReportsRelations, gossipEngagementVelocityRelations, insertUserSchema, insertPostSchema, insertCommentSchema, insertMessageSchema, insertStorySchema, insertStoryDraftSchema, interactionTypeEnum, contentTypeEnum, contentInteractions, userInterestProfiles, creatorAffinities, seenContent, seenProfiles, contentFatigue, contentVelocity, notInterested, pushTokens, insertDraftSchema, insertScheduledPostSchema, wallets, coinTransactionTypeEnum, payfastOrderStatusEnum, payfastOrders, coinTransactions, giftTypes, giftTransactions, coinBundles, coinPurchases, dailyRewards, dailyRewardConfig, mallWishlists, mallReviews, withdrawalStatusEnum, userBankAccounts, kycStatusEnum, userKyc, withdrawalRequests, platformRevenueSourceEnum, platformRevenue, platformStats, achievementCategoryEnum, achievements, userAchievements, wealthClubTierEnum, wealthClubs, userWealthClub, stakeStatusEnum, giftStakes, stakingTiers, battleStatusEnum, platformBattles, battleParticipants, creatorEarnings, earningsHistory, economyConfig, ticketStatusEnum, ticketPriorityEnum, ticketCategoryEnum, supportTickets, supportTicketMessages, platformConfig, liveStreamStatusEnum, liveStreams, liveStreamViewers, liveStreamComments, liveStreamReactions, liveStreamGifts, groupPrivacyEnum, groupMemberRoleEnum, groups, groupMembers, groupJoinRequestStatusEnum, groupJoinRequests, groupPosts, eventStatusEnum, eventTypeEnum, rsvpStatusEnum, events, eventRsvps, subscriptionTiers, subscriptionStatusEnum, subscriptions, broadcastChannels, broadcastChannelSubscribers, broadcastMessages, postReactionTypeEnum, postReactions, userLocations, locationSharingSettings, venues, checkIns, groupConversations, groupConversationMemberRoleEnum, groupConversationMembers, groupMessages, callStatusEnum, callTypeEnum, videoCalls, vanishModeSettings, hiddenWords, linkedAccounts, totpSecrets, backupCodes, arFilters, hashtags, postHashtags, postThreads, threadPosts, duetStitchTypeEnum, duetStitchPosts, webhooks, webhookDeliveries, apiAccessTokens, featureFlags, commentReplies, pokes, bffStatus, scheduledMessages, pinnedMessages, chatFolders, chatFolderConversations, usageStats, focusModeSettings, notificationPreferences, securityCheckups, accountBackups, aiAvatars, aiTranslations, platformImportStatusEnum, platformImports, exploreCategories;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    init_ads_schema();
    postTypeEnum = pgEnum2("post_type", ["TEXT", "PHOTO", "VIDEO", "VOICE"]);
    visibilityEnum = pgEnum2("visibility", ["PUBLIC", "FOLLOWERS", "PRIVATE"]);
    userCategoryEnum = pgEnum2("user_category", ["PERSONAL", "CREATOR", "BUSINESS"]);
    policyEnum = pgEnum2("policy", ["EVERYONE", "FOLLOWERS", "NOBODY"]);
    playlistTypeEnum = pgEnum2("playlist_type", ["VIDEO", "VOICE"]);
    verificationStatusEnum = pgEnum2("verification_status", ["SUBMITTED", "UNDER_REVIEW", "APPROVED", "DENIED", "MORE_INFO_NEEDED"]);
    verificationCategoryEnum = pgEnum2("verification_category", ["CELEBRITY", "INFLUENCER", "BUSINESS", "ORGANIZATION", "GOVERNMENT", "OTHER"]);
    relationshipStatusEnum = pgEnum2("relationship_status", ["SINGLE", "IN_RELATIONSHIP", "ENGAGED", "MARRIED", "COMPLICATED", "OPEN", "PREFER_NOT_TO_SAY"]);
    themeStyleEnum = pgEnum2("theme_style", ["DEFAULT", "MINIMAL", "BOLD", "ELEGANT", "DARK", "VIBRANT"]);
    fontSizeEnum = pgEnum2("font_size", ["SMALL", "MEDIUM", "LARGE", "EXTRA_LARGE"]);
    exportStatusEnum = pgEnum2("export_status", ["PENDING", "PROCESSING", "COMPLETED", "FAILED", "EXPIRED"]);
    scheduledStatusEnum = pgEnum2("scheduled_status", ["PENDING", "PUBLISHED", "FAILED", "CANCELLED"]);
    linkIconTypeEnum = pgEnum2("link_icon_type", ["LINK", "WEBSITE", "INSTAGRAM", "TWITTER", "YOUTUBE", "TIKTOK", "LINKEDIN", "GITHUB", "DISCORD", "TWITCH", "SPOTIFY", "AMAZON", "SHOP", "OTHER"]);
    industryEnum = pgEnum2("industry", [
      "TECH",
      "FINANCE",
      "REAL_ESTATE",
      "ENTERTAINMENT",
      "SPORTS",
      "HEALTHCARE",
      "LEGAL",
      "FASHION",
      "HOSPITALITY",
      "MEDIA",
      "AUTOMOTIVE",
      "AVIATION",
      "ART",
      "EDUCATION",
      "CONSULTING",
      "CRYPTO",
      "VENTURE_CAPITAL",
      "PRIVATE_EQUITY",
      "PHILANTHROPY",
      "OTHER"
    ]);
    netWorthTierEnum = pgEnum2("net_worth_tier", [
      "BUILDING",
      "SILVER",
      "GOLD",
      "PLATINUM",
      "DIAMOND"
    ]);
    genderEnum = pgEnum2("gender", [
      "MALE",
      "FEMALE",
      "NON_BINARY",
      "OTHER",
      "PREFER_NOT_TO_SAY"
    ]);
    creatorCategoryEnum = pgEnum2("creator_category", [
      "INFLUENCER",
      "ARTIST_MUSICIAN",
      "PHOTOGRAPHER",
      "VIDEOGRAPHER",
      "BLOGGER",
      "DJ_PRODUCER",
      "COMEDIAN",
      "PUBLIC_FIGURE",
      "GAMER_STREAMER",
      "EDUCATOR",
      "FASHION_MODEL",
      "FITNESS_COACH",
      "BEAUTY_MAKEUP",
      "BUSINESS_CREATOR",
      "OTHER"
    ]);
    businessCategoryEnum = pgEnum2("business_category", [
      "LUXURY_BRAND",
      "RESTAURANT_FOOD",
      "REAL_ESTATE",
      "FASHION_CLOTHING",
      "AUTOMOTIVE",
      "BEAUTY_SALON_SPA",
      "FINANCE_TRADING",
      "MEDIA_ENTERTAINMENT",
      "NIGHTLIFE_CLUB_EVENTS",
      "TECH_SOFTWARE",
      "EDUCATION",
      "HEALTH_MEDICAL",
      "ECOMMERCE_STORE",
      "SERVICES",
      "AGENCY_MARKETING",
      "OTHER"
    ]);
    users = pgTable2("users", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      username: text2("username").notNull().unique(),
      email: text2("email").notNull().unique(),
      emailVerified: boolean2("email_verified").default(false).notNull(),
      password: text2("password").notNull(),
      displayName: text2("display_name").notNull(),
      bio: text2("bio").default(""),
      avatarUrl: text2("avatar_url"),
      coverUrl: text2("cover_url"),
      category: userCategoryEnum("category").default("PERSONAL").notNull(),
      location: text2("location"),
      linkUrl: text2("link_url"),
      netWorth: bigint2("net_worth", { mode: "number" }).default(0).notNull(),
      influenceScore: integer2("influence_score").default(0).notNull(),
      isAdmin: boolean2("is_admin").default(false).notNull(),
      suspendedAt: timestamp2("suspended_at"),
      suspendedUntil: timestamp2("suspended_until"),
      suspendedReason: text2("suspended_reason"),
      suspendedById: varchar2("suspended_by_id"),
      deactivatedAt: timestamp2("deactivated_at"),
      isVerified: boolean2("is_verified").default(false).notNull(),
      verifiedAt: timestamp2("verified_at"),
      pronouns: text2("pronouns"),
      lastActiveAt: timestamp2("last_active_at"),
      birthday: timestamp2("birthday"),
      profileSongUrl: text2("profile_song_url"),
      profileSongTitle: text2("profile_song_title"),
      profileSongArtist: text2("profile_song_artist"),
      avatarVideoUrl: text2("avatar_video_url"),
      phoneNumber: text2("phone_number"),
      phoneVerified: boolean2("phone_verified").default(false).notNull(),
      smsNotificationsEnabled: boolean2("sms_notifications_enabled").default(false).notNull(),
      voiceBioUrl: text2("voice_bio_url"),
      voiceBioDurationMs: integer2("voice_bio_duration_ms"),
      contactEmail: text2("contact_email"),
      contactPhone: text2("contact_phone"),
      contactAddress: text2("contact_address"),
      relationshipStatus: relationshipStatusEnum("relationship_status"),
      relationshipPartnerId: varchar2("relationship_partner_id"),
      themeColor: text2("theme_color"),
      themeStyle: themeStyleEnum("theme_style").default("DEFAULT"),
      // New profile fields
      customHandle: text2("custom_handle").unique(),
      // Vanity URL like @username
      headline: text2("headline"),
      // Professional headline
      extendedBio: text2("extended_bio"),
      // Longer bio (500 chars)
      timezone: text2("timezone"),
      // User's timezone
      profileEffects: jsonb2("profile_effects").default({}),
      // Custom profile effects
      lastSeenAt: timestamp2("last_seen_at"),
      // For activity status
      // Milestones
      followerMilestone: integer2("follower_milestone").default(0),
      // Last reached milestone
      totalLikesReceived: integer2("total_likes_received").default(0),
      totalViewsReceived: integer2("total_views_received").default(0),
      // Onboarding fields
      industry: industryEnum("industry"),
      netWorthTier: netWorthTierEnum("net_worth_tier").default("BUILDING"),
      onboardingCompleted: boolean2("onboarding_completed").default(false).notNull(),
      onboardingStep: integer2("onboarding_step").default(0).notNull(),
      netWorthVisibility: policyEnum("net_worth_visibility").default("EVERYONE"),
      profileVisibility: policyEnum("profile_visibility").default("EVERYONE"),
      firstSessionCompleted: boolean2("first_session_completed").default(false).notNull(),
      // Location fields (all account types)
      country: text2("country"),
      province: text2("province"),
      city: text2("city"),
      gender: genderEnum("gender"),
      // Creator-specific fields
      creatorCategory: creatorCategoryEnum("creator_category"),
      portfolioUrl: text2("portfolio_url"),
      primaryPlatforms: jsonb2("primary_platforms").default([]),
      // Array of platforms: TikTok, Instagram, YouTube, X
      contentLanguage: text2("content_language"),
      contentTags: jsonb2("content_tags").default([]),
      // Array of content focus tags
      hasManagement: boolean2("has_management").default(false),
      managementName: text2("management_name"),
      showLocationPublicly: boolean2("show_location_publicly").default(true),
      // Business-specific fields
      businessCategory: businessCategoryEnum("business_category"),
      dateEstablished: timestamp2("date_established"),
      whatsappNumber: text2("whatsapp_number"),
      businessHours: jsonb2("business_hours").default({}),
      // Object with day keys and open/close times
      websiteUrl: text2("website_url"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      // Social auth fields
      authProvider: text2("auth_provider").default("email"),
      // email, google, apple
      googleId: text2("google_id").unique(),
      appleId: text2("apple_id").unique(),
      profileComplete: boolean2("profile_complete").default(false).notNull(),
      // For social auth users to complete profile
      // Legal agreement tracking
      termsAcceptedAt: timestamp2("terms_accepted_at"),
      privacyAcceptedAt: timestamp2("privacy_accepted_at"),
      communityGuidelinesAcceptedAt: timestamp2("community_guidelines_accepted_at"),
      legalVersion: text2("legal_version"),
      // Version of agreements accepted (e.g., "1.0")
      marketingOptIn: boolean2("marketing_opt_in").default(false),
      // Optional marketing consent
      // End-to-end encryption key pair
      encryptionPublicKey: text2("encryption_public_key"),
      // RSA public key for E2E encryption
      encryptionKeyCreatedAt: timestamp2("encryption_key_created_at")
    });
    usersRelations = relations(users, ({ many }) => ({
      posts: many(posts),
      comments: many(comments),
      likes: many(likes),
      followers: many(follows, { relationName: "following" }),
      following: many(follows, { relationName: "followers" }),
      sentMessages: many(messages, { relationName: "sender" }),
      receivedMessages: many(messages, { relationName: "receiver" })
    }));
    posts = pgTable2("posts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      authorId: varchar2("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      type: postTypeEnum("type").default("TEXT").notNull(),
      content: text2("content"),
      caption: text2("caption"),
      mediaUrl: text2("media_url"),
      thumbnailUrl: text2("thumbnail_url"),
      durationMs: integer2("duration_ms"),
      aspectRatio: real2("aspect_ratio"),
      visibility: visibilityEnum("visibility").default("PUBLIC").notNull(),
      commentsEnabled: boolean2("comments_enabled").default(true).notNull(),
      likesCount: integer2("likes_count").default(0).notNull(),
      commentsCount: integer2("comments_count").default(0).notNull(),
      savesCount: integer2("saves_count").default(0).notNull(),
      sharesCount: integer2("shares_count").default(0).notNull(),
      viewsCount: integer2("views_count").default(0).notNull(),
      isFeatured: boolean2("is_featured").default(false).notNull(),
      isHidden: boolean2("is_hidden").default(false).notNull(),
      hiddenReason: text2("hidden_reason"),
      hiddenAt: timestamp2("hidden_at"),
      hiddenById: varchar2("hidden_by_id"),
      deletedAt: timestamp2("deleted_at"),
      deletedById: varchar2("deleted_by_id"),
      deleteReason: text2("delete_reason"),
      editedAt: timestamp2("edited_at"),
      isArchived: boolean2("is_archived").default(false).notNull(),
      archivedAt: timestamp2("archived_at"),
      isPinned: boolean2("is_pinned").default(false).notNull(),
      pinnedAt: timestamp2("pinned_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("posts_created_at_idx").on(table.createdAt),
      index2("posts_author_id_idx").on(table.authorId),
      index2("posts_type_created_at_idx").on(table.type, table.createdAt),
      index2("posts_author_created_at_idx").on(table.authorId, table.createdAt),
      index2("posts_is_pinned_idx").on(table.isPinned, table.authorId)
    ]);
    postsRelations = relations(posts, ({ one, many }) => ({
      author: one(users, {
        fields: [posts.authorId],
        references: [users.id]
      }),
      comments: many(comments),
      likes: many(likes)
    }));
    comments = pgTable2("comments", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      authorId: varchar2("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      content: text2("content").notNull(),
      isHidden: boolean2("is_hidden").default(false).notNull(),
      hiddenReason: text2("hidden_reason"),
      hiddenAt: timestamp2("hidden_at"),
      hiddenById: varchar2("hidden_by_id"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    commentsRelations = relations(comments, ({ one }) => ({
      post: one(posts, {
        fields: [comments.postId],
        references: [posts.id]
      }),
      author: one(users, {
        fields: [comments.authorId],
        references: [users.id]
      })
    }));
    likes = pgTable2("likes", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("likes_user_post_unique").on(table.userId, table.postId),
      index2("likes_post_id_idx").on(table.postId)
    ]);
    likesRelations = relations(likes, ({ one }) => ({
      post: one(posts, {
        fields: [likes.postId],
        references: [posts.id]
      }),
      user: one(users, {
        fields: [likes.userId],
        references: [users.id]
      })
    }));
    savedPosts = pgTable2("saved_posts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("saved_posts_user_post_unique").on(table.userId, table.postId),
      index2("saved_posts_user_id_idx").on(table.userId),
      index2("saved_posts_post_id_idx").on(table.postId)
    ]);
    savedPostsRelations = relations(savedPosts, ({ one }) => ({
      post: one(posts, {
        fields: [savedPosts.postId],
        references: [posts.id]
      }),
      user: one(users, {
        fields: [savedPosts.userId],
        references: [users.id]
      })
    }));
    hiddenPosts = pgTable2("hidden_posts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      reason: text2("reason"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("hidden_posts_user_post_unique").on(table.userId, table.postId),
      index2("hidden_posts_user_id_idx").on(table.userId)
    ]);
    hiddenPostsRelations = relations(hiddenPosts, ({ one }) => ({
      post: one(posts, {
        fields: [hiddenPosts.postId],
        references: [posts.id]
      }),
      user: one(users, {
        fields: [hiddenPosts.userId],
        references: [users.id]
      })
    }));
    notInterestedPosts = pgTable2("not_interested_posts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      reason: text2("reason"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("not_interested_user_post_unique").on(table.userId, table.postId),
      index2("not_interested_user_id_idx").on(table.userId)
    ]);
    notInterestedPostsRelations = relations(notInterestedPosts, ({ one }) => ({
      post: one(posts, {
        fields: [notInterestedPosts.postId],
        references: [posts.id]
      }),
      user: one(users, {
        fields: [notInterestedPosts.userId],
        references: [users.id]
      })
    }));
    follows = pgTable2("follows", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      followerId: varchar2("follower_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      followingId: varchar2("following_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("follows_unique").on(table.followerId, table.followingId),
      index2("follows_follower_id_idx").on(table.followerId),
      index2("follows_following_id_idx").on(table.followingId)
    ]);
    followsRelations = relations(follows, ({ one }) => ({
      follower: one(users, {
        fields: [follows.followerId],
        references: [users.id],
        relationName: "followers"
      }),
      following: one(users, {
        fields: [follows.followingId],
        references: [users.id],
        relationName: "following"
      })
    }));
    conversations = pgTable2("conversations", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      participant1Id: varchar2("participant1_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      participant2Id: varchar2("participant2_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      status: text2("status").default("ACCEPTED").notNull(),
      inboxFolder: text2("inbox_folder").default("PRIMARY").notNull(),
      requestedByUserId: varchar2("requested_by_user_id").references(() => users.id, { onDelete: "set null" }),
      acceptedAt: timestamp2("accepted_at"),
      lastMessageAt: timestamp2("last_message_at").defaultNow().notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("conversations_participants_unique").on(table.participant1Id, table.participant2Id)
    ]);
    conversationsRelations = relations(conversations, ({ one, many }) => ({
      participant1: one(users, {
        fields: [conversations.participant1Id],
        references: [users.id]
      }),
      participant2: one(users, {
        fields: [conversations.participant2Id],
        references: [users.id]
      }),
      messages: many(messages)
    }));
    conversationSettings = pgTable2("conversation_settings", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      conversationId: varchar2("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      isMuted: boolean2("is_muted").default(false).notNull(),
      mutedUntil: timestamp2("muted_until"),
      // null = muted forever
      isPinned: boolean2("is_pinned").default(false).notNull(),
      isArchived: boolean2("is_archived").default(false).notNull(),
      notificationSound: text2("notification_sound").default("default"),
      customName: text2("custom_name"),
      // Custom nickname for conversation
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("conversation_settings_unique").on(table.conversationId, table.userId),
      index2("conversation_settings_user_idx").on(table.userId)
    ]);
    messageTypeEnum = pgEnum2("message_type", ["TEXT", "PHOTO", "VIDEO", "VOICE", "FILE", "GIF", "STICKER", "LINK"]);
    messageStatusEnum = pgEnum2("message_status", ["SENDING", "SENT", "DELIVERED", "READ", "FAILED"]);
    messages = pgTable2("messages", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      conversationId: varchar2("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }),
      senderId: varchar2("sender_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      receiverId: varchar2("receiver_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      content: text2("content").notNull(),
      messageType: messageTypeEnum("message_type").default("TEXT"),
      // End-to-end encryption fields
      encryptedContent: text2("encrypted_content"),
      // Encrypted message content
      encryptedKey: text2("encrypted_key"),
      // Symmetric key encrypted with recipient's public key
      iv: text2("iv"),
      // Initialization vector for decryption
      // Delivery status
      status: messageStatusEnum("status").default("SENT"),
      deliveredAt: timestamp2("delivered_at"),
      // Media fields
      mediaUrl: text2("media_url"),
      mediaThumbnail: text2("media_thumbnail"),
      mediaDuration: integer2("media_duration"),
      // File fields
      fileName: text2("file_name"),
      fileSize: integer2("file_size"),
      fileMimeType: text2("file_mime_type"),
      // Voice note fields
      voiceWaveform: jsonb2("voice_waveform"),
      // Array of amplitude values for visualization
      // Link preview fields
      linkUrl: text2("link_url"),
      linkTitle: text2("link_title"),
      linkDescription: text2("link_description"),
      linkImage: text2("link_image"),
      linkDomain: text2("link_domain"),
      // Reply/quote
      replyToId: varchar2("reply_to_id"),
      // Read/delete status
      read: boolean2("read").default(false).notNull(),
      readAt: timestamp2("read_at"),
      deletedAt: timestamp2("deleted_at"),
      deletedForSender: boolean2("deleted_for_sender").default(false),
      deletedForReceiver: boolean2("deleted_for_receiver").default(false),
      // Disappearing messages (optional feature)
      expiresAt: timestamp2("expires_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("messages_conversation_created_idx").on(table.conversationId, table.createdAt),
      index2("messages_reply_to_idx").on(table.replyToId),
      index2("messages_status_idx").on(table.status)
    ]);
    messageReactions = pgTable2("message_reactions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      messageId: varchar2("message_id").notNull().references(() => messages.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      reaction: varchar2("reaction", { length: 10 }).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("message_reactions_unique").on(table.messageId, table.userId),
      index2("message_reactions_message_idx").on(table.messageId)
    ]);
    userOnlineStatus = pgTable2("user_online_status", {
      userId: varchar2("user_id").primaryKey().references(() => users.id, { onDelete: "cascade" }),
      isOnline: boolean2("is_online").default(false).notNull(),
      lastSeenAt: timestamp2("last_seen_at").defaultNow().notNull()
    });
    typingIndicators = pgTable2("typing_indicators", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      conversationId: varchar2("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      isTyping: boolean2("is_typing").default(false).notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("typing_indicators_unique").on(table.conversationId, table.userId)
    ]);
    messagesRelations = relations(messages, ({ one }) => ({
      conversation: one(conversations, {
        fields: [messages.conversationId],
        references: [conversations.id]
      }),
      sender: one(users, {
        fields: [messages.senderId],
        references: [users.id],
        relationName: "sender"
      }),
      receiver: one(users, {
        fields: [messages.receiverId],
        references: [users.id],
        relationName: "receiver"
      })
    }));
    notificationTypeEnum = pgEnum2("notification_type", [
      "LIKE",
      "COMMENT",
      "FOLLOW",
      "MESSAGE",
      "MENTION",
      "VERIFICATION_APPROVED",
      "VERIFICATION_DENIED",
      "VERIFICATION_INFO_NEEDED",
      "STORY_MENTION",
      "STORY_REPLY",
      "STORY_REACTION",
      "STORY_STICKER_RESPONSE",
      "AD_CAMPAIGN_ENDED",
      "AD_LOW_BALANCE",
      "AD_REFUND_PROCESSED",
      "AD_DISPUTE_RESOLVED"
    ]);
    reportStatusEnum = pgEnum2("report_status", ["PENDING", "REVIEWED", "RESOLVED", "DISMISSED"]);
    blocks = pgTable2("blocks", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      blockerId: varchar2("blocker_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      blockedId: varchar2("blocked_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("blocks_unique").on(table.blockerId, table.blockedId),
      index2("blocks_blocker_id_idx").on(table.blockerId),
      index2("blocks_blocked_id_idx").on(table.blockedId)
    ]);
    blocksRelations = relations(blocks, ({ one }) => ({
      blocker: one(users, {
        fields: [blocks.blockerId],
        references: [users.id],
        relationName: "blocker"
      }),
      blocked: one(users, {
        fields: [blocks.blockedId],
        references: [users.id],
        relationName: "blocked"
      })
    }));
    reports = pgTable2("reports", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      reporterId: varchar2("reporter_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      reportedUserId: varchar2("reported_user_id").references(() => users.id, { onDelete: "cascade" }),
      reportedPostId: varchar2("reported_post_id").references(() => posts.id, { onDelete: "cascade" }),
      reason: text2("reason").notNull(),
      status: reportStatusEnum("status").default("PENDING").notNull(),
      adminNotes: text2("admin_notes"),
      resolvedAt: timestamp2("resolved_at"),
      resolvedById: varchar2("resolved_by_id").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("reports_status_idx").on(table.status),
      index2("reports_reporter_id_idx").on(table.reporterId),
      index2("reports_created_at_idx").on(table.createdAt)
    ]);
    reportsRelations = relations(reports, ({ one }) => ({
      reporter: one(users, {
        fields: [reports.reporterId],
        references: [users.id],
        relationName: "reporter"
      }),
      reportedUser: one(users, {
        fields: [reports.reportedUserId],
        references: [users.id],
        relationName: "reportedUser"
      }),
      reportedPost: one(posts, {
        fields: [reports.reportedPostId],
        references: [posts.id]
      }),
      resolvedBy: one(users, {
        fields: [reports.resolvedById],
        references: [users.id],
        relationName: "resolver"
      })
    }));
    notifications = pgTable2("notifications", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      actorId: varchar2("actor_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      type: notificationTypeEnum("type").notNull(),
      entityId: varchar2("entity_id"),
      readAt: timestamp2("read_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("notifications_user_id_idx").on(table.userId),
      index2("notifications_user_read_idx").on(table.userId, table.readAt),
      index2("notifications_created_at_idx").on(table.createdAt)
    ]);
    notificationsRelations = relations(notifications, ({ one }) => ({
      user: one(users, {
        fields: [notifications.userId],
        references: [users.id],
        relationName: "recipient"
      }),
      actor: one(users, {
        fields: [notifications.actorId],
        references: [users.id],
        relationName: "actor"
      })
    }));
    bookmarks = pgTable2("bookmarks", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("bookmarks_user_post_unique").on(table.userId, table.postId),
      index2("bookmarks_user_id_idx").on(table.userId),
      index2("bookmarks_post_id_idx").on(table.postId)
    ]);
    bookmarksRelations = relations(bookmarks, ({ one }) => ({
      user: one(users, {
        fields: [bookmarks.userId],
        references: [users.id]
      }),
      post: one(posts, {
        fields: [bookmarks.postId],
        references: [posts.id]
      })
    }));
    shares = pgTable2("shares", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      platform: text2("platform"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("shares_user_id_idx").on(table.userId),
      index2("shares_post_id_idx").on(table.postId)
    ]);
    sharesRelations = relations(shares, ({ one }) => ({
      user: one(users, {
        fields: [shares.userId],
        references: [users.id]
      }),
      post: one(posts, {
        fields: [shares.postId],
        references: [posts.id]
      })
    }));
    postViews = pgTable2("post_views", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      viewedAt: timestamp2("viewed_at").defaultNow().notNull()
    }, (table) => [
      unique2("post_views_user_post_date_unique").on(table.userId, table.postId),
      index2("post_views_user_id_idx").on(table.userId),
      index2("post_views_post_id_idx").on(table.postId)
    ]);
    postViewsRelations = relations(postViews, ({ one }) => ({
      user: one(users, {
        fields: [postViews.userId],
        references: [users.id]
      }),
      post: one(posts, {
        fields: [postViews.postId],
        references: [posts.id]
      })
    }));
    userSettings = pgTable2("user_settings", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      // Account Privacy
      privateAccount: boolean2("private_account").default(false).notNull(),
      activityStatusVisible: boolean2("activity_status_visible").default(true).notNull(),
      readReceiptsEnabled: boolean2("read_receipts_enabled").default(true).notNull(),
      profileViewHistoryEnabled: boolean2("profile_view_history_enabled").default(true).notNull(),
      anonymousViewingEnabled: boolean2("anonymous_viewing_enabled").default(false).notNull(),
      hideLikesTab: boolean2("hide_likes_tab").default(false).notNull(),
      tagApprovalRequired: boolean2("tag_approval_required").default(false).notNull(),
      searchEngineVisible: boolean2("search_engine_visible").default(true).notNull(),
      emailDiscoverable: boolean2("email_discoverable").default(false).notNull(),
      phoneDiscoverable: boolean2("phone_discoverable").default(false).notNull(),
      // Content Policies
      commentPolicy: policyEnum("comment_policy").default("EVERYONE").notNull(),
      messagePolicy: policyEnum("message_policy").default("EVERYONE").notNull(),
      mentionPolicy: policyEnum("mention_policy").default("EVERYONE").notNull(),
      storyViewPolicy: policyEnum("story_view_policy").default("FOLLOWERS").notNull(),
      followersListVisibility: policyEnum("followers_list_visibility").default("EVERYONE").notNull(),
      followingListVisibility: policyEnum("following_list_visibility").default("EVERYONE").notNull(),
      // Push Notifications
      pushNotifications: jsonb2("push_notifications").default({
        likes: true,
        comments: true,
        follows: true,
        messages: true,
        mentions: true,
        storyViews: false,
        profileViews: false,
        newFollowers: true,
        liveVideos: true,
        promotions: false
      }).notNull(),
      // Email Notifications
      emailNotifications: jsonb2("email_notifications").default({
        weeklyDigest: true,
        newFollowers: false,
        messages: false,
        mentions: false,
        productUpdates: true,
        securityAlerts: true
      }).notNull(),
      // Quiet Hours / Do Not Disturb
      quietHoursEnabled: boolean2("quiet_hours_enabled").default(false).notNull(),
      quietHoursStart: text2("quiet_hours_start"),
      // "22:00" format
      quietHoursEnd: text2("quiet_hours_end"),
      // "07:00" format
      quietHoursTimezone: text2("quiet_hours_timezone"),
      // Content Preferences
      contentPreferences: jsonb2("content_preferences").default({
        showSensitiveContent: false,
        autoTranslate: true,
        prioritizeFollowing: true
      }).notNull(),
      sensitiveContentFilter: boolean2("sensitive_content_filter").default(true).notNull(),
      // Security
      loginAlertsEnabled: boolean2("login_alerts_enabled").default(true).notNull(),
      twoFactorEnabled: boolean2("two_factor_enabled").default(false).notNull(),
      // Accessibility
      fontSizePreference: fontSizeEnum("font_size_preference").default("MEDIUM").notNull(),
      // Legacy (keeping for compatibility)
      notifications: jsonb2("notifications").default({
        likes: true,
        comments: true,
        follows: true,
        messages: true,
        mentions: true
      }).notNull(),
      mediaPrefs: jsonb2("media_prefs").default({
        autoplay: true,
        dataSaver: false,
        uploadQuality: "high"
      }).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    userSettingsRelations = relations(userSettings, ({ one }) => ({
      user: one(users, {
        fields: [userSettings.userId],
        references: [users.id]
      })
    }));
    verificationRequests = pgTable2("verification_requests", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      fullName: text2("full_name").notNull(),
      category: verificationCategoryEnum("category").notNull(),
      documentUrls: jsonb2("document_urls").default([]).notNull(),
      links: jsonb2("links").default([]).notNull(),
      reason: text2("reason").notNull(),
      status: verificationStatusEnum("status").default("SUBMITTED").notNull(),
      adminNotes: text2("admin_notes"),
      denialReason: text2("denial_reason"),
      reviewedById: varchar2("reviewed_by_id"),
      reviewedAt: timestamp2("reviewed_at"),
      submittedAt: timestamp2("submitted_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("verification_requests_user_id_idx").on(table.userId),
      index2("verification_requests_status_idx").on(table.status),
      index2("verification_requests_submitted_at_idx").on(table.submittedAt)
    ]);
    verificationRequestsRelations = relations(verificationRequests, ({ one }) => ({
      user: one(users, {
        fields: [verificationRequests.userId],
        references: [users.id]
      }),
      reviewedBy: one(users, {
        fields: [verificationRequests.reviewedById],
        references: [users.id]
      })
    }));
    trafficSourceEnum = pgEnum2("traffic_source", ["FEED", "PROFILE", "SEARCH", "SHARE", "DIRECT", "OTHER"]);
    profileViews = pgTable2("profile_views", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      profileUserId: varchar2("profile_user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      viewerId: varchar2("viewer_id").references(() => users.id, { onDelete: "set null" }),
      source: trafficSourceEnum("source").default("DIRECT").notNull(),
      viewedAt: timestamp2("viewed_at").defaultNow().notNull()
    }, (table) => [
      index2("profile_views_profile_user_id_idx").on(table.profileUserId),
      index2("profile_views_viewed_at_idx").on(table.viewedAt),
      index2("profile_views_profile_date_idx").on(table.profileUserId, table.viewedAt)
    ]);
    profileViewsRelations = relations(profileViews, ({ one }) => ({
      profileUser: one(users, {
        fields: [profileViews.profileUserId],
        references: [users.id]
      }),
      viewer: one(users, {
        fields: [profileViews.viewerId],
        references: [users.id]
      })
    }));
    watchEvents = pgTable2("watch_events", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").references(() => users.id, { onDelete: "set null" }),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      watchTimeMs: integer2("watch_time_ms").default(0).notNull(),
      completed: boolean2("completed").default(false).notNull(),
      source: trafficSourceEnum("source").default("FEED").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("watch_events_post_id_idx").on(table.postId),
      index2("watch_events_user_id_idx").on(table.userId),
      index2("watch_events_created_at_idx").on(table.createdAt),
      index2("watch_events_post_date_idx").on(table.postId, table.createdAt)
    ]);
    watchEventsRelations = relations(watchEvents, ({ one }) => ({
      user: one(users, {
        fields: [watchEvents.userId],
        references: [users.id]
      }),
      post: one(posts, {
        fields: [watchEvents.postId],
        references: [posts.id]
      })
    }));
    dailyUserAnalytics = pgTable2("daily_user_analytics", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      date: timestamp2("date").notNull(),
      profileViews: integer2("profile_views").default(0).notNull(),
      postViews: integer2("post_views").default(0).notNull(),
      likesReceived: integer2("likes_received").default(0).notNull(),
      commentsReceived: integer2("comments_received").default(0).notNull(),
      sharesReceived: integer2("shares_received").default(0).notNull(),
      savesReceived: integer2("saves_received").default(0).notNull(),
      newFollowers: integer2("new_followers").default(0).notNull(),
      unfollows: integer2("unfollows").default(0).notNull(),
      totalWatchTimeMs: integer2("total_watch_time_ms").default(0).notNull(),
      sourceFromFeed: integer2("source_from_feed").default(0).notNull(),
      sourceFromProfile: integer2("source_from_profile").default(0).notNull(),
      sourceFromSearch: integer2("source_from_search").default(0).notNull(),
      sourceFromShare: integer2("source_from_share").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("daily_user_analytics_user_date_unique").on(table.userId, table.date),
      index2("daily_user_analytics_user_id_idx").on(table.userId),
      index2("daily_user_analytics_date_idx").on(table.date)
    ]);
    dailyUserAnalyticsRelations = relations(dailyUserAnalytics, ({ one }) => ({
      user: one(users, {
        fields: [dailyUserAnalytics.userId],
        references: [users.id]
      })
    }));
    dailyPostAnalytics = pgTable2("daily_post_analytics", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      date: timestamp2("date").notNull(),
      views: integer2("views").default(0).notNull(),
      uniqueViews: integer2("unique_views").default(0).notNull(),
      likes: integer2("likes").default(0).notNull(),
      comments: integer2("comments").default(0).notNull(),
      shares: integer2("shares").default(0).notNull(),
      saves: integer2("saves").default(0).notNull(),
      totalWatchTimeMs: integer2("total_watch_time_ms").default(0).notNull(),
      avgWatchTimeMs: integer2("avg_watch_time_ms").default(0).notNull(),
      completions: integer2("completions").default(0).notNull(),
      sourceFromFeed: integer2("source_from_feed").default(0).notNull(),
      sourceFromProfile: integer2("source_from_profile").default(0).notNull(),
      sourceFromSearch: integer2("source_from_search").default(0).notNull(),
      sourceFromShare: integer2("source_from_share").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("daily_post_analytics_post_date_unique").on(table.postId, table.date),
      index2("daily_post_analytics_post_id_idx").on(table.postId),
      index2("daily_post_analytics_date_idx").on(table.date)
    ]);
    dailyPostAnalyticsRelations = relations(dailyPostAnalytics, ({ one }) => ({
      post: one(posts, {
        fields: [dailyPostAnalytics.postId],
        references: [posts.id]
      })
    }));
    playlists = pgTable2("playlists", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      title: varchar2("title", { length: 100 }).notNull(),
      description: text2("description"),
      type: playlistTypeEnum("type").notNull(),
      isPublic: boolean2("is_public").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("playlists_user_id_idx").on(table.userId),
      index2("playlists_type_idx").on(table.type)
    ]);
    playlistsRelations = relations(playlists, ({ one, many }) => ({
      user: one(users, {
        fields: [playlists.userId],
        references: [users.id]
      }),
      items: many(playlistItems)
    }));
    playlistItems = pgTable2("playlist_items", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      playlistId: varchar2("playlist_id").notNull().references(() => playlists.id, { onDelete: "cascade" }),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      order: integer2("order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("playlist_items_playlist_post_unique").on(table.playlistId, table.postId),
      index2("playlist_items_playlist_id_idx").on(table.playlistId),
      index2("playlist_items_order_idx").on(table.playlistId, table.order)
    ]);
    playlistItemsRelations = relations(playlistItems, ({ one }) => ({
      playlist: one(playlists, {
        fields: [playlistItems.playlistId],
        references: [playlists.id]
      }),
      post: one(posts, {
        fields: [playlistItems.postId],
        references: [posts.id]
      })
    }));
    featuredIntros = pgTable2("featured_intros", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      title: varchar2("title", { length: 100 }).notNull(),
      body: text2("body").notNull(),
      ctaText: varchar2("cta_text", { length: 50 }),
      ctaUrl: text2("cta_url"),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    featuredIntrosRelations = relations(featuredIntros, ({ one }) => ({
      user: one(users, {
        fields: [featuredIntros.userId],
        references: [users.id]
      })
    }));
    pins = pgTable2("pins", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      order: integer2("order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("pins_user_post_unique").on(table.userId, table.postId),
      index2("pins_user_id_idx").on(table.userId),
      index2("pins_order_idx").on(table.userId, table.order)
    ]);
    pinsRelations = relations(pins, ({ one }) => ({
      user: one(users, {
        fields: [pins.userId],
        references: [users.id]
      }),
      post: one(posts, {
        fields: [pins.postId],
        references: [posts.id]
      })
    }));
    storyTypeEnum = pgEnum2("story_type", ["PHOTO", "VIDEO", "TEXT", "VOICE", "SHARED_POST"]);
    storyFontEnum = pgEnum2("story_font", ["MODERN", "SERIF", "HANDWRITTEN", "BOLD", "LUXURY"]);
    storyTextAlignEnum = pgEnum2("story_text_align", ["LEFT", "CENTER", "RIGHT"]);
    storyTextAnimationEnum = pgEnum2("story_text_animation", ["NONE", "TYPEWRITER", "FADE", "BOUNCE", "GLOW", "SPARKLE", "RAINBOW"]);
    storyReplySettingEnum = pgEnum2("story_reply_setting", ["ALL", "FOLLOWERS", "CLOSE_FRIENDS", "OFF"]);
    storyStickerTypeEnum = pgEnum2("story_sticker_type", [
      "POLL",
      "QUESTION",
      "SLIDER",
      "QUIZ",
      "COUNTDOWN",
      "LOCATION",
      "TIME",
      "LINK",
      "MENTION",
      "HASHTAG",
      "GIF",
      "SHOPPING",
      "TIP"
    ]);
    storyReactionTypeEnum = pgEnum2("story_reaction_type", ["FIRE", "HEART", "LAUGH", "WOW", "SAD", "CLAP"]);
    stories = pgTable2("stories", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      type: storyTypeEnum("type").notNull(),
      mediaUrl: text2("media_url"),
      thumbnailUrl: text2("thumbnail_url"),
      durationMs: integer2("duration_ms"),
      caption: text2("caption"),
      viewsCount: integer2("views_count").default(0).notNull(),
      expiresAt: timestamp2("expires_at").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      // Text story fields
      textContent: text2("text_content"),
      backgroundColor: text2("background_color"),
      isGradient: boolean2("is_gradient").default(false),
      gradientColors: jsonb2("gradient_colors"),
      fontFamily: storyFontEnum("font_family").default("MODERN"),
      textAlignment: storyTextAlignEnum("text_alignment").default("CENTER"),
      textAnimation: storyTextAnimationEnum("text_animation").default("NONE"),
      textBackgroundPill: boolean2("text_background_pill").default(false),
      fontSize: integer2("font_size").default(24),
      // Voice story fields
      audioUrl: text2("audio_url"),
      audioDuration: integer2("audio_duration"),
      audioTranscript: text2("audio_transcript"),
      // Music overlay
      musicUrl: text2("music_url"),
      musicTitle: text2("music_title"),
      musicArtist: text2("music_artist"),
      musicStartTime: integer2("music_start_time"),
      musicDuration: integer2("music_duration"),
      // Filters & effects
      filterName: text2("filter_name"),
      // Text overlays (for photo/video stories)
      textOverlays: jsonb2("text_overlays"),
      // Drawing data
      drawings: jsonb2("drawings"),
      // Settings
      isCloseFriends: boolean2("is_close_friends").default(false),
      replySetting: storyReplySettingEnum("reply_setting").default("ALL"),
      scheduledAt: timestamp2("scheduled_at"),
      // Location
      locationName: text2("location_name"),
      locationLat: real2("location_lat"),
      locationLng: real2("location_lng"),
      // Reshare (for story resharing)
      resharedFromId: varchar2("reshared_from_id"),
      reshareComment: text2("reshare_comment"),
      // Shared Post (for sharing feed posts to story - Instagram-style)
      sharedPostId: varchar2("shared_post_id"),
      // Stats
      reactionsCount: integer2("reactions_count").default(0).notNull(),
      repliesCount: integer2("replies_count").default(0).notNull(),
      sharesCount: integer2("shares_count").default(0).notNull(),
      tapsForwardCount: integer2("taps_forward_count").default(0).notNull(),
      tapsBackCount: integer2("taps_back_count").default(0).notNull(),
      exitsCount: integer2("exits_count").default(0).notNull()
    }, (table) => [
      index2("stories_user_id_idx").on(table.userId),
      index2("stories_expires_at_idx").on(table.expiresAt),
      index2("stories_user_created_idx").on(table.userId, table.createdAt),
      index2("stories_type_idx").on(table.type),
      index2("stories_close_friends_idx").on(table.isCloseFriends)
    ]);
    storiesRelations = relations(stories, ({ one, many }) => ({
      user: one(users, {
        fields: [stories.userId],
        references: [users.id]
      }),
      views: many(storyViews)
    }));
    storyViews = pgTable2("story_views", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      storyId: varchar2("story_id").notNull().references(() => stories.id, { onDelete: "cascade" }),
      viewerId: varchar2("viewer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      viewedAt: timestamp2("viewed_at").defaultNow().notNull()
    }, (table) => [
      unique2("story_views_unique").on(table.storyId, table.viewerId),
      index2("story_views_story_id_idx").on(table.storyId),
      index2("story_views_viewer_id_idx").on(table.viewerId)
    ]);
    storyViewsRelations = relations(storyViews, ({ one }) => ({
      story: one(stories, {
        fields: [storyViews.storyId],
        references: [stories.id]
      }),
      viewer: one(users, {
        fields: [storyViews.viewerId],
        references: [users.id]
      })
    }));
    storyHighlights = pgTable2("story_highlights", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      name: text2("name").notNull(),
      coverUrl: text2("cover_url"),
      order: integer2("order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("story_highlights_user_id_idx").on(table.userId),
      index2("story_highlights_order_idx").on(table.userId, table.order)
    ]);
    storyHighlightItems = pgTable2("story_highlight_items", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      highlightId: varchar2("highlight_id").notNull().references(() => storyHighlights.id, { onDelete: "cascade" }),
      storyId: varchar2("story_id").notNull().references(() => stories.id, { onDelete: "cascade" }),
      order: integer2("order").default(0).notNull(),
      addedAt: timestamp2("added_at").defaultNow().notNull()
    }, (table) => [
      unique2("highlight_story_unique").on(table.highlightId, table.storyId),
      index2("story_highlight_items_highlight_idx").on(table.highlightId)
    ]);
    storyHighlightsRelations = relations(storyHighlights, ({ one, many }) => ({
      user: one(users, {
        fields: [storyHighlights.userId],
        references: [users.id]
      }),
      items: many(storyHighlightItems)
    }));
    storyHighlightItemsRelations = relations(storyHighlightItems, ({ one }) => ({
      highlight: one(storyHighlights, {
        fields: [storyHighlightItems.highlightId],
        references: [storyHighlights.id]
      }),
      story: one(stories, {
        fields: [storyHighlightItems.storyId],
        references: [stories.id]
      })
    }));
    storyStickers = pgTable2("story_stickers", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      storyId: varchar2("story_id").notNull().references(() => stories.id, { onDelete: "cascade" }),
      type: storyStickerTypeEnum("type").notNull(),
      positionX: real2("position_x").default(0.5).notNull(),
      positionY: real2("position_y").default(0.5).notNull(),
      scale: real2("scale").default(1).notNull(),
      rotation: real2("rotation").default(0).notNull(),
      data: jsonb2("data").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("story_stickers_story_id_idx").on(table.storyId)
    ]);
    storyStickersRelations = relations(storyStickers, ({ one, many }) => ({
      story: one(stories, {
        fields: [storyStickers.storyId],
        references: [stories.id]
      }),
      responses: many(storyStickerResponses)
    }));
    storyStickerResponses = pgTable2("story_sticker_responses", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      stickerId: varchar2("sticker_id").notNull().references(() => storyStickers.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      responseType: text2("response_type").notNull(),
      responseData: jsonb2("response_data").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("story_sticker_responses_sticker_id_idx").on(table.stickerId),
      index2("story_sticker_responses_user_id_idx").on(table.userId),
      unique2("story_sticker_response_unique").on(table.stickerId, table.userId)
    ]);
    storyStickerResponsesRelations = relations(storyStickerResponses, ({ one }) => ({
      sticker: one(storyStickers, {
        fields: [storyStickerResponses.stickerId],
        references: [storyStickers.id]
      }),
      user: one(users, {
        fields: [storyStickerResponses.userId],
        references: [users.id]
      })
    }));
    storyReactions = pgTable2("story_reactions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      storyId: varchar2("story_id").notNull().references(() => stories.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      reactionType: storyReactionTypeEnum("reaction_type").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("story_reactions_story_id_idx").on(table.storyId),
      index2("story_reactions_user_id_idx").on(table.userId),
      unique2("story_reaction_unique").on(table.storyId, table.userId)
    ]);
    storyReactionsRelations = relations(storyReactions, ({ one }) => ({
      story: one(stories, {
        fields: [storyReactions.storyId],
        references: [stories.id]
      }),
      user: one(users, {
        fields: [storyReactions.userId],
        references: [users.id]
      })
    }));
    storyReplies = pgTable2("story_replies", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      storyId: varchar2("story_id").notNull().references(() => stories.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      content: text2("content"),
      mediaUrl: text2("media_url"),
      mediaType: text2("media_type"),
      isRead: boolean2("is_read").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("story_replies_story_id_idx").on(table.storyId),
      index2("story_replies_user_id_idx").on(table.userId)
    ]);
    storyRepliesRelations = relations(storyReplies, ({ one }) => ({
      story: one(stories, {
        fields: [storyReplies.storyId],
        references: [stories.id]
      }),
      user: one(users, {
        fields: [storyReplies.userId],
        references: [users.id]
      })
    }));
    storyDrafts = pgTable2("story_drafts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      type: storyTypeEnum("type").notNull(),
      mediaUrl: text2("media_url"),
      thumbnailUrl: text2("thumbnail_url"),
      textContent: text2("text_content"),
      backgroundColor: text2("background_color"),
      isGradient: boolean2("is_gradient").default(false),
      gradientColors: jsonb2("gradient_colors"),
      fontFamily: storyFontEnum("font_family").default("MODERN"),
      textAlignment: storyTextAlignEnum("text_alignment").default("CENTER"),
      textAnimation: storyTextAnimationEnum("text_animation").default("NONE"),
      fontSize: integer2("font_size").default(24),
      audioUrl: text2("audio_url"),
      audioDuration: integer2("audio_duration"),
      musicUrl: text2("music_url"),
      musicTitle: text2("music_title"),
      musicArtist: text2("music_artist"),
      filterName: text2("filter_name"),
      textOverlays: jsonb2("text_overlays"),
      drawings: jsonb2("drawings"),
      stickers: jsonb2("stickers"),
      isCloseFriends: boolean2("is_close_friends").default(false),
      replySetting: storyReplySettingEnum("reply_setting").default("ALL"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("story_drafts_user_id_idx").on(table.userId)
    ]);
    storyDraftsRelations = relations(storyDrafts, ({ one }) => ({
      user: one(users, {
        fields: [storyDrafts.userId],
        references: [users.id]
      })
    }));
    storyInsights = pgTable2("story_insights", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      storyId: varchar2("story_id").notNull().references(() => stories.id, { onDelete: "cascade" }),
      viewerId: varchar2("viewer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      viewDuration: integer2("view_duration"),
      tappedForward: boolean2("tapped_forward").default(false),
      tappedBack: boolean2("tapped_back").default(false),
      exited: boolean2("exited").default(false),
      shared: boolean2("shared").default(false),
      profileVisited: boolean2("profile_visited").default(false),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("story_insights_story_id_idx").on(table.storyId),
      index2("story_insights_viewer_id_idx").on(table.viewerId),
      unique2("story_insights_unique").on(table.storyId, table.viewerId)
    ]);
    storyInsightsRelations = relations(storyInsights, ({ one }) => ({
      story: one(stories, {
        fields: [storyInsights.storyId],
        references: [stories.id]
      }),
      viewer: one(users, {
        fields: [storyInsights.viewerId],
        references: [users.id]
      })
    }));
    storyStreaks = pgTable2("story_streaks", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }).unique(),
      currentStreak: integer2("current_streak").default(0).notNull(),
      longestStreak: integer2("longest_streak").default(0).notNull(),
      lastStoryAt: timestamp2("last_story_at"),
      streakStartedAt: timestamp2("streak_started_at"),
      milestone7Claimed: boolean2("milestone_7_claimed").default(false),
      milestone30Claimed: boolean2("milestone_30_claimed").default(false),
      milestone100Claimed: boolean2("milestone_100_claimed").default(false),
      milestone365Claimed: boolean2("milestone_365_claimed").default(false),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("story_streaks_user_id_idx").on(table.userId)
    ]);
    storyStreaksRelations = relations(storyStreaks, ({ one }) => ({
      user: one(users, {
        fields: [storyStreaks.userId],
        references: [users.id]
      })
    }));
    storyTemplates = pgTable2("story_templates", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: text2("name").notNull(),
      description: text2("description"),
      category: text2("category").notNull(),
      thumbnailUrl: text2("thumbnail_url"),
      backgroundColor: text2("background_color"),
      isGradient: boolean2("is_gradient").default(false),
      gradientColors: jsonb2("gradient_colors"),
      fontFamily: storyFontEnum("font_family").default("MODERN"),
      textAlignment: storyTextAlignEnum("text_alignment").default("CENTER"),
      textAnimation: storyTextAnimationEnum("text_animation").default("NONE"),
      fontSize: integer2("font_size").default(24),
      filterName: text2("filter_name"),
      stickerPresets: jsonb2("sticker_presets"),
      isActive: boolean2("is_active").default(true).notNull(),
      isPremium: boolean2("is_premium").default(false).notNull(),
      usageCount: integer2("usage_count").default(0).notNull(),
      order: integer2("order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("story_templates_category_idx").on(table.category),
      index2("story_templates_active_idx").on(table.isActive)
    ]);
    storyMusicLibrary = pgTable2("story_music_library", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      title: text2("title").notNull(),
      artist: text2("artist").notNull(),
      album: text2("album"),
      genre: text2("genre"),
      duration: integer2("duration").notNull(),
      previewUrl: text2("preview_url").notNull(),
      fullUrl: text2("full_url"),
      coverUrl: text2("cover_url"),
      isActive: boolean2("is_active").default(true).notNull(),
      isFeatured: boolean2("is_featured").default(false).notNull(),
      usageCount: integer2("usage_count").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("story_music_library_genre_idx").on(table.genre),
      index2("story_music_library_featured_idx").on(table.isFeatured)
    ]);
    storyTips = pgTable2("story_tips", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      storyId: varchar2("story_id").notNull().references(() => stories.id, { onDelete: "cascade" }),
      senderId: varchar2("sender_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      recipientId: varchar2("recipient_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      amount: integer2("amount").notNull(),
      message: text2("message"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("story_tips_story_id_idx").on(table.storyId),
      index2("story_tips_sender_id_idx").on(table.senderId),
      index2("story_tips_recipient_id_idx").on(table.recipientId)
    ]);
    storyTipsRelations = relations(storyTips, ({ one }) => ({
      story: one(stories, {
        fields: [storyTips.storyId],
        references: [stories.id]
      }),
      sender: one(users, {
        fields: [storyTips.senderId],
        references: [users.id],
        relationName: "tipSender"
      }),
      recipient: one(users, {
        fields: [storyTips.recipientId],
        references: [users.id],
        relationName: "tipRecipient"
      })
    }));
    storyCountdownSubscriptions = pgTable2("story_countdown_subscriptions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      stickerId: varchar2("sticker_id").notNull().references(() => storyStickers.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      notified: boolean2("notified").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("story_countdown_subscriptions_sticker_id_idx").on(table.stickerId),
      unique2("story_countdown_subscription_unique").on(table.stickerId, table.userId)
    ]);
    userNotes = pgTable2("user_notes", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      content: text2("content").notNull(),
      expiresAt: timestamp2("expires_at").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("user_notes_user_id_idx").on(table.userId),
      index2("user_notes_expires_at_idx").on(table.expiresAt)
    ]);
    userNotesRelations = relations(userNotes, ({ one }) => ({
      user: one(users, {
        fields: [userNotes.userId],
        references: [users.id]
      })
    }));
    userLinks = pgTable2("user_links", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      title: text2("title").notNull(),
      url: text2("url").notNull(),
      iconType: linkIconTypeEnum("icon_type").default("LINK").notNull(),
      order: integer2("order").default(0).notNull(),
      clicks: integer2("clicks").default(0).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("user_links_user_id_idx").on(table.userId),
      index2("user_links_order_idx").on(table.userId, table.order)
    ]);
    userLinksRelations = relations(userLinks, ({ one }) => ({
      user: one(users, {
        fields: [userLinks.userId],
        references: [users.id]
      })
    }));
    interestCategories = pgTable2("interest_categories", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      slug: varchar2("slug", { length: 50 }).notNull().unique(),
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description"),
      icon: varchar2("icon", { length: 50 }),
      // Feather icon name
      color: varchar2("color", { length: 20 }),
      // Hex color for UI
      gradientColors: jsonb2("gradient_colors").default([]),
      // For animated backgrounds
      order: integer2("order").default(0).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("interest_categories_order_idx").on(table.order),
      index2("interest_categories_active_idx").on(table.isActive)
    ]);
    userInterests = pgTable2("user_interests", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      categoryId: varchar2("category_id").references(() => interestCategories.id, { onDelete: "cascade" }),
      interest: text2("interest").notNull(),
      // Category slug or custom interest
      affinityScore: real2("affinity_score").default(1).notNull(),
      // 0-10 scale, learned from engagement
      order: integer2("order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("user_interest_unique").on(table.userId, table.interest),
      index2("user_interests_user_id_idx").on(table.userId),
      index2("user_interests_category_idx").on(table.categoryId),
      index2("user_interests_affinity_idx").on(table.affinityScore)
    ]);
    userInterestsRelations = relations(userInterests, ({ one }) => ({
      user: one(users, {
        fields: [userInterests.userId],
        references: [users.id]
      }),
      category: one(interestCategories, {
        fields: [userInterests.categoryId],
        references: [interestCategories.id]
      })
    }));
    contentCategories = pgTable2("content_categories", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      categoryId: varchar2("category_id").references(() => interestCategories.id, { onDelete: "cascade" }),
      categorySlug: varchar2("category_slug", { length: 50 }).notNull(),
      confidence: real2("confidence").default(0.5).notNull(),
      // 0-1 confidence score
      analyzedAt: timestamp2("analyzed_at").defaultNow().notNull(),
      analyzedBy: varchar2("analyzed_by", { length: 20 }).default("gemini")
      // AI model used
    }, (table) => [
      unique2("content_category_unique").on(table.postId, table.categorySlug),
      index2("content_categories_post_idx").on(table.postId),
      index2("content_categories_category_idx").on(table.categoryId),
      index2("content_categories_slug_idx").on(table.categorySlug)
    ]);
    contentCategoriesRelations = relations(contentCategories, ({ one }) => ({
      post: one(posts, {
        fields: [contentCategories.postId],
        references: [posts.id]
      }),
      category: one(interestCategories, {
        fields: [contentCategories.categoryId],
        references: [interestCategories.id]
      })
    }));
    loginSessions = pgTable2("login_sessions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      sessionToken: text2("session_token").notNull(),
      deviceName: text2("device_name"),
      deviceType: text2("device_type"),
      // mobile, desktop, tablet
      browser: text2("browser"),
      os: text2("os"),
      ipAddress: text2("ip_address"),
      location: text2("location"),
      // City, Country
      isTrusted: boolean2("is_trusted").default(false).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      lastActiveAt: timestamp2("last_active_at").defaultNow().notNull(),
      expiresAt: timestamp2("expires_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("login_sessions_user_id_idx").on(table.userId),
      index2("login_sessions_token_idx").on(table.sessionToken),
      index2("login_sessions_active_idx").on(table.userId, table.isActive)
    ]);
    loginSessionsRelations = relations(loginSessions, ({ one }) => ({
      user: one(users, {
        fields: [loginSessions.userId],
        references: [users.id]
      })
    }));
    trustedDevices = pgTable2("trusted_devices", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      deviceId: text2("device_id").notNull(),
      // Unique device identifier
      deviceName: text2("device_name").notNull(),
      deviceType: text2("device_type"),
      browser: text2("browser"),
      os: text2("os"),
      lastUsedAt: timestamp2("last_used_at").defaultNow().notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("trusted_device_user_device_unique").on(table.userId, table.deviceId),
      index2("trusted_devices_user_id_idx").on(table.userId)
    ]);
    trustedDevicesRelations = relations(trustedDevices, ({ one }) => ({
      user: one(users, {
        fields: [trustedDevices.userId],
        references: [users.id]
      })
    }));
    restrictedAccounts = pgTable2("restricted_accounts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      restrictedUserId: varchar2("restricted_user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      reason: text2("reason"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("restricted_unique").on(table.userId, table.restrictedUserId),
      index2("restricted_accounts_user_id_idx").on(table.userId)
    ]);
    restrictedAccountsRelations = relations(restrictedAccounts, ({ one }) => ({
      user: one(users, {
        fields: [restrictedAccounts.userId],
        references: [users.id],
        relationName: "restricter"
      }),
      restrictedUser: one(users, {
        fields: [restrictedAccounts.restrictedUserId],
        references: [users.id],
        relationName: "restricted"
      })
    }));
    mutedAccounts = pgTable2("muted_accounts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      mutedUserId: varchar2("muted_user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      mutePosts: boolean2("mute_posts").default(true).notNull(),
      muteStories: boolean2("mute_stories").default(true).notNull(),
      muteMessages: boolean2("mute_messages").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("muted_unique").on(table.userId, table.mutedUserId),
      index2("muted_accounts_user_id_idx").on(table.userId)
    ]);
    mutedAccountsRelations = relations(mutedAccounts, ({ one }) => ({
      user: one(users, {
        fields: [mutedAccounts.userId],
        references: [users.id],
        relationName: "muter"
      }),
      mutedUser: one(users, {
        fields: [mutedAccounts.mutedUserId],
        references: [users.id],
        relationName: "muted"
      })
    }));
    keywordFilters = pgTable2("keyword_filters", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      keyword: text2("keyword").notNull(),
      filterComments: boolean2("filter_comments").default(true).notNull(),
      filterMessages: boolean2("filter_messages").default(true).notNull(),
      filterPosts: boolean2("filter_posts").default(false).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("keyword_filter_unique").on(table.userId, table.keyword),
      index2("keyword_filters_user_id_idx").on(table.userId)
    ]);
    keywordFiltersRelations = relations(keywordFilters, ({ one }) => ({
      user: one(users, {
        fields: [keywordFilters.userId],
        references: [users.id]
      })
    }));
    drafts = pgTable2("drafts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      type: postTypeEnum("type").default("TEXT").notNull(),
      content: text2("content"),
      caption: text2("caption"),
      mediaUrl: text2("media_url"),
      thumbnailUrl: text2("thumbnail_url"),
      durationMs: integer2("duration_ms"),
      aspectRatio: real2("aspect_ratio"),
      visibility: visibilityEnum("visibility").default("PUBLIC").notNull(),
      commentsEnabled: boolean2("comments_enabled").default(true).notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("drafts_user_id_idx").on(table.userId),
      index2("drafts_updated_at_idx").on(table.userId, table.updatedAt)
    ]);
    draftsRelations = relations(drafts, ({ one }) => ({
      user: one(users, {
        fields: [drafts.userId],
        references: [users.id]
      })
    }));
    scheduledPosts = pgTable2("scheduled_posts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      type: postTypeEnum("type").default("TEXT").notNull(),
      content: text2("content"),
      caption: text2("caption"),
      mediaUrl: text2("media_url"),
      thumbnailUrl: text2("thumbnail_url"),
      durationMs: integer2("duration_ms"),
      aspectRatio: real2("aspect_ratio"),
      visibility: visibilityEnum("visibility").default("PUBLIC").notNull(),
      commentsEnabled: boolean2("comments_enabled").default(true).notNull(),
      scheduledFor: timestamp2("scheduled_for").notNull(),
      status: scheduledStatusEnum("status").default("PENDING").notNull(),
      publishedPostId: varchar2("published_post_id").references(() => posts.id, { onDelete: "set null" }),
      errorMessage: text2("error_message"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("scheduled_posts_user_id_idx").on(table.userId),
      index2("scheduled_posts_scheduled_for_idx").on(table.scheduledFor),
      index2("scheduled_posts_status_idx").on(table.status, table.scheduledFor)
    ]);
    scheduledPostsRelations = relations(scheduledPosts, ({ one }) => ({
      user: one(users, {
        fields: [scheduledPosts.userId],
        references: [users.id]
      }),
      publishedPost: one(posts, {
        fields: [scheduledPosts.publishedPostId],
        references: [posts.id]
      })
    }));
    postCollaborators = pgTable2("post_collaborators", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      status: text2("status").default("pending").notNull(),
      // pending, accepted, declined
      invitedAt: timestamp2("invited_at").defaultNow().notNull(),
      respondedAt: timestamp2("responded_at")
    }, (table) => [
      unique2("post_collaborator_unique").on(table.postId, table.userId),
      index2("post_collaborators_post_id_idx").on(table.postId),
      index2("post_collaborators_user_id_idx").on(table.userId)
    ]);
    postCollaboratorsRelations = relations(postCollaborators, ({ one }) => ({
      post: one(posts, {
        fields: [postCollaborators.postId],
        references: [posts.id]
      }),
      user: one(users, {
        fields: [postCollaborators.userId],
        references: [users.id]
      })
    }));
    adminUserNotes = pgTable2("admin_user_notes", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      adminId: varchar2("admin_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      content: text2("content").notNull(),
      isPinned: boolean2("is_pinned").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("admin_user_notes_user_id_idx").on(table.userId),
      index2("admin_user_notes_admin_id_idx").on(table.adminId)
    ]);
    adminUserNotesRelations = relations(adminUserNotes, ({ one }) => ({
      user: one(users, {
        fields: [adminUserNotes.userId],
        references: [users.id],
        relationName: "targetUser"
      }),
      admin: one(users, {
        fields: [adminUserNotes.adminId],
        references: [users.id],
        relationName: "noteAuthor"
      })
    }));
    closeFriends = pgTable2("close_friends", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      friendId: varchar2("friend_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("close_friend_unique").on(table.userId, table.friendId),
      index2("close_friends_user_id_idx").on(table.userId)
    ]);
    closeFriendsRelations = relations(closeFriends, ({ one }) => ({
      user: one(users, {
        fields: [closeFriends.userId],
        references: [users.id],
        relationName: "owner"
      }),
      friend: one(users, {
        fields: [closeFriends.friendId],
        references: [users.id],
        relationName: "friend"
      })
    }));
    storyViewerRestrictions = pgTable2("story_viewer_restrictions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      restrictedViewerId: varchar2("restricted_viewer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("story_viewer_restriction_unique").on(table.userId, table.restrictedViewerId),
      index2("story_viewer_restrictions_user_id_idx").on(table.userId)
    ]);
    storyViewerRestrictionsRelations = relations(storyViewerRestrictions, ({ one }) => ({
      user: one(users, {
        fields: [storyViewerRestrictions.userId],
        references: [users.id],
        relationName: "storyOwner"
      }),
      restrictedViewer: one(users, {
        fields: [storyViewerRestrictions.restrictedViewerId],
        references: [users.id],
        relationName: "restrictedViewer"
      })
    }));
    dataExportRequests = pgTable2("data_export_requests", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      status: exportStatusEnum("status").default("PENDING").notNull(),
      includeProfile: boolean2("include_profile").default(true).notNull(),
      includePosts: boolean2("include_posts").default(true).notNull(),
      includeMessages: boolean2("include_messages").default(true).notNull(),
      includeMedia: boolean2("include_media").default(false).notNull(),
      downloadUrl: text2("download_url"),
      expiresAt: timestamp2("expires_at"),
      completedAt: timestamp2("completed_at"),
      errorMessage: text2("error_message"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("data_export_requests_user_id_idx").on(table.userId),
      index2("data_export_requests_status_idx").on(table.status)
    ]);
    dataExportRequestsRelations = relations(dataExportRequests, ({ one }) => ({
      user: one(users, {
        fields: [dataExportRequests.userId],
        references: [users.id]
      })
    }));
    pendingTagApprovals = pgTable2("pending_tag_approvals", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      taggedById: varchar2("tagged_by_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      status: text2("status").default("pending").notNull(),
      // pending, approved, declined
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      respondedAt: timestamp2("responded_at")
    }, (table) => [
      unique2("pending_tag_unique").on(table.userId, table.postId),
      index2("pending_tag_approvals_user_id_idx").on(table.userId)
    ]);
    pendingTagApprovalsRelations = relations(pendingTagApprovals, ({ one }) => ({
      user: one(users, {
        fields: [pendingTagApprovals.userId],
        references: [users.id],
        relationName: "taggedUser"
      }),
      post: one(posts, {
        fields: [pendingTagApprovals.postId],
        references: [posts.id]
      }),
      taggedBy: one(users, {
        fields: [pendingTagApprovals.taggedById],
        references: [users.id],
        relationName: "tagger"
      })
    }));
    roles = pgTable2("roles", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 50 }).notNull().unique(),
      displayName: varchar2("display_name", { length: 100 }).notNull(),
      description: text2("description"),
      level: integer2("level").default(0).notNull(),
      // Higher = more authority
      isSystem: boolean2("is_system").default(false).notNull(),
      // Cannot be deleted
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    permissions = pgTable2("permissions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      key: varchar2("key", { length: 100 }).notNull().unique(),
      // e.g., "users.view", "posts.delete"
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description"),
      group: varchar2("group", { length: 50 }).notNull(),
      // e.g., "users", "posts", "reports"
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    rolePermissions = pgTable2("role_permissions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      roleId: varchar2("role_id").notNull().references(() => roles.id, { onDelete: "cascade" }),
      permissionId: varchar2("permission_id").notNull().references(() => permissions.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("role_permission_unique").on(table.roleId, table.permissionId),
      index2("role_permissions_role_id_idx").on(table.roleId)
    ]);
    userRoles = pgTable2("user_roles", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      roleId: varchar2("role_id").notNull().references(() => roles.id, { onDelete: "cascade" }),
      assignedBy: varchar2("assigned_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("user_role_unique").on(table.userId, table.roleId),
      index2("user_roles_user_id_idx").on(table.userId)
    ]);
    auditActionEnum = pgEnum2("audit_action", [
      "CREATE",
      "UPDATE",
      "DELETE",
      "LOGIN",
      "LOGOUT",
      "ROLE_ASSIGNED",
      "ROLE_REMOVED",
      "PERMISSION_GRANTED",
      "PERMISSION_REVOKED",
      "USER_SUSPENDED",
      "USER_ACTIVATED",
      "USER_FORCE_LOGOUT",
      "USER_DEACTIVATED",
      "USER_REACTIVATED",
      "USER_BANNED",
      "USER_UNBANNED",
      "CONTENT_HIDDEN",
      "CONTENT_UNHIDDEN",
      "CONTENT_SOFT_DELETED",
      "FEATURED_REMOVED",
      "REPORT_RESOLVED",
      "SETTING_CHANGED",
      "SETTINGS_UPDATED",
      "USER_PROFILE_EDITED",
      "USER_PASSWORD_RESET",
      "USER_IMPERSONATED",
      "USER_NOTE_ADDED",
      "MASS_ACTION_PERFORMED",
      "DATA_EXPORTED",
      "DATA_IMPORTED",
      "AR_FILTER_CREATED",
      "AR_FILTER_UPDATED",
      "AR_FILTER_FEATURED",
      "AR_FILTER_UNFEATURED",
      "AR_FILTER_ENABLED",
      "AR_FILTER_DISABLED",
      "AR_FILTER_DELETED",
      "AI_AVATAR_APPROVED",
      "AI_AVATAR_REJECTED",
      "AI_AVATAR_DELETED",
      "EXPLORE_CATEGORY_CREATED",
      "EXPLORE_CATEGORY_UPDATED",
      "EXPLORE_CATEGORY_DELETED",
      "ADMIN_UPDATE_GROUP_SETTINGS",
      "ADMIN_REMOVE_GROUP_MEMBER",
      "ADMIN_APPROVE_JOIN_REQUEST",
      "ADMIN_REJECT_JOIN_REQUEST",
      "ADMIN_DELETE_GROUP",
      "ADMIN_REMOVE_STREAM_VIEWER",
      "ADMIN_KICK_STREAM_VIEWER",
      "WALLET_ADJUSTED",
      "GIFT_TYPE_CREATED",
      "GIFT_TYPE_UPDATED",
      "WITHDRAWAL_APPROVED",
      "WITHDRAWAL_REJECTED",
      "KYC_APPROVED",
      "KYC_REJECTED"
    ]);
    passwordResetTokens = pgTable2("password_reset_tokens", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      token: varchar2("token", { length: 6 }).notNull(),
      // 6-digit code
      expiresAt: timestamp2("expires_at").notNull(),
      usedAt: timestamp2("used_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("password_reset_tokens_user_id_idx").on(table.userId),
      index2("password_reset_tokens_token_idx").on(table.token)
    ]);
    emailVerificationTokens = pgTable2("email_verification_tokens", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      email: text2("email").notNull(),
      token: varchar2("token", { length: 6 }).notNull(),
      // 6-digit code
      expiresAt: timestamp2("expires_at").notNull(),
      verifiedAt: timestamp2("verified_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("email_verification_tokens_user_id_idx").on(table.userId),
      index2("email_verification_tokens_token_idx").on(table.token)
    ]);
    phoneVerificationTokens = pgTable2("phone_verification_tokens", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      phoneNumber: text2("phone_number").notNull(),
      token: varchar2("token", { length: 6 }).notNull(),
      expiresAt: timestamp2("expires_at").notNull(),
      verifiedAt: timestamp2("verified_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("phone_verification_tokens_user_id_idx").on(table.userId),
      index2("phone_verification_tokens_token_idx").on(table.token)
    ]);
    auditLogs = pgTable2("audit_logs", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").references(() => users.id, { onDelete: "set null" }),
      action: auditActionEnum("action").notNull(),
      targetType: varchar2("target_type", { length: 50 }),
      // "user", "post", "role", etc.
      targetId: varchar2("target_id"),
      details: text2("details"),
      // JSON string with additional details
      ipAddress: varchar2("ip_address", { length: 45 }),
      userAgent: text2("user_agent"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("audit_logs_user_id_idx").on(table.userId),
      index2("audit_logs_action_idx").on(table.action),
      index2("audit_logs_created_at_idx").on(table.createdAt),
      index2("audit_logs_target_idx").on(table.targetType, table.targetId)
    ]);
    appSettings = pgTable2("app_settings", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      key: varchar2("key", { length: 100 }).notNull().unique(),
      value: text2("value"),
      type: varchar2("type", { length: 20 }).default("string").notNull(),
      // "string", "number", "boolean", "json"
      description: text2("description"),
      updatedBy: varchar2("updated_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    rolesRelations = relations(roles, ({ many }) => ({
      rolePermissions: many(rolePermissions),
      userRoles: many(userRoles)
    }));
    permissionsRelations = relations(permissions, ({ many }) => ({
      rolePermissions: many(rolePermissions)
    }));
    rolePermissionsRelations = relations(rolePermissions, ({ one }) => ({
      role: one(roles, {
        fields: [rolePermissions.roleId],
        references: [roles.id]
      }),
      permission: one(permissions, {
        fields: [rolePermissions.permissionId],
        references: [permissions.id]
      })
    }));
    userRolesRelations = relations(userRoles, ({ one }) => ({
      user: one(users, {
        fields: [userRoles.userId],
        references: [users.id]
      }),
      role: one(roles, {
        fields: [userRoles.roleId],
        references: [roles.id]
      }),
      assigner: one(users, {
        fields: [userRoles.assignedBy],
        references: [users.id],
        relationName: "assigner"
      })
    }));
    auditLogsRelations = relations(auditLogs, ({ one }) => ({
      user: one(users, {
        fields: [auditLogs.userId],
        references: [users.id]
      })
    }));
    appSettingsRelations = relations(appSettings, ({ one }) => ({
      updater: one(users, {
        fields: [appSettings.updatedBy],
        references: [users.id]
      })
    }));
    wordFilterActionEnum = pgEnum2("word_filter_action", ["BLOCK", "REPLACE", "FLAG"]);
    wordFilters = pgTable2("word_filters", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      word: text2("word").notNull().unique(),
      action: wordFilterActionEnum("action").default("BLOCK").notNull(),
      replacement: text2("replacement"),
      isActive: boolean2("is_active").default(true).notNull(),
      createdBy: varchar2("created_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("word_filters_word_idx").on(table.word),
      index2("word_filters_active_idx").on(table.isActive)
    ]);
    wordFiltersRelations = relations(wordFilters, ({ one }) => ({
      creator: one(users, {
        fields: [wordFilters.createdBy],
        references: [users.id]
      })
    }));
    adminKeywordFilterActionEnum = pgEnum2("admin_keyword_filter_action", ["BLOCK", "FLAG", "SHADOW_BAN", "WARN"]);
    adminKeywordFilters = pgTable2("admin_keyword_filters", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      keyword: text2("keyword").notNull().unique(),
      action: adminKeywordFilterActionEnum("action").default("FLAG").notNull(),
      filterComments: boolean2("filter_comments").default(true).notNull(),
      filterMessages: boolean2("filter_messages").default(true).notNull(),
      filterPosts: boolean2("filter_posts").default(true).notNull(),
      filterUsernames: boolean2("filter_usernames").default(true).notNull(),
      filterBios: boolean2("filter_bios").default(true).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      createdBy: varchar2("created_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("admin_keyword_filters_keyword_idx").on(table.keyword),
      index2("admin_keyword_filters_active_idx").on(table.isActive)
    ]);
    adminKeywordFiltersRelations = relations(adminKeywordFilters, ({ one }) => ({
      creator: one(users, {
        fields: [adminKeywordFilters.createdBy],
        references: [users.id]
      })
    }));
    notificationDefaults = pgTable2("notification_defaults", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      key: varchar2("key", { length: 100 }).notNull().unique(),
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description"),
      category: varchar2("category", { length: 50 }).notNull(),
      defaultEnabled: boolean2("default_enabled").default(true).notNull(),
      canUserDisable: boolean2("can_user_disable").default(true).notNull(),
      updatedBy: varchar2("updated_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    notificationDefaultsRelations = relations(notificationDefaults, ({ one }) => ({
      updater: one(users, {
        fields: [notificationDefaults.updatedBy],
        references: [users.id]
      })
    }));
    conversationStatusEnum = pgEnum2("conversation_status", ["REQUEST", "ACCEPTED"]);
    inboxFolderEnum = pgEnum2("inbox_folder", ["PRIMARY", "GENERAL"]);
    gossipTypeEnum = pgEnum2("gossip_type", ["TEXT", "VOICE"]);
    gossipPosts = pgTable2("gossip_posts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      authorUserId: varchar2("author_user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      type: gossipTypeEnum("type").notNull(),
      text: text2("text"),
      mediaUrl: text2("media_url"),
      thumbnailUrl: text2("thumbnail_url"),
      durationMs: integer2("duration_ms"),
      likeCount: integer2("like_count").default(0).notNull(),
      commentCount: integer2("comment_count").default(0).notNull(),
      retweetCount: integer2("retweet_count").default(0).notNull(),
      isDeleted: boolean2("is_deleted").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("gossip_posts_created_at_idx").on(table.createdAt)
    ]);
    gossipLikes = pgTable2("gossip_likes", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      gossipPostId: varchar2("gossip_post_id").notNull().references(() => gossipPosts.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("gossip_likes_user_post_unique").on(table.userId, table.gossipPostId),
      index2("gossip_likes_post_id_idx").on(table.gossipPostId)
    ]);
    gossipComments = pgTable2("gossip_comments", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      gossipPostId: varchar2("gossip_post_id").notNull().references(() => gossipPosts.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      body: text2("body").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("gossip_comments_post_id_idx").on(table.gossipPostId)
    ]);
    gossipRetweets = pgTable2("gossip_retweets", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      originalGossipPostId: varchar2("original_gossip_post_id").notNull().references(() => gossipPosts.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("gossip_retweets_user_post_unique").on(table.userId, table.originalGossipPostId),
      index2("gossip_retweets_post_id_idx").on(table.originalGossipPostId)
    ]);
    anonReactionTypeEnum = pgEnum2("anon_reaction_type", ["FIRE", "MINDBLOWN", "LAUGH", "SKULL", "EYES"]);
    anonReportStatusEnum = pgEnum2("anon_report_status", ["PENDING", "REVIEWED", "DISMISSED", "REMOVED"]);
    countries = pgTable2("countries", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      code: varchar2("code", { length: 2 }).notNull().unique(),
      name: varchar2("name", { length: 100 }).notNull(),
      isSouthAfrica: boolean2("is_south_africa").default(false).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      sortOrder: integer2("sort_order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("countries_code_idx").on(table.code),
      index2("countries_is_active_idx").on(table.isActive)
    ]);
    zaLocations = pgTable2("za_locations", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      province: varchar2("province", { length: 100 }).notNull(),
      city: varchar2("city", { length: 100 }),
      kasi: varchar2("kasi", { length: 100 }),
      fullPath: varchar2("full_path", { length: 300 }).notNull(),
      level: integer2("level").notNull(),
      parentId: varchar2("parent_id"),
      population: integer2("population"),
      latitude: real2("latitude"),
      longitude: real2("longitude"),
      isActive: boolean2("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("za_locations_province_idx").on(table.province),
      index2("za_locations_city_idx").on(table.city),
      index2("za_locations_kasi_idx").on(table.kasi),
      index2("za_locations_full_path_idx").on(table.fullPath),
      index2("za_locations_level_idx").on(table.level),
      index2("za_locations_parent_idx").on(table.parentId)
    ]);
    anonGossipPosts = pgTable2("anon_gossip_posts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      deviceHash: varchar2("device_hash", { length: 64 }).notNull(),
      countryCode: varchar2("country_code", { length: 2 }),
      zaLocationId: varchar2("za_location_id"),
      locationDisplay: varchar2("location_display", { length: 300 }),
      type: gossipTypeEnum("type").notNull().default("TEXT"),
      content: text2("content"),
      mediaUrl: text2("media_url"),
      thumbnailUrl: text2("thumbnail_url"),
      durationMs: integer2("duration_ms"),
      isWhisper: boolean2("is_whisper").default(false).notNull(),
      whisperExpiresAt: timestamp2("whisper_expires_at"),
      teaMeter: integer2("tea_meter").default(0).notNull(),
      fireCount: integer2("fire_count").default(0).notNull(),
      mindblownCount: integer2("mindblown_count").default(0).notNull(),
      laughCount: integer2("laugh_count").default(0).notNull(),
      skullCount: integer2("skull_count").default(0).notNull(),
      eyesCount: integer2("eyes_count").default(0).notNull(),
      replyCount: integer2("reply_count").default(0).notNull(),
      viewCount: integer2("view_count").default(0).notNull(),
      reportCount: integer2("report_count").default(0).notNull(),
      isHidden: boolean2("is_hidden").default(false).notNull(),
      isRemovedByAdmin: boolean2("is_removed_by_admin").default(false).notNull(),
      removedReason: text2("removed_reason"),
      removedAt: timestamp2("removed_at"),
      removedBy: varchar2("removed_by"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("anon_gossip_posts_device_hash_idx").on(table.deviceHash),
      index2("anon_gossip_posts_country_code_idx").on(table.countryCode),
      index2("anon_gossip_posts_za_location_idx").on(table.zaLocationId),
      index2("anon_gossip_posts_created_at_idx").on(table.createdAt),
      index2("anon_gossip_posts_tea_meter_idx").on(table.teaMeter),
      index2("anon_gossip_posts_is_whisper_idx").on(table.isWhisper),
      index2("anon_gossip_posts_whisper_expires_idx").on(table.whisperExpiresAt),
      index2("anon_gossip_posts_is_hidden_idx").on(table.isHidden)
    ]);
    anonGossipReactions = pgTable2("anon_gossip_reactions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => anonGossipPosts.id, { onDelete: "cascade" }),
      deviceHash: varchar2("device_hash", { length: 64 }).notNull(),
      reactionType: anonReactionTypeEnum("reaction_type").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("anon_gossip_reactions_unique").on(table.postId, table.deviceHash, table.reactionType),
      index2("anon_gossip_reactions_post_idx").on(table.postId),
      index2("anon_gossip_reactions_device_idx").on(table.deviceHash)
    ]);
    anonGossipReplies = pgTable2("anon_gossip_replies", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => anonGossipPosts.id, { onDelete: "cascade" }),
      parentReplyId: varchar2("parent_reply_id"),
      deviceHash: varchar2("device_hash", { length: 64 }).notNull(),
      content: text2("content").notNull(),
      depth: integer2("depth").default(1).notNull(),
      fireCount: integer2("fire_count").default(0).notNull(),
      mindblownCount: integer2("mindblown_count").default(0).notNull(),
      laughCount: integer2("laugh_count").default(0).notNull(),
      skullCount: integer2("skull_count").default(0).notNull(),
      eyesCount: integer2("eyes_count").default(0).notNull(),
      isHidden: boolean2("is_hidden").default(false).notNull(),
      isRemovedByAdmin: boolean2("is_removed_by_admin").default(false).notNull(),
      removedReason: text2("removed_reason"),
      removedAt: timestamp2("removed_at"),
      removedBy: varchar2("removed_by"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("anon_gossip_replies_post_idx").on(table.postId),
      index2("anon_gossip_replies_parent_idx").on(table.parentReplyId),
      index2("anon_gossip_replies_device_idx").on(table.deviceHash),
      index2("anon_gossip_replies_depth_idx").on(table.depth)
    ]);
    anonGossipReplyReactions = pgTable2("anon_gossip_reply_reactions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      replyId: varchar2("reply_id").notNull().references(() => anonGossipReplies.id, { onDelete: "cascade" }),
      deviceHash: varchar2("device_hash", { length: 64 }).notNull(),
      reactionType: anonReactionTypeEnum("reaction_type").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("anon_reply_reactions_unique").on(table.replyId, table.deviceHash, table.reactionType),
      index2("anon_reply_reactions_reply_idx").on(table.replyId)
    ]);
    anonGossipReports = pgTable2("anon_gossip_reports", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").references(() => anonGossipPosts.id, { onDelete: "cascade" }),
      replyId: varchar2("reply_id").references(() => anonGossipReplies.id, { onDelete: "cascade" }),
      deviceHash: varchar2("device_hash", { length: 64 }).notNull(),
      reason: text2("reason").notNull(),
      status: anonReportStatusEnum("status").default("PENDING").notNull(),
      reviewedBy: varchar2("reviewed_by"),
      reviewedAt: timestamp2("reviewed_at"),
      reviewNotes: text2("review_notes"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("anon_gossip_reports_post_idx").on(table.postId),
      index2("anon_gossip_reports_reply_idx").on(table.replyId),
      index2("anon_gossip_reports_status_idx").on(table.status),
      index2("anon_gossip_reports_created_idx").on(table.createdAt)
    ]);
    gossipSettings = pgTable2("gossip_settings", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      key: varchar2("key", { length: 100 }).notNull().unique(),
      value: text2("value").notNull(),
      description: text2("description"),
      updatedBy: varchar2("updated_by"),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("gossip_settings_key_idx").on(table.key)
    ]);
    gossipBlockedWords = pgTable2("gossip_blocked_words", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      word: varchar2("word", { length: 100 }).notNull().unique(),
      isRegex: boolean2("is_regex").default(false).notNull(),
      severity: integer2("severity").default(1).notNull(),
      addedBy: varchar2("added_by"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("gossip_blocked_words_word_idx").on(table.word)
    ]);
    gossipLocationStats = pgTable2("gossip_location_stats", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      locationType: varchar2("location_type", { length: 20 }).notNull(),
      locationId: varchar2("location_id", { length: 300 }).notNull(),
      locationDisplay: varchar2("location_display", { length: 300 }).notNull(),
      totalPosts: integer2("total_posts").default(0).notNull(),
      postsToday: integer2("posts_today").default(0).notNull(),
      postsThisWeek: integer2("posts_this_week").default(0).notNull(),
      streakDays: integer2("streak_days").default(0).notNull(),
      lastPostAt: timestamp2("last_post_at"),
      milestoneReached: integer2("milestone_reached").default(0).notNull(),
      trendingScore: real2("trending_score").default(0).notNull(),
      lastCalculatedAt: timestamp2("last_calculated_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("gossip_location_stats_unique").on(table.locationType, table.locationId),
      index2("gossip_location_stats_type_idx").on(table.locationType),
      index2("gossip_location_stats_trending_idx").on(table.trendingScore),
      index2("gossip_location_stats_streak_idx").on(table.streakDays)
    ]);
    gossipEngagementVelocity = pgTable2("gossip_engagement_velocity", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => anonGossipPosts.id, { onDelete: "cascade" }),
      hourNumber: integer2("hour_number").notNull(),
      reactions: integer2("reactions").default(0).notNull(),
      replies: integer2("replies").default(0).notNull(),
      views: integer2("views").default(0).notNull(),
      velocityScore: real2("velocity_score").default(0).notNull(),
      recordedAt: timestamp2("recorded_at").defaultNow().notNull()
    }, (table) => [
      unique2("gossip_velocity_post_hour").on(table.postId, table.hourNumber),
      index2("gossip_velocity_post_idx").on(table.postId),
      index2("gossip_velocity_score_idx").on(table.velocityScore)
    ]);
    mallCategories = pgTable2("mall_categories", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 100 }).notNull().unique(),
      description: text2("description"),
      isActive: boolean2("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    mallItems = pgTable2("mall_items", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      categoryId: varchar2("category_id").notNull().references(() => mallCategories.id, { onDelete: "cascade" }),
      name: varchar2("name", { length: 200 }).notNull(),
      description: text2("description").notNull(),
      value: integer2("value").notNull(),
      coinPrice: integer2("coin_price").notNull().default(0),
      imageUrl: text2("image_url"),
      isActive: boolean2("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("mall_items_category_id_idx").on(table.categoryId)
    ]);
    mallPurchases = pgTable2("mall_purchases", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      itemId: varchar2("item_id").notNull().references(() => mallItems.id, { onDelete: "cascade" }),
      quantity: integer2("quantity").default(1).notNull(),
      netWorthGained: bigint2("net_worth_gained", { mode: "number" }).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("mall_purchases_user_id_idx").on(table.userId),
      index2("mall_purchases_item_id_idx").on(table.itemId)
    ]);
    netWorthReasonEnum = pgEnum2("net_worth_reason", ["MALL_PURCHASE", "ADMIN_ADJUST", "GIFT", "ACHIEVEMENT", "OTHER"]);
    netWorthLedger = pgTable2("net_worth_ledger", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      delta: bigint2("delta", { mode: "number" }).notNull(),
      reason: netWorthReasonEnum("reason").notNull(),
      refType: varchar2("ref_type", { length: 50 }),
      refId: varchar2("ref_id"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("net_worth_ledger_user_id_idx").on(table.userId),
      index2("net_worth_ledger_created_at_idx").on(table.createdAt)
    ]);
    trendsDaily = pgTable2("trends_daily", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      topic: varchar2("topic", { length: 200 }).notNull(),
      score: real2("score").notNull(),
      postCount: integer2("post_count").default(0).notNull(),
      windowStart: timestamp2("window_start").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("trends_daily_window_start_idx").on(table.windowStart),
      index2("trends_daily_score_idx").on(table.score)
    ]);
    gossipPostsRelations = relations(gossipPosts, ({ many }) => ({
      likes: many(gossipLikes),
      comments: many(gossipComments),
      retweets: many(gossipRetweets)
    }));
    gossipLikesRelations = relations(gossipLikes, ({ one }) => ({
      gossipPost: one(gossipPosts, {
        fields: [gossipLikes.gossipPostId],
        references: [gossipPosts.id]
      })
    }));
    gossipCommentsRelations = relations(gossipComments, ({ one }) => ({
      gossipPost: one(gossipPosts, {
        fields: [gossipComments.gossipPostId],
        references: [gossipPosts.id]
      })
    }));
    gossipRetweetsRelations = relations(gossipRetweets, ({ one }) => ({
      originalGossipPost: one(gossipPosts, {
        fields: [gossipRetweets.originalGossipPostId],
        references: [gossipPosts.id]
      })
    }));
    mallCategoriesRelations = relations(mallCategories, ({ many }) => ({
      items: many(mallItems)
    }));
    mallItemsRelations = relations(mallItems, ({ one, many }) => ({
      category: one(mallCategories, {
        fields: [mallItems.categoryId],
        references: [mallCategories.id]
      }),
      purchases: many(mallPurchases)
    }));
    mallPurchasesRelations = relations(mallPurchases, ({ one }) => ({
      user: one(users, {
        fields: [mallPurchases.userId],
        references: [users.id]
      }),
      item: one(mallItems, {
        fields: [mallPurchases.itemId],
        references: [mallItems.id]
      })
    }));
    netWorthLedgerRelations = relations(netWorthLedger, ({ one }) => ({
      user: one(users, {
        fields: [netWorthLedger.userId],
        references: [users.id]
      })
    }));
    anonGossipPostsRelations = relations(anonGossipPosts, ({ many }) => ({
      reactions: many(anonGossipReactions),
      replies: many(anonGossipReplies),
      reports: many(anonGossipReports),
      velocityRecords: many(gossipEngagementVelocity)
    }));
    anonGossipReactionsRelations = relations(anonGossipReactions, ({ one }) => ({
      post: one(anonGossipPosts, {
        fields: [anonGossipReactions.postId],
        references: [anonGossipPosts.id]
      })
    }));
    anonGossipRepliesRelations = relations(anonGossipReplies, ({ one, many }) => ({
      post: one(anonGossipPosts, {
        fields: [anonGossipReplies.postId],
        references: [anonGossipPosts.id]
      }),
      parentReply: one(anonGossipReplies, {
        fields: [anonGossipReplies.parentReplyId],
        references: [anonGossipReplies.id],
        relationName: "parentChild"
      }),
      childReplies: many(anonGossipReplies, { relationName: "parentChild" }),
      reactions: many(anonGossipReplyReactions)
    }));
    anonGossipReplyReactionsRelations = relations(anonGossipReplyReactions, ({ one }) => ({
      reply: one(anonGossipReplies, {
        fields: [anonGossipReplyReactions.replyId],
        references: [anonGossipReplies.id]
      })
    }));
    anonGossipReportsRelations = relations(anonGossipReports, ({ one }) => ({
      post: one(anonGossipPosts, {
        fields: [anonGossipReports.postId],
        references: [anonGossipPosts.id]
      }),
      reply: one(anonGossipReplies, {
        fields: [anonGossipReports.replyId],
        references: [anonGossipReplies.id]
      })
    }));
    gossipEngagementVelocityRelations = relations(gossipEngagementVelocity, ({ one }) => ({
      post: one(anonGossipPosts, {
        fields: [gossipEngagementVelocity.postId],
        references: [anonGossipPosts.id]
      })
    }));
    insertUserSchema = createInsertSchema2(users).pick({
      username: true,
      email: true,
      password: true,
      displayName: true,
      bio: true,
      avatarUrl: true
    });
    insertPostSchema = createInsertSchema2(posts).pick({
      authorId: true,
      type: true,
      content: true,
      caption: true,
      mediaUrl: true,
      thumbnailUrl: true,
      durationMs: true,
      aspectRatio: true,
      visibility: true,
      commentsEnabled: true
    });
    insertCommentSchema = createInsertSchema2(comments).pick({
      postId: true,
      authorId: true,
      content: true
    });
    insertMessageSchema = createInsertSchema2(messages).pick({
      conversationId: true,
      senderId: true,
      receiverId: true,
      content: true
    });
    insertStorySchema = createInsertSchema2(stories).pick({
      userId: true,
      type: true,
      mediaUrl: true,
      thumbnailUrl: true,
      durationMs: true,
      caption: true,
      textContent: true,
      backgroundColor: true,
      isGradient: true,
      gradientColors: true,
      fontFamily: true,
      textAlignment: true,
      textAnimation: true,
      fontSize: true,
      audioUrl: true,
      audioDuration: true,
      musicUrl: true,
      musicTitle: true,
      musicArtist: true,
      filterName: true,
      textOverlays: true,
      drawings: true,
      isCloseFriends: true,
      replySetting: true,
      locationName: true,
      locationLat: true,
      locationLng: true
    });
    insertStoryDraftSchema = createInsertSchema2(storyDrafts).pick({
      userId: true,
      type: true,
      mediaUrl: true,
      textContent: true,
      backgroundColor: true,
      isGradient: true,
      gradientColors: true,
      fontFamily: true,
      textAlignment: true,
      textAnimation: true,
      fontSize: true,
      audioUrl: true,
      audioDuration: true,
      musicUrl: true,
      musicTitle: true,
      musicArtist: true,
      filterName: true,
      textOverlays: true,
      drawings: true,
      stickers: true,
      isCloseFriends: true,
      replySetting: true
    });
    interactionTypeEnum = pgEnum2("interaction_type", ["VIEW", "LIKE", "SAVE", "SHARE", "COMMENT", "SKIP", "REWATCH"]);
    contentTypeEnum = pgEnum2("content_type", ["REEL", "VOICE", "PHOTO", "TEXT", "STORY"]);
    contentInteractions = pgTable2("content_interactions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      contentId: varchar2("content_id").notNull(),
      // Can be postId, storyId, gossipId
      contentType: contentTypeEnum("content_type").notNull(),
      interactionType: interactionTypeEnum("interaction_type").notNull(),
      watchTimeMs: integer2("watch_time_ms").default(0),
      // How long they watched
      completionRate: real2("completion_rate").default(0),
      // 0-1 percentage watched
      rewatchCount: integer2("rewatch_count").default(0),
      // How many times rewatched
      skippedAtMs: integer2("skipped_at_ms"),
      // When they skipped (null if didn't skip)
      creatorId: varchar2("creator_id").references(() => users.id, { onDelete: "set null" }),
      sessionId: varchar2("session_id"),
      // Group interactions by session
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("content_interactions_user_idx").on(table.userId),
      index2("content_interactions_content_idx").on(table.contentId),
      index2("content_interactions_creator_idx").on(table.creatorId),
      index2("content_interactions_user_type_idx").on(table.userId, table.contentType),
      index2("content_interactions_created_idx").on(table.createdAt)
    ]);
    userInterestProfiles = pgTable2("user_interest_profiles", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // Content type preferences (0-100 score)
      reelPreference: integer2("reel_preference").default(50).notNull(),
      voicePreference: integer2("voice_preference").default(50).notNull(),
      photoPreference: integer2("photo_preference").default(50).notNull(),
      textPreference: integer2("text_preference").default(50).notNull(),
      // Engagement patterns
      avgWatchTimeMs: integer2("avg_watch_time_ms").default(0),
      avgCompletionRate: real2("avg_completion_rate").default(0),
      totalInteractions: integer2("total_interactions").default(0),
      // Time-based patterns
      preferredHours: jsonb2("preferred_hours").default("[]"),
      // Array of hours (0-23) when most active
      // Topic preferences (keywords from engaged content)
      topicScores: jsonb2("topic_scores").default("{}"),
      // { "luxury": 80, "cars": 60, etc }
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("user_interest_profiles_user").on(table.userId),
      index2("user_interest_profiles_user_idx").on(table.userId)
    ]);
    creatorAffinities = pgTable2("creator_affinities", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      creatorId: varchar2("creator_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      affinityScore: integer2("affinity_score").default(0).notNull(),
      // 0-1000
      totalViews: integer2("total_views").default(0),
      totalLikes: integer2("total_likes").default(0),
      totalShares: integer2("total_shares").default(0),
      totalSaves: integer2("total_saves").default(0),
      avgWatchTimeMs: integer2("avg_watch_time_ms").default(0),
      avgCompletionRate: real2("avg_completion_rate").default(0),
      lastInteractedAt: timestamp2("last_interacted_at"),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("creator_affinities_user_creator").on(table.userId, table.creatorId),
      index2("creator_affinities_user_idx").on(table.userId),
      index2("creator_affinities_score_idx").on(table.affinityScore)
    ]);
    seenContent = pgTable2("seen_content", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      contentId: varchar2("content_id").notNull(),
      contentType: contentTypeEnum("content_type").notNull(),
      sessionId: varchar2("session_id"),
      seenAt: timestamp2("seen_at").defaultNow().notNull(),
      expiresAt: timestamp2("expires_at").notNull()
      // Auto-cleanup after 24-48 hours
    }, (table) => [
      unique2("seen_content_user_content").on(table.userId, table.contentId),
      index2("seen_content_user_idx").on(table.userId),
      index2("seen_content_expires_idx").on(table.expiresAt)
    ]);
    seenProfiles = pgTable2("seen_profiles", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      profileId: varchar2("profile_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      sessionId: varchar2("session_id"),
      seenAt: timestamp2("seen_at").defaultNow().notNull(),
      expiresAt: timestamp2("expires_at").notNull()
      // Rotate after 24 hours
    }, (table) => [
      unique2("seen_profiles_user_profile").on(table.userId, table.profileId),
      index2("seen_profiles_user_idx").on(table.userId),
      index2("seen_profiles_expires_idx").on(table.expiresAt)
    ]);
    contentFatigue = pgTable2("content_fatigue", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      contentId: varchar2("content_id").notNull(),
      contentType: contentTypeEnum("content_type").notNull(),
      totalImpressions: integer2("total_impressions").default(0).notNull(),
      totalSkips: integer2("total_skips").default(0).notNull(),
      skipRate: real2("skip_rate").default(0),
      // totalSkips / totalImpressions
      avgWatchTimeMs: integer2("avg_watch_time_ms").default(0),
      avgCompletionRate: real2("avg_completion_rate").default(0),
      lastShownAt: timestamp2("last_shown_at"),
      fatigueScore: integer2("fatigue_score").default(0),
      // Higher = show less often
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("content_fatigue_content").on(table.contentId),
      index2("content_fatigue_score_idx").on(table.fatigueScore),
      index2("content_fatigue_updated_idx").on(table.updatedAt)
    ]);
    contentVelocity = pgTable2("content_velocity", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      contentId: varchar2("content_id").notNull(),
      contentType: contentTypeEnum("content_type").notNull(),
      hourNumber: integer2("hour_number").notNull(),
      // Hours since creation
      views: integer2("views").default(0),
      likes: integer2("likes").default(0),
      shares: integer2("shares").default(0),
      saves: integer2("saves").default(0),
      comments: integer2("comments").default(0),
      velocityScore: real2("velocity_score").default(0),
      // Engagement per hour
      recordedAt: timestamp2("recorded_at").defaultNow().notNull()
    }, (table) => [
      unique2("content_velocity_content_hour").on(table.contentId, table.hourNumber),
      index2("content_velocity_score_idx").on(table.velocityScore),
      index2("content_velocity_content_idx").on(table.contentId)
    ]);
    notInterested = pgTable2("not_interested", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      targetType: varchar2("target_type", { length: 20 }).notNull(),
      // "CONTENT" or "CREATOR"
      targetId: varchar2("target_id").notNull(),
      // contentId or creatorId
      reason: varchar2("reason", { length: 50 }),
      // Optional: "not_relevant", "seen_too_much", etc
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("not_interested_user_target").on(table.userId, table.targetType, table.targetId),
      index2("not_interested_user_idx").on(table.userId)
    ]);
    pushTokens = pgTable2("push_tokens", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      token: text2("token").notNull(),
      // Expo push token (ExponentPushToken[xxx])
      deviceId: text2("device_id"),
      // Optional device identifier for managing multiple devices
      platform: varchar2("platform", { length: 20 }),
      // "ios", "android", "web"
      deviceName: text2("device_name"),
      // Optional friendly device name
      isActive: boolean2("is_active").default(true).notNull(),
      lastUsedAt: timestamp2("last_used_at").defaultNow(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("push_tokens_token").on(table.token),
      index2("push_tokens_user_idx").on(table.userId),
      index2("push_tokens_active_idx").on(table.isActive)
    ]);
    insertDraftSchema = createInsertSchema2(drafts).pick({
      userId: true,
      type: true,
      content: true,
      caption: true,
      mediaUrl: true,
      thumbnailUrl: true,
      durationMs: true,
      aspectRatio: true,
      visibility: true,
      commentsEnabled: true
    });
    insertScheduledPostSchema = createInsertSchema2(scheduledPosts).pick({
      userId: true,
      type: true,
      content: true,
      caption: true,
      mediaUrl: true,
      thumbnailUrl: true,
      durationMs: true,
      aspectRatio: true,
      visibility: true,
      commentsEnabled: true,
      scheduledFor: true
    });
    wallets = pgTable2("wallets", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      coinBalance: bigint2("coin_balance", { mode: "number" }).default(0).notNull(),
      lifetimeEarned: bigint2("lifetime_earned", { mode: "number" }).default(0).notNull(),
      lifetimeSpent: bigint2("lifetime_spent", { mode: "number" }).default(0).notNull(),
      isFrozen: boolean2("is_frozen").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("wallets_user_id_idx").on(table.userId)
    ]);
    coinTransactionTypeEnum = pgEnum2("coin_transaction_type", [
      "PURCHASE",
      "GIFT_SENT",
      "GIFT_RECEIVED",
      "REFUND",
      "ADMIN_CREDIT",
      "ADMIN_DEBIT",
      "SUBSCRIPTION_PAYMENT"
    ]);
    payfastOrderStatusEnum = pgEnum2("payfast_order_status", [
      "PENDING",
      "COMPLETE",
      "FAILED",
      "CANCELLED"
    ]);
    payfastOrders = pgTable2("payfast_orders", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      mallItemId: varchar2("mall_item_id").references(() => mallItems.id, { onDelete: "set null" }),
      quantity: integer2("quantity").default(1).notNull(),
      amountCents: integer2("amount_cents").notNull(),
      status: payfastOrderStatusEnum("status").default("PENDING").notNull(),
      itemName: varchar2("item_name", { length: 255 }).notNull(),
      itemDescription: text2("item_description"),
      emailAddress: varchar2("email_address", { length: 255 }),
      pfPaymentId: varchar2("pf_payment_id", { length: 255 }),
      paymentStatus: varchar2("payment_status", { length: 50 }),
      amountGross: varchar2("amount_gross", { length: 50 }),
      amountFee: varchar2("amount_fee", { length: 50 }),
      amountNet: varchar2("amount_net", { length: 50 }),
      signature: varchar2("signature", { length: 255 }),
      itnPayload: text2("itn_payload"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull(),
      completedAt: timestamp2("completed_at")
    }, (table) => [
      index2("payfast_orders_user_id_idx").on(table.userId),
      index2("payfast_orders_status_idx").on(table.status),
      index2("payfast_orders_pf_payment_id_idx").on(table.pfPaymentId)
    ]);
    coinTransactions = pgTable2("coin_transactions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      walletId: varchar2("wallet_id").notNull().references(() => wallets.id, { onDelete: "cascade" }),
      type: coinTransactionTypeEnum("type").notNull(),
      amount: bigint2("amount", { mode: "number" }).notNull(),
      balanceAfter: bigint2("balance_after", { mode: "number" }).notNull(),
      description: text2("description"),
      referenceId: varchar2("reference_id"),
      referenceType: varchar2("reference_type", { length: 50 }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("coin_transactions_wallet_idx").on(table.walletId),
      index2("coin_transactions_created_idx").on(table.createdAt)
    ]);
    giftTypes = pgTable2("gift_types", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description"),
      iconUrl: text2("icon_url").notNull(),
      animationUrl: text2("animation_url"),
      coinCost: integer2("coin_cost").notNull(),
      netWorthValue: integer2("net_worth_value").default(0).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      category: varchar2("category", { length: 50 }),
      sortOrder: integer2("sort_order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("gift_types_active_idx").on(table.isActive),
      index2("gift_types_category_idx").on(table.category)
    ]);
    giftTransactions = pgTable2("gift_transactions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      senderId: varchar2("sender_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      recipientId: varchar2("recipient_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      giftTypeId: varchar2("gift_type_id").notNull().references(() => giftTypes.id, { onDelete: "cascade" }),
      quantity: integer2("quantity").default(1).notNull(),
      totalCoins: integer2("total_coins").notNull(),
      contextType: varchar2("context_type", { length: 50 }),
      contextId: varchar2("context_id"),
      message: text2("message"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("gift_transactions_sender_idx").on(table.senderId),
      index2("gift_transactions_recipient_idx").on(table.recipientId),
      index2("gift_transactions_context_idx").on(table.contextType, table.contextId)
    ]);
    coinBundles = pgTable2("coin_bundles", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description"),
      coinAmount: integer2("coin_amount").notNull(),
      bonusCoins: integer2("bonus_coins").default(0).notNull(),
      priceRands: integer2("price_rands").notNull(),
      iconUrl: text2("icon_url"),
      isActive: boolean2("is_active").default(true).notNull(),
      isFeatured: boolean2("is_featured").default(false).notNull(),
      sortOrder: integer2("sort_order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("coin_bundles_active_idx").on(table.isActive),
      index2("coin_bundles_sort_idx").on(table.sortOrder)
    ]);
    coinPurchases = pgTable2("coin_purchases", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      bundleId: varchar2("bundle_id").notNull().references(() => coinBundles.id, { onDelete: "restrict" }),
      coinsReceived: integer2("coins_received").notNull(),
      amountPaidRands: integer2("amount_paid_rands").notNull(),
      paymentMethod: varchar2("payment_method", { length: 50 }).default("payfast").notNull(),
      paymentReference: varchar2("payment_reference", { length: 255 }),
      status: varchar2("status", { length: 20 }).default("pending").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      completedAt: timestamp2("completed_at")
    }, (table) => [
      index2("coin_purchases_user_idx").on(table.userId),
      index2("coin_purchases_status_idx").on(table.status),
      index2("coin_purchases_reference_idx").on(table.paymentReference)
    ]);
    dailyRewards = pgTable2("daily_rewards", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }).unique(),
      lastClaimDate: date("last_claim_date"),
      currentStreak: integer2("current_streak").default(0).notNull(),
      longestStreak: integer2("longest_streak").default(0).notNull(),
      totalClaimed: integer2("total_claimed").default(0).notNull(),
      totalCoinsEarned: integer2("total_coins_earned").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("daily_rewards_user_idx").on(table.userId)
    ]);
    dailyRewardConfig = pgTable2("daily_reward_config", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      dayNumber: integer2("day_number").notNull().unique(),
      baseCoins: integer2("base_coins").notNull(),
      streakBonus: integer2("streak_bonus").default(0).notNull(),
      description: text2("description"),
      iconUrl: text2("icon_url"),
      isActive: boolean2("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    mallWishlists = pgTable2("mall_wishlists", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      itemId: varchar2("item_id").notNull().references(() => mallItems.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("mall_wishlists_unique").on(table.userId, table.itemId),
      index2("mall_wishlists_user_idx").on(table.userId)
    ]);
    mallReviews = pgTable2("mall_reviews", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      itemId: varchar2("item_id").notNull().references(() => mallItems.id, { onDelete: "cascade" }),
      rating: integer2("rating").notNull(),
      review: text2("review"),
      isVerifiedPurchase: boolean2("is_verified_purchase").default(false).notNull(),
      isFeatured: boolean2("is_featured").default(false).notNull(),
      isHidden: boolean2("is_hidden").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("mall_reviews_unique").on(table.userId, table.itemId),
      index2("mall_reviews_item_idx").on(table.itemId),
      index2("mall_reviews_user_idx").on(table.userId)
    ]);
    withdrawalStatusEnum = pgEnum2("withdrawal_status", [
      "PENDING",
      "PROCESSING",
      "APPROVED",
      "REJECTED",
      "COMPLETED",
      "FAILED",
      "CANCELLED"
    ]);
    userBankAccounts = pgTable2("user_bank_accounts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      bankName: varchar2("bank_name", { length: 100 }).notNull(),
      accountNumber: varchar2("account_number", { length: 50 }).notNull(),
      accountHolderName: varchar2("account_holder_name", { length: 200 }).notNull(),
      branchCode: varchar2("branch_code", { length: 20 }),
      accountType: varchar2("account_type", { length: 50 }).default("savings").notNull(),
      isVerified: boolean2("is_verified").default(false).notNull(),
      isPrimary: boolean2("is_primary").default(false).notNull(),
      verifiedAt: timestamp2("verified_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("user_bank_accounts_user_idx").on(table.userId)
    ]);
    kycStatusEnum = pgEnum2("kyc_status", [
      "NOT_STARTED",
      "PENDING",
      "UNDER_REVIEW",
      "APPROVED",
      "REJECTED",
      "EXPIRED"
    ]);
    userKyc = pgTable2("user_kyc", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }).unique(),
      status: kycStatusEnum("status").default("NOT_STARTED").notNull(),
      idType: varchar2("id_type", { length: 50 }),
      idNumber: varchar2("id_number", { length: 50 }),
      idDocumentUrl: text2("id_document_url"),
      selfieUrl: text2("selfie_url"),
      proofOfAddressUrl: text2("proof_of_address_url"),
      fullLegalName: varchar2("full_legal_name", { length: 200 }),
      dateOfBirth: date("date_of_birth"),
      nationality: varchar2("nationality", { length: 100 }),
      address: text2("address"),
      rejectionReason: text2("rejection_reason"),
      reviewedBy: varchar2("reviewed_by").references(() => users.id, { onDelete: "set null" }),
      reviewedAt: timestamp2("reviewed_at"),
      submittedAt: timestamp2("submitted_at"),
      expiresAt: timestamp2("expires_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("user_kyc_user_idx").on(table.userId),
      index2("user_kyc_status_idx").on(table.status)
    ]);
    withdrawalRequests = pgTable2("withdrawal_requests", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      bankAccountId: varchar2("bank_account_id").notNull().references(() => userBankAccounts.id, { onDelete: "restrict" }),
      amountCoins: integer2("amount_coins").notNull(),
      platformFeeCoins: integer2("platform_fee_coins").notNull(),
      netAmountCoins: integer2("net_amount_coins").notNull(),
      amountRands: integer2("amount_rands").notNull(),
      status: withdrawalStatusEnum("status").default("PENDING").notNull(),
      paymentReference: varchar2("payment_reference", { length: 255 }),
      rejectionReason: text2("rejection_reason"),
      adminNotes: text2("admin_notes"),
      processedBy: varchar2("processed_by").references(() => users.id, { onDelete: "set null" }),
      processedAt: timestamp2("processed_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("withdrawal_requests_user_idx").on(table.userId),
      index2("withdrawal_requests_status_idx").on(table.status),
      index2("withdrawal_requests_created_idx").on(table.createdAt)
    ]);
    platformRevenueSourceEnum = pgEnum2("platform_revenue_source", [
      "COIN_PURCHASE",
      "WITHDRAWAL_FEE",
      "MARKETPLACE_FEE",
      "BATTLE_FEE",
      "PREMIUM_FEATURE",
      "ADVERTISEMENT",
      "OTHER"
    ]);
    platformRevenue = pgTable2("platform_revenue", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      source: platformRevenueSourceEnum("source").notNull(),
      amountRands: integer2("amount_rands").notNull(),
      referenceType: varchar2("reference_type", { length: 50 }),
      referenceId: varchar2("reference_id"),
      userId: varchar2("user_id").references(() => users.id, { onDelete: "set null" }),
      description: text2("description"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("platform_revenue_source_idx").on(table.source),
      index2("platform_revenue_created_idx").on(table.createdAt),
      index2("platform_revenue_user_idx").on(table.userId)
    ]);
    platformStats = pgTable2("platform_stats", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      statDate: date("stat_date").notNull().unique(),
      totalCoinsInCirculation: bigint2("total_coins_in_circulation", { mode: "number" }).default(0).notNull(),
      totalCoinsIssuedToday: integer2("total_coins_issued_today").default(0).notNull(),
      totalCoinsBurnedToday: integer2("total_coins_burned_today").default(0).notNull(),
      dailyActiveWallets: integer2("daily_active_wallets").default(0).notNull(),
      totalRevenueToday: integer2("total_revenue_today").default(0).notNull(),
      totalWithdrawalsToday: integer2("total_withdrawals_today").default(0).notNull(),
      totalGiftsSent: integer2("total_gifts_sent").default(0).notNull(),
      totalMallPurchases: integer2("total_mall_purchases").default(0).notNull(),
      averageWalletBalance: integer2("average_wallet_balance").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("platform_stats_date_idx").on(table.statDate)
    ]);
    achievementCategoryEnum = pgEnum2("achievement_category", [
      "WEALTH",
      "SOCIAL",
      "CONTENT",
      "SHOPPING",
      "GIFTING",
      "STREAMING",
      "SPECIAL"
    ]);
    achievements = pgTable2("achievements", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description").notNull(),
      category: achievementCategoryEnum("category").notNull(),
      iconUrl: text2("icon_url"),
      requirement: text2("requirement").notNull(),
      rewardCoins: integer2("reward_coins").default(0).notNull(),
      rewardBadge: varchar2("reward_badge", { length: 100 }),
      sortOrder: integer2("sort_order").default(0).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      isSecret: boolean2("is_secret").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("achievements_category_idx").on(table.category),
      index2("achievements_active_idx").on(table.isActive)
    ]);
    userAchievements = pgTable2("user_achievements", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      achievementId: varchar2("achievement_id").notNull().references(() => achievements.id, { onDelete: "cascade" }),
      progress: integer2("progress").default(0).notNull(),
      progressMax: integer2("progress_max").notNull(),
      isCompleted: boolean2("is_completed").default(false).notNull(),
      completedAt: timestamp2("completed_at"),
      rewardClaimed: boolean2("reward_claimed").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("user_achievements_unique").on(table.userId, table.achievementId),
      index2("user_achievements_user_idx").on(table.userId),
      index2("user_achievements_completed_idx").on(table.isCompleted)
    ]);
    wealthClubTierEnum = pgEnum2("wealth_club_tier", [
      "BRONZE",
      "SILVER",
      "GOLD",
      "PLATINUM",
      "DIAMOND"
    ]);
    wealthClubs = pgTable2("wealth_clubs", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      tier: wealthClubTierEnum("tier").notNull().unique(),
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description"),
      minNetWorth: bigint2("min_net_worth", { mode: "number" }).notNull(),
      maxNetWorth: bigint2("max_net_worth", { mode: "number" }),
      badgeIconUrl: text2("badge_icon_url"),
      perks: text2("perks"),
      discountPercent: integer2("discount_percent").default(0).notNull(),
      bonusCoinPercent: integer2("bonus_coin_percent").default(0).notNull(),
      prioritySupport: boolean2("priority_support").default(false).notNull(),
      exclusiveContent: boolean2("exclusive_content").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    userWealthClub = pgTable2("user_wealth_club", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      clubId: varchar2("club_id").notNull().references(() => wealthClubs.id, { onDelete: "cascade" }),
      joinedAt: timestamp2("joined_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("user_wealth_club_user_idx").on(table.userId),
      index2("user_wealth_club_club_idx").on(table.clubId)
    ]);
    stakeStatusEnum = pgEnum2("stake_status", [
      "ACTIVE",
      "MATURED",
      "CLAIMED",
      "CANCELLED"
    ]);
    giftStakes = pgTable2("gift_stakes", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      giftTransactionId: varchar2("gift_transaction_id").notNull().references(() => giftTransactions.id, { onDelete: "cascade" }),
      stakedCoins: integer2("staked_coins").notNull(),
      stakeDurationDays: integer2("stake_duration_days").notNull(),
      bonusPercent: integer2("bonus_percent").notNull(),
      expectedReturn: integer2("expected_return").notNull(),
      status: stakeStatusEnum("status").default("ACTIVE").notNull(),
      stakedAt: timestamp2("staked_at").defaultNow().notNull(),
      maturesAt: timestamp2("matures_at").notNull(),
      claimedAt: timestamp2("claimed_at")
    }, (table) => [
      index2("gift_stakes_user_idx").on(table.userId),
      index2("gift_stakes_status_idx").on(table.status),
      index2("gift_stakes_matures_idx").on(table.maturesAt)
    ]);
    stakingTiers = pgTable2("staking_tiers", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 100 }).notNull(),
      durationDays: integer2("duration_days").notNull(),
      bonusPercent: integer2("bonus_percent").notNull(),
      minCoins: integer2("min_coins").default(100).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      sortOrder: integer2("sort_order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    battleStatusEnum = pgEnum2("battle_status", [
      "PENDING",
      "ACTIVE",
      "COMPLETED",
      "CANCELLED"
    ]);
    platformBattles = pgTable2("platform_battles", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 200 }).notNull(),
      description: text2("description"),
      creatorId: varchar2("creator_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      status: battleStatusEnum("status").default("PENDING").notNull(),
      entryFeeCoins: integer2("entry_fee_coins").default(0).notNull(),
      prizePoolCoins: integer2("prize_pool_coins").default(0).notNull(),
      platformFeePercent: integer2("platform_fee_percent").default(20).notNull(),
      maxParticipants: integer2("max_participants"),
      startsAt: timestamp2("starts_at").notNull(),
      endsAt: timestamp2("ends_at").notNull(),
      winnerId: varchar2("winner_id").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("platform_battles_creator_idx").on(table.creatorId),
      index2("platform_battles_status_idx").on(table.status),
      index2("platform_battles_starts_idx").on(table.startsAt)
    ]);
    battleParticipants = pgTable2("battle_participants", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      battleId: varchar2("battle_id").notNull().references(() => platformBattles.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      totalGiftsReceived: integer2("total_gifts_received").default(0).notNull(),
      totalCoinsReceived: integer2("total_coins_received").default(0).notNull(),
      rank: integer2("rank"),
      joinedAt: timestamp2("joined_at").defaultNow().notNull()
    }, (table) => [
      unique2("battle_participants_unique").on(table.battleId, table.userId),
      index2("battle_participants_battle_idx").on(table.battleId),
      index2("battle_participants_user_idx").on(table.userId)
    ]);
    creatorEarnings = pgTable2("creator_earnings", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      totalEarningsCoins: bigint2("total_earnings_coins", { mode: "number" }).default(0).notNull(),
      pendingWithdrawalCoins: bigint2("pending_withdrawal_coins", { mode: "number" }).default(0).notNull(),
      withdrawnCoins: bigint2("withdrawn_coins", { mode: "number" }).default(0).notNull(),
      platformFeePaid: bigint2("platform_fee_paid", { mode: "number" }).default(0).notNull(),
      lastUpdated: timestamp2("last_updated").defaultNow().notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("creator_earnings_user_unique").on(table.userId),
      index2("creator_earnings_user_idx").on(table.userId)
    ]);
    earningsHistory = pgTable2("earnings_history", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      amount: integer2("amount").notNull(),
      sourceType: varchar2("source_type", { length: 50 }).notNull(),
      sourceId: varchar2("source_id"),
      description: text2("description"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("earnings_history_user_idx").on(table.userId),
      index2("earnings_history_created_idx").on(table.createdAt)
    ]);
    economyConfig = pgTable2("economy_config", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      key: varchar2("key", { length: 100 }).notNull().unique(),
      value: text2("value").notNull(),
      description: text2("description"),
      updatedBy: varchar2("updated_by").references(() => users.id, { onDelete: "set null" }),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    ticketStatusEnum = pgEnum2("ticket_status", [
      "OPEN",
      "IN_PROGRESS",
      "WAITING_USER",
      "RESOLVED",
      "CLOSED"
    ]);
    ticketPriorityEnum = pgEnum2("ticket_priority", [
      "LOW",
      "MEDIUM",
      "HIGH",
      "URGENT"
    ]);
    ticketCategoryEnum = pgEnum2("ticket_category", [
      "ACCOUNT",
      "PAYMENT",
      "WITHDRAWAL",
      "COINS",
      "GIFTS",
      "MALL",
      "TECHNICAL",
      "REPORT",
      "OTHER"
    ]);
    supportTickets = pgTable2("support_tickets", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      subject: varchar2("subject", { length: 200 }).notNull(),
      description: text2("description").notNull(),
      category: ticketCategoryEnum("category").notNull(),
      priority: ticketPriorityEnum("priority").default("MEDIUM").notNull(),
      status: ticketStatusEnum("status").default("OPEN").notNull(),
      assignedTo: varchar2("assigned_to").references(() => users.id, { onDelete: "set null" }),
      resolvedAt: timestamp2("resolved_at"),
      closedAt: timestamp2("closed_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("support_tickets_user_idx").on(table.userId),
      index2("support_tickets_status_idx").on(table.status),
      index2("support_tickets_category_idx").on(table.category),
      index2("support_tickets_assigned_idx").on(table.assignedTo)
    ]);
    supportTicketMessages = pgTable2("support_ticket_messages", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      ticketId: varchar2("ticket_id").notNull().references(() => supportTickets.id, { onDelete: "cascade" }),
      senderId: varchar2("sender_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      message: text2("message").notNull(),
      isInternal: boolean2("is_internal").default(false).notNull(),
      attachmentUrls: text2("attachment_urls"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("support_ticket_messages_ticket_idx").on(table.ticketId)
    ]);
    platformConfig = pgTable2("platform_config", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      key: varchar2("key", { length: 100 }).notNull().unique(),
      value: text2("value").notNull(),
      valueType: varchar2("value_type", { length: 20 }).default("string").notNull(),
      category: varchar2("category", { length: 50 }).notNull(),
      description: text2("description"),
      isEditable: boolean2("is_editable").default(true).notNull(),
      updatedBy: varchar2("updated_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("platform_config_category_idx").on(table.category)
    ]);
    liveStreamStatusEnum = pgEnum2("live_stream_status", ["PREPARING", "LIVE", "ENDED", "CANCELLED"]);
    liveStreams = pgTable2("live_streams", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      hostId: varchar2("host_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      coHostId: varchar2("co_host_id").references(() => users.id, { onDelete: "set null" }),
      title: varchar2("title", { length: 200 }),
      description: text2("description"),
      thumbnailUrl: text2("thumbnail_url"),
      status: liveStreamStatusEnum("status").default("PREPARING").notNull(),
      streamKey: varchar2("stream_key", { length: 100 }),
      viewerCount: integer2("viewer_count").default(0).notNull(),
      peakViewerCount: integer2("peak_viewer_count").default(0).notNull(),
      totalViews: integer2("total_views").default(0).notNull(),
      totalGiftsReceived: integer2("total_gifts_received").default(0).notNull(),
      totalCoinsReceived: bigint2("total_coins_received", { mode: "number" }).default(0).notNull(),
      likesCount: integer2("likes_count").default(0).notNull(),
      commentsCount: integer2("comments_count").default(0).notNull(),
      sharesCount: integer2("shares_count").default(0).notNull(),
      isRecorded: boolean2("is_recorded").default(false).notNull(),
      recordingUrl: text2("recording_url"),
      savedToProfile: boolean2("saved_to_profile").default(false).notNull(),
      durationSeconds: integer2("duration_seconds").default(0),
      startedAt: timestamp2("started_at"),
      endedAt: timestamp2("ended_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("live_streams_host_idx").on(table.hostId),
      index2("live_streams_status_idx").on(table.status),
      index2("live_streams_created_idx").on(table.createdAt)
    ]);
    liveStreamViewers = pgTable2("live_stream_viewers", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      streamId: varchar2("stream_id").notNull().references(() => liveStreams.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      joinedAt: timestamp2("joined_at").defaultNow().notNull(),
      leftAt: timestamp2("left_at"),
      watchTimeSeconds: integer2("watch_time_seconds").default(0)
    }, (table) => [
      index2("live_stream_viewers_stream_idx").on(table.streamId),
      index2("live_stream_viewers_user_idx").on(table.userId),
      unique2("live_stream_viewers_unique").on(table.streamId, table.userId)
    ]);
    liveStreamComments = pgTable2("live_stream_comments", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      streamId: varchar2("stream_id").notNull().references(() => liveStreams.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      content: text2("content").notNull(),
      isPinned: boolean2("is_pinned").default(false).notNull(),
      isHidden: boolean2("is_hidden").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("live_stream_comments_stream_idx").on(table.streamId),
      index2("live_stream_comments_created_idx").on(table.createdAt)
    ]);
    liveStreamReactions = pgTable2("live_stream_reactions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      streamId: varchar2("stream_id").notNull().references(() => liveStreams.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      reactionType: varchar2("reaction_type", { length: 20 }).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("live_stream_reactions_stream_idx").on(table.streamId)
    ]);
    liveStreamGifts = pgTable2("live_stream_gifts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      streamId: varchar2("stream_id").notNull().references(() => liveStreams.id, { onDelete: "cascade" }),
      giftTransactionId: varchar2("gift_transaction_id").notNull().references(() => giftTransactions.id, { onDelete: "cascade" }),
      displayedAt: timestamp2("displayed_at").defaultNow().notNull()
    }, (table) => [
      index2("live_stream_gifts_stream_idx").on(table.streamId)
    ]);
    groupPrivacyEnum = pgEnum2("group_privacy", ["PUBLIC", "PRIVATE", "SECRET"]);
    groupMemberRoleEnum = pgEnum2("group_member_role", ["OWNER", "ADMIN", "MODERATOR", "MEMBER"]);
    groups = pgTable2("groups", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description"),
      coverUrl: text2("cover_url"),
      iconUrl: text2("icon_url"),
      privacy: groupPrivacyEnum("privacy").default("PUBLIC").notNull(),
      ownerId: varchar2("owner_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      memberCount: integer2("member_count").default(1).notNull(),
      postCount: integer2("post_count").default(0).notNull(),
      rules: jsonb2("rules").default([]),
      tags: jsonb2("tags").default([]),
      requireApproval: boolean2("require_approval").default(false).notNull(),
      isVerified: boolean2("is_verified").default(false).notNull(),
      netWorthRequirement: bigint2("net_worth_requirement", { mode: "number" }),
      isArchived: boolean2("is_archived").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("groups_owner_idx").on(table.ownerId),
      index2("groups_privacy_idx").on(table.privacy),
      index2("groups_created_idx").on(table.createdAt)
    ]);
    groupMembers = pgTable2("group_members", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      groupId: varchar2("group_id").notNull().references(() => groups.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      role: groupMemberRoleEnum("role").default("MEMBER").notNull(),
      invitedById: varchar2("invited_by_id").references(() => users.id, { onDelete: "set null" }),
      muteNotifications: boolean2("mute_notifications").default(false).notNull(),
      joinedAt: timestamp2("joined_at").defaultNow().notNull()
    }, (table) => [
      unique2("group_members_unique").on(table.groupId, table.userId),
      index2("group_members_group_idx").on(table.groupId),
      index2("group_members_user_idx").on(table.userId)
    ]);
    groupJoinRequestStatusEnum = pgEnum2("group_join_request_status", ["PENDING", "APPROVED", "REJECTED"]);
    groupJoinRequests = pgTable2("group_join_requests", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      groupId: varchar2("group_id").notNull().references(() => groups.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      message: text2("message"),
      status: groupJoinRequestStatusEnum("status").default("PENDING").notNull(),
      reviewedById: varchar2("reviewed_by_id").references(() => users.id, { onDelete: "set null" }),
      reviewedAt: timestamp2("reviewed_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("group_join_requests_unique").on(table.groupId, table.userId),
      index2("group_join_requests_status_idx").on(table.status)
    ]);
    groupPosts = pgTable2("group_posts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      groupId: varchar2("group_id").notNull().references(() => groups.id, { onDelete: "cascade" }),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      isPinned: boolean2("is_pinned").default(false).notNull(),
      pinnedById: varchar2("pinned_by_id").references(() => users.id, { onDelete: "set null" }),
      pinnedAt: timestamp2("pinned_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("group_posts_unique").on(table.groupId, table.postId),
      index2("group_posts_group_idx").on(table.groupId),
      index2("group_posts_pinned_idx").on(table.isPinned)
    ]);
    eventStatusEnum = pgEnum2("event_status", ["DRAFT", "PUBLISHED", "CANCELLED", "COMPLETED"]);
    eventTypeEnum = pgEnum2("event_type", ["IN_PERSON", "VIRTUAL", "HYBRID"]);
    rsvpStatusEnum = pgEnum2("rsvp_status", ["GOING", "INTERESTED", "NOT_GOING"]);
    events = pgTable2("events", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      hostId: varchar2("host_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      groupId: varchar2("group_id").references(() => groups.id, { onDelete: "set null" }),
      title: varchar2("title", { length: 200 }).notNull(),
      description: text2("description"),
      coverUrl: text2("cover_url"),
      eventType: eventTypeEnum("event_type").default("IN_PERSON").notNull(),
      status: eventStatusEnum("status").default("DRAFT").notNull(),
      locationName: text2("location_name"),
      locationAddress: text2("location_address"),
      locationLat: real2("location_lat"),
      locationLng: real2("location_lng"),
      virtualLink: text2("virtual_link"),
      startsAt: timestamp2("starts_at").notNull(),
      endsAt: timestamp2("ends_at"),
      timezone: varchar2("timezone", { length: 50 }),
      maxAttendees: integer2("max_attendees"),
      goingCount: integer2("going_count").default(0).notNull(),
      interestedCount: integer2("interested_count").default(0).notNull(),
      isPrivate: boolean2("is_private").default(false).notNull(),
      requireApproval: boolean2("require_approval").default(false).notNull(),
      ticketPrice: integer2("ticket_price"),
      tags: jsonb2("tags").default([]),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("events_host_idx").on(table.hostId),
      index2("events_status_idx").on(table.status),
      index2("events_starts_at_idx").on(table.startsAt),
      index2("events_group_idx").on(table.groupId)
    ]);
    eventRsvps = pgTable2("event_rsvps", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      eventId: varchar2("event_id").notNull().references(() => events.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      status: rsvpStatusEnum("status").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("event_rsvps_unique").on(table.eventId, table.userId),
      index2("event_rsvps_event_idx").on(table.eventId),
      index2("event_rsvps_user_idx").on(table.userId)
    ]);
    subscriptionTiers = pgTable2("subscription_tiers", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      creatorId: varchar2("creator_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description"),
      monthlyPriceCoins: integer2("monthly_price_coins").notNull(),
      yearlyPriceCoins: integer2("yearly_price_coins"),
      benefits: jsonb2("benefits").default([]),
      isActive: boolean2("is_active").default(true).notNull(),
      subscriberCount: integer2("subscriber_count").default(0).notNull(),
      sortOrder: integer2("sort_order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("subscription_tiers_creator_idx").on(table.creatorId),
      index2("subscription_tiers_active_idx").on(table.isActive)
    ]);
    subscriptionStatusEnum = pgEnum2("subscription_status", ["ACTIVE", "CANCELLED", "EXPIRED", "PAUSED"]);
    subscriptions = pgTable2("subscriptions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      subscriberId: varchar2("subscriber_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      creatorId: varchar2("creator_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      tierId: varchar2("tier_id").notNull().references(() => subscriptionTiers.id, { onDelete: "cascade" }),
      status: subscriptionStatusEnum("status").default("ACTIVE").notNull(),
      isYearly: boolean2("is_yearly").default(false).notNull(),
      currentPeriodStart: timestamp2("current_period_start").notNull(),
      currentPeriodEnd: timestamp2("current_period_end").notNull(),
      cancelledAt: timestamp2("cancelled_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      unique2("subscriptions_unique").on(table.subscriberId, table.creatorId),
      index2("subscriptions_subscriber_idx").on(table.subscriberId),
      index2("subscriptions_creator_idx").on(table.creatorId),
      index2("subscriptions_status_idx").on(table.status)
    ]);
    broadcastChannels = pgTable2("broadcast_channels", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      ownerId: varchar2("owner_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description"),
      avatarUrl: text2("avatar_url"),
      subscriberCount: integer2("subscriber_count").default(0).notNull(),
      messageCount: integer2("message_count").default(0).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("broadcast_channels_owner_idx").on(table.ownerId),
      index2("broadcast_channels_active_idx").on(table.isActive)
    ]);
    broadcastChannelSubscribers = pgTable2("broadcast_channel_subscribers", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      channelId: varchar2("channel_id").notNull().references(() => broadcastChannels.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      muteNotifications: boolean2("mute_notifications").default(false).notNull(),
      subscribedAt: timestamp2("subscribed_at").defaultNow().notNull()
    }, (table) => [
      unique2("broadcast_channel_subscribers_unique").on(table.channelId, table.userId),
      index2("broadcast_channel_subscribers_channel_idx").on(table.channelId),
      index2("broadcast_channel_subscribers_user_idx").on(table.userId)
    ]);
    broadcastMessages = pgTable2("broadcast_messages", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      channelId: varchar2("channel_id").notNull().references(() => broadcastChannels.id, { onDelete: "cascade" }),
      content: text2("content"),
      mediaUrl: text2("media_url"),
      mediaType: varchar2("media_type", { length: 20 }),
      isPinned: boolean2("is_pinned").default(false).notNull(),
      reactionsCount: integer2("reactions_count").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("broadcast_messages_channel_idx").on(table.channelId),
      index2("broadcast_messages_created_idx").on(table.createdAt)
    ]);
    postReactionTypeEnum = pgEnum2("post_reaction_type", [
      "LIKE",
      "LOVE",
      "HAHA",
      "WOW",
      "SAD",
      "ANGRY",
      "FIRE",
      "DIAMOND",
      "CROWN"
    ]);
    postReactions = pgTable2("post_reactions", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      reactionType: postReactionTypeEnum("reaction_type").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("post_reactions_unique").on(table.postId, table.userId),
      index2("post_reactions_post_idx").on(table.postId),
      index2("post_reactions_type_idx").on(table.reactionType)
    ]);
    userLocations = pgTable2("user_locations", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      latitude: real2("latitude").notNull(),
      longitude: real2("longitude").notNull(),
      accuracy: real2("accuracy"),
      locationName: text2("location_name"),
      isSharing: boolean2("is_sharing").default(false).notNull(),
      sharingMode: varchar2("sharing_mode", { length: 20 }).default("FRIENDS"),
      expiresAt: timestamp2("expires_at"),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("user_locations_user_idx").on(table.userId),
      index2("user_locations_sharing_idx").on(table.isSharing)
    ]);
    locationSharingSettings = pgTable2("location_sharing_settings", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      ghostMode: boolean2("ghost_mode").default(false).notNull(),
      shareWithFollowers: boolean2("share_with_followers").default(true).notNull(),
      shareWithCloseFriends: boolean2("share_with_close_friends").default(true).notNull(),
      showLastSeen: boolean2("show_last_seen").default(true).notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    venues = pgTable2("venues", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 200 }).notNull(),
      category: varchar2("category", { length: 100 }),
      address: text2("address"),
      city: varchar2("city", { length: 100 }),
      country: varchar2("country", { length: 100 }),
      latitude: real2("latitude"),
      longitude: real2("longitude"),
      photoUrl: text2("photo_url"),
      checkInCount: integer2("check_in_count").default(0).notNull(),
      isVerified: boolean2("is_verified").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("venues_location_idx").on(table.latitude, table.longitude),
      index2("venues_city_idx").on(table.city),
      index2("venues_category_idx").on(table.category)
    ]);
    checkIns = pgTable2("check_ins", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      venueId: varchar2("venue_id").references(() => venues.id, { onDelete: "set null" }),
      postId: varchar2("post_id").references(() => posts.id, { onDelete: "set null" }),
      customLocationName: text2("custom_location_name"),
      latitude: real2("latitude"),
      longitude: real2("longitude"),
      caption: text2("caption"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("check_ins_user_idx").on(table.userId),
      index2("check_ins_venue_idx").on(table.venueId),
      index2("check_ins_created_idx").on(table.createdAt)
    ]);
    groupConversations = pgTable2("group_conversations", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 100 }),
      avatarUrl: text2("avatar_url"),
      creatorId: varchar2("creator_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      memberCount: integer2("member_count").default(1).notNull(),
      messageCount: integer2("message_count").default(0).notNull(),
      lastMessageAt: timestamp2("last_message_at").defaultNow().notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      settings: jsonb2("settings").default({}),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("group_conversations_creator_idx").on(table.creatorId),
      index2("group_conversations_last_message_idx").on(table.lastMessageAt)
    ]);
    groupConversationMemberRoleEnum = pgEnum2("group_conversation_member_role", ["ADMIN", "MEMBER"]);
    groupConversationMembers = pgTable2("group_conversation_members", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      conversationId: varchar2("conversation_id").notNull().references(() => groupConversations.id, { onDelete: "cascade" }),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      role: groupConversationMemberRoleEnum("role").default("MEMBER").notNull(),
      nickname: varchar2("nickname", { length: 50 }),
      muteUntil: timestamp2("mute_until"),
      lastReadAt: timestamp2("last_read_at"),
      joinedAt: timestamp2("joined_at").defaultNow().notNull()
    }, (table) => [
      unique2("group_conversation_members_unique").on(table.conversationId, table.userId),
      index2("group_conversation_members_conv_idx").on(table.conversationId),
      index2("group_conversation_members_user_idx").on(table.userId)
    ]);
    groupMessages = pgTable2("group_messages", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      conversationId: varchar2("conversation_id").notNull().references(() => groupConversations.id, { onDelete: "cascade" }),
      senderId: varchar2("sender_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      content: text2("content"),
      messageType: messageTypeEnum("message_type").default("TEXT"),
      mediaUrl: text2("media_url"),
      mediaThumbnail: text2("media_thumbnail"),
      mediaDuration: integer2("media_duration"),
      fileName: text2("file_name"),
      fileSize: integer2("file_size"),
      replyToId: varchar2("reply_to_id"),
      isDeleted: boolean2("is_deleted").default(false).notNull(),
      isPinned: boolean2("is_pinned").default(false).notNull(),
      reactions: jsonb2("reactions").default({}),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("group_messages_conv_idx").on(table.conversationId),
      index2("group_messages_created_idx").on(table.createdAt)
    ]);
    callStatusEnum = pgEnum2("call_status", ["RINGING", "ONGOING", "ENDED", "MISSED", "DECLINED", "CANCELLED"]);
    callTypeEnum = pgEnum2("call_type", ["AUDIO", "VIDEO"]);
    videoCalls = pgTable2("video_calls", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      callerId: varchar2("caller_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      calleeId: varchar2("callee_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      callType: callTypeEnum("call_type").default("VIDEO").notNull(),
      status: callStatusEnum("status").default("RINGING").notNull(),
      roomId: varchar2("room_id", { length: 100 }),
      durationSeconds: integer2("duration_seconds"),
      startedAt: timestamp2("started_at"),
      endedAt: timestamp2("ended_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("video_calls_caller_idx").on(table.callerId),
      index2("video_calls_callee_idx").on(table.calleeId),
      index2("video_calls_status_idx").on(table.status),
      index2("video_calls_created_idx").on(table.createdAt)
    ]);
    vanishModeSettings = pgTable2("vanish_mode_settings", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      conversationId: varchar2("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }),
      isEnabled: boolean2("is_enabled").default(false).notNull(),
      enabledById: varchar2("enabled_by_id").references(() => users.id, { onDelete: "set null" }),
      enabledAt: timestamp2("enabled_at"),
      disabledAt: timestamp2("disabled_at")
    }, (table) => [
      unique2("vanish_mode_settings_conv").on(table.conversationId),
      index2("vanish_mode_settings_enabled_idx").on(table.isEnabled)
    ]);
    hiddenWords = pgTable2("hidden_words", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      word: varchar2("word", { length: 100 }).notNull(),
      filterInComments: boolean2("filter_in_comments").default(true).notNull(),
      filterInMessages: boolean2("filter_in_messages").default(true).notNull(),
      filterInStoryReplies: boolean2("filter_in_story_replies").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("hidden_words_unique").on(table.userId, table.word),
      index2("hidden_words_user_idx").on(table.userId)
    ]);
    linkedAccounts = pgTable2("linked_accounts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      primaryUserId: varchar2("primary_user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      linkedUserId: varchar2("linked_user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      linkedAt: timestamp2("linked_at").defaultNow().notNull()
    }, (table) => [
      unique2("linked_accounts_unique").on(table.primaryUserId, table.linkedUserId),
      index2("linked_accounts_primary_idx").on(table.primaryUserId),
      index2("linked_accounts_linked_idx").on(table.linkedUserId)
    ]);
    totpSecrets = pgTable2("totp_secrets", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      secret: text2("secret").notNull(),
      isEnabled: boolean2("is_enabled").default(false).notNull(),
      verifiedAt: timestamp2("verified_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    backupCodes = pgTable2("backup_codes", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      code: varchar2("code", { length: 20 }).notNull(),
      usedAt: timestamp2("used_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("backup_codes_user_idx").on(table.userId)
    ]);
    arFilters = pgTable2("ar_filters", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 100 }).notNull(),
      description: text2("description"),
      creatorId: varchar2("creator_id").references(() => users.id, { onDelete: "set null" }),
      thumbnailUrl: text2("thumbnail_url").notNull(),
      filterUrl: text2("filter_url").notNull(),
      category: varchar2("category", { length: 50 }),
      usageCount: integer2("usage_count").default(0).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      isFeatured: boolean2("is_featured").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("ar_filters_category_idx").on(table.category),
      index2("ar_filters_active_idx").on(table.isActive),
      index2("ar_filters_featured_idx").on(table.isFeatured)
    ]);
    hashtags = pgTable2("hashtags", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      tag: varchar2("tag", { length: 100 }).notNull().unique(),
      postCount: integer2("post_count").default(0).notNull(),
      weeklyPostCount: integer2("weekly_post_count").default(0).notNull(),
      isBlocked: boolean2("is_blocked").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("hashtags_tag_idx").on(table.tag),
      index2("hashtags_post_count_idx").on(table.postCount),
      index2("hashtags_weekly_idx").on(table.weeklyPostCount)
    ]);
    postHashtags = pgTable2("post_hashtags", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      hashtagId: varchar2("hashtag_id").notNull().references(() => hashtags.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("post_hashtags_unique").on(table.postId, table.hashtagId),
      index2("post_hashtags_post_idx").on(table.postId),
      index2("post_hashtags_hashtag_idx").on(table.hashtagId)
    ]);
    postThreads = pgTable2("post_threads", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      authorId: varchar2("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      title: varchar2("title", { length: 200 }),
      postCount: integer2("post_count").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("post_threads_author_idx").on(table.authorId)
    ]);
    threadPosts = pgTable2("thread_posts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      threadId: varchar2("thread_id").notNull().references(() => postThreads.id, { onDelete: "cascade" }),
      postId: varchar2("post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      position: integer2("position").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("thread_posts_unique").on(table.threadId, table.postId),
      index2("thread_posts_thread_idx").on(table.threadId),
      index2("thread_posts_position_idx").on(table.threadId, table.position)
    ]);
    duetStitchTypeEnum = pgEnum2("duet_stitch_type", ["DUET", "STITCH"]);
    duetStitchPosts = pgTable2("duet_stitch_posts", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      postId: varchar2("post_id").notNull().unique().references(() => posts.id, { onDelete: "cascade" }),
      originalPostId: varchar2("original_post_id").notNull().references(() => posts.id, { onDelete: "cascade" }),
      type: duetStitchTypeEnum("type").notNull(),
      stitchStartMs: integer2("stitch_start_ms"),
      stitchEndMs: integer2("stitch_end_ms"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("duet_stitch_posts_original_idx").on(table.originalPostId),
      index2("duet_stitch_posts_type_idx").on(table.type)
    ]);
    webhooks = pgTable2("webhooks", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      url: text2("url").notNull(),
      secret: varchar2("secret", { length: 100 }).notNull(),
      events: jsonb2("events").default([]).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      failureCount: integer2("failure_count").default(0).notNull(),
      lastDeliveredAt: timestamp2("last_delivered_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("webhooks_user_idx").on(table.userId),
      index2("webhooks_active_idx").on(table.isActive)
    ]);
    webhookDeliveries = pgTable2("webhook_deliveries", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      webhookId: varchar2("webhook_id").notNull().references(() => webhooks.id, { onDelete: "cascade" }),
      event: varchar2("event", { length: 100 }).notNull(),
      payload: jsonb2("payload").notNull(),
      responseStatus: integer2("response_status"),
      responseBody: text2("response_body"),
      retryCount: integer2("retry_count").default(0).notNull(),
      success: boolean2("success").default(false).notNull(),
      deliveredAt: timestamp2("delivered_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("webhook_deliveries_webhook_idx").on(table.webhookId),
      index2("webhook_deliveries_created_idx").on(table.createdAt),
      index2("webhook_deliveries_success_idx").on(table.success)
    ]);
    apiAccessTokens = pgTable2("api_access_tokens", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      name: varchar2("name", { length: 100 }).notNull(),
      token: varchar2("token", { length: 255 }).notNull().unique(),
      scopes: jsonb2("scopes").default([]).notNull(),
      isRevoked: boolean2("is_revoked").default(false).notNull(),
      lastUsedAt: timestamp2("last_used_at"),
      expiresAt: timestamp2("expires_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("api_tokens_user_idx").on(table.userId),
      index2("api_tokens_token_idx").on(table.token),
      index2("api_tokens_revoked_idx").on(table.isRevoked)
    ]);
    featureFlags = pgTable2("feature_flags", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      key: varchar2("key", { length: 100 }).notNull().unique(),
      name: varchar2("name", { length: 200 }).notNull(),
      description: text2("description"),
      isEnabled: boolean2("is_enabled").default(false).notNull(),
      rolloutPercentage: integer2("rollout_percentage").default(100),
      allowedUserIds: jsonb2("allowed_user_ids").default([]),
      blockedUserIds: jsonb2("blocked_user_ids").default([]),
      metadata: jsonb2("metadata").default({}),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index2("feature_flags_key_idx").on(table.key),
      index2("feature_flags_enabled_idx").on(table.isEnabled)
    ]);
    commentReplies = pgTable2("comment_replies", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      commentId: varchar2("comment_id").notNull().references(() => comments.id, { onDelete: "cascade" }),
      authorId: varchar2("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      parentReplyId: varchar2("parent_reply_id"),
      content: text2("content").notNull(),
      likesCount: integer2("likes_count").default(0).notNull(),
      isHidden: boolean2("is_hidden").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("comment_replies_comment_idx").on(table.commentId),
      index2("comment_replies_parent_idx").on(table.parentReplyId),
      index2("comment_replies_author_idx").on(table.authorId)
    ]);
    pokes = pgTable2("pokes", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      senderId: varchar2("sender_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      recipientId: varchar2("recipient_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      pokeType: varchar2("poke_type", { length: 20 }).default("WAVE").notNull(),
      seenAt: timestamp2("seen_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("pokes_sender_idx").on(table.senderId),
      index2("pokes_recipient_idx").on(table.recipientId),
      index2("pokes_created_idx").on(table.createdAt)
    ]);
    bffStatus = pgTable2("bff_status", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      bffId: varchar2("bff_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      streakCount: integer2("streak_count").default(0).notNull(),
      lastInteractionAt: timestamp2("last_interaction_at").defaultNow().notNull(),
      becameBffAt: timestamp2("became_bff_at").defaultNow().notNull()
    }, (table) => [
      unique2("bff_status_unique").on(table.userId, table.bffId),
      index2("bff_status_user_idx").on(table.userId),
      index2("bff_status_streak_idx").on(table.streakCount)
    ]);
    scheduledMessages = pgTable2("scheduled_messages", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      conversationId: varchar2("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }),
      senderId: varchar2("sender_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      content: text2("content").notNull(),
      messageType: messageTypeEnum("message_type").default("TEXT"),
      mediaUrl: text2("media_url"),
      scheduledFor: timestamp2("scheduled_for").notNull(),
      sentAt: timestamp2("sent_at"),
      isCancelled: boolean2("is_cancelled").default(false).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("scheduled_messages_scheduled_for_idx").on(table.scheduledFor),
      index2("scheduled_messages_sender_idx").on(table.senderId)
    ]);
    pinnedMessages = pgTable2("pinned_messages", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      conversationId: varchar2("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }),
      messageId: varchar2("message_id").notNull().references(() => messages.id, { onDelete: "cascade" }),
      pinnedById: varchar2("pinned_by_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      pinnedAt: timestamp2("pinned_at").defaultNow().notNull()
    }, (table) => [
      unique2("pinned_messages_unique").on(table.conversationId, table.messageId),
      index2("pinned_messages_conv_idx").on(table.conversationId)
    ]);
    chatFolders = pgTable2("chat_folders", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      name: varchar2("name", { length: 50 }).notNull(),
      iconName: varchar2("icon_name", { length: 50 }),
      sortOrder: integer2("sort_order").default(0).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("chat_folders_user_idx").on(table.userId)
    ]);
    chatFolderConversations = pgTable2("chat_folder_conversations", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      folderId: varchar2("folder_id").notNull().references(() => chatFolders.id, { onDelete: "cascade" }),
      conversationId: varchar2("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      unique2("chat_folder_conversations_unique").on(table.folderId, table.conversationId),
      index2("chat_folder_conversations_folder_idx").on(table.folderId)
    ]);
    usageStats = pgTable2("usage_stats", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      date: timestamp2("date").notNull(),
      screenTimeMinutes: integer2("screen_time_minutes").default(0).notNull(),
      sessionsCount: integer2("sessions_count").default(0).notNull(),
      postsViewed: integer2("posts_viewed").default(0).notNull(),
      storiesViewed: integer2("stories_viewed").default(0).notNull(),
      messagesSent: integer2("messages_sent").default(0).notNull(),
      notificationsReceived: integer2("notifications_received").default(0).notNull()
    }, (table) => [
      unique2("usage_stats_user_date").on(table.userId, table.date),
      index2("usage_stats_user_idx").on(table.userId),
      index2("usage_stats_date_idx").on(table.date)
    ]);
    focusModeSettings = pgTable2("focus_mode_settings", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      isEnabled: boolean2("is_enabled").default(false).notNull(),
      dailyLimitMinutes: integer2("daily_limit_minutes"),
      breakReminderMinutes: integer2("break_reminder_minutes"),
      quietHoursStart: varchar2("quiet_hours_start", { length: 5 }),
      quietHoursEnd: varchar2("quiet_hours_end", { length: 5 }),
      hideNotificationCounts: boolean2("hide_notification_counts").default(false).notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    notificationPreferences = pgTable2("notification_preferences", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      digestMode: boolean2("digest_mode").default(false).notNull(),
      digestFrequency: varchar2("digest_frequency", { length: 20 }).default("DAILY"),
      prioritizeCloseFriends: boolean2("prioritize_close_friends").default(true).notNull(),
      muteLowEngagement: boolean2("mute_low_engagement").default(false).notNull(),
      smartBundling: boolean2("smart_bundling").default(true).notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    securityCheckups = pgTable2("security_checkups", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      checkupDate: timestamp2("checkup_date").defaultNow().notNull(),
      passwordStrength: varchar2("password_strength", { length: 20 }),
      twoFactorEnabled: boolean2("two_factor_enabled").default(false).notNull(),
      recoveryEmailSet: boolean2("recovery_email_set").default(false).notNull(),
      loginAlertsEnabled: boolean2("login_alerts_enabled").default(false).notNull(),
      suspiciousActivityFound: boolean2("suspicious_activity_found").default(false).notNull(),
      recommendations: jsonb2("recommendations").default([])
    }, (table) => [
      index2("security_checkups_user_idx").on(table.userId),
      index2("security_checkups_date_idx").on(table.checkupDate)
    ]);
    accountBackups = pgTable2("account_backups", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      backupType: varchar2("backup_type", { length: 50 }).notNull(),
      downloadUrl: text2("download_url"),
      fileSize: bigint2("file_size", { mode: "number" }),
      status: varchar2("status", { length: 20 }).default("PENDING").notNull(),
      expiresAt: timestamp2("expires_at"),
      completedAt: timestamp2("completed_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("account_backups_user_idx").on(table.userId),
      index2("account_backups_status_idx").on(table.status)
    ]);
    aiAvatars = pgTable2("ai_avatars", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      name: varchar2("name", { length: 100 }),
      sourceImageUrl: text2("source_image_url"),
      avatarUrl: text2("avatar_url").notNull(),
      style: varchar2("style", { length: 50 }),
      isActive: boolean2("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("ai_avatars_user_idx").on(table.userId)
    ]);
    aiTranslations = pgTable2("ai_translations", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      sourceText: text2("source_text").notNull(),
      sourceLanguage: varchar2("source_language", { length: 10 }),
      targetLanguage: varchar2("target_language", { length: 10 }).notNull(),
      translatedText: text2("translated_text").notNull(),
      contentType: varchar2("content_type", { length: 50 }),
      contentId: varchar2("content_id"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("ai_translations_content_idx").on(table.contentType, table.contentId)
    ]);
    platformImportStatusEnum = pgEnum2("platform_import_status", ["PENDING", "PROCESSING", "COMPLETED", "FAILED"]);
    platformImports = pgTable2("platform_imports", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar2("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      platform: varchar2("platform", { length: 50 }).notNull(),
      status: platformImportStatusEnum("status").default("PENDING").notNull(),
      importedFollowers: integer2("imported_followers").default(0),
      importedPosts: integer2("imported_posts").default(0),
      errorMessage: text2("error_message"),
      completedAt: timestamp2("completed_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("platform_imports_user_idx").on(table.userId),
      index2("platform_imports_status_idx").on(table.status)
    ]);
    exploreCategories = pgTable2("explore_categories", {
      id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: varchar2("name", { length: 100 }).notNull(),
      slug: varchar2("slug", { length: 100 }).notNull().unique(),
      description: text2("description"),
      iconName: varchar2("icon_name", { length: 50 }),
      coverUrl: text2("cover_url"),
      sortOrder: integer2("sort_order").default(0).notNull(),
      isActive: boolean2("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index2("explore_categories_slug_idx").on(table.slug),
      index2("explore_categories_active_idx").on(table.isActive)
    ]);
  }
});

// server/db.ts
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
import bcrypt from "bcrypt";
import { eq } from "drizzle-orm";
async function runStartupMigrations() {
  const client2 = await pool.connect();
  try {
    console.log("[DB] Running startup migrations...");
    const migrations = [
      `DO $$ BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.columns 
          WHERE table_name = 'users' AND column_name = 'net_worth' AND data_type = 'integer') THEN
          ALTER TABLE users ALTER COLUMN net_worth TYPE bigint;
          RAISE NOTICE 'Altered users.net_worth to bigint';
        END IF;
      END $$;`,
      `DO $$ BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.columns 
          WHERE table_name = 'mall_purchases' AND column_name = 'net_worth_gained' AND data_type = 'integer') THEN
          ALTER TABLE mall_purchases ALTER COLUMN net_worth_gained TYPE bigint;
          RAISE NOTICE 'Altered mall_purchases.net_worth_gained to bigint';
        END IF;
      END $$;`,
      `DO $$ BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.columns 
          WHERE table_name = 'net_worth_ledger' AND column_name = 'delta' AND data_type = 'integer') THEN
          ALTER TABLE net_worth_ledger ALTER COLUMN delta TYPE bigint;
          RAISE NOTICE 'Altered net_worth_ledger.delta to bigint';
        END IF;
      END $$;`
    ];
    for (const migration of migrations) {
      await client2.query(migration);
    }
    console.log("[DB] Startup migrations completed");
  } catch (error) {
    console.error("[DB] Startup migration error:", error);
  } finally {
    client2.release();
  }
  await seedAdminUser();
  await seedEconomyConfig();
}
async function seedAdminUser() {
  try {
    const adminEmail = "admin@rabitchat.com";
    const adminPassword = "AdminPass123!";
    const existingAdmin = await db.select().from(users).where(eq(users.email, adminEmail)).limit(1);
    if (existingAdmin.length === 0) {
      console.log("[DB] Creating admin user...");
      const hashedPassword = await bcrypt.hash(adminPassword, 10);
      await db.insert(users).values({
        id: crypto.randomUUID(),
        email: adminEmail,
        username: "admin",
        displayName: "Administrator",
        password: hashedPassword,
        isAdmin: true,
        isVerified: true,
        verifiedAt: /* @__PURE__ */ new Date(),
        bio: "RabitChat Administrator",
        influenceScore: 100,
        netWorth: 0
      });
      console.log("[DB] Admin user created: " + adminEmail);
    } else {
      console.log("[DB] Admin user already exists");
    }
  } catch (error) {
    console.error("[DB] Admin seed error:", error);
  }
}
async function seedEconomyConfig() {
  try {
    const defaultConfigs = [
      { key: "withdrawals_enabled", value: "true" },
      { key: "purchases_enabled", value: "true" },
      { key: "gifts_enabled", value: "true" },
      { key: "staking_enabled", value: "true" },
      { key: "battles_enabled", value: "true" },
      { key: "daily_rewards_enabled", value: "true" },
      { key: "coin_to_rand_rate", value: "0.10" },
      { key: "platform_fee_percent", value: "50" },
      { key: "min_withdrawal_amount", value: "1000" },
      { key: "battle_fee_percent", value: "20" }
    ];
    for (const config of defaultConfigs) {
      const existing = await db.select().from(economyConfig).where(eq(economyConfig.key, config.key)).limit(1);
      if (existing.length === 0) {
        await db.insert(economyConfig).values({
          key: config.key,
          value: config.value
        });
      }
    }
    console.log("[DB] Economy config seeded");
    const customBundleId = "custom-purchase-bundle";
    const existingBundle = await db.select().from(coinBundles).where(eq(coinBundles.id, customBundleId)).limit(1);
    if (existingBundle.length === 0) {
      await db.insert(coinBundles).values({
        id: customBundleId,
        name: "Custom Purchase",
        description: "Custom coin amount purchase",
        coinAmount: 0,
        bonusCoins: 0,
        priceRands: 0,
        isActive: false,
        isFeatured: false,
        sortOrder: 999
      });
      console.log("[DB] Custom purchase bundle created");
    }
  } catch (error) {
    console.error("[DB] Economy config seed error:", error);
  }
}
var Pool, pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    ({ Pool } = pg);
    if (!process.env.DATABASE_URL) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    pool = new Pool({ connectionString: process.env.DATABASE_URL });
    db = drizzle(pool, { schema: schema_exports });
  }
});

// server/algorithm/diversity.ts
function applyDiversity(items, config = {}) {
  const cfg = { ...DEFAULT_DIVERSITY_CONFIG, ...config };
  if (items.length === 0) return [];
  const creatorCounts = /* @__PURE__ */ new Map();
  const lastPosition = /* @__PURE__ */ new Map();
  const result = [];
  const deferred = [];
  for (const item of items) {
    const count5 = creatorCounts.get(item.authorId) || 0;
    if (count5 >= cfg.maxPerCreator) {
      continue;
    }
    const lastPos = lastPosition.get(item.authorId);
    const currentPos = result.length;
    if (lastPos !== void 0 && currentPos - lastPos < cfg.minSpacing) {
      deferred.push(item);
      continue;
    }
    result.push(item);
    creatorCounts.set(item.authorId, count5 + 1);
    lastPosition.set(item.authorId, currentPos);
  }
  for (const item of deferred) {
    const count5 = creatorCounts.get(item.authorId) || 0;
    if (count5 >= cfg.maxPerCreator) continue;
    const lastPos = lastPosition.get(item.authorId) || -cfg.minSpacing;
    const validPos = lastPos + cfg.minSpacing;
    if (validPos < result.length) {
      result.splice(validPos, 0, item);
      creatorCounts.set(item.authorId, count5 + 1);
      lastPosition.set(item.authorId, validPos);
      for (const [creator, pos] of lastPosition) {
        if (pos >= validPos && creator !== item.authorId) {
          lastPosition.set(creator, pos + 1);
        }
      }
    } else if (result.length - (lastPos + 1) >= cfg.minSpacing) {
      result.push(item);
      creatorCounts.set(item.authorId, count5 + 1);
      lastPosition.set(item.authorId, result.length - 1);
    }
  }
  return result;
}
function applyDiversityWithScores(items, config = {}) {
  const cfg = { ...DEFAULT_DIVERSITY_CONFIG, ...config };
  if (items.length === 0) return [];
  const sorted = [...items].sort((a, b) => (b.score || 0) - (a.score || 0));
  const creatorSeen = /* @__PURE__ */ new Map();
  const adjusted = sorted.map((item) => {
    const seen = creatorSeen.get(item.authorId) || 0;
    const penalty = Math.pow(cfg.recentCreatorPenalty, seen);
    const adjustedScore = (item.score || 1) * (seen === 0 ? 1 : penalty);
    creatorSeen.set(item.authorId, seen + 1);
    return { ...item, adjustedScore };
  });
  adjusted.sort((a, b) => b.adjustedScore - a.adjustedScore);
  return applyDiversity(adjusted, cfg);
}
function interleaveByCreator(items, maxPerCreator = 2) {
  if (items.length === 0) return [];
  const byCreator = /* @__PURE__ */ new Map();
  for (const item of items) {
    const list = byCreator.get(item.authorId) || [];
    list.push(item);
    byCreator.set(item.authorId, list);
  }
  const creators = [...byCreator.entries()].map(([id, items2]) => ({
    id,
    items: items2.slice(0, maxPerCreator),
    bestScore: Math.max(...items2.map((i) => i.score || 0))
  })).sort((a, b) => b.bestScore - a.bestScore);
  const result = [];
  let round = 0;
  let hasMore = true;
  while (hasMore) {
    hasMore = false;
    for (const creator of creators) {
      if (round < creator.items.length) {
        result.push(creator.items[round]);
        hasMore = true;
      }
    }
    round++;
  }
  return result;
}
function shuffleWithinTiers(items, tierSize = 5) {
  if (items.length === 0) return [];
  const sorted = [...items].sort((a, b) => (b.score || 0) - (a.score || 0));
  const result = [];
  for (let i = 0; i < sorted.length; i += tierSize) {
    const tier = sorted.slice(i, i + tierSize);
    for (let j = tier.length - 1; j > 0; j--) {
      const k = Math.floor(Math.random() * (j + 1));
      [tier[j], tier[k]] = [tier[k], tier[j]];
    }
    result.push(...tier);
  }
  return result;
}
function diversifyFeed(items, options = {}) {
  const {
    minSpacing = 4,
    maxPerCreator = 3,
    useScoreWeighting = true,
    shuffleTiers = false
  } = options;
  let result;
  if (useScoreWeighting) {
    result = applyDiversityWithScores(items, { minSpacing, maxPerCreator });
  } else {
    result = interleaveByCreator(items, maxPerCreator);
  }
  if (shuffleTiers) {
    result = shuffleWithinTiers(result);
  }
  return result;
}
var DEFAULT_DIVERSITY_CONFIG;
var init_diversity = __esm({
  "server/algorithm/diversity.ts"() {
    "use strict";
    DEFAULT_DIVERSITY_CONFIG = {
      minSpacing: 4,
      // At least 4 posts between same creator
      maxPerCreator: 3,
      // Max 3 posts from same creator in a batch
      recentCreatorPenalty: 0.3,
      // 70% penalty for recently seen
      shuffleWithinTiers: true
    };
  }
});

// server/storage.ts
var storage_exports = {};
__export(storage_exports, {
  DatabaseStorage: () => DatabaseStorage,
  storage: () => storage
});
import { eq as eq2, desc, or, and, ilike, sql as sql3, inArray, isNull, isNotNull, gt, lt, gte, lte, ne } from "drizzle-orm";
var DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema();
    init_db();
    init_diversity();
    DatabaseStorage = class {
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq2(users.id, id));
        return user || void 0;
      }
      async getUserByUsername(username) {
        const [user] = await db.select().from(users).where(ilike(users.username, username));
        return user || void 0;
      }
      async getUserByEmail(email) {
        const [user] = await db.select().from(users).where(ilike(users.email, email));
        return user || void 0;
      }
      async getUserByPhoneNumber(phoneNumber) {
        const [user] = await db.select().from(users).where(eq2(users.phoneNumber, phoneNumber));
        return user || void 0;
      }
      async createUser(insertUser) {
        const [user] = await db.insert(users).values(insertUser).returning();
        return user;
      }
      async updateUser(id, data) {
        const [user] = await db.update(users).set(data).where(eq2(users.id, id)).returning();
        return user || void 0;
      }
      async searchUsers(query) {
        return db.select().from(users).where(
          or(
            ilike(users.username, `%${query}%`),
            ilike(users.displayName, `%${query}%`)
          )
        ).limit(20);
      }
      async deleteUser(id) {
        await db.transaction(async (tx) => {
          await tx.delete(messages).where(
            or(eq2(messages.senderId, id), eq2(messages.receiverId, id))
          );
          await tx.delete(conversations).where(
            or(eq2(conversations.participant1Id, id), eq2(conversations.participant2Id, id))
          );
          const userPosts = await tx.select({ id: posts.id }).from(posts).where(eq2(posts.authorId, id));
          const userPostIds = userPosts.map((p) => p.id);
          if (userPostIds.length > 0) {
            await tx.delete(likes).where(inArray(likes.postId, userPostIds));
            await tx.delete(comments).where(inArray(comments.postId, userPostIds));
          }
          await tx.delete(likes).where(eq2(likes.userId, id));
          await tx.delete(comments).where(eq2(comments.authorId, id));
          await tx.delete(follows).where(
            or(eq2(follows.followerId, id), eq2(follows.followingId, id))
          );
          await tx.delete(posts).where(eq2(posts.authorId, id));
          await tx.delete(users).where(eq2(users.id, id));
        });
      }
      async createPost(data) {
        const [post] = await db.insert(posts).values({
          authorId: data.authorId,
          type: data.type || "TEXT",
          content: data.content,
          caption: data.caption,
          mediaUrl: data.mediaUrl,
          thumbnailUrl: data.thumbnailUrl,
          durationMs: data.durationMs,
          aspectRatio: data.aspectRatio,
          visibility: data.visibility || "PUBLIC",
          commentsEnabled: data.commentsEnabled ?? true
        }).returning();
        await db.update(users).set({
          influenceScore: sql3`${users.influenceScore} + 10`
        }).where(eq2(users.id, data.authorId));
        return post;
      }
      async getPost(id) {
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(eq2(posts.id, id));
        if (result.length === 0) return void 0;
        return { ...result[0].posts, author: result[0].users };
      }
      async getPosts(limit = 50, offset = 0) {
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).orderBy(desc(posts.createdAt)).limit(limit).offset(offset);
        return result.map((r) => ({ ...r.posts, author: r.users }));
      }
      async getFeedPosts(userId, limit = 20, cursor) {
        const followingIds = await db.select({ id: follows.followingId }).from(follows).where(eq2(follows.followerId, userId));
        const ids = [userId, ...followingIds.map((f) => f.id)];
        let query = db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(inArray(posts.authorId, ids)).orderBy(desc(posts.createdAt)).limit(limit + 1);
        if (cursor) {
          const cursorPost = await db.select().from(posts).where(eq2(posts.id, cursor)).limit(1);
          if (cursorPost.length > 0) {
            query = db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(and(
              inArray(posts.authorId, ids),
              lt(posts.createdAt, cursorPost[0].createdAt)
            )).orderBy(desc(posts.createdAt)).limit(limit + 1);
          }
        }
        const result = await query;
        const postsResult = result.map((r) => ({ ...r.posts, author: r.users }));
        const hasMore = postsResult.length > limit;
        const paginatedPosts = hasMore ? postsResult.slice(0, limit) : postsResult;
        const nextCursor = hasMore ? paginatedPosts[paginatedPosts.length - 1].id : null;
        return { posts: paginatedPosts, nextCursor };
      }
      async getTrendingPreviewPosts(limit = 5) {
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(and(
          eq2(posts.isHidden, false),
          isNull(posts.deletedAt),
          or(
            eq2(posts.visibility, "PUBLIC"),
            isNull(posts.visibility)
          )
        )).orderBy(
          desc(posts.likesCount),
          desc(posts.commentsCount),
          desc(posts.createdAt)
        ).limit(limit);
        return result.map((r) => ({ ...r.posts, author: r.users }));
      }
      async getUserPosts(userId) {
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(eq2(posts.authorId, userId)).orderBy(desc(posts.createdAt));
        return result.map((r) => ({ ...r.posts, author: r.users }));
      }
      async deletePost(id) {
        await db.transaction(async (tx) => {
          await tx.delete(likes).where(eq2(likes.postId, id));
          await tx.delete(comments).where(eq2(comments.postId, id));
          await tx.delete(bookmarks).where(eq2(bookmarks.postId, id));
          await tx.delete(shares).where(eq2(shares.postId, id));
          await tx.delete(postViews).where(eq2(postViews.postId, id));
          await tx.delete(playlistItems).where(eq2(playlistItems.postId, id));
          await tx.delete(pins).where(eq2(pins.postId, id));
          await tx.delete(postCollaborators).where(eq2(postCollaborators.postId, id));
          await tx.delete(pendingTagApprovals).where(eq2(pendingTagApprovals.postId, id));
          await tx.delete(savedPosts).where(eq2(savedPosts.postId, id));
          await tx.delete(hiddenPosts).where(eq2(hiddenPosts.postId, id));
          await tx.delete(notInterestedPosts).where(eq2(notInterestedPosts.postId, id));
          await tx.delete(posts).where(eq2(posts.id, id));
        });
      }
      async searchPosts(query) {
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(ilike(posts.content, `%${query}%`)).orderBy(desc(posts.createdAt)).limit(20);
        return result.map((r) => ({ ...r.posts, author: r.users }));
      }
      async createComment(postId, authorId, content) {
        return await db.transaction(async (tx) => {
          const [comment] = await tx.insert(comments).values({ postId, authorId, content }).returning();
          await tx.update(posts).set({
            commentsCount: sql3`${posts.commentsCount} + 1`
          }).where(eq2(posts.id, postId));
          return comment;
        });
      }
      async getPostComments(postId) {
        const result = await db.select().from(comments).innerJoin(users, eq2(comments.authorId, users.id)).where(eq2(comments.postId, postId)).orderBy(desc(comments.createdAt));
        return result.map((r) => ({ ...r.comments, author: r.users }));
      }
      async deleteComment(id) {
        const [comment] = await db.select().from(comments).where(eq2(comments.id, id));
        if (comment) {
          await db.transaction(async (tx) => {
            await tx.delete(comments).where(eq2(comments.id, id));
            await tx.update(posts).set({
              commentsCount: sql3`${posts.commentsCount} - 1`
            }).where(eq2(posts.id, comment.postId));
          });
        }
      }
      async likePost(postId, userId) {
        const existing = await db.select().from(likes).where(and(eq2(likes.postId, postId), eq2(likes.userId, userId)));
        if (existing.length > 0) return existing[0];
        return await db.transaction(async (tx) => {
          const [like3] = await tx.insert(likes).values({ postId, userId }).returning();
          await tx.update(posts).set({
            likesCount: sql3`${posts.likesCount} + 1`
          }).where(eq2(posts.id, postId));
          const [post] = await tx.select().from(posts).where(eq2(posts.id, postId));
          if (post) {
            await tx.update(users).set({
              influenceScore: sql3`${users.influenceScore} + 1`
            }).where(eq2(users.id, post.authorId));
          }
          return like3;
        });
      }
      async unlikePost(postId, userId) {
        const [existing] = await db.select().from(likes).where(and(eq2(likes.postId, postId), eq2(likes.userId, userId)));
        if (!existing) return;
        await db.transaction(async (tx) => {
          await tx.delete(likes).where(eq2(likes.id, existing.id));
          await tx.update(posts).set({
            likesCount: sql3`${posts.likesCount} - 1`
          }).where(eq2(posts.id, postId));
        });
      }
      async hasUserLikedPost(postId, userId) {
        const result = await db.select().from(likes).where(and(eq2(likes.postId, postId), eq2(likes.userId, userId)));
        return result.length > 0;
      }
      // Bookmark methods
      async savePost(userId, postId) {
        const existing = await db.select().from(bookmarks).where(and(eq2(bookmarks.postId, postId), eq2(bookmarks.userId, userId)));
        if (existing.length > 0) return existing[0];
        return await db.transaction(async (tx) => {
          const [bookmark] = await tx.insert(bookmarks).values({ postId, userId }).returning();
          await tx.update(posts).set({
            savesCount: sql3`${posts.savesCount} + 1`
          }).where(eq2(posts.id, postId));
          return bookmark;
        });
      }
      async unsavePost(userId, postId) {
        const [existing] = await db.select().from(bookmarks).where(and(eq2(bookmarks.postId, postId), eq2(bookmarks.userId, userId)));
        if (!existing) return;
        await db.transaction(async (tx) => {
          await tx.delete(bookmarks).where(eq2(bookmarks.id, existing.id));
          await tx.update(posts).set({
            savesCount: sql3`${posts.savesCount} - 1`
          }).where(eq2(posts.id, postId));
        });
      }
      async hasUserSavedPost(postId, userId) {
        const result = await db.select().from(bookmarks).where(and(eq2(bookmarks.postId, postId), eq2(bookmarks.userId, userId)));
        return result.length > 0;
      }
      async getUserBookmarks(userId) {
        const result = await db.select().from(bookmarks).innerJoin(posts, eq2(bookmarks.postId, posts.id)).innerJoin(users, eq2(posts.authorId, users.id)).where(eq2(bookmarks.userId, userId)).orderBy(desc(bookmarks.createdAt));
        return result.map((r) => ({ ...r.posts, author: r.users }));
      }
      // Share methods
      async sharePost(userId, postId, platform) {
        return await db.transaction(async (tx) => {
          const [share] = await tx.insert(shares).values({ postId, userId, platform }).returning();
          await tx.update(posts).set({
            sharesCount: sql3`${posts.sharesCount} + 1`
          }).where(eq2(posts.id, postId));
          return share;
        });
      }
      // View methods
      async viewPost(userId, postId) {
        const existing = await db.select().from(postViews).where(and(eq2(postViews.postId, postId), eq2(postViews.userId, userId)));
        if (existing.length > 0) {
          return { isNew: false };
        }
        await db.transaction(async (tx) => {
          await tx.insert(postViews).values({ postId, userId }).onConflictDoNothing();
          await tx.update(posts).set({
            viewsCount: sql3`${posts.viewsCount} + 1`
          }).where(eq2(posts.id, postId));
        });
        return { isNew: true };
      }
      async hasUserViewedPost(postId, userId) {
        const result = await db.select().from(postViews).where(and(eq2(postViews.postId, postId), eq2(postViews.userId, userId)));
        return result.length > 0;
      }
      async followUser(followerId, followingId) {
        const existing = await db.select().from(follows).where(and(eq2(follows.followerId, followerId), eq2(follows.followingId, followingId)));
        if (existing.length > 0) return existing[0];
        const [follow] = await db.insert(follows).values({ followerId, followingId }).returning();
        await db.update(users).set({
          influenceScore: sql3`${users.influenceScore} + 5`
        }).where(eq2(users.id, followingId));
        return follow;
      }
      async unfollowUser(followerId, followingId) {
        await db.delete(follows).where(
          and(eq2(follows.followerId, followerId), eq2(follows.followingId, followingId))
        );
      }
      async isFollowing(followerId, followingId) {
        const result = await db.select().from(follows).where(and(eq2(follows.followerId, followerId), eq2(follows.followingId, followingId)));
        return result.length > 0;
      }
      async getFollowers(userId) {
        const result = await db.select().from(follows).innerJoin(users, eq2(follows.followerId, users.id)).where(eq2(follows.followingId, userId));
        return result.map((r) => r.users);
      }
      async getFollowing(userId) {
        const result = await db.select().from(follows).innerJoin(users, eq2(follows.followingId, users.id)).where(eq2(follows.followerId, userId));
        return result.map((r) => r.users);
      }
      async getFollowersCount(userId) {
        const result = await db.select({ count: sql3`count(*)` }).from(follows).where(eq2(follows.followingId, userId));
        return Number(result[0]?.count || 0);
      }
      async getFollowingCount(userId) {
        const result = await db.select({ count: sql3`count(*)` }).from(follows).where(eq2(follows.followerId, userId));
        return Number(result[0]?.count || 0);
      }
      async getOrCreateConversation(userId1, userId2, senderId) {
        const [p1, p2] = userId1 < userId2 ? [userId1, userId2] : [userId2, userId1];
        const existing = await db.select().from(conversations).where(
          and(eq2(conversations.participant1Id, p1), eq2(conversations.participant2Id, p2))
        );
        if (existing.length > 0) return existing[0];
        const recipientId = senderId === userId1 ? userId2 : userId1;
        const recipientFollowsSender = senderId ? await this.isFollowing(recipientId, senderId) : true;
        const conversationStatus = recipientFollowsSender ? "ACCEPTED" : "REQUEST";
        const requestedByUserId = recipientFollowsSender ? null : senderId;
        const [conversation] = await db.insert(conversations).values({
          participant1Id: p1,
          participant2Id: p2,
          status: conversationStatus,
          requestedByUserId,
          inboxFolder: "PRIMARY"
        }).returning();
        return conversation;
      }
      async getConversation(conversationId) {
        const [conversation] = await db.select().from(conversations).where(eq2(conversations.id, conversationId));
        return conversation || void 0;
      }
      async isConversationParticipant(conversationId, userId) {
        const [conversation] = await db.select().from(conversations).where(
          and(
            eq2(conversations.id, conversationId),
            or(
              eq2(conversations.participant1Id, userId),
              eq2(conversations.participant2Id, userId)
            )
          )
        );
        return !!conversation;
      }
      async getUserConversations(userId) {
        const result = await db.select().from(conversations).where(or(
          eq2(conversations.participant1Id, userId),
          eq2(conversations.participant2Id, userId)
        )).orderBy(desc(conversations.lastMessageAt));
        const conversationsWithParticipants = [];
        for (const conv of result) {
          const [p1] = await db.select().from(users).where(eq2(users.id, conv.participant1Id));
          const [p2] = await db.select().from(users).where(eq2(users.id, conv.participant2Id));
          const [lastMessage] = await db.select().from(messages).where(eq2(messages.conversationId, conv.id)).orderBy(desc(messages.createdAt)).limit(1);
          conversationsWithParticipants.push({
            ...conv,
            participant1: p1,
            participant2: p2,
            lastMessage
          });
        }
        return conversationsWithParticipants;
      }
      async createMessage(conversationId, senderId, receiverId, content) {
        const [message] = await db.insert(messages).values({ conversationId, senderId, receiverId, content }).returning();
        await db.update(conversations).set({ lastMessageAt: /* @__PURE__ */ new Date() }).where(eq2(conversations.id, conversationId));
        return message;
      }
      async createMessageWithMedia(conversationId, senderId, receiverId, content, messageType, mediaUrl, replyToId) {
        const [message] = await db.insert(messages).values({
          conversationId,
          senderId,
          receiverId,
          content,
          messageType,
          mediaUrl,
          replyToId
        }).returning();
        await db.update(conversations).set({ lastMessageAt: /* @__PURE__ */ new Date() }).where(eq2(conversations.id, conversationId));
        return message;
      }
      async getMessage(messageId) {
        const [message] = await db.select().from(messages).where(eq2(messages.id, messageId));
        return message || void 0;
      }
      async deleteMessage(messageId) {
        await db.update(messages).set({ deletedAt: /* @__PURE__ */ new Date() }).where(eq2(messages.id, messageId));
      }
      async addMessageReaction(messageId, userId, emoji) {
        const existing = await db.select().from(messageReactions).where(and(
          eq2(messageReactions.messageId, messageId),
          eq2(messageReactions.userId, userId),
          eq2(messageReactions.reaction, emoji)
        ));
        if (existing.length > 0) {
          return existing[0];
        }
        const [reactionRow] = await db.insert(messageReactions).values({ messageId, userId, reaction: emoji }).returning();
        return reactionRow;
      }
      async removeMessageReaction(messageId, userId, emoji) {
        await db.delete(messageReactions).where(and(
          eq2(messageReactions.messageId, messageId),
          eq2(messageReactions.userId, userId),
          eq2(messageReactions.reaction, emoji)
        ));
      }
      async updateUserOnlineStatus(userId, isOnline) {
        const existing = await db.select().from(userOnlineStatus).where(eq2(userOnlineStatus.userId, userId));
        if (existing.length > 0) {
          await db.update(userOnlineStatus).set({
            isOnline,
            lastSeenAt: /* @__PURE__ */ new Date()
          }).where(eq2(userOnlineStatus.userId, userId));
        } else {
          await db.insert(userOnlineStatus).values({ userId, isOnline, lastSeenAt: /* @__PURE__ */ new Date() });
        }
      }
      async getUserOnlineStatus(userId) {
        const [status] = await db.select().from(userOnlineStatus).where(eq2(userOnlineStatus.userId, userId));
        return status || { userId, isOnline: false, lastSeenAt: null };
      }
      async getConversationMessages(conversationId, limit = 100) {
        const result = await db.select().from(messages).innerJoin(users, eq2(messages.senderId, users.id)).where(eq2(messages.conversationId, conversationId)).orderBy(desc(messages.createdAt)).limit(limit);
        return result.map((r) => ({ ...r.messages, sender: r.users }));
      }
      async markMessagesAsRead(conversationId, userId) {
        await db.update(messages).set({ read: true }).where(and(
          eq2(messages.conversationId, conversationId),
          eq2(messages.receiverId, userId),
          eq2(messages.read, false)
        ));
      }
      async createNotification(userId, actorId, type, entityId) {
        if (userId === actorId) {
          return { id: "", userId, actorId, type, entityId: entityId || null, readAt: null, createdAt: /* @__PURE__ */ new Date() };
        }
        const [notification] = await db.insert(notifications).values({ userId, actorId, type, entityId }).returning();
        return notification;
      }
      async getUserNotifications(userId, limit = 50) {
        const result = await db.select().from(notifications).innerJoin(users, eq2(notifications.actorId, users.id)).where(eq2(notifications.userId, userId)).orderBy(desc(notifications.createdAt)).limit(limit);
        return result.map((r) => ({ ...r.notifications, actor: r.users }));
      }
      async markNotificationRead(notificationId, userId) {
        const [notification] = await db.update(notifications).set({ readAt: /* @__PURE__ */ new Date() }).where(and(
          eq2(notifications.id, notificationId),
          eq2(notifications.userId, userId)
        )).returning();
        return notification || void 0;
      }
      async markAllNotificationsRead(userId) {
        await db.update(notifications).set({ readAt: /* @__PURE__ */ new Date() }).where(and(
          eq2(notifications.userId, userId),
          isNull(notifications.readAt)
        ));
      }
      async getUnreadNotificationCount(userId) {
        const result = await db.select({ count: sql3`count(*)::int` }).from(notifications).where(and(
          eq2(notifications.userId, userId),
          isNull(notifications.readAt)
        ));
        return result[0]?.count || 0;
      }
      // Blocking methods
      async blockUser(blockerId, blockedId) {
        const [block] = await db.insert(blocks).values({ blockerId, blockedId }).onConflictDoNothing().returning();
        if (!block) {
          const [existing] = await db.select().from(blocks).where(and(eq2(blocks.blockerId, blockerId), eq2(blocks.blockedId, blockedId)));
          return existing;
        }
        await db.delete(follows).where(
          or(
            and(eq2(follows.followerId, blockerId), eq2(follows.followingId, blockedId)),
            and(eq2(follows.followerId, blockedId), eq2(follows.followingId, blockerId))
          )
        );
        return block;
      }
      async unblockUser(blockerId, blockedId) {
        await db.delete(blocks).where(
          and(eq2(blocks.blockerId, blockerId), eq2(blocks.blockedId, blockedId))
        );
      }
      async isBlocked(blockerId, blockedId) {
        const [block] = await db.select().from(blocks).where(and(eq2(blocks.blockerId, blockerId), eq2(blocks.blockedId, blockedId)));
        return !!block;
      }
      async isBlockedEither(userId1, userId2) {
        const [block] = await db.select().from(blocks).where(or(
          and(eq2(blocks.blockerId, userId1), eq2(blocks.blockedId, userId2)),
          and(eq2(blocks.blockerId, userId2), eq2(blocks.blockedId, userId1))
        ));
        return !!block;
      }
      async getBlockedUsers(userId) {
        const result = await db.select().from(blocks).innerJoin(users, eq2(blocks.blockedId, users.id)).where(eq2(blocks.blockerId, userId));
        return result.map((r) => r.users);
      }
      // Get all user IDs that should be hidden from a user (both blocking and blocked by)
      async getHiddenUserIds(userId) {
        const blocked = await db.select({ id: blocks.blockedId }).from(blocks).where(eq2(blocks.blockerId, userId));
        const blockedBy = await db.select({ id: blocks.blockerId }).from(blocks).where(eq2(blocks.blockedId, userId));
        const blockedIds = blocked.map((b) => b.id);
        const blockedByIds = blockedBy.map((b) => b.id);
        return [.../* @__PURE__ */ new Set([...blockedIds, ...blockedByIds])];
      }
      // Reporting methods
      async createReport(reporterId, reason, reportedUserId, reportedPostId) {
        const [report] = await db.insert(reports).values({ reporterId, reason, reportedUserId, reportedPostId }).returning();
        return report;
      }
      async getReports(status) {
        if (status) {
          return db.select().from(reports).where(eq2(reports.status, status)).orderBy(desc(reports.createdAt));
        }
        return db.select().from(reports).orderBy(desc(reports.createdAt));
      }
      async getReportsWithFilters(filters) {
        const conditions = [];
        if (filters.status) {
          conditions.push(eq2(reports.status, filters.status));
        }
        if (filters.type === "user") {
          conditions.push(isNotNull(reports.reportedUserId));
        } else if (filters.type === "post") {
          conditions.push(isNotNull(reports.reportedPostId));
        }
        if (filters.reporterId) {
          conditions.push(eq2(reports.reporterId, filters.reporterId));
        }
        if (filters.dateFrom) {
          conditions.push(gte(reports.createdAt, filters.dateFrom));
        }
        if (filters.dateTo) {
          conditions.push(lte(reports.createdAt, filters.dateTo));
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const result = await db.select().from(reports).innerJoin(users, eq2(reports.reporterId, users.id)).leftJoin(posts, eq2(reports.reportedPostId, posts.id)).where(whereClause).orderBy(desc(reports.createdAt)).limit(100);
        const reportsWithDetails = await Promise.all(
          result.map(async (r) => {
            let reportedUser;
            if (r.reports.reportedUserId) {
              reportedUser = await this.getUser(r.reports.reportedUserId);
            }
            return {
              ...r.reports,
              reporter: r.users,
              reportedUser,
              reportedPost: r.posts || void 0
            };
          })
        );
        return reportsWithDetails;
      }
      async getReportById(id) {
        const [report] = await db.select().from(reports).where(eq2(reports.id, id));
        return report || void 0;
      }
      async getReportWithDetails(id) {
        const [result] = await db.select().from(reports).innerJoin(users, eq2(reports.reporterId, users.id)).where(eq2(reports.id, id));
        if (!result) return void 0;
        let reportedUser;
        let reportedPost;
        if (result.reports.reportedUserId) {
          reportedUser = await this.getUser(result.reports.reportedUserId);
        }
        if (result.reports.reportedPostId) {
          const postResult = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(eq2(posts.id, result.reports.reportedPostId));
          if (postResult.length > 0) {
            reportedPost = { ...postResult[0].posts, author: postResult[0].users };
          }
        }
        return {
          ...result.reports,
          reporter: result.users,
          reportedUser,
          reportedPost
        };
      }
      async updateReportStatus(id, status, adminId, notes) {
        const [report] = await db.update(reports).set({
          status,
          resolvedById: adminId,
          resolvedAt: /* @__PURE__ */ new Date(),
          adminNotes: notes
        }).where(eq2(reports.id, id)).returning();
        return report || void 0;
      }
      // Admin methods
      async getAdminStats() {
        const [usersCount] = await db.select({ count: sql3`count(*)::int` }).from(users);
        const [postsCount] = await db.select({ count: sql3`count(*)::int` }).from(posts);
        const [commentsCount] = await db.select({ count: sql3`count(*)::int` }).from(comments);
        const [reportsCount] = await db.select({ count: sql3`count(*)::int` }).from(reports).where(eq2(reports.status, "PENDING"));
        return {
          users: usersCount?.count || 0,
          posts: postsCount?.count || 0,
          comments: commentsCount?.count || 0,
          reports: reportsCount?.count || 0
        };
      }
      async getAllUsers() {
        return db.select().from(users).orderBy(desc(users.createdAt));
      }
      async getAllPostsWithAuthors() {
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).orderBy(desc(posts.createdAt)).limit(100);
        return result.map((r) => ({ ...r.posts, author: r.users }));
      }
      async getAllCommentsWithAuthors() {
        const result = await db.select().from(comments).innerJoin(users, eq2(comments.authorId, users.id)).orderBy(desc(comments.createdAt)).limit(100);
        return result.map((r) => ({ ...r.comments, author: r.users }));
      }
      async getAllRoles() {
        return db.select().from(roles).orderBy(desc(roles.level));
      }
      async getRoleById(id) {
        const [role] = await db.select().from(roles).where(eq2(roles.id, id));
        return role || void 0;
      }
      async getRoleByName(name) {
        const [role] = await db.select().from(roles).where(eq2(roles.name, name));
        return role || void 0;
      }
      async createRole(data) {
        const [role] = await db.insert(roles).values({
          name: data.name.toUpperCase().replace(/\s+/g, "_"),
          displayName: data.displayName,
          description: data.description,
          level: data.level || 0,
          isSystem: false
        }).returning();
        return role;
      }
      async updateRole(id, data) {
        const [role] = await db.update(roles).set({
          ...data,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(roles.id, id)).returning();
        return role || void 0;
      }
      async deleteRole(id) {
        await db.delete(roles).where(eq2(roles.id, id));
      }
      async getSuperAdminCount() {
        const superAdminRole = await this.getRoleByName("SUPER_ADMIN");
        if (!superAdminRole) return 0;
        const result = await db.select({ count: sql3`count(*)::int` }).from(userRoles).where(eq2(userRoles.roleId, superAdminRole.id));
        return result[0]?.count || 0;
      }
      async getAllPermissions() {
        return db.select().from(permissions).orderBy(permissions.group, permissions.key);
      }
      async getPermissionsByGroup() {
        const allPermissions = await this.getAllPermissions();
        const grouped = {};
        for (const perm of allPermissions) {
          if (!grouped[perm.group]) {
            grouped[perm.group] = [];
          }
          grouped[perm.group].push(perm);
        }
        return grouped;
      }
      async getRolePermissions(roleId) {
        const result = await db.select().from(rolePermissions).innerJoin(permissions, eq2(rolePermissions.permissionId, permissions.id)).where(eq2(rolePermissions.roleId, roleId));
        return result.map((r) => r.permissions);
      }
      async getRoleWithPermissions(roleId) {
        const role = await this.getRoleById(roleId);
        if (!role) return void 0;
        const perms = await this.getRolePermissions(roleId);
        return { ...role, permissions: perms };
      }
      async getAllRolesWithPermissions() {
        const allRoles = await this.getAllRoles();
        const result = await Promise.all(
          allRoles.map(async (role) => {
            const perms = await this.getRolePermissions(role.id);
            return { ...role, permissions: perms };
          })
        );
        return result;
      }
      async setRolePermissions(roleId, permissionIds) {
        await db.delete(rolePermissions).where(eq2(rolePermissions.roleId, roleId));
        if (permissionIds.length > 0) {
          await db.insert(rolePermissions).values(permissionIds.map((permissionId) => ({ roleId, permissionId }))).onConflictDoNothing();
        }
      }
      async addRolePermission(roleId, permissionId) {
        await db.insert(rolePermissions).values({ roleId, permissionId }).onConflictDoNothing();
      }
      async removeRolePermission(roleId, permissionId) {
        await db.delete(rolePermissions).where(and(
          eq2(rolePermissions.roleId, roleId),
          eq2(rolePermissions.permissionId, permissionId)
        ));
      }
      async getAppSettings() {
        return db.select().from(appSettings).orderBy(appSettings.key);
      }
      async getAppSetting(key) {
        const [setting] = await db.select().from(appSettings).where(eq2(appSettings.key, key));
        return setting || void 0;
      }
      async getAppSettingValue(key, defaultValue) {
        const setting = await this.getAppSetting(key);
        if (!setting || setting.value === null) return defaultValue;
        try {
          if (setting.type === "boolean") {
            return setting.value === "true";
          } else if (setting.type === "number") {
            return Number(setting.value);
          } else if (setting.type === "json") {
            return JSON.parse(setting.value);
          }
          return setting.value;
        } catch {
          return defaultValue;
        }
      }
      async setAppSetting(key, value, type, description, updatedBy) {
        const stringValue = typeof value === "object" ? JSON.stringify(value) : String(value);
        const existing = await this.getAppSetting(key);
        if (existing) {
          const [updated] = await db.update(appSettings).set({
            value: stringValue,
            type,
            description: description || existing.description,
            updatedBy,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq2(appSettings.key, key)).returning();
          return updated;
        }
        const [created] = await db.insert(appSettings).values({
          key,
          value: stringValue,
          type,
          description,
          updatedBy
        }).returning();
        return created;
      }
      async updateAppSettings(settings, updatedBy) {
        const results = [];
        for (const setting of settings) {
          const result = await this.setAppSetting(setting.key, setting.value, setting.type, void 0, updatedBy);
          results.push(result);
        }
        return results;
      }
      async getAuditLogs(filters) {
        const conditions = [];
        if (filters?.actorId) {
          conditions.push(eq2(auditLogs.userId, filters.actorId));
        }
        if (filters?.action) {
          conditions.push(eq2(auditLogs.action, filters.action));
        }
        if (filters?.targetType) {
          conditions.push(eq2(auditLogs.targetType, filters.targetType));
        }
        if (filters?.startDate) {
          conditions.push(gte(auditLogs.createdAt, filters.startDate));
        }
        if (filters?.endDate) {
          conditions.push(lte(auditLogs.createdAt, filters.endDate));
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const limit = filters?.limit || 50;
        const offset = filters?.offset || 0;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(auditLogs).where(whereClause);
        const logs = await db.select().from(auditLogs).leftJoin(users, eq2(auditLogs.userId, users.id)).where(whereClause).orderBy(desc(auditLogs.createdAt)).limit(limit).offset(offset);
        return {
          logs: logs.map((l) => ({
            ...l.audit_logs,
            actor: l.users ? { ...l.users, password: "" } : void 0
          })),
          total: countResult?.count || 0
        };
      }
      async getAnalyticsOverview() {
        const sevenDaysAgo = /* @__PURE__ */ new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        const [totalUsersResult] = await db.select({ count: sql3`count(*)::int` }).from(users);
        const [newUsers7dResult] = await db.select({ count: sql3`count(*)::int` }).from(users).where(gte(users.createdAt, sevenDaysAgo));
        const [posts7dResult] = await db.select({ count: sql3`count(*)::int` }).from(posts).where(gte(posts.createdAt, sevenDaysAgo));
        const [openReportsResult] = await db.select({ count: sql3`count(*)::int` }).from(reports).where(eq2(reports.status, "PENDING"));
        const [messages7dResult] = await db.select({ count: sql3`count(*)::int` }).from(messages).where(gte(messages.createdAt, sevenDaysAgo));
        const [totalPostsResult] = await db.select({ count: sql3`count(*)::int` }).from(posts);
        const [totalMessagesResult] = await db.select({ count: sql3`count(*)::int` }).from(messages);
        return {
          totalUsers: totalUsersResult?.count || 0,
          newUsers7d: newUsers7dResult?.count || 0,
          posts7d: posts7dResult?.count || 0,
          openReports: openReportsResult?.count || 0,
          messages7d: messages7dResult?.count || 0,
          totalPosts: totalPostsResult?.count || 0,
          totalMessages: totalMessagesResult?.count || 0
        };
      }
      // Admin user management
      async getAdminUser(id) {
        const [user] = await db.select().from(users).where(eq2(users.id, id));
        return user || void 0;
      }
      async adminUpdateUser(id, data) {
        const [user] = await db.update(users).set(data).where(eq2(users.id, id)).returning();
        return user || void 0;
      }
      async suspendUser(userId, adminId, reason, durationDays) {
        const now = /* @__PURE__ */ new Date();
        const until = durationDays ? new Date(now.getTime() + durationDays * 24 * 60 * 60 * 1e3) : null;
        const [user] = await db.update(users).set({
          suspendedAt: now,
          suspendedUntil: until,
          suspendedReason: reason,
          suspendedById: adminId
        }).where(eq2(users.id, userId)).returning();
        return user || void 0;
      }
      async unsuspendUser(userId) {
        const [user] = await db.update(users).set({
          suspendedAt: null,
          suspendedUntil: null,
          suspendedReason: null,
          suspendedById: null
        }).where(eq2(users.id, userId)).returning();
        return user || void 0;
      }
      async getUserRoles(userId) {
        const result = await db.select().from(userRoles).innerJoin(roles, eq2(userRoles.roleId, roles.id)).where(eq2(userRoles.userId, userId));
        return result.map((r) => r.roles);
      }
      async assignRole(userId, roleId, assignedBy) {
        await db.insert(userRoles).values({ userId, roleId, assignedBy }).onConflictDoNothing();
      }
      async removeRole(userId, roleId) {
        await db.delete(userRoles).where(and(eq2(userRoles.userId, userId), eq2(userRoles.roleId, roleId)));
      }
      // Audit logging
      async createAuditLog(userIdOrOptions, action, targetType, targetId, details, ipAddress, userAgent) {
        let userId;
        let actionValue;
        let targetTypeValue;
        let targetIdValue;
        let detailsValue;
        let ipAddressValue;
        let userAgentValue;
        if (typeof userIdOrOptions === "object" && userIdOrOptions !== null && "actorId" in userIdOrOptions) {
          userId = userIdOrOptions.actorId;
          actionValue = userIdOrOptions.action;
          targetTypeValue = userIdOrOptions.targetType;
          targetIdValue = userIdOrOptions.targetId;
          detailsValue = userIdOrOptions.details;
          ipAddressValue = userIdOrOptions.ipAddress;
          userAgentValue = userIdOrOptions.userAgent;
        } else {
          userId = userIdOrOptions;
          actionValue = action;
          targetTypeValue = targetType;
          targetIdValue = targetId;
          detailsValue = details;
          ipAddressValue = ipAddress;
          userAgentValue = userAgent;
        }
        const [log3] = await db.insert(auditLogs).values({
          userId,
          action: actionValue,
          targetType: targetTypeValue,
          targetId: targetIdValue,
          details: detailsValue ? JSON.stringify(detailsValue) : null,
          ipAddress: ipAddressValue,
          userAgent: userAgentValue
        }).returning();
        return log3;
      }
      // Admin content management - Posts
      async getAdminPost(id) {
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(eq2(posts.id, id));
        if (result.length === 0) return void 0;
        return { ...result[0].posts, author: result[0].users };
      }
      async hidePost(postId, adminId, reason) {
        const [post] = await db.update(posts).set({
          isHidden: true,
          hiddenReason: reason,
          hiddenAt: /* @__PURE__ */ new Date(),
          hiddenById: adminId
        }).where(eq2(posts.id, postId)).returning();
        return post || void 0;
      }
      async unhidePost(postId) {
        const [post] = await db.update(posts).set({
          isHidden: false,
          hiddenReason: null,
          hiddenAt: null,
          hiddenById: null
        }).where(eq2(posts.id, postId)).returning();
        return post || void 0;
      }
      async featurePost(postId, featured) {
        const [post] = await db.update(posts).set({ isFeatured: featured }).where(eq2(posts.id, postId)).returning();
        return post || void 0;
      }
      async hardDeletePost(postId) {
        await db.transaction(async (tx) => {
          await tx.delete(likes).where(eq2(likes.postId, postId));
          await tx.delete(comments).where(eq2(comments.postId, postId));
          await tx.delete(bookmarks).where(eq2(bookmarks.postId, postId));
          await tx.delete(shares).where(eq2(shares.postId, postId));
          await tx.delete(postViews).where(eq2(postViews.postId, postId));
          await tx.delete(playlistItems).where(eq2(playlistItems.postId, postId));
          await tx.delete(pins).where(eq2(pins.postId, postId));
          await tx.delete(postCollaborators).where(eq2(postCollaborators.postId, postId));
          await tx.delete(pendingTagApprovals).where(eq2(pendingTagApprovals.postId, postId));
          await tx.delete(savedPosts).where(eq2(savedPosts.postId, postId));
          await tx.delete(hiddenPosts).where(eq2(hiddenPosts.postId, postId));
          await tx.delete(notInterestedPosts).where(eq2(notInterestedPosts.postId, postId));
          await tx.delete(posts).where(eq2(posts.id, postId));
        });
      }
      async softDeletePost(postId, adminId, reason) {
        const [post] = await db.update(posts).set({
          deletedAt: /* @__PURE__ */ new Date(),
          deletedById: adminId,
          deleteReason: reason || null
        }).where(eq2(posts.id, postId)).returning();
        return post || void 0;
      }
      async getAdminPosts(filters, limit = 100, offset = 0) {
        const conditions = [];
        if (filters.type) {
          conditions.push(eq2(posts.type, filters.type));
        }
        if (filters.visibility) {
          conditions.push(eq2(posts.visibility, filters.visibility));
        }
        if (filters.isHidden !== void 0) {
          conditions.push(eq2(posts.isHidden, filters.isHidden));
        }
        if (filters.isDeleted === true) {
          conditions.push(isNotNull(posts.deletedAt));
        } else if (filters.isDeleted === false) {
          conditions.push(isNull(posts.deletedAt));
        }
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(conditions.length > 0 ? and(...conditions) : void 0).orderBy(desc(posts.createdAt)).limit(limit).offset(offset);
        return result.map((r) => ({ ...r.posts, author: r.users }));
      }
      // Admin content management - Comments
      async getAdminComment(id) {
        const result = await db.select().from(comments).innerJoin(users, eq2(comments.authorId, users.id)).where(eq2(comments.id, id));
        if (result.length === 0) return void 0;
        return { ...result[0].comments, author: result[0].users };
      }
      async hideComment(commentId, adminId, reason) {
        const [comment] = await db.update(comments).set({
          isHidden: true,
          hiddenReason: reason,
          hiddenAt: /* @__PURE__ */ new Date(),
          hiddenById: adminId
        }).where(eq2(comments.id, commentId)).returning();
        return comment || void 0;
      }
      async unhideComment(commentId) {
        const [comment] = await db.update(comments).set({
          isHidden: false,
          hiddenReason: null,
          hiddenAt: null,
          hiddenById: null
        }).where(eq2(comments.id, commentId)).returning();
        return comment || void 0;
      }
      async hardDeleteComment(commentId) {
        await db.delete(comments).where(eq2(comments.id, commentId));
      }
      // User Settings methods for policy engine
      async getUserSettings(userId) {
        const [settings] = await db.select().from(userSettings).where(eq2(userSettings.userId, userId));
        return settings || void 0;
      }
      async getOrCreateUserSettings(userId) {
        let settings = await this.getUserSettings(userId);
        if (!settings) {
          const [created] = await db.insert(userSettings).values({ userId }).returning();
          settings = created;
        }
        return settings;
      }
      async updateUserSettings(userId, data) {
        const existing = await this.getUserSettings(userId);
        if (!existing) {
          const [created] = await db.insert(userSettings).values({ userId, ...data, updatedAt: /* @__PURE__ */ new Date() }).returning();
          return created;
        }
        const [updated] = await db.update(userSettings).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(userSettings.userId, userId)).returning();
        return updated || void 0;
      }
      // ===== PINS (max 3 per user) =====
      async getUserPins(userId) {
        const result = await db.select().from(pins).innerJoin(posts, eq2(pins.postId, posts.id)).innerJoin(users, eq2(posts.authorId, users.id)).where(eq2(pins.userId, userId)).orderBy(pins.order);
        return result.map((r) => ({
          ...r.pins,
          post: { ...r.posts, author: r.users }
        }));
      }
      async setUserPins(userId, postIds) {
        const limitedPostIds = postIds.slice(0, 3);
        return db.transaction(async (tx) => {
          await tx.delete(pins).where(eq2(pins.userId, userId));
          if (limitedPostIds.length === 0) return [];
          const pinValues = limitedPostIds.map((postId, index3) => ({
            userId,
            postId,
            order: index3
          }));
          const created = await tx.insert(pins).values(pinValues).returning();
          return created;
        });
      }
      // ===== PLAYLISTS =====
      async getUserPlaylists(userId) {
        return db.select().from(playlists).where(eq2(playlists.userId, userId)).orderBy(desc(playlists.updatedAt));
      }
      async getPlaylist(id) {
        const [playlist] = await db.select().from(playlists).where(eq2(playlists.id, id));
        return playlist || void 0;
      }
      async getPlaylistWithItems(id) {
        const playlist = await this.getPlaylist(id);
        if (!playlist) return void 0;
        const itemsResult = await db.select().from(playlistItems).innerJoin(posts, eq2(playlistItems.postId, posts.id)).innerJoin(users, eq2(posts.authorId, users.id)).where(eq2(playlistItems.playlistId, id)).orderBy(playlistItems.order);
        const items = itemsResult.map((r) => ({
          ...r.playlist_items,
          post: { ...r.posts, author: r.users }
        }));
        return { ...playlist, items };
      }
      async getPlaylistItemCount(playlistId) {
        const result = await db.select({ count: sql3`count(*)::int` }).from(playlistItems).where(eq2(playlistItems.playlistId, playlistId));
        return result[0]?.count || 0;
      }
      async createPlaylist(userId, title, type, description) {
        const [playlist] = await db.insert(playlists).values({ userId, title, type, description, isPublic: true }).returning();
        return playlist;
      }
      async updatePlaylist(id, data) {
        const [updated] = await db.update(playlists).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(playlists.id, id)).returning();
        return updated || void 0;
      }
      async deletePlaylist(id) {
        await db.delete(playlists).where(eq2(playlists.id, id));
      }
      async getPlaylistById(id) {
        const [playlist] = await db.select().from(playlists).where(eq2(playlists.id, id));
        return playlist || void 0;
      }
      async getAdminPlaylists(type, userId, limit = 100, offset = 0) {
        const conditions = [];
        if (type) {
          conditions.push(eq2(playlists.type, type));
        }
        if (userId) {
          conditions.push(eq2(playlists.userId, userId));
        }
        const result = await db.select().from(playlists).innerJoin(users, eq2(playlists.userId, users.id)).where(conditions.length > 0 ? and(...conditions) : void 0).orderBy(desc(playlists.createdAt)).limit(limit).offset(offset);
        return result.map((r) => ({ ...r.playlists, user: r.users }));
      }
      async addPlaylistItem(playlistId, postId) {
        const maxOrderResult = await db.select({ maxOrder: sql3`COALESCE(MAX(${playlistItems.order}), -1)::int` }).from(playlistItems).where(eq2(playlistItems.playlistId, playlistId));
        const nextOrder = (maxOrderResult[0]?.maxOrder ?? -1) + 1;
        const [item] = await db.insert(playlistItems).values({ playlistId, postId, order: nextOrder }).onConflictDoNothing().returning();
        return item;
      }
      async removePlaylistItem(playlistId, postId) {
        await db.delete(playlistItems).where(and(eq2(playlistItems.playlistId, playlistId), eq2(playlistItems.postId, postId)));
      }
      async reorderPlaylistItems(playlistId, postIds) {
        await db.transaction(async (tx) => {
          for (let i = 0; i < postIds.length; i++) {
            await tx.update(playlistItems).set({ order: i }).where(and(eq2(playlistItems.playlistId, playlistId), eq2(playlistItems.postId, postIds[i])));
          }
        });
      }
      // ===== FEATURED INTRO =====
      async getUserFeaturedIntro(userId) {
        const [intro] = await db.select().from(featuredIntros).where(eq2(featuredIntros.userId, userId));
        return intro || void 0;
      }
      async updateFeaturedIntro(userId, data) {
        const existing = await this.getUserFeaturedIntro(userId);
        if (existing) {
          const [updated] = await db.update(featuredIntros).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(featuredIntros.userId, userId)).returning();
          return updated;
        }
        const [created] = await db.insert(featuredIntros).values({ userId, ...data }).returning();
        return created;
      }
      async deleteFeaturedIntro(id) {
        await db.delete(featuredIntros).where(eq2(featuredIntros.id, id));
      }
      async getFeaturedIntro(id) {
        const [intro] = await db.select().from(featuredIntros).where(eq2(featuredIntros.id, id));
        return intro || void 0;
      }
      async getAllFeaturedIntros() {
        const result = await db.select().from(featuredIntros).innerJoin(users, eq2(featuredIntros.userId, users.id)).orderBy(desc(featuredIntros.updatedAt));
        return result.map((r) => ({ ...r.featured_intros, user: r.users }));
      }
      // ===== PROFILE DATA =====
      async getUserPostsCount(userId) {
        const result = await db.select({ count: sql3`count(*)::int` }).from(posts).where(and(eq2(posts.authorId, userId), eq2(posts.isHidden, false)));
        return result[0]?.count || 0;
      }
      async getUserTotalLikes(userId) {
        const result = await db.select({ total: sql3`COALESCE(SUM(${posts.likesCount}), 0)::int` }).from(posts).where(and(eq2(posts.authorId, userId), eq2(posts.isHidden, false)));
        return result[0]?.total || 0;
      }
      async getUserTotalViews(userId) {
        const result = await db.select({ total: sql3`COALESCE(SUM(${posts.viewsCount}), 0)::int` }).from(posts).where(and(eq2(posts.authorId, userId), eq2(posts.isHidden, false)));
        return result[0]?.total || 0;
      }
      async getUserPostsByType(userId, type, limit = 24, cursor) {
        let conditions = [eq2(posts.authorId, userId), eq2(posts.isHidden, false)];
        if (type) {
          conditions.push(eq2(posts.type, type));
        }
        if (cursor) {
          conditions.push(lt(posts.createdAt, new Date(cursor)));
        }
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(and(...conditions)).orderBy(desc(posts.createdAt)).limit(limit + 1);
        const hasMore = result.length > limit;
        const items = result.slice(0, limit).map((r) => ({ ...r.posts, author: r.users }));
        const nextCursor = hasMore && items.length > 0 ? items[items.length - 1].createdAt.toISOString() : null;
        return { posts: items, nextCursor };
      }
      async getUserPinnedPosts(userId) {
        const result = await db.select().from(pins).innerJoin(posts, eq2(pins.postId, posts.id)).innerJoin(users, eq2(posts.authorId, users.id)).where(and(eq2(pins.userId, userId), eq2(posts.isHidden, false))).orderBy(pins.order);
        return result.map((r) => ({ ...r.posts, author: r.users }));
      }
      async getUserPlaylistsSummary(userId) {
        const userPlaylists = await this.getUserPlaylists(userId);
        const summaries = await Promise.all(
          userPlaylists.map(async (p) => ({
            id: p.id,
            title: p.title,
            type: p.type,
            itemCount: await this.getPlaylistItemCount(p.id),
            isPublic: p.isPublic
          }))
        );
        return summaries;
      }
      // ===== VERIFICATION REQUESTS =====
      async createVerificationRequest(data) {
        const [request] = await db.insert(verificationRequests).values({
          userId: data.userId,
          fullName: data.fullName,
          category: data.category,
          documentUrls: data.documentUrls,
          links: data.links,
          reason: data.reason,
          status: "SUBMITTED"
        }).returning();
        return request;
      }
      async getVerificationRequest(id) {
        const result = await db.select().from(verificationRequests).innerJoin(users, eq2(verificationRequests.userId, users.id)).where(eq2(verificationRequests.id, id));
        if (result.length === 0) return void 0;
        const { verification_requests: request, users: user } = result[0];
        let reviewedBy;
        if (request.reviewedById) {
          reviewedBy = await this.getUser(request.reviewedById);
        }
        return { ...request, user, reviewedBy };
      }
      async getUserVerificationRequests(userId) {
        return db.select().from(verificationRequests).where(eq2(verificationRequests.userId, userId)).orderBy(desc(verificationRequests.submittedAt));
      }
      async getLatestUserVerificationRequest(userId) {
        const [request] = await db.select().from(verificationRequests).where(eq2(verificationRequests.userId, userId)).orderBy(desc(verificationRequests.submittedAt)).limit(1);
        return request || void 0;
      }
      async getVerificationRequests(filters) {
        const conditions = [];
        if (filters?.status) {
          conditions.push(eq2(verificationRequests.status, filters.status));
        }
        if (filters?.category) {
          conditions.push(eq2(verificationRequests.category, filters.category));
        }
        let query = db.select().from(verificationRequests).innerJoin(users, eq2(verificationRequests.userId, users.id)).orderBy(desc(verificationRequests.submittedAt));
        if (conditions.length > 0) {
          query = query.where(and(...conditions));
        }
        if (filters?.limit) {
          query = query.limit(filters.limit);
        }
        if (filters?.offset) {
          query = query.offset(filters.offset);
        }
        const results = await query;
        return Promise.all(results.map(async (r) => {
          let reviewedBy;
          if (r.verification_requests.reviewedById) {
            reviewedBy = await this.getUser(r.verification_requests.reviewedById);
          }
          return { ...r.verification_requests, user: r.users, reviewedBy };
        }));
      }
      async updateVerificationRequest(id, data) {
        const [request] = await db.update(verificationRequests).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(verificationRequests.id, id)).returning();
        return request || void 0;
      }
      async approveVerification(requestId, adminId, notes) {
        const request = await this.updateVerificationRequest(requestId, {
          status: "APPROVED",
          reviewedById: adminId,
          reviewedAt: /* @__PURE__ */ new Date(),
          adminNotes: notes
        });
        if (request) {
          await this.updateUser(request.userId, {
            isVerified: true,
            verifiedAt: /* @__PURE__ */ new Date()
          });
        }
        return request;
      }
      async denyVerification(requestId, adminId, reason, notes) {
        return this.updateVerificationRequest(requestId, {
          status: "DENIED",
          denialReason: reason,
          reviewedById: adminId,
          reviewedAt: /* @__PURE__ */ new Date(),
          adminNotes: notes
        });
      }
      async requestMoreInfo(requestId, adminId, notes) {
        return this.updateVerificationRequest(requestId, {
          status: "MORE_INFO_NEEDED",
          reviewedById: adminId,
          reviewedAt: /* @__PURE__ */ new Date(),
          adminNotes: notes
        });
      }
      // ===== Studio Analytics =====
      async recordProfileView(profileUserId, viewerId, source = "DIRECT") {
        const [view] = await db.insert(profileViews).values({
          profileUserId,
          viewerId: viewerId || null,
          source
        }).returning();
        return view;
      }
      async recordWatchEvent(postId, userId, watchTimeMs, completed, source = "FEED") {
        const [event] = await db.insert(watchEvents).values({
          postId,
          userId,
          watchTimeMs,
          completed,
          source
        }).returning();
        return event;
      }
      async getStudioOverview(userId, startDate, endDate) {
        const profileViewsResult = await db.select({ count: sql3`count(*)::int` }).from(profileViews).where(and(
          eq2(profileViews.profileUserId, userId),
          gte(profileViews.viewedAt, startDate),
          lte(profileViews.viewedAt, endDate)
        ));
        const userPosts = await db.select({ id: posts.id }).from(posts).where(eq2(posts.authorId, userId));
        const postIds = userPosts.map((p) => p.id);
        let postViewsCount = 0;
        let likesCount = 0;
        let commentsCount = 0;
        let sharesCount = 0;
        let savesCount = 0;
        let totalWatchTimeMs = 0;
        let watchEventCount = 0;
        let completionsCount = 0;
        let trafficFromFeed = 0;
        let trafficFromProfile = 0;
        let trafficFromSearch = 0;
        let trafficFromShare = 0;
        if (postIds.length > 0) {
          const postViewsResult = await db.select({ count: sql3`count(*)::int` }).from(postViews).where(and(
            inArray(postViews.postId, postIds),
            gte(postViews.viewedAt, startDate),
            lte(postViews.viewedAt, endDate)
          ));
          postViewsCount = postViewsResult[0]?.count || 0;
          const likesResult = await db.select({ count: sql3`count(*)::int` }).from(likes).where(and(
            inArray(likes.postId, postIds),
            gte(likes.createdAt, startDate),
            lte(likes.createdAt, endDate)
          ));
          likesCount = likesResult[0]?.count || 0;
          const commentsResult = await db.select({ count: sql3`count(*)::int` }).from(comments).where(and(
            inArray(comments.postId, postIds),
            gte(comments.createdAt, startDate),
            lte(comments.createdAt, endDate)
          ));
          commentsCount = commentsResult[0]?.count || 0;
          const sharesResult = await db.select({ count: sql3`count(*)::int` }).from(shares).where(and(
            inArray(shares.postId, postIds),
            gte(shares.createdAt, startDate),
            lte(shares.createdAt, endDate)
          ));
          sharesCount = sharesResult[0]?.count || 0;
          const savesResult = await db.select({ count: sql3`count(*)::int` }).from(bookmarks).where(and(
            inArray(bookmarks.postId, postIds),
            gte(bookmarks.createdAt, startDate),
            lte(bookmarks.createdAt, endDate)
          ));
          savesCount = savesResult[0]?.count || 0;
          const watchResult = await db.select({
            totalTime: sql3`coalesce(sum(watch_time_ms), 0)::int`,
            count: sql3`count(*)::int`,
            completions: sql3`count(*) filter (where completed = true)::int`
          }).from(watchEvents).where(and(
            inArray(watchEvents.postId, postIds),
            gte(watchEvents.createdAt, startDate),
            lte(watchEvents.createdAt, endDate)
          ));
          totalWatchTimeMs = watchResult[0]?.totalTime || 0;
          watchEventCount = watchResult[0]?.count || 0;
          completionsCount = watchResult[0]?.completions || 0;
          const trafficResult = await db.select({
            source: watchEvents.source,
            count: sql3`count(*)::int`
          }).from(watchEvents).where(and(
            inArray(watchEvents.postId, postIds),
            gte(watchEvents.createdAt, startDate),
            lte(watchEvents.createdAt, endDate)
          )).groupBy(watchEvents.source);
          for (const t of trafficResult) {
            switch (t.source) {
              case "FEED":
                trafficFromFeed = t.count;
                break;
              case "PROFILE":
                trafficFromProfile = t.count;
                break;
              case "SEARCH":
                trafficFromSearch = t.count;
                break;
              case "SHARE":
                trafficFromShare = t.count;
                break;
            }
          }
        }
        const followersResult = await db.select({ count: sql3`count(*)::int` }).from(follows).where(and(
          eq2(follows.followingId, userId),
          gte(follows.createdAt, startDate),
          lte(follows.createdAt, endDate)
        ));
        const newFollowers = followersResult[0]?.count || 0;
        const periodLength = endDate.getTime() - startDate.getTime();
        const prevStartDate = new Date(startDate.getTime() - periodLength);
        const prevEndDate = new Date(startDate.getTime() - 1);
        const prevProfileViews = await db.select({ count: sql3`count(*)::int` }).from(profileViews).where(and(
          eq2(profileViews.profileUserId, userId),
          gte(profileViews.viewedAt, prevStartDate),
          lte(profileViews.viewedAt, prevEndDate)
        ));
        const prevFollowers = await db.select({ count: sql3`count(*)::int` }).from(follows).where(and(
          eq2(follows.followingId, userId),
          gte(follows.createdAt, prevStartDate),
          lte(follows.createdAt, prevEndDate)
        ));
        const currentProfileViews = profileViewsResult[0]?.count || 0;
        const prevProfileViewsCount = prevProfileViews[0]?.count || 0;
        const prevFollowersCount = prevFollowers[0]?.count || 0;
        return {
          profileViews: currentProfileViews,
          postViews: postViewsCount,
          likesReceived: likesCount,
          commentsReceived: commentsCount,
          sharesReceived: sharesCount,
          savesReceived: savesCount,
          newFollowers,
          totalWatchTimeMs,
          avgWatchTimeMs: watchEventCount > 0 ? Math.round(totalWatchTimeMs / watchEventCount) : 0,
          completionRate: watchEventCount > 0 ? Math.round(completionsCount / watchEventCount * 100) : 0,
          trafficSources: {
            feed: trafficFromFeed,
            profile: trafficFromProfile,
            search: trafficFromSearch,
            share: trafficFromShare
          },
          trend: {
            profileViews: prevProfileViewsCount > 0 ? Math.round((currentProfileViews - prevProfileViewsCount) / prevProfileViewsCount * 100) : currentProfileViews > 0 ? 100 : 0,
            postViews: 0,
            followers: prevFollowersCount > 0 ? Math.round((newFollowers - prevFollowersCount) / prevFollowersCount * 100) : newFollowers > 0 ? 100 : 0
          }
        };
      }
      async getStudioContent(userId, startDate, endDate, type, sortBy = "views") {
        const conditions = [eq2(posts.authorId, userId)];
        if (type) {
          conditions.push(eq2(posts.type, type));
        }
        const userPosts = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(and(...conditions)).orderBy(desc(posts.createdAt));
        const result = [];
        for (const { posts: post, users: author } of userPosts) {
          const viewsResult = await db.select({ count: sql3`count(*)::int` }).from(postViews).where(and(
            eq2(postViews.postId, post.id),
            gte(postViews.viewedAt, startDate),
            lte(postViews.viewedAt, endDate)
          ));
          const likesResult = await db.select({ count: sql3`count(*)::int` }).from(likes).where(and(
            eq2(likes.postId, post.id),
            gte(likes.createdAt, startDate),
            lte(likes.createdAt, endDate)
          ));
          const commentsResult = await db.select({ count: sql3`count(*)::int` }).from(comments).where(and(
            eq2(comments.postId, post.id),
            gte(comments.createdAt, startDate),
            lte(comments.createdAt, endDate)
          ));
          const sharesResult = await db.select({ count: sql3`count(*)::int` }).from(shares).where(and(
            eq2(shares.postId, post.id),
            gte(shares.createdAt, startDate),
            lte(shares.createdAt, endDate)
          ));
          const savesResult = await db.select({ count: sql3`count(*)::int` }).from(bookmarks).where(and(
            eq2(bookmarks.postId, post.id),
            gte(bookmarks.createdAt, startDate),
            lte(bookmarks.createdAt, endDate)
          ));
          let totalWatchTimeMs = 0;
          let avgWatchTimeMs = 0;
          let completionRate = 0;
          if (post.type === "VIDEO" || post.type === "VOICE") {
            const watchResult = await db.select({
              totalTime: sql3`coalesce(sum(watch_time_ms), 0)::int`,
              count: sql3`count(*)::int`,
              completions: sql3`count(*) filter (where completed = true)::int`
            }).from(watchEvents).where(and(
              eq2(watchEvents.postId, post.id),
              gte(watchEvents.createdAt, startDate),
              lte(watchEvents.createdAt, endDate)
            ));
            totalWatchTimeMs = watchResult[0]?.totalTime || 0;
            const watchCount = watchResult[0]?.count || 0;
            const completions = watchResult[0]?.completions || 0;
            avgWatchTimeMs = watchCount > 0 ? Math.round(totalWatchTimeMs / watchCount) : 0;
            completionRate = watchCount > 0 ? Math.round(completions / watchCount * 100) : 0;
          }
          result.push({
            post: { ...post, author },
            views: viewsResult[0]?.count || 0,
            likes: likesResult[0]?.count || 0,
            comments: commentsResult[0]?.count || 0,
            shares: sharesResult[0]?.count || 0,
            saves: savesResult[0]?.count || 0,
            totalWatchTimeMs,
            avgWatchTimeMs,
            completionRate
          });
        }
        result.sort((a, b) => {
          switch (sortBy) {
            case "views":
              return b.views - a.views;
            case "likes":
              return b.likes - a.likes;
            case "comments":
              return b.comments - a.comments;
            case "shares":
              return b.shares - a.shares;
            case "watchTime":
              return b.totalWatchTimeMs - a.totalWatchTimeMs;
            default:
              return b.views - a.views;
          }
        });
        return result;
      }
      async getStudioPostDetail(postId, startDate, endDate) {
        const post = await this.getPost(postId);
        if (!post) return void 0;
        const totalViewsResult = await db.select({ count: sql3`count(*)::int` }).from(postViews).where(eq2(postViews.postId, postId));
        const uniqueViewsResult = await db.select({ count: sql3`count(distinct user_id)::int` }).from(postViews).where(and(
          eq2(postViews.postId, postId),
          gte(postViews.viewedAt, startDate),
          lte(postViews.viewedAt, endDate)
        ));
        const likesResult = await db.select({ count: sql3`count(*)::int` }).from(likes).where(and(
          eq2(likes.postId, postId),
          gte(likes.createdAt, startDate),
          lte(likes.createdAt, endDate)
        ));
        const commentsResult = await db.select({ count: sql3`count(*)::int` }).from(comments).where(and(
          eq2(comments.postId, postId),
          gte(comments.createdAt, startDate),
          lte(comments.createdAt, endDate)
        ));
        const sharesResult = await db.select({ count: sql3`count(*)::int` }).from(shares).where(and(
          eq2(shares.postId, postId),
          gte(shares.createdAt, startDate),
          lte(shares.createdAt, endDate)
        ));
        const savesResult = await db.select({ count: sql3`count(*)::int` }).from(bookmarks).where(and(
          eq2(bookmarks.postId, postId),
          gte(bookmarks.createdAt, startDate),
          lte(bookmarks.createdAt, endDate)
        ));
        const watchResult = await db.select({
          totalTime: sql3`coalesce(sum(watch_time_ms), 0)::int`,
          count: sql3`count(*)::int`,
          completions: sql3`count(*) filter (where completed = true)::int`
        }).from(watchEvents).where(and(
          eq2(watchEvents.postId, postId),
          gte(watchEvents.createdAt, startDate),
          lte(watchEvents.createdAt, endDate)
        ));
        const trafficResult = await db.select({
          source: watchEvents.source,
          count: sql3`count(*)::int`
        }).from(watchEvents).where(and(
          eq2(watchEvents.postId, postId),
          gte(watchEvents.createdAt, startDate),
          lte(watchEvents.createdAt, endDate)
        )).groupBy(watchEvents.source);
        let trafficFromFeed = 0;
        let trafficFromProfile = 0;
        let trafficFromSearch = 0;
        let trafficFromShare = 0;
        for (const t of trafficResult) {
          switch (t.source) {
            case "FEED":
              trafficFromFeed = t.count;
              break;
            case "PROFILE":
              trafficFromProfile = t.count;
              break;
            case "SEARCH":
              trafficFromSearch = t.count;
              break;
            case "SHARE":
              trafficFromShare = t.count;
              break;
          }
        }
        const dailyMetrics = await db.select().from(dailyPostAnalytics).where(and(
          eq2(dailyPostAnalytics.postId, postId),
          gte(dailyPostAnalytics.date, startDate),
          lte(dailyPostAnalytics.date, endDate)
        )).orderBy(dailyPostAnalytics.date);
        const totalWatchTimeMs = watchResult[0]?.totalTime || 0;
        const watchCount = watchResult[0]?.count || 0;
        const completions = watchResult[0]?.completions || 0;
        return {
          post,
          totalViews: totalViewsResult[0]?.count || 0,
          uniqueViews: uniqueViewsResult[0]?.count || 0,
          likes: likesResult[0]?.count || 0,
          comments: commentsResult[0]?.count || 0,
          shares: sharesResult[0]?.count || 0,
          saves: savesResult[0]?.count || 0,
          totalWatchTimeMs,
          avgWatchTimeMs: watchCount > 0 ? Math.round(totalWatchTimeMs / watchCount) : 0,
          completionRate: watchCount > 0 ? Math.round(completions / watchCount * 100) : 0,
          dailyMetrics,
          trafficSources: {
            feed: trafficFromFeed,
            profile: trafficFromProfile,
            search: trafficFromSearch,
            share: trafficFromShare
          }
        };
      }
      async getStudioAudience(userId, startDate, endDate) {
        const totalFollowersResult = await db.select({ count: sql3`count(*)::int` }).from(follows).where(eq2(follows.followingId, userId));
        const newFollowersResult = await db.select({ count: sql3`count(*)::int` }).from(follows).where(and(
          eq2(follows.followingId, userId),
          gte(follows.createdAt, startDate),
          lte(follows.createdAt, endDate)
        ));
        const unfollowsResult = await db.select({ unfollows: sql3`coalesce(sum(unfollows), 0)::int` }).from(dailyUserAnalytics).where(and(
          eq2(dailyUserAnalytics.userId, userId),
          gte(dailyUserAnalytics.date, startDate),
          lte(dailyUserAnalytics.date, endDate)
        ));
        const totalFollowers = totalFollowersResult[0]?.count || 0;
        const newFollowers = newFollowersResult[0]?.count || 0;
        const unfollows = unfollowsResult[0]?.unfollows || 0;
        const dailyGrowth = await db.select({
          date: dailyUserAnalytics.date,
          followers: dailyUserAnalytics.newFollowers,
          unfollows: dailyUserAnalytics.unfollows
        }).from(dailyUserAnalytics).where(and(
          eq2(dailyUserAnalytics.userId, userId),
          gte(dailyUserAnalytics.date, startDate),
          lte(dailyUserAnalytics.date, endDate)
        )).orderBy(dailyUserAnalytics.date);
        return {
          totalFollowers,
          newFollowers,
          unfollows,
          netGrowth: newFollowers - unfollows,
          dailyFollowerGrowth: dailyGrowth.map((d) => ({
            date: d.date.toISOString().split("T")[0],
            followers: d.followers,
            unfollows: d.unfollows
          }))
        };
      }
      // ===== STORIES =====
      async createStory(userId, data) {
        const expiresAt = data.scheduledAt ? new Date(data.scheduledAt.getTime() + 24 * 60 * 60 * 1e3) : new Date(Date.now() + 24 * 60 * 60 * 1e3);
        const [story] = await db.insert(stories).values({
          userId,
          type: data.type,
          mediaUrl: data.mediaUrl,
          thumbnailUrl: data.thumbnailUrl,
          durationMs: data.durationMs,
          caption: data.caption,
          textContent: data.textContent,
          backgroundColor: data.backgroundColor,
          isGradient: data.isGradient,
          gradientColors: data.gradientColors,
          fontFamily: data.fontFamily,
          textAlignment: data.textAlignment,
          textAnimation: data.textAnimation,
          textBackgroundPill: data.textBackgroundPill,
          fontSize: data.fontSize,
          audioUrl: data.audioUrl,
          audioDuration: data.audioDuration,
          audioTranscript: data.audioTranscript,
          musicUrl: data.musicUrl,
          musicTitle: data.musicTitle,
          musicArtist: data.musicArtist,
          musicStartTime: data.musicStartTime,
          musicDuration: data.musicDuration,
          filterName: data.filterName,
          textOverlays: data.textOverlays,
          drawings: data.drawings,
          isCloseFriends: data.isCloseFriends,
          replySetting: data.replySetting,
          scheduledAt: data.scheduledAt,
          locationName: data.locationName,
          locationLat: data.locationLat,
          locationLng: data.locationLng,
          expiresAt
        }).returning();
        await this.updateStreak(userId).catch(() => {
        });
        return story;
      }
      async getStory(id) {
        const result = await db.select().from(stories).innerJoin(users, eq2(stories.userId, users.id)).where(eq2(stories.id, id));
        if (result.length === 0) return void 0;
        return { ...result[0].stories, user: result[0].users };
      }
      async getUserStories(userId) {
        const result = await db.select().from(stories).innerJoin(users, eq2(stories.userId, users.id)).where(eq2(stories.userId, userId)).orderBy(desc(stories.createdAt));
        return result.map((r) => ({ ...r.stories, user: r.users }));
      }
      async getActiveUserStories(userId) {
        const now = /* @__PURE__ */ new Date();
        const result = await db.select().from(stories).innerJoin(users, eq2(stories.userId, users.id)).where(and(
          eq2(stories.userId, userId),
          gt(stories.expiresAt, now)
        )).orderBy(desc(stories.createdAt));
        return result.map((r) => ({ ...r.stories, user: r.users }));
      }
      async getFeedStories(userId) {
        const now = /* @__PURE__ */ new Date();
        const followingIds = await db.select({ id: follows.followingId }).from(follows).where(eq2(follows.followerId, userId));
        const ids = followingIds.map((f) => f.id);
        if (ids.length === 0) return [];
        const storyRestrictions = await db.select({ userId: storyViewerRestrictions.userId }).from(storyViewerRestrictions).where(eq2(storyViewerRestrictions.restrictedViewerId, userId));
        const restrictedUserIds = new Set(storyRestrictions.map((r) => r.userId));
        const mutedList = await db.select().from(mutedAccounts).where(and(eq2(mutedAccounts.userId, userId), eq2(mutedAccounts.muteStories, true)));
        const mutedUserIds = new Set(mutedList.map((m) => m.mutedUserId));
        const filteredIds = ids.filter((id) => !restrictedUserIds.has(id) && !mutedUserIds.has(id));
        if (filteredIds.length === 0) return [];
        const result = await db.select().from(stories).innerJoin(users, eq2(stories.userId, users.id)).where(and(
          inArray(stories.userId, filteredIds),
          gt(stories.expiresAt, now)
        )).orderBy(desc(stories.createdAt));
        const grouped = /* @__PURE__ */ new Map();
        for (const r of result) {
          const existing = grouped.get(r.users.id);
          if (existing) {
            existing.stories.push(r.stories);
          } else {
            grouped.set(r.users.id, { user: r.users, stories: [r.stories] });
          }
        }
        return Array.from(grouped.values()).sort((a, b) => {
          const aLatest = a.stories[0]?.createdAt?.getTime() || 0;
          const bLatest = b.stories[0]?.createdAt?.getTime() || 0;
          return bLatest - aLatest;
        });
      }
      async getAllStories(limit, offset, userId) {
        const conditions = [];
        if (userId) {
          conditions.push(eq2(stories.userId, userId));
        }
        const result = await db.select().from(stories).innerJoin(users, eq2(stories.userId, users.id)).where(conditions.length > 0 ? and(...conditions) : void 0).orderBy(desc(stories.createdAt)).limit(limit).offset(offset);
        return result.map((r) => ({ ...r.stories, user: r.users }));
      }
      async deleteStory(id) {
        await db.delete(stories).where(eq2(stories.id, id));
      }
      async viewStory(storyId, viewerId) {
        const existing = await db.select().from(storyViews).where(and(eq2(storyViews.storyId, storyId), eq2(storyViews.viewerId, viewerId)));
        if (existing.length > 0) return existing[0];
        return await db.transaction(async (tx) => {
          const [view] = await tx.insert(storyViews).values({ storyId, viewerId }).returning();
          await tx.update(stories).set({ viewsCount: sql3`${stories.viewsCount} + 1` }).where(eq2(stories.id, storyId));
          return view;
        });
      }
      async getStoryViewers(storyId) {
        const result = await db.select().from(storyViews).innerJoin(users, eq2(storyViews.viewerId, users.id)).where(eq2(storyViews.storyId, storyId)).orderBy(desc(storyViews.viewedAt));
        return result.map((r) => ({ ...r.users, viewedAt: r.story_views.viewedAt }));
      }
      async hasUserViewedStory(storyId, viewerId) {
        const result = await db.select().from(storyViews).where(and(eq2(storyViews.storyId, storyId), eq2(storyViews.viewerId, viewerId)));
        return result.length > 0;
      }
      async deleteExpiredStories() {
        const now = /* @__PURE__ */ new Date();
        const result = await db.delete(stories).where(lt(stories.expiresAt, now)).returning();
        return result.length;
      }
      // ===== STORY STICKERS =====
      async createStorySticker(data) {
        const [sticker] = await db.insert(storyStickers).values({
          storyId: data.storyId,
          type: data.type,
          positionX: data.positionX ?? 0.5,
          positionY: data.positionY ?? 0.5,
          scale: data.scale ?? 1,
          rotation: data.rotation ?? 0,
          data: data.data
        }).returning();
        return sticker;
      }
      async getSticker(stickerId) {
        const [sticker] = await db.select().from(storyStickers).where(eq2(storyStickers.id, stickerId)).limit(1);
        return sticker;
      }
      async getStoryStickers(storyId) {
        return db.select().from(storyStickers).where(eq2(storyStickers.storyId, storyId)).orderBy(storyStickers.createdAt);
      }
      async updateStorySticker(stickerId, data) {
        const [sticker] = await db.update(storyStickers).set(data).where(eq2(storyStickers.id, stickerId)).returning();
        return sticker;
      }
      async deleteStorySticker(stickerId) {
        await db.delete(storyStickers).where(eq2(storyStickers.id, stickerId));
      }
      async respondToSticker(stickerId, userId, responseType, responseData) {
        const [response] = await db.insert(storyStickerResponses).values({ stickerId, userId, responseType, responseData }).onConflictDoUpdate({
          target: [storyStickerResponses.stickerId, storyStickerResponses.userId],
          set: { responseType, responseData }
        }).returning();
        return response;
      }
      async getStickerResponses(stickerId) {
        return db.select().from(storyStickerResponses).where(eq2(storyStickerResponses.stickerId, stickerId)).orderBy(desc(storyStickerResponses.createdAt));
      }
      async getUserStickerResponse(stickerId, userId) {
        const [response] = await db.select().from(storyStickerResponses).where(and(
          eq2(storyStickerResponses.stickerId, stickerId),
          eq2(storyStickerResponses.userId, userId)
        ));
        return response;
      }
      // ===== STORY REACTIONS =====
      async addStoryReaction(storyId, userId, reactionType) {
        const [reaction] = await db.insert(storyReactions).values({ storyId, userId, reactionType }).onConflictDoUpdate({
          target: [storyReactions.storyId, storyReactions.userId],
          set: { reactionType }
        }).returning();
        await db.update(stories).set({ reactionsCount: sql3`${stories.reactionsCount} + 1` }).where(eq2(stories.id, storyId));
        return reaction;
      }
      async removeStoryReaction(storyId, userId) {
        const deleted = await db.delete(storyReactions).where(and(eq2(storyReactions.storyId, storyId), eq2(storyReactions.userId, userId))).returning();
        if (deleted.length > 0) {
          await db.update(stories).set({ reactionsCount: sql3`GREATEST(${stories.reactionsCount} - 1, 0)` }).where(eq2(stories.id, storyId));
        }
      }
      async getStoryReactions(storyId) {
        return db.select().from(storyReactions).where(eq2(storyReactions.storyId, storyId)).orderBy(desc(storyReactions.createdAt));
      }
      async hasUserReactedToStory(storyId, userId) {
        const [reaction] = await db.select().from(storyReactions).where(and(eq2(storyReactions.storyId, storyId), eq2(storyReactions.userId, userId)));
        return reaction;
      }
      // ===== STORY REPLIES =====
      async createStoryReply(storyId, userId, content, mediaUrl, mediaType) {
        const [reply] = await db.insert(storyReplies).values({ storyId, userId, content, mediaUrl, mediaType }).returning();
        await db.update(stories).set({ repliesCount: sql3`${stories.repliesCount} + 1` }).where(eq2(stories.id, storyId));
        return reply;
      }
      async getStoryReplies(storyId) {
        const result = await db.select().from(storyReplies).innerJoin(users, eq2(storyReplies.userId, users.id)).where(eq2(storyReplies.storyId, storyId)).orderBy(desc(storyReplies.createdAt));
        return result.map((r) => ({ ...r.story_replies, user: r.users }));
      }
      async markStoryRepliesRead(storyId) {
        await db.update(storyReplies).set({ isRead: true }).where(eq2(storyReplies.storyId, storyId));
      }
      async deleteStoryReply(replyId) {
        const [deleted] = await db.delete(storyReplies).where(eq2(storyReplies.id, replyId)).returning();
        if (deleted) {
          await db.update(stories).set({ repliesCount: sql3`GREATEST(${stories.repliesCount} - 1, 0)` }).where(eq2(stories.id, deleted.storyId));
        }
      }
      // ===== STORY DRAFTS =====
      async createStoryDraft(userId, data) {
        const [draft] = await db.insert(storyDrafts).values({
          userId,
          type: data.type,
          mediaUrl: data.mediaUrl,
          thumbnailUrl: data.thumbnailUrl,
          textContent: data.textContent,
          backgroundColor: data.backgroundColor,
          isGradient: data.isGradient,
          gradientColors: data.gradientColors,
          fontFamily: data.fontFamily,
          textAlignment: data.textAlignment,
          textAnimation: data.textAnimation,
          fontSize: data.fontSize,
          audioUrl: data.audioUrl,
          audioDuration: data.audioDuration,
          musicUrl: data.musicUrl,
          musicTitle: data.musicTitle,
          musicArtist: data.musicArtist,
          filterName: data.filterName,
          textOverlays: data.textOverlays,
          drawings: data.drawings,
          stickers: data.stickers,
          isCloseFriends: data.isCloseFriends,
          replySetting: data.replySetting
        }).returning();
        return draft;
      }
      async getStoryDraft(draftId) {
        const [draft] = await db.select().from(storyDrafts).where(eq2(storyDrafts.id, draftId));
        return draft;
      }
      async getUserStoryDrafts(userId) {
        return db.select().from(storyDrafts).where(eq2(storyDrafts.userId, userId)).orderBy(desc(storyDrafts.updatedAt));
      }
      async updateStoryDraft(draftId, data) {
        const [draft] = await db.update(storyDrafts).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(storyDrafts.id, draftId)).returning();
        return draft;
      }
      async deleteStoryDraft(draftId) {
        await db.delete(storyDrafts).where(eq2(storyDrafts.id, draftId));
      }
      // ===== STORY INSIGHTS =====
      async recordStoryInsight(storyId, viewerId, data) {
        const [insight] = await db.insert(storyInsights).values({ storyId, viewerId, ...data }).onConflictDoUpdate({
          target: [storyInsights.storyId, storyInsights.viewerId],
          set: data
        }).returning();
        if (data.tappedForward) {
          await db.update(stories).set({ tapsForwardCount: sql3`${stories.tapsForwardCount} + 1` }).where(eq2(stories.id, storyId));
        }
        if (data.tappedBack) {
          await db.update(stories).set({ tapsBackCount: sql3`${stories.tapsBackCount} + 1` }).where(eq2(stories.id, storyId));
        }
        if (data.exited) {
          await db.update(stories).set({ exitsCount: sql3`${stories.exitsCount} + 1` }).where(eq2(stories.id, storyId));
        }
        if (data.shared) {
          await db.update(stories).set({ sharesCount: sql3`${stories.sharesCount} + 1` }).where(eq2(stories.id, storyId));
        }
        return insight;
      }
      async getStoryInsights(storyId) {
        return db.select().from(storyInsights).where(eq2(storyInsights.storyId, storyId)).orderBy(desc(storyInsights.createdAt));
      }
      async getStoryAnalytics(storyId) {
        const insights = await this.getStoryInsights(storyId);
        const views = insights.length;
        const totalDuration = insights.reduce((sum, i) => sum + (i.viewDuration || 0), 0);
        const avgDuration = views > 0 ? Math.round(totalDuration / views) : 0;
        const exits = insights.filter((i) => i.exited).length;
        const shares2 = insights.filter((i) => i.shared).length;
        const profileVisits = insights.filter((i) => i.profileVisited).length;
        return { views, avgDuration, exits, shares: shares2, profileVisits };
      }
      // ===== STORY STREAKS =====
      async getOrCreateStreak(userId) {
        const [existing] = await db.select().from(storyStreaks).where(eq2(storyStreaks.userId, userId));
        if (existing) return existing;
        const [streak] = await db.insert(storyStreaks).values({ userId }).returning();
        return streak;
      }
      async updateStreak(userId) {
        const streak = await this.getOrCreateStreak(userId);
        const now = /* @__PURE__ */ new Date();
        const lastStoryTime = streak.lastStoryAt?.getTime() || 0;
        const hoursSinceLastStory = (now.getTime() - lastStoryTime) / (1e3 * 60 * 60);
        let newStreak = streak.currentStreak;
        let streakStartedAt = streak.streakStartedAt;
        if (hoursSinceLastStory > 48) {
          newStreak = 1;
          streakStartedAt = now;
        } else if (hoursSinceLastStory > 24) {
          newStreak = streak.currentStreak + 1;
        }
        const longestStreak = Math.max(streak.longestStreak, newStreak);
        const [updated] = await db.update(storyStreaks).set({
          currentStreak: newStreak,
          longestStreak,
          lastStoryAt: now,
          streakStartedAt,
          updatedAt: now
        }).where(eq2(storyStreaks.userId, userId)).returning();
        return updated;
      }
      async claimStreakMilestone(userId, milestone) {
        const fieldMap = {
          7: "milestone7Claimed",
          30: "milestone30Claimed",
          100: "milestone100Claimed",
          365: "milestone365Claimed"
        };
        const field = fieldMap[milestone];
        if (!field) return void 0;
        const [updated] = await db.update(storyStreaks).set({ [field]: true, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(storyStreaks.userId, userId)).returning();
        return updated;
      }
      // ===== STORY TEMPLATES =====
      async getStoryTemplates(category) {
        const conditions = [eq2(storyTemplates.isActive, true)];
        if (category) conditions.push(eq2(storyTemplates.category, category));
        return db.select().from(storyTemplates).where(and(...conditions)).orderBy(storyTemplates.order, desc(storyTemplates.usageCount));
      }
      async getStoryTemplate(templateId) {
        const [template] = await db.select().from(storyTemplates).where(eq2(storyTemplates.id, templateId));
        return template;
      }
      async createStoryTemplate(data) {
        const [template] = await db.insert(storyTemplates).values(data).returning();
        return template;
      }
      async updateStoryTemplate(templateId, data) {
        const [template] = await db.update(storyTemplates).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(storyTemplates.id, templateId)).returning();
        return template;
      }
      async deleteStoryTemplate(templateId) {
        await db.delete(storyTemplates).where(eq2(storyTemplates.id, templateId));
      }
      async incrementTemplateUsage(templateId) {
        await db.update(storyTemplates).set({ usageCount: sql3`${storyTemplates.usageCount} + 1` }).where(eq2(storyTemplates.id, templateId));
      }
      // ===== STORY MUSIC LIBRARY =====
      async getStoryMusic(genre, limit = 50) {
        const conditions = [eq2(storyMusicLibrary.isActive, true)];
        if (genre) conditions.push(eq2(storyMusicLibrary.genre, genre));
        return db.select().from(storyMusicLibrary).where(and(...conditions)).orderBy(desc(storyMusicLibrary.usageCount)).limit(limit);
      }
      async getFeaturedStoryMusic() {
        return db.select().from(storyMusicLibrary).where(and(eq2(storyMusicLibrary.isActive, true), eq2(storyMusicLibrary.isFeatured, true))).orderBy(desc(storyMusicLibrary.usageCount)).limit(20);
      }
      async searchStoryMusic(query) {
        return db.select().from(storyMusicLibrary).where(and(
          eq2(storyMusicLibrary.isActive, true),
          or(
            ilike(storyMusicLibrary.title, `%${query}%`),
            ilike(storyMusicLibrary.artist, `%${query}%`)
          )
        )).orderBy(desc(storyMusicLibrary.usageCount)).limit(50);
      }
      async addStoryMusic(data) {
        const [music] = await db.insert(storyMusicLibrary).values(data).returning();
        return music;
      }
      async updateStoryMusic(musicId, data) {
        const [music] = await db.update(storyMusicLibrary).set(data).where(eq2(storyMusicLibrary.id, musicId)).returning();
        return music;
      }
      async deleteStoryMusic(musicId) {
        await db.delete(storyMusicLibrary).where(eq2(storyMusicLibrary.id, musicId));
      }
      async incrementMusicUsage(musicId) {
        await db.update(storyMusicLibrary).set({ usageCount: sql3`${storyMusicLibrary.usageCount} + 1` }).where(eq2(storyMusicLibrary.id, musicId));
      }
      async getStoryMusicById(musicId) {
        const [music] = await db.select().from(storyMusicLibrary).where(eq2(storyMusicLibrary.id, musicId));
        return music;
      }
      async createStoryMusic(data) {
        const [music] = await db.insert(storyMusicLibrary).values(data).returning();
        return music;
      }
      // ===== STORY REPORTS (ADMIN) =====
      async getStoryReports(status) {
        const conditions = [];
        if (status) {
          conditions.push(eq2(reports.status, status));
        }
        return db.select().from(reports).where(conditions.length > 0 ? and(...conditions) : void 0).orderBy(desc(reports.createdAt));
      }
      // ===== PLATFORM STORY ANALYTICS (ADMIN) =====
      async getPlatformStoryStats(days) {
        const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1e3);
        const [storyCount] = await db.select({ count: sql3`count(*)` }).from(stories).where(gte(stories.createdAt, cutoff));
        const [viewCount] = await db.select({ sum: sql3`coalesce(sum(${stories.viewsCount}), 0)` }).from(stories).where(gte(stories.createdAt, cutoff));
        const [avgDuration] = await db.select({ avg: sql3`coalesce(avg(${storyInsights.viewDuration}), 0)` }).from(storyInsights).innerJoin(stories, eq2(storyInsights.storyId, stories.id)).where(gte(stories.createdAt, cutoff));
        const topCreators = await db.select({
          userId: stories.userId,
          storyCount: sql3`count(*)::int`,
          totalViews: sql3`coalesce(sum(${stories.viewsCount}), 0)::int`
        }).from(stories).where(gte(stories.createdAt, cutoff)).groupBy(stories.userId).orderBy(desc(sql3`sum(${stories.viewsCount})`)).limit(10);
        const byType = await db.select({
          type: stories.type,
          count: sql3`count(*)::int`
        }).from(stories).where(gte(stories.createdAt, cutoff)).groupBy(stories.type);
        const [engagement] = await db.select({
          reactions: sql3`coalesce(sum(${stories.reactionsCount}), 0)::int`,
          replies: sql3`coalesce(sum(${stories.repliesCount}), 0)::int`,
          views: sql3`coalesce(sum(${stories.viewsCount}), 0)::int`
        }).from(stories).where(gte(stories.createdAt, cutoff));
        const totalEngagement = (engagement.reactions || 0) + (engagement.replies || 0);
        const totalViews = engagement.views || 1;
        const engagementRate = totalEngagement / totalViews;
        return {
          totalStories: Number(storyCount?.count || 0),
          totalViews: Number(viewCount?.sum || 0),
          avgViewDuration: Number(avgDuration?.avg || 0),
          topCreators: topCreators.map((c) => ({
            userId: c.userId,
            storyCount: c.storyCount,
            totalViews: c.totalViews
          })),
          byType: byType.map((b) => ({ type: b.type, count: b.count })),
          engagementRate
        };
      }
      // ===== STORY TIPS =====
      async createStoryTip(storyId, senderId, recipientId, amount, message) {
        const [tip] = await db.insert(storyTips).values({ storyId, senderId, recipientId, amount, message }).returning();
        await this.addNetWorthEntry(recipientId, amount, "GIFT", "story_tip", tip.id);
        return tip;
      }
      async getStoryTips(storyId) {
        const result = await db.select().from(storyTips).innerJoin(users, eq2(storyTips.senderId, users.id)).where(eq2(storyTips.storyId, storyId)).orderBy(desc(storyTips.createdAt));
        return result.map((r) => ({ ...r.story_tips, sender: r.users }));
      }
      async getUserReceivedTips(userId) {
        const result = await db.select().from(storyTips).innerJoin(users, eq2(storyTips.senderId, users.id)).innerJoin(stories, eq2(storyTips.storyId, stories.id)).where(eq2(storyTips.recipientId, userId)).orderBy(desc(storyTips.createdAt));
        return result.map((r) => ({ ...r.story_tips, sender: r.users, story: r.stories }));
      }
      async getUserSentTips(userId) {
        const result = await db.select().from(storyTips).innerJoin(users, eq2(storyTips.recipientId, users.id)).innerJoin(stories, eq2(storyTips.storyId, stories.id)).where(eq2(storyTips.senderId, userId)).orderBy(desc(storyTips.createdAt));
        return result.map((r) => ({ ...r.story_tips, recipient: r.users, story: r.stories }));
      }
      // ===== STORY COUNTDOWN SUBSCRIPTIONS =====
      async subscribeToCountdown(stickerId, userId) {
        const [sub] = await db.insert(storyCountdownSubscriptions).values({ stickerId, userId }).onConflictDoNothing().returning();
        if (!sub) {
          const [existing] = await db.select().from(storyCountdownSubscriptions).where(and(
            eq2(storyCountdownSubscriptions.stickerId, stickerId),
            eq2(storyCountdownSubscriptions.userId, userId)
          ));
          return existing;
        }
        return sub;
      }
      async unsubscribeFromCountdown(stickerId, userId) {
        await db.delete(storyCountdownSubscriptions).where(and(
          eq2(storyCountdownSubscriptions.stickerId, stickerId),
          eq2(storyCountdownSubscriptions.userId, userId)
        ));
      }
      async getCountdownSubscribers(stickerId) {
        const result = await db.select().from(storyCountdownSubscriptions).innerJoin(users, eq2(storyCountdownSubscriptions.userId, users.id)).where(eq2(storyCountdownSubscriptions.stickerId, stickerId));
        return result.map((r) => r.users);
      }
      async getPendingCountdownNotifications() {
        const now = /* @__PURE__ */ new Date();
        const result = await db.select().from(storyCountdownSubscriptions).innerJoin(storyStickers, eq2(storyCountdownSubscriptions.stickerId, storyStickers.id)).where(eq2(storyCountdownSubscriptions.notified, false));
        return result.filter((r) => {
          const countdownEnd = r.story_stickers.data?.endTime;
          return countdownEnd && new Date(countdownEnd) <= now;
        }).map((r) => ({ subscription: r.story_countdown_subscriptions, sticker: r.story_stickers }));
      }
      async markCountdownNotified(subscriptionId) {
        await db.update(storyCountdownSubscriptions).set({ notified: true }).where(eq2(storyCountdownSubscriptions.id, subscriptionId));
      }
      // ===== MUTUAL FOLLOWERS =====
      async getMutualFollowers(userId, viewerId, limit = 5) {
        const userFollowing = await db.select({ id: follows.followingId }).from(follows).where(eq2(follows.followerId, userId));
        const viewerFollowing = await db.select({ id: follows.followingId }).from(follows).where(eq2(follows.followerId, viewerId));
        const userFollowingIds = new Set(userFollowing.map((f) => f.id));
        const mutualIds = viewerFollowing.filter((f) => userFollowingIds.has(f.id)).map((f) => f.id).slice(0, limit);
        if (mutualIds.length === 0) return [];
        const result = await db.select().from(users).where(inArray(users.id, mutualIds));
        return result;
      }
      // ===== ACTIVITY STATUS =====
      async updateLastActive(userId) {
        await db.update(users).set({ lastActiveAt: /* @__PURE__ */ new Date() }).where(eq2(users.id, userId));
      }
      // ===== STORY HIGHLIGHTS =====
      async createStoryHighlight(userId, name, coverUrl) {
        const maxOrder = await db.select({ max: sql3`COALESCE(MAX("order"), -1)` }).from(storyHighlights).where(eq2(storyHighlights.userId, userId));
        const [highlight] = await db.insert(storyHighlights).values({ userId, name, coverUrl, order: (maxOrder[0]?.max ?? -1) + 1 }).returning();
        return highlight;
      }
      async getStoryHighlights(userId) {
        return db.select().from(storyHighlights).where(eq2(storyHighlights.userId, userId)).orderBy(storyHighlights.order);
      }
      async getStoryHighlight(highlightId) {
        const [highlight] = await db.select().from(storyHighlights).where(eq2(storyHighlights.id, highlightId));
        return highlight;
      }
      async updateStoryHighlight(highlightId, data) {
        const [updated] = await db.update(storyHighlights).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(storyHighlights.id, highlightId)).returning();
        return updated;
      }
      async deleteStoryHighlight(highlightId) {
        const result = await db.delete(storyHighlights).where(eq2(storyHighlights.id, highlightId)).returning();
        return result.length > 0;
      }
      async addStoryToHighlight(highlightId, storyId) {
        const maxOrder = await db.select({ max: sql3`COALESCE(MAX("order"), -1)` }).from(storyHighlightItems).where(eq2(storyHighlightItems.highlightId, highlightId));
        try {
          const [item] = await db.insert(storyHighlightItems).values({ highlightId, storyId, order: (maxOrder[0]?.max ?? -1) + 1 }).returning();
          return item;
        } catch {
          return void 0;
        }
      }
      async removeStoryFromHighlight(highlightId, storyId) {
        const result = await db.delete(storyHighlightItems).where(and(eq2(storyHighlightItems.highlightId, highlightId), eq2(storyHighlightItems.storyId, storyId))).returning();
        return result.length > 0;
      }
      async getHighlightItems(highlightId) {
        const result = await db.select().from(storyHighlightItems).innerJoin(stories, eq2(storyHighlightItems.storyId, stories.id)).where(eq2(storyHighlightItems.highlightId, highlightId)).orderBy(storyHighlightItems.order);
        return result.map((r) => ({ ...r.story_highlight_items, story: r.stories }));
      }
      // ===== USER NOTES (24h STATUS) =====
      async createUserNote(userId, content) {
        await db.delete(userNotes).where(eq2(userNotes.userId, userId));
        const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1e3);
        const [note] = await db.insert(userNotes).values({ userId, content, expiresAt }).returning();
        return note;
      }
      async getUserNote(userId) {
        const [note] = await db.select().from(userNotes).where(and(eq2(userNotes.userId, userId), gt(userNotes.expiresAt, /* @__PURE__ */ new Date())));
        return note;
      }
      async deleteUserNote(userId) {
        const result = await db.delete(userNotes).where(eq2(userNotes.userId, userId)).returning();
        return result.length > 0;
      }
      async deleteExpiredNotes() {
        const result = await db.delete(userNotes).where(lt(userNotes.expiresAt, /* @__PURE__ */ new Date())).returning();
        return result.length;
      }
      // ===== USER LINKS =====
      async createUserLink(userId, data) {
        const maxOrder = await db.select({ max: sql3`COALESCE(MAX("order"), -1)` }).from(userLinks).where(eq2(userLinks.userId, userId));
        const [link] = await db.insert(userLinks).values({ userId, ...data, order: (maxOrder[0]?.max ?? -1) + 1 }).returning();
        return link;
      }
      async getUserLinks(userId) {
        return db.select().from(userLinks).where(eq2(userLinks.userId, userId)).orderBy(userLinks.order);
      }
      async updateUserLink(linkId, data) {
        const [updated] = await db.update(userLinks).set(data).where(eq2(userLinks.id, linkId)).returning();
        return updated;
      }
      async deleteUserLink(linkId) {
        const result = await db.delete(userLinks).where(eq2(userLinks.id, linkId)).returning();
        return result.length > 0;
      }
      async getUserLink(linkId) {
        const [link] = await db.select().from(userLinks).where(eq2(userLinks.id, linkId));
        return link;
      }
      async incrementLinkClicks(linkId) {
        await db.update(userLinks).set({ clicks: sql3`${userLinks.clicks} + 1` }).where(eq2(userLinks.id, linkId));
      }
      // ===== USER INTERESTS =====
      async addUserInterest(userId, interest) {
        const maxOrder = await db.select({ max: sql3`COALESCE(MAX("order"), -1)` }).from(userInterests).where(eq2(userInterests.userId, userId));
        try {
          const [item] = await db.insert(userInterests).values({ userId, interest: interest.toLowerCase().trim(), order: (maxOrder[0]?.max ?? -1) + 1 }).returning();
          return item;
        } catch {
          return void 0;
        }
      }
      async getUserInterests(userId) {
        return db.select().from(userInterests).where(eq2(userInterests.userId, userId)).orderBy(userInterests.order);
      }
      async removeUserInterest(userId, interest) {
        const result = await db.delete(userInterests).where(and(eq2(userInterests.userId, userId), eq2(userInterests.interest, interest.toLowerCase().trim()))).returning();
        return result.length > 0;
      }
      async setUserInterests(userId, interests) {
        await db.delete(userInterests).where(eq2(userInterests.userId, userId));
        if (interests.length === 0) return [];
        const items = interests.map((interest, idx) => ({
          userId,
          interest: interest.toLowerCase().trim(),
          order: idx
        }));
        return db.insert(userInterests).values(items).returning();
      }
      // ===== PROFILE ENHANCEMENTS =====
      async updateProfileEnhancements(userId, data) {
        const [updated] = await db.update(users).set(data).where(eq2(users.id, userId)).returning();
        return updated;
      }
      async getRelationshipPartner(userId) {
        const user = await this.getUser(userId);
        if (!user?.relationshipPartnerId) return void 0;
        return this.getUser(user.relationshipPartnerId);
      }
      // ===== LOGIN SESSIONS =====
      async createLoginSession(userId, data) {
        const [session2] = await db.insert(loginSessions).values({
          userId,
          sessionToken: data.sessionToken,
          deviceName: data.deviceName,
          deviceType: data.deviceType,
          browser: data.browser,
          os: data.os,
          ipAddress: data.ipAddress,
          location: data.location
        }).returning();
        return session2;
      }
      async getLoginSessions(userId) {
        return db.select().from(loginSessions).where(eq2(loginSessions.userId, userId)).orderBy(desc(loginSessions.lastActiveAt));
      }
      async getActiveLoginSessions(userId) {
        return db.select().from(loginSessions).where(and(eq2(loginSessions.userId, userId), eq2(loginSessions.isActive, true))).orderBy(desc(loginSessions.lastActiveAt));
      }
      async getLoginSessionByToken(token) {
        const [session2] = await db.select().from(loginSessions).where(eq2(loginSessions.sessionToken, token));
        return session2;
      }
      async getLoginSession(sessionId) {
        const [session2] = await db.select().from(loginSessions).where(eq2(loginSessions.id, sessionId));
        return session2;
      }
      async updateLoginSession(sessionId, data) {
        const [updated] = await db.update(loginSessions).set(data).where(eq2(loginSessions.id, sessionId)).returning();
        return updated;
      }
      async invalidateLoginSession(sessionId) {
        await db.update(loginSessions).set({ isActive: false }).where(eq2(loginSessions.id, sessionId));
      }
      async invalidateAllLoginSessions(userId, exceptSessionId) {
        const conditions = [eq2(loginSessions.userId, userId)];
        if (exceptSessionId) {
          await db.update(loginSessions).set({ isActive: false }).where(and(eq2(loginSessions.userId, userId), sql3`${loginSessions.id} != ${exceptSessionId}`));
        } else {
          await db.update(loginSessions).set({ isActive: false }).where(eq2(loginSessions.userId, userId));
        }
      }
      // ===== TRUSTED DEVICES =====
      async addTrustedDevice(userId, data) {
        const [device] = await db.insert(trustedDevices).values({
          userId,
          ...data
        }).returning();
        return device;
      }
      async getTrustedDevices(userId) {
        return db.select().from(trustedDevices).where(eq2(trustedDevices.userId, userId)).orderBy(desc(trustedDevices.lastUsedAt));
      }
      async getTrustedDevice(deviceId) {
        const [device] = await db.select().from(trustedDevices).where(eq2(trustedDevices.id, deviceId));
        return device;
      }
      async removeTrustedDevice(deviceId) {
        await db.delete(trustedDevices).where(eq2(trustedDevices.id, deviceId));
      }
      async isTrustedDevice(userId, deviceId) {
        const [device] = await db.select().from(trustedDevices).where(and(eq2(trustedDevices.userId, userId), eq2(trustedDevices.deviceId, deviceId)));
        return !!device;
      }
      // ===== RESTRICTED ACCOUNTS =====
      async restrictAccount(userId, restrictedUserId, reason) {
        const [restricted] = await db.insert(restrictedAccounts).values({
          userId,
          restrictedUserId,
          reason
        }).returning();
        return restricted;
      }
      async unrestrictAccount(userId, restrictedUserId) {
        await db.delete(restrictedAccounts).where(and(eq2(restrictedAccounts.userId, userId), eq2(restrictedAccounts.restrictedUserId, restrictedUserId)));
      }
      async isRestricted(userId, restrictedUserId) {
        const [record] = await db.select().from(restrictedAccounts).where(and(eq2(restrictedAccounts.userId, userId), eq2(restrictedAccounts.restrictedUserId, restrictedUserId)));
        return !!record;
      }
      async getRestrictedAccounts(userId) {
        const result = await db.select({ users }).from(restrictedAccounts).innerJoin(users, eq2(restrictedAccounts.restrictedUserId, users.id)).where(eq2(restrictedAccounts.userId, userId));
        return result.map((r) => r.users);
      }
      // ===== MUTED ACCOUNTS =====
      async muteAccount(userId, mutedUserId, options) {
        const [muted] = await db.insert(mutedAccounts).values({
          userId,
          mutedUserId,
          mutePosts: options?.mutePosts ?? true,
          muteStories: options?.muteStories ?? true,
          muteMessages: options?.muteMessages ?? false
        }).returning();
        return muted;
      }
      async unmuteAccount(userId, mutedUserId) {
        await db.delete(mutedAccounts).where(and(eq2(mutedAccounts.userId, userId), eq2(mutedAccounts.mutedUserId, mutedUserId)));
      }
      async isMuted(userId, mutedUserId) {
        const [record] = await db.select().from(mutedAccounts).where(and(eq2(mutedAccounts.userId, userId), eq2(mutedAccounts.mutedUserId, mutedUserId)));
        return !!record;
      }
      async getMutedAccounts(userId) {
        return db.select().from(mutedAccounts).where(eq2(mutedAccounts.userId, userId)).orderBy(desc(mutedAccounts.createdAt));
      }
      // ===== KEYWORD FILTERS =====
      async addKeywordFilter(userId, keyword, options) {
        const [filter] = await db.insert(keywordFilters).values({
          userId,
          keyword: keyword.toLowerCase().trim(),
          filterComments: options?.filterComments ?? true,
          filterMessages: options?.filterMessages ?? true,
          filterPosts: options?.filterPosts ?? false
        }).returning();
        return filter;
      }
      async getKeywordFilters(userId) {
        return db.select().from(keywordFilters).where(eq2(keywordFilters.userId, userId)).orderBy(desc(keywordFilters.createdAt));
      }
      async getKeywordFilter(filterId) {
        const [filter] = await db.select().from(keywordFilters).where(eq2(keywordFilters.id, filterId));
        return filter;
      }
      async updateKeywordFilter(filterId, data) {
        const [updated] = await db.update(keywordFilters).set(data).where(eq2(keywordFilters.id, filterId)).returning();
        return updated;
      }
      async removeKeywordFilter(filterId) {
        await db.delete(keywordFilters).where(eq2(keywordFilters.id, filterId));
      }
      // ===== DRAFTS =====
      async createDraft(userId, data) {
        const [draft] = await db.insert(drafts).values({
          userId,
          type: data.type || "TEXT",
          content: data.content,
          caption: data.caption,
          mediaUrl: data.mediaUrl,
          thumbnailUrl: data.thumbnailUrl,
          durationMs: data.durationMs,
          aspectRatio: data.aspectRatio,
          visibility: data.visibility || "PUBLIC",
          commentsEnabled: data.commentsEnabled ?? true
        }).returning();
        return draft;
      }
      async getDraft(draftId) {
        const [draft] = await db.select().from(drafts).where(eq2(drafts.id, draftId));
        return draft;
      }
      async getUserDrafts(userId) {
        return db.select().from(drafts).where(eq2(drafts.userId, userId)).orderBy(desc(drafts.updatedAt));
      }
      async updateDraft(draftId, data) {
        const [updated] = await db.update(drafts).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(drafts.id, draftId)).returning();
        return updated;
      }
      async deleteDraft(draftId) {
        await db.delete(drafts).where(eq2(drafts.id, draftId));
      }
      // ===== SCHEDULED POSTS =====
      async createScheduledPost(userId, data) {
        const [scheduled] = await db.insert(scheduledPosts).values({
          userId,
          type: data.type || "TEXT",
          content: data.content,
          caption: data.caption,
          mediaUrl: data.mediaUrl,
          thumbnailUrl: data.thumbnailUrl,
          durationMs: data.durationMs,
          aspectRatio: data.aspectRatio,
          visibility: data.visibility || "PUBLIC",
          commentsEnabled: data.commentsEnabled ?? true,
          scheduledFor: data.scheduledFor
        }).returning();
        return scheduled;
      }
      async getScheduledPost(postId) {
        const [scheduled] = await db.select().from(scheduledPosts).where(eq2(scheduledPosts.id, postId));
        return scheduled;
      }
      async getUserScheduledPosts(userId) {
        return db.select().from(scheduledPosts).where(eq2(scheduledPosts.userId, userId)).orderBy(scheduledPosts.scheduledFor);
      }
      async updateScheduledPost(postId, data) {
        const [updated] = await db.update(scheduledPosts).set(data).where(eq2(scheduledPosts.id, postId)).returning();
        return updated;
      }
      async deleteScheduledPost(postId) {
        await db.delete(scheduledPosts).where(eq2(scheduledPosts.id, postId));
      }
      async getPendingScheduledPosts(before) {
        return db.select().from(scheduledPosts).where(and(
          eq2(scheduledPosts.status, "PENDING"),
          lte(scheduledPosts.scheduledFor, before)
        )).orderBy(scheduledPosts.scheduledFor);
      }
      // ===== CLOSE FRIENDS =====
      async addCloseFriend(userId, friendId) {
        const [friend] = await db.insert(closeFriends).values({
          userId,
          friendId
        }).returning();
        return friend;
      }
      async removeCloseFriend(userId, friendId) {
        await db.delete(closeFriends).where(and(eq2(closeFriends.userId, userId), eq2(closeFriends.friendId, friendId)));
      }
      async isCloseFriend(userId, friendId) {
        const [record] = await db.select().from(closeFriends).where(and(eq2(closeFriends.userId, userId), eq2(closeFriends.friendId, friendId)));
        return !!record;
      }
      async getCloseFriends(userId) {
        const result = await db.select({ users }).from(closeFriends).innerJoin(users, eq2(closeFriends.friendId, users.id)).where(eq2(closeFriends.userId, userId));
        return result.map((r) => r.users);
      }
      // ===== STORY VIEWER RESTRICTIONS =====
      async addStoryViewerRestriction(userId, restrictedViewerId) {
        const [restriction] = await db.insert(storyViewerRestrictions).values({
          userId,
          restrictedViewerId
        }).returning();
        return restriction;
      }
      async removeStoryViewerRestriction(userId, restrictedViewerId) {
        await db.delete(storyViewerRestrictions).where(and(eq2(storyViewerRestrictions.userId, userId), eq2(storyViewerRestrictions.restrictedViewerId, restrictedViewerId)));
      }
      async isStoryViewerRestricted(userId, viewerId) {
        const [record] = await db.select().from(storyViewerRestrictions).where(and(eq2(storyViewerRestrictions.userId, userId), eq2(storyViewerRestrictions.restrictedViewerId, viewerId)));
        return !!record;
      }
      async getStoryViewerRestrictions(userId) {
        const result = await db.select({ users }).from(storyViewerRestrictions).innerJoin(users, eq2(storyViewerRestrictions.restrictedViewerId, users.id)).where(eq2(storyViewerRestrictions.userId, userId));
        return result.map((r) => r.users);
      }
      // ===== ADMIN USER NOTES =====
      async addAdminUserNote(userId, adminId, content) {
        const [note] = await db.insert(adminUserNotes).values({
          userId,
          adminId,
          content
        }).returning();
        return note;
      }
      async getAdminUserNotes(userId) {
        return db.select().from(adminUserNotes).where(eq2(adminUserNotes.userId, userId)).orderBy(desc(adminUserNotes.createdAt));
      }
      async updateAdminUserNote(noteId, data) {
        const [updated] = await db.update(adminUserNotes).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(adminUserNotes.id, noteId)).returning();
        return updated;
      }
      async deleteAdminUserNote(noteId) {
        await db.delete(adminUserNotes).where(eq2(adminUserNotes.id, noteId));
      }
      // ===== DATA EXPORT REQUESTS =====
      async createDataExportRequest(userId, options) {
        const [request] = await db.insert(dataExportRequests).values({
          userId,
          includeProfile: options.includeProfile ?? true,
          includePosts: options.includePosts ?? true,
          includeMessages: options.includeMessages ?? true,
          includeMedia: options.includeMedia ?? false
        }).returning();
        return request;
      }
      async getDataExportRequest(requestId) {
        const [request] = await db.select().from(dataExportRequests).where(eq2(dataExportRequests.id, requestId));
        return request;
      }
      async getUserDataExportRequests(userId) {
        return db.select().from(dataExportRequests).where(eq2(dataExportRequests.userId, userId)).orderBy(desc(dataExportRequests.createdAt));
      }
      async updateDataExportRequest(requestId, data) {
        const [updated] = await db.update(dataExportRequests).set(data).where(eq2(dataExportRequests.id, requestId)).returning();
        return updated;
      }
      async getPendingDataExportRequests() {
        return db.select().from(dataExportRequests).where(eq2(dataExportRequests.status, "PENDING")).orderBy(dataExportRequests.createdAt);
      }
      async triggerDataExport(userId, triggeredBy) {
        const [request] = await db.insert(dataExportRequests).values({
          userId,
          includeProfile: true,
          includePosts: true,
          includeMessages: true,
          includeMedia: true
        }).returning();
        return request;
      }
      // ===== GOSSIP (Anonymous Posts) =====
      async createGossipPost(authorId, type, data) {
        const [post] = await db.insert(gossipPosts).values({
          authorUserId: authorId,
          type,
          text: data.text,
          mediaUrl: data.mediaUrl,
          thumbnailUrl: data.thumbnailUrl,
          durationMs: data.durationMs
        }).returning();
        return post;
      }
      async getGossipPosts(limit = 50, offset = 0) {
        return db.select().from(gossipPosts).where(eq2(gossipPosts.isDeleted, false)).orderBy(desc(gossipPosts.createdAt)).limit(limit).offset(offset);
      }
      async getGossipPost(id) {
        const [post] = await db.select().from(gossipPosts).where(and(eq2(gossipPosts.id, id), eq2(gossipPosts.isDeleted, false)));
        return post;
      }
      async deleteGossipPost(id) {
        await db.update(gossipPosts).set({ isDeleted: true }).where(eq2(gossipPosts.id, id));
      }
      async likeGossipPost(userId, postId) {
        const [like3] = await db.insert(gossipLikes).values({
          userId,
          gossipPostId: postId
        }).returning();
        await db.update(gossipPosts).set({ likeCount: sql3`${gossipPosts.likeCount} + 1` }).where(eq2(gossipPosts.id, postId));
        return like3;
      }
      async unlikeGossipPost(userId, postId) {
        await db.delete(gossipLikes).where(and(eq2(gossipLikes.userId, userId), eq2(gossipLikes.gossipPostId, postId)));
        await db.update(gossipPosts).set({ likeCount: sql3`GREATEST(${gossipPosts.likeCount} - 1, 0)` }).where(eq2(gossipPosts.id, postId));
      }
      async hasUserLikedGossipPost(userId, postId) {
        const [like3] = await db.select().from(gossipLikes).where(and(eq2(gossipLikes.userId, userId), eq2(gossipLikes.gossipPostId, postId)));
        return !!like3;
      }
      async createGossipComment(userId, postId, body) {
        const [comment] = await db.insert(gossipComments).values({
          userId,
          gossipPostId: postId,
          body
        }).returning();
        await db.update(gossipPosts).set({ commentCount: sql3`${gossipPosts.commentCount} + 1` }).where(eq2(gossipPosts.id, postId));
        return comment;
      }
      async getGossipComments(postId) {
        const result = await db.select().from(gossipComments).where(eq2(gossipComments.gossipPostId, postId)).orderBy(desc(gossipComments.createdAt));
        return result.map(({ userId, ...safeComment }) => safeComment);
      }
      async retweetGossipPost(userId, postId) {
        const [retweet] = await db.insert(gossipRetweets).values({
          userId,
          originalGossipPostId: postId
        }).returning();
        await db.update(gossipPosts).set({ retweetCount: sql3`${gossipPosts.retweetCount} + 1` }).where(eq2(gossipPosts.id, postId));
        return retweet;
      }
      async unretweetGossipPost(userId, postId) {
        await db.delete(gossipRetweets).where(and(eq2(gossipRetweets.userId, userId), eq2(gossipRetweets.originalGossipPostId, postId)));
        await db.update(gossipPosts).set({ retweetCount: sql3`GREATEST(${gossipPosts.retweetCount} - 1, 0)` }).where(eq2(gossipPosts.id, postId));
      }
      async hasUserRetweetedGossipPost(userId, postId) {
        const [retweet] = await db.select().from(gossipRetweets).where(and(eq2(gossipRetweets.userId, userId), eq2(gossipRetweets.originalGossipPostId, postId)));
        return !!retweet;
      }
      // ===== MALL =====
      async getMallCategories() {
        return db.select().from(mallCategories).where(eq2(mallCategories.isActive, true)).orderBy(mallCategories.name);
      }
      async getMallCategory(id) {
        const [category] = await db.select().from(mallCategories).where(eq2(mallCategories.id, id));
        return category;
      }
      async getMallItems(categoryId) {
        if (categoryId) {
          return db.select().from(mallItems).where(and(eq2(mallItems.categoryId, categoryId), eq2(mallItems.isActive, true))).orderBy(mallItems.value);
        }
        return db.select().from(mallItems).where(eq2(mallItems.isActive, true)).orderBy(mallItems.value);
      }
      // Get ALL mall items including inactive ones (for admin/refresh operations)
      async getAllMallItemsIncludingInactive() {
        return db.select().from(mallItems).orderBy(mallItems.value);
      }
      async getMallItem(id) {
        const [item] = await db.select().from(mallItems).where(eq2(mallItems.id, id));
        return item;
      }
      async purchaseMallItem(userId, itemId, quantity = 1) {
        const item = await this.getMallItem(itemId);
        if (!item) throw new Error("Item not found");
        const pricePerItem = item.coinPrice > 0 ? item.coinPrice : item.value;
        const totalCoinCost = pricePerItem * quantity;
        const netWorthGained = item.value * 10 * quantity;
        if (totalCoinCost <= 0) {
          throw new Error("Item has no valid price");
        }
        await this.deductCoins(userId, totalCoinCost, "PURCHASE", `Mall purchase: ${item.name} x${quantity}`, "mall_item", itemId);
        const [purchase] = await db.insert(mallPurchases).values({
          userId,
          itemId,
          quantity,
          netWorthGained
        }).returning();
        await db.update(users).set({ netWorth: sql3`COALESCE(${users.netWorth}, 0) + ${netWorthGained}` }).where(eq2(users.id, userId));
        await this.addNetWorthEntry(userId, netWorthGained, "MALL_PURCHASE", "mall_item", itemId);
        return purchase;
      }
      // Admin function to add mall product to user
      async adminAddMallProduct(userId, itemId, quantity = 1, adminId) {
        const item = await this.getMallItem(itemId);
        if (!item) throw new Error("Item not found");
        const netWorthGained = item.value * 10 * quantity;
        const [purchase] = await db.insert(mallPurchases).values({
          userId,
          itemId,
          quantity,
          netWorthGained
        }).returning();
        await db.update(users).set({ netWorth: sql3`COALESCE(${users.netWorth}, 0) + ${netWorthGained}` }).where(eq2(users.id, userId));
        await this.addNetWorthEntry(userId, netWorthGained, "MALL_PURCHASE", "mall_item", itemId);
        return purchase;
      }
      // Admin function to remove mall product from user
      async adminRemoveMallProduct(userId, purchaseId, adminId) {
        const [purchase] = await db.select().from(mallPurchases).where(and(eq2(mallPurchases.id, purchaseId), eq2(mallPurchases.userId, userId)));
        if (!purchase) {
          throw new Error("Purchase not found");
        }
        const netWorthToRemove = purchase.netWorthGained || 0;
        await db.delete(mallPurchases).where(eq2(mallPurchases.id, purchaseId));
        await db.update(users).set({ netWorth: sql3`GREATEST(0, COALESCE(${users.netWorth}, 0) - ${netWorthToRemove})` }).where(eq2(users.id, userId));
        await this.addNetWorthEntry(userId, -netWorthToRemove, "ADMIN_ADJUST", "admin", adminId);
        return { removed: true, netWorthReduced: netWorthToRemove };
      }
      // Admin function to remove all mall products from user
      async adminRemoveAllMallProducts(userId, adminId) {
        const purchases = await db.select().from(mallPurchases).where(eq2(mallPurchases.userId, userId));
        if (purchases.length === 0) {
          return { removed: 0, netWorthReduced: 0 };
        }
        const totalNetWorth = purchases.reduce((sum, p) => sum + (p.netWorthGained || 0), 0);
        await db.delete(mallPurchases).where(eq2(mallPurchases.userId, userId));
        await db.update(users).set({ netWorth: sql3`GREATEST(0, COALESCE(${users.netWorth}, 0) - ${totalNetWorth})` }).where(eq2(users.id, userId));
        await this.addNetWorthEntry(userId, -totalNetWorth, "ADMIN_ADJUST", "admin", adminId);
        return { removed: purchases.length, netWorthReduced: totalNetWorth };
      }
      async getUserPurchases(userId) {
        const result = await db.select({
          purchase: mallPurchases,
          item: mallItems
        }).from(mallPurchases).innerJoin(mallItems, eq2(mallPurchases.itemId, mallItems.id)).where(eq2(mallPurchases.userId, userId)).orderBy(desc(mallPurchases.createdAt));
        return result.map((r) => ({ ...r.purchase, item: r.item }));
      }
      async getTop50WealthyUsers() {
        return db.select({
          id: users.id,
          username: users.username,
          displayName: users.displayName,
          avatarUrl: users.avatarUrl,
          netWorth: users.netWorth,
          isVerified: users.isVerified
        }).from(users).leftJoin(userSettings, eq2(users.id, userSettings.userId)).where(and(
          isNull(users.deactivatedAt),
          isNotNull(users.netWorth),
          or(isNull(userSettings.privateAccount), eq2(userSettings.privateAccount, false))
        )).orderBy(desc(users.netWorth)).limit(50);
      }
      async getUserWealthRank(userId) {
        const user = await this.getUser(userId);
        if (!user || user.netWorth === null) {
          return null;
        }
        const result = await db.select({ count: sql3`count(*)::int` }).from(users).leftJoin(userSettings, eq2(users.id, userSettings.userId)).where(and(
          isNull(users.deactivatedAt),
          isNotNull(users.netWorth),
          gt(users.netWorth, user.netWorth),
          or(isNull(userSettings.privateAccount), eq2(userSettings.privateAccount, false))
        ));
        const countAbove = Number(result[0]?.count || 0);
        return countAbove + 1;
      }
      async addNetWorthEntry(userId, delta, reason, refType, refId) {
        const [entry] = await db.insert(netWorthLedger).values({
          userId,
          delta,
          reason,
          refType,
          refId
        }).returning();
        return entry;
      }
      async getNetWorthHistory(userId, limit = 50) {
        return db.select().from(netWorthLedger).where(eq2(netWorthLedger.userId, userId)).orderBy(desc(netWorthLedger.createdAt)).limit(limit);
      }
      async createMallCategory(data) {
        const [category] = await db.insert(mallCategories).values({
          name: data.name,
          description: data.description
        }).returning();
        return category;
      }
      async updateMallCategory(id, data) {
        const updateData = {};
        if (data.name !== void 0) updateData.name = data.name;
        if (data.description !== void 0) updateData.description = data.description;
        if (data.isActive !== void 0) updateData.isActive = data.isActive;
        if (Object.keys(updateData).length === 0) return this.getMallCategory(id);
        const [category] = await db.update(mallCategories).set(updateData).where(eq2(mallCategories.id, id)).returning();
        return category;
      }
      async deleteMallCategory(id) {
        await db.delete(mallCategories).where(eq2(mallCategories.id, id));
      }
      async createMallItem(data) {
        const [item] = await db.insert(mallItems).values({
          name: data.name,
          description: data.description,
          value: data.value,
          imageUrl: data.imageUrl,
          categoryId: data.categoryId
        }).returning();
        return item;
      }
      async updateMallItem(id, data) {
        const updateData = {};
        if (data.name !== void 0) updateData.name = data.name;
        if (data.description !== void 0) updateData.description = data.description;
        if (data.value !== void 0) updateData.value = data.value;
        if (data.coinPrice !== void 0) updateData.coinPrice = data.coinPrice;
        if (data.imageUrl !== void 0) updateData.imageUrl = data.imageUrl;
        if (data.categoryId !== void 0) updateData.categoryId = data.categoryId;
        if (data.isActive !== void 0) updateData.isActive = data.isActive;
        updateData.updatedAt = /* @__PURE__ */ new Date();
        if (Object.keys(updateData).length === 1) return this.getMallItem(id);
        const [item] = await db.update(mallItems).set(updateData).where(eq2(mallItems.id, id)).returning();
        return item;
      }
      // Fix all mall items with coinPrice = 0 to use their value as coinPrice (1 coin = R1)
      async fixAllMallItemPrices() {
        const allItems = await this.getAllMallItemsIncludingInactive();
        let fixed = 0;
        for (const item of allItems) {
          if (!item.coinPrice || item.coinPrice === 0) {
            await db.update(mallItems).set({ coinPrice: item.value, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(mallItems.id, item.id));
            fixed++;
          }
        }
        return { fixed, total: allItems.length };
      }
      async deleteMallItem(id) {
        await db.delete(mallItems).where(eq2(mallItems.id, id));
      }
      async getAllMallPurchases() {
        const result = await db.select({
          purchase: mallPurchases,
          item: mallItems,
          buyer: users
        }).from(mallPurchases).innerJoin(mallItems, eq2(mallPurchases.itemId, mallItems.id)).innerJoin(users, eq2(mallPurchases.userId, users.id)).orderBy(desc(mallPurchases.createdAt));
        return result.map((r) => ({ ...r.purchase, item: r.item, buyer: r.buyer }));
      }
      // ===== MESSAGES INBOX =====
      async getUserConversationsByFolder(userId, folder) {
        const result = await db.select().from(conversations).where(and(
          or(eq2(conversations.participant1Id, userId), eq2(conversations.participant2Id, userId)),
          eq2(conversations.status, "ACCEPTED"),
          eq2(conversations.inboxFolder, folder)
        )).orderBy(desc(conversations.lastMessageAt));
        const enriched = [];
        for (const conv of result) {
          const [participant1] = await db.select().from(users).where(eq2(users.id, conv.participant1Id));
          const [participant2] = await db.select().from(users).where(eq2(users.id, conv.participant2Id));
          if (participant1 && participant2) {
            enriched.push({ ...conv, participant1, participant2 });
          }
        }
        return enriched;
      }
      async getMessageRequests(userId) {
        const result = await db.select().from(conversations).where(and(
          or(eq2(conversations.participant1Id, userId), eq2(conversations.participant2Id, userId)),
          eq2(conversations.status, "REQUEST")
        )).orderBy(desc(conversations.lastMessageAt));
        const enriched = [];
        for (const conv of result) {
          const [participant1] = await db.select().from(users).where(eq2(users.id, conv.participant1Id));
          const [participant2] = await db.select().from(users).where(eq2(users.id, conv.participant2Id));
          if (participant1 && participant2) {
            enriched.push({ ...conv, participant1, participant2 });
          }
        }
        return enriched;
      }
      async acceptMessageRequest(conversationId, userId) {
        const [updated] = await db.update(conversations).set({
          status: "ACCEPTED",
          acceptedAt: /* @__PURE__ */ new Date(),
          inboxFolder: "PRIMARY"
        }).where(eq2(conversations.id, conversationId)).returning();
        return updated;
      }
      async declineMessageRequest(conversationId) {
        await db.delete(conversations).where(eq2(conversations.id, conversationId));
      }
      async updateConversationFolder(conversationId, folder) {
        const [updated] = await db.update(conversations).set({ inboxFolder: folder }).where(eq2(conversations.id, conversationId)).returning();
        return updated;
      }
      // ===== DISCOVER =====
      async getNewPeopleToFollow(userId, limit = 20) {
        const following = await this.getFollowing(userId);
        const followingIds = following.map((u) => u.id);
        followingIds.push(userId);
        const hiddenIds = await this.getHiddenUserIds(userId);
        const excludeIds = [.../* @__PURE__ */ new Set([...followingIds, ...hiddenIds])];
        const fetchLimit = limit * 3;
        let candidates;
        if (excludeIds.length === 0) {
          candidates = await db.select().from(users).where(isNull(users.deactivatedAt)).orderBy(
            desc(users.isVerified),
            desc(users.netWorth),
            desc(users.influenceScore),
            desc(users.createdAt)
          ).limit(fetchLimit);
        } else {
          candidates = await db.select().from(users).where(and(
            isNull(users.deactivatedAt),
            sql3`${users.id} NOT IN (${sql3.raw(excludeIds.map((id) => `'${id}'`).join(","))})`
          )).orderBy(
            desc(users.isVerified),
            desc(users.netWorth),
            desc(users.influenceScore),
            desc(users.createdAt)
          ).limit(fetchLimit);
        }
        const scoredCandidates = candidates.map((user) => ({
          ...user,
          id: user.id,
          authorId: user.id,
          // For diversity engine compatibility
          score: (user.isVerified ? 100 : 0) + Math.min((user.netWorth || 0) / 1e5, 50) + Math.min((user.influenceScore || 0) / 1e3, 30)
        }));
        const shuffled = diversifyFeed(scoredCandidates, {
          minSpacing: 2,
          maxPerCreator: 1,
          // Each user appears only once anyway
          useScoreWeighting: true,
          shuffleTiers: true
        });
        return shuffled.slice(0, limit);
      }
      async getReelsPosts(limit = 20, offset = 0) {
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(and(
          eq2(posts.type, "VIDEO"),
          eq2(posts.visibility, "PUBLIC"),
          isNull(posts.deletedAt)
        )).orderBy(desc(posts.createdAt)).limit(limit).offset(offset);
        return result.map((r) => ({
          ...r.posts,
          user: {
            id: r.users.id,
            username: r.users.username,
            displayName: r.users.displayName,
            avatarUrl: r.users.avatarUrl,
            isVerified: r.users.isVerified
          }
        }));
      }
      async getAlgorithmReelsPosts(userId, limit = 50, offset = 0) {
        const fetchLimit = Math.max(limit * 4, 100);
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(and(
          eq2(posts.type, "VIDEO"),
          eq2(posts.visibility, "PUBLIC"),
          isNull(posts.deletedAt)
        )).orderBy(
          desc(users.isVerified),
          desc(users.netWorth),
          desc(users.influenceScore),
          desc(sql3`${posts.likesCount} + ${posts.commentsCount} * 2 + ${posts.sharesCount} * 3`),
          desc(posts.createdAt)
        ).limit(fetchLimit);
        const candidates = result.map((r) => {
          const engagement = (r.posts.likesCount || 0) + (r.posts.commentsCount || 0) * 2 + (r.posts.sharesCount || 0) * 3;
          return {
            id: r.posts.id,
            authorId: r.posts.authorId,
            score: (r.users.isVerified ? 100 : 0) + Math.min((r.users.netWorth || 0) / 1e5, 50) + Math.min((r.users.influenceScore || 0) / 1e3, 30) + Math.min(engagement / 10, 20),
            post: r.posts,
            user: {
              id: r.users.id,
              username: r.users.username,
              displayName: r.users.displayName,
              avatarUrl: r.users.avatarUrl,
              isVerified: r.users.isVerified,
              netWorth: r.users.netWorth,
              influenceScore: r.users.influenceScore
            }
          };
        });
        const diversified = diversifyFeed(candidates, {
          minSpacing: 5,
          // At least 5 reels between same creator
          maxPerCreator: 3,
          // Max 3 reels per creator
          useScoreWeighting: true,
          shuffleTiers: true
        });
        const paginated = diversified.slice(offset, offset + limit);
        return paginated.map((item) => ({
          ...item.post,
          user: item.user
        }));
      }
      async getExplorePosts(userId, limit = 200, offset = 0) {
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(and(
          eq2(posts.visibility, "PUBLIC"),
          isNull(posts.deletedAt),
          ne(posts.authorId, userId),
          or(eq2(posts.type, "PHOTO"), eq2(posts.type, "VIDEO"))
        )).orderBy(desc(posts.createdAt)).limit(limit).offset(offset);
        return result.map((r) => ({
          ...r.posts,
          user: {
            id: r.users.id,
            username: r.users.username,
            displayName: r.users.displayName,
            avatarUrl: r.users.avatarUrl,
            isVerified: r.users.isVerified
          }
        }));
      }
      async getVoicePosts(userId, limit = 30, offset = 0) {
        const fetchLimit = Math.max(limit * 4, 80);
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(and(
          eq2(posts.type, "VOICE"),
          eq2(posts.visibility, "PUBLIC"),
          isNull(posts.deletedAt)
        )).orderBy(
          desc(users.isVerified),
          desc(users.netWorth),
          desc(users.influenceScore),
          desc(sql3`${posts.likesCount} + ${posts.commentsCount} * 2 + ${posts.sharesCount} * 3`),
          desc(posts.createdAt)
        ).limit(fetchLimit);
        const candidates = result.map((r) => {
          const engagement = (r.posts.likesCount || 0) + (r.posts.commentsCount || 0) * 2 + (r.posts.sharesCount || 0) * 3;
          return {
            id: r.posts.id,
            authorId: r.posts.authorId,
            score: (r.users.isVerified ? 100 : 0) + Math.min((r.users.netWorth || 0) / 1e5, 50) + Math.min((r.users.influenceScore || 0) / 1e3, 30) + Math.min(engagement / 10, 20),
            post: r.posts,
            user: {
              id: r.users.id,
              username: r.users.username,
              displayName: r.users.displayName,
              avatarUrl: r.users.avatarUrl,
              isVerified: r.users.isVerified,
              netWorth: r.users.netWorth,
              influenceScore: r.users.influenceScore
            }
          };
        });
        const diversified = diversifyFeed(candidates, {
          minSpacing: 4,
          // At least 4 voice notes between same creator
          maxPerCreator: 3,
          // Max 3 voice notes per creator
          useScoreWeighting: true,
          shuffleTiers: true
        });
        const paginated = diversified.slice(offset, offset + limit);
        return paginated.map((item) => ({
          ...item.post,
          user: item.user
        }));
      }
      async getTrendingTopics(limit = 10) {
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3);
        return db.select().from(trendsDaily).where(gte(trendsDaily.windowStart, oneDayAgo)).orderBy(desc(trendsDaily.score)).limit(limit);
      }
      async getTrendingPosts(limit = 20) {
        const result = await db.select().from(posts).innerJoin(users, eq2(posts.authorId, users.id)).where(
          and(
            eq2(posts.visibility, "PUBLIC"),
            isNull(posts.deletedAt)
          )
        ).orderBy(
          desc(sql3`(${posts.likesCount} * 3 + ${posts.commentsCount} * 2 + ${posts.sharesCount} * 4 + ${posts.viewsCount})`)
        ).limit(limit);
        return result.map((r) => ({
          ...r.posts,
          author: {
            id: r.users.id,
            username: r.users.username,
            displayName: r.users.displayName,
            avatarUrl: r.users.avatarUrl,
            isVerified: r.users.isVerified,
            netWorth: r.users.netWorth,
            influenceScore: r.users.influenceScore
          },
          engagement: r.posts.likesCount * 3 + r.posts.commentsCount * 2 + r.posts.sharesCount * 4 + r.posts.viewsCount
        }));
      }
      // ===== HIDDEN POSTS (Hide from feed) =====
      async hidePostFromFeed(userId, postId, reason) {
        await db.insert(hiddenPosts).values({ userId, postId, reason }).onConflictDoNothing();
      }
      async unhidePostFromFeed(userId, postId) {
        await db.delete(hiddenPosts).where(and(eq2(hiddenPosts.userId, userId), eq2(hiddenPosts.postId, postId)));
      }
      async getHiddenPostIds(userId) {
        const result = await db.select({ postId: hiddenPosts.postId }).from(hiddenPosts).where(eq2(hiddenPosts.userId, userId));
        return result.map((r) => r.postId);
      }
      async isPostHiddenByUser(userId, postId) {
        const [result] = await db.select().from(hiddenPosts).where(and(eq2(hiddenPosts.userId, userId), eq2(hiddenPosts.postId, postId)));
        return !!result;
      }
      // ===== NOT INTERESTED POSTS =====
      async markNotInterested(userId, postId, reason) {
        await db.insert(notInterestedPosts).values({ userId, postId, reason }).onConflictDoNothing();
      }
      async unmarkNotInterested(userId, postId) {
        await db.delete(notInterestedPosts).where(and(eq2(notInterestedPosts.userId, userId), eq2(notInterestedPosts.postId, postId)));
      }
      async getNotInterestedPostIds(userId) {
        const result = await db.select({ postId: notInterestedPosts.postId }).from(notInterestedPosts).where(eq2(notInterestedPosts.userId, userId));
        return result.map((r) => r.postId);
      }
      async isNotInterested(userId, postId) {
        const [result] = await db.select().from(notInterestedPosts).where(and(eq2(notInterestedPosts.userId, userId), eq2(notInterestedPosts.postId, postId)));
        return !!result;
      }
      // ===== DISCOVERY NOT INTERESTED (Content + Creators) =====
      async markDiscoveryNotInterested(userId, targetId, targetType, reason) {
        await db.execute(sql3`
      INSERT INTO not_interested (id, user_id, target_type, target_id, reason)
      VALUES (${crypto.randomUUID()}, ${userId}, ${targetType}, ${targetId}, ${reason || null})
      ON CONFLICT ON CONSTRAINT not_interested_user_target DO NOTHING
    `);
      }
      async unmarkDiscoveryNotInterested(userId, targetId, targetType) {
        await db.execute(sql3`
      DELETE FROM not_interested 
      WHERE user_id = ${userId} AND target_type = ${targetType} AND target_id = ${targetId}
    `);
      }
      async getNotInterestedCreatorIds(userId) {
        const result = await db.execute(sql3`
      SELECT target_id FROM not_interested 
      WHERE user_id = ${userId} AND target_type = 'CREATOR'
    `);
        return result.rows.map((r) => r.target_id);
      }
      async getNotInterestedContentIds(userId) {
        const result = await db.execute(sql3`
      SELECT target_id FROM not_interested 
      WHERE user_id = ${userId} AND target_type = 'CONTENT'
    `);
        return result.rows.map((r) => r.target_id);
      }
      async getNotInterestedItems(userId) {
        const result = await db.execute(sql3`
      SELECT target_id, target_type FROM not_interested 
      WHERE user_id = ${userId}
    `);
        const content = [];
        const creators = [];
        result.rows.forEach((row) => {
          if (row.target_type === "CONTENT") {
            content.push(row.target_id);
          } else if (row.target_type === "CREATOR") {
            creators.push(row.target_id);
          }
        });
        return { content, creators };
      }
      // ===== POST OWNER ACTIONS =====
      async archivePost(postId, authorId) {
        const [post] = await db.update(posts).set({ isArchived: true, archivedAt: /* @__PURE__ */ new Date() }).where(and(eq2(posts.id, postId), eq2(posts.authorId, authorId))).returning();
        return post;
      }
      async unarchivePost(postId, authorId) {
        const [post] = await db.update(posts).set({ isArchived: false, archivedAt: null }).where(and(eq2(posts.id, postId), eq2(posts.authorId, authorId))).returning();
        return post;
      }
      async pinPost(postId, authorId) {
        return await db.transaction(async (tx) => {
          await tx.update(posts).set({ isPinned: false, pinnedAt: null }).where(and(eq2(posts.authorId, authorId), eq2(posts.isPinned, true)));
          const [post] = await tx.update(posts).set({ isPinned: true, pinnedAt: /* @__PURE__ */ new Date() }).where(and(eq2(posts.id, postId), eq2(posts.authorId, authorId))).returning();
          return post;
        });
      }
      async unpinPost(postId, authorId) {
        const [post] = await db.update(posts).set({ isPinned: false, pinnedAt: null }).where(and(eq2(posts.id, postId), eq2(posts.authorId, authorId))).returning();
        return post;
      }
      async deletePostPermanently(postId, authorId) {
        const [post] = await db.select().from(posts).where(and(eq2(posts.id, postId), eq2(posts.authorId, authorId)));
        if (!post) return false;
        await db.transaction(async (tx) => {
          await tx.delete(likes).where(eq2(likes.postId, postId));
          await tx.delete(comments).where(eq2(comments.postId, postId));
          await tx.delete(bookmarks).where(eq2(bookmarks.postId, postId));
          await tx.delete(shares).where(eq2(shares.postId, postId));
          await tx.delete(postViews).where(eq2(postViews.postId, postId));
          await tx.delete(playlistItems).where(eq2(playlistItems.postId, postId));
          await tx.delete(pins).where(eq2(pins.postId, postId));
          await tx.delete(postCollaborators).where(eq2(postCollaborators.postId, postId));
          await tx.delete(pendingTagApprovals).where(eq2(pendingTagApprovals.postId, postId));
          await tx.delete(savedPosts).where(eq2(savedPosts.postId, postId));
          await tx.delete(hiddenPosts).where(eq2(hiddenPosts.postId, postId));
          await tx.delete(notInterestedPosts).where(eq2(notInterestedPosts.postId, postId));
          await tx.delete(posts).where(eq2(posts.id, postId));
        });
        return true;
      }
      async editPost(postId, authorId, updates) {
        const [post] = await db.update(posts).set({
          ...updates,
          editedAt: /* @__PURE__ */ new Date()
        }).where(and(eq2(posts.id, postId), eq2(posts.authorId, authorId))).returning();
        return post;
      }
      async toggleComments(postId, authorId, enabled) {
        const [post] = await db.update(posts).set({ commentsEnabled: enabled }).where(and(eq2(posts.id, postId), eq2(posts.authorId, authorId))).returning();
        return post;
      }
      // ===== SAVED POSTS (using savedPosts table) =====
      async isPostSaved(userId, postId) {
        const result = await db.select().from(savedPosts).where(and(eq2(savedPosts.postId, postId), eq2(savedPosts.userId, userId)));
        return result.length > 0;
      }
      async getSavedPosts(userId) {
        const result = await db.select().from(savedPosts).innerJoin(posts, eq2(savedPosts.postId, posts.id)).innerJoin(users, eq2(posts.authorId, users.id)).where(eq2(savedPosts.userId, userId)).orderBy(desc(savedPosts.createdAt));
        return result.map((r) => ({ ...r.posts, author: r.users }));
      }
      /**
       * Facebook/Instagram/TikTok-Style People Discovery Algorithm
       * 
       * Based on Meta's transparency docs and industry research, this algorithm scores users on:
       * 
       * TIER 1 - SOCIAL GRAPH (Highest Weight - 40%)
       * - Mutual connections (friends-of-friends) - strongest signal
       * - 2nd degree network (followers of your followers)
       * - People who follow you but you don't follow back
       * 
       * TIER 2 - ENGAGEMENT OVERLAP (25%)
       * - Users who like/comment on same posts as you
       * - Users who interact with same creators
       * - Content affinity (similar post types)
       * 
       * TIER 3 - PROFILE SIMILARITY (20%)
       * - Bio keyword matching
       * - Location proximity
       * - Interests overlap
       * - Similar net worth tier (RabitChat elite focus)
       * 
       * TIER 4 - USER QUALITY SIGNALS (15%)
       * - Verified status
       * - Profile completeness
       * - Activity recency
       * - Follower-to-following ratio
       * - Engagement rate
       */
      async getSuggestedPeople(userId, limit = 30) {
        try {
          const [currentUser] = await db.select().from(users).where(eq2(users.id, userId));
          if (!currentUser) throw new Error("User not found");
          const following = await this.getFollowing(userId);
          const followingIds = new Set(following.map((u) => u.id));
          const followers = await this.getFollowers(userId);
          const followerIds = new Set(followers.map((u) => u.id));
          const hiddenIds = await this.getHiddenUserIds(userId);
          const excludeIds = /* @__PURE__ */ new Set([...followingIds, userId, ...hiddenIds]);
          const secondDegreeIds = /* @__PURE__ */ new Set();
          const secondDegreeCounts = /* @__PURE__ */ new Map();
          for (const followedUser of following.slice(0, 50)) {
            const theirFollowing = await this.getFollowing(followedUser.id);
            for (const user of theirFollowing) {
              if (!excludeIds.has(user.id)) {
                secondDegreeIds.add(user.id);
                secondDegreeCounts.set(user.id, (secondDegreeCounts.get(user.id) || 0) + 1);
              }
            }
          }
          const pendingFollowBacks = followers.filter((f) => !followingIds.has(f.id));
          const userRecentLikes = await db.select({ postId: likes.postId }).from(likes).where(and(
            eq2(likes.userId, userId),
            gt(likes.createdAt, new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3))
          )).limit(100);
          const likedPostIds = userRecentLikes.map((l) => l.postId);
          const engagementOverlapUsers = /* @__PURE__ */ new Map();
          if (likedPostIds.length > 0) {
            const otherLikers = await db.select({ userId: likes.userId }).from(likes).where(and(
              inArray(likes.postId, likedPostIds),
              ne(likes.userId, userId)
            )).limit(500);
            for (const liker of otherLikers) {
              if (!excludeIds.has(liker.userId)) {
                engagementOverlapUsers.set(liker.userId, (engagementOverlapUsers.get(liker.userId) || 0) + 1);
              }
            }
          }
          let fallbackCandidates = [];
          if (secondDegreeIds.size < limit * 2) {
            fallbackCandidates = await db.select().from(users).where(and(
              isNull(users.deactivatedAt),
              ne(users.id, userId)
            )).orderBy(desc(users.influenceScore)).limit(limit * 3);
          }
          const fourteenDaysAgo = new Date(Date.now() - 14 * 24 * 60 * 60 * 1e3);
          const newUsers = await db.select().from(users).where(and(
            isNull(users.deactivatedAt),
            ne(users.id, userId),
            gt(users.createdAt, fourteenDaysAgo)
          )).orderBy(desc(users.createdAt)).limit(Math.ceil(limit / 3));
          const myPosts = await db.select({ id: posts.id }).from(posts).where(eq2(posts.authorId, userId)).limit(50);
          const myPostIds = myPosts.map((p) => p.id);
          const engagedWithMeUsers = /* @__PURE__ */ new Set();
          if (myPostIds.length > 0) {
            const recentEngagers = await db.select({ userId: likes.userId }).from(likes).where(and(
              inArray(likes.postId, myPostIds),
              ne(likes.userId, userId),
              gt(likes.createdAt, new Date(Date.now() - 14 * 24 * 60 * 60 * 1e3))
            )).limit(100);
            for (const engager of recentEngagers) {
              if (!excludeIds.has(engager.userId)) {
                engagedWithMeUsers.add(engager.userId);
              }
            }
          }
          const allCandidateIds = /* @__PURE__ */ new Set([
            ...secondDegreeIds,
            ...pendingFollowBacks.map((u) => u.id),
            ...engagementOverlapUsers.keys(),
            ...fallbackCandidates.map((u) => u.id),
            ...newUsers.map((u) => u.id),
            // NEW: Fresh accounts
            ...engagedWithMeUsers
            // NEW: People who engaged with you
          ]);
          for (const id of excludeIds) {
            allCandidateIds.delete(id);
          }
          if (allCandidateIds.size === 0) {
            return [];
          }
          const candidates = await db.select().from(users).where(and(
            inArray(users.id, [...allCandidateIds]),
            isNull(users.deactivatedAt)
          )).limit(limit * 5);
          const scoredCandidates = await Promise.all(candidates.map(async (candidate) => {
            try {
              let score = 0;
              const scoreBreakdown = {};
              const candidateFollowers = await this.getFollowers(candidate.id);
              const candidateFollowing = await this.getFollowing(candidate.id);
              const candidateFollowerIds = new Set(candidateFollowers.map((u) => u.id));
              const candidateFollowingIds = new Set(candidateFollowing.map((u) => u.id));
              const mutualFollowers = candidateFollowers.filter(
                (f) => followingIds.has(f.id) || followerIds.has(f.id)
              );
              const mutualScore = Math.min(mutualFollowers.length * 40, 200);
              score += mutualScore;
              scoreBreakdown.mutualConnections = mutualScore;
              const secondDegreePathCount = secondDegreeCounts.get(candidate.id) || 0;
              const secondDegreeScore = Math.min(secondDegreePathCount * 25, 100);
              score += secondDegreeScore;
              scoreBreakdown.secondDegree = secondDegreeScore;
              const followsYou = candidateFollowingIds.has(userId);
              if (followsYou) {
                score += 100;
                scoreBreakdown.followsYou = 100;
              }
              const engagementOverlap = engagementOverlapUsers.get(candidate.id) || 0;
              const engagementScore = Math.min(engagementOverlap * 15, 150);
              score += engagementScore;
              scoreBreakdown.engagementOverlap = engagementScore;
              const userBio = (currentUser.bio || "").toLowerCase();
              const candidateBio = (candidate.bio || "").toLowerCase();
              if (userBio && candidateBio) {
                const commonWords = this.findCommonKeywords(userBio, candidateBio);
                const bioScore = Math.min(commonWords * 10, 100);
                score += bioScore;
                scoreBreakdown.bioSimilarity = bioScore;
              }
              const userNetWorth = currentUser.netWorth || 0;
              const candidateNetWorth = candidate.netWorth || 0;
              const wealthTierMatch = this.calculateWealthTierSimilarity(userNetWorth, candidateNetWorth);
              score += wealthTierMatch;
              scoreBreakdown.wealthTier = wealthTierMatch;
              if (candidate.isVerified) {
                score += 50;
                scoreBreakdown.verified = 50;
              }
              const profileScore = this.calculateProfileCompleteness(candidate);
              score += profileScore;
              scoreBreakdown.profileComplete = profileScore;
              const lastActive = candidate.lastActiveAt || candidate.createdAt;
              const daysSinceActive = Math.floor((Date.now() - new Date(lastActive).getTime()) / (1e3 * 60 * 60 * 24));
              const recencyScore = Math.max(0, 30 - daysSinceActive);
              score += recencyScore;
              scoreBreakdown.recency = recencyScore;
              const followerCount = candidateFollowers.length;
              const followingCount = candidateFollowing.length;
              if (followingCount > 0) {
                const ratio = followerCount / followingCount;
                const ratioScore = ratio >= 1 ? Math.min(ratio * 10, 30) : 0;
                score += ratioScore;
                scoreBreakdown.ratio = ratioScore;
              }
              const influenceBonus = Math.min((candidate.influenceScore || 0) / 50, 40);
              score += influenceBonus;
              scoreBreakdown.influence = influenceBonus;
              const accountAgeDays = Math.floor((Date.now() - new Date(candidate.createdAt).getTime()) / (1e3 * 60 * 60 * 24));
              if (accountAgeDays <= 14) {
                const newUserBoost = Math.max(0, 75 - accountAgeDays * 5);
                score += newUserBoost;
                scoreBreakdown.newUserBoost = newUserBoost;
              }
              if (engagedWithMeUsers.has(candidate.id)) {
                score += 80;
                scoreBreakdown.engagedWithYou = 80;
              }
              if (accountAgeDays <= 7) {
                const candidatePosts = await db.select({ id: posts.id }).from(posts).where(eq2(posts.authorId, candidate.id)).limit(1);
                if (candidatePosts.length > 0) {
                  score += 40;
                  scoreBreakdown.hasFirstPost = 40;
                }
              }
              const discoveryFactor = Math.random() * 15;
              score += discoveryFactor;
              return {
                id: candidate.id,
                username: candidate.username,
                displayName: candidate.displayName,
                avatarUrl: candidate.avatarUrl,
                bio: candidate.bio,
                netWorth: candidate.netWorth,
                influenceScore: candidate.influenceScore,
                isVerified: candidate.isVerified,
                followersCount: followerCount,
                followingCount,
                mutualFollowersCount: mutualFollowers.length,
                mutualFollowers: mutualFollowers.slice(0, 3).map((u) => ({
                  id: u.id,
                  username: u.username,
                  displayName: u.displayName,
                  avatarUrl: u.avatarUrl
                })),
                followsYou,
                score: Math.round(score),
                scoreBreakdown
              };
            } catch (err) {
              console.error(`Error scoring candidate ${candidate.id}:`, err);
              return {
                id: candidate.id,
                username: candidate.username,
                displayName: candidate.displayName,
                avatarUrl: candidate.avatarUrl,
                bio: candidate.bio,
                netWorth: candidate.netWorth || 0,
                influenceScore: candidate.influenceScore || 0,
                isVerified: candidate.isVerified || false,
                followersCount: 0,
                followingCount: 0,
                mutualFollowersCount: 0,
                mutualFollowers: [],
                followsYou: false,
                score: Math.random() * 10
              };
            }
          }));
          scoredCandidates.sort((a, b) => b.score - a.score);
          const diversified = this.diversifySuggestions(scoredCandidates, limit);
          return diversified;
        } catch (error) {
          console.error("getSuggestedPeople error:", error);
          throw error;
        }
      }
      /**
       * Find common keywords between two bio strings
       */
      findCommonKeywords(bio1, bio2) {
        const stopWords = /* @__PURE__ */ new Set(["the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for", "of", "is", "i", "my", "me", "we", "you", "it"]);
        const words1 = new Set(bio1.split(/\s+/).filter((w) => w.length > 2 && !stopWords.has(w)));
        const words2 = new Set(bio2.split(/\s+/).filter((w) => w.length > 2 && !stopWords.has(w)));
        let commonCount = 0;
        for (const word of words1) {
          if (words2.has(word)) commonCount++;
        }
        return commonCount;
      }
      /**
       * Calculate wealth tier similarity for elite app matching
       */
      calculateWealthTierSimilarity(worth1, worth2) {
        const getTier = (w) => {
          if (w >= 1e7) return 5;
          if (w >= 1e6) return 4;
          if (w >= 1e5) return 3;
          if (w >= 1e4) return 2;
          return 1;
        };
        const tier1 = getTier(worth1);
        const tier2 = getTier(worth2);
        const tierDiff = Math.abs(tier1 - tier2);
        if (tierDiff === 0) return 50;
        if (tierDiff === 1) return 25;
        if (tierDiff === 2) return 10;
        return 0;
      }
      /**
       * Calculate profile completeness score
       */
      calculateProfileCompleteness(user) {
        let score = 0;
        if (user.avatarUrl) score += 10;
        if (user.bio && user.bio.length > 20) score += 10;
        if (user.displayName && user.displayName !== user.username) score += 5;
        if (user.coverUrl) score += 5;
        return score;
      }
      /**
       * Diversify suggestions to prevent showing too many from same cluster
       */
      diversifySuggestions(candidates, limit) {
        const result = [];
        const mutualCounts = /* @__PURE__ */ new Map();
        for (const candidate of candidates) {
          if (result.length >= limit) break;
          const mutualCount = candidate.mutualFollowersCount;
          const currentMutualCount = mutualCounts.get(mutualCount) || 0;
          if (mutualCount > 0 && currentMutualCount >= Math.ceil(limit / 3)) {
            continue;
          }
          result.push(candidate);
          mutualCounts.set(mutualCount, currentMutualCount + 1);
        }
        if (result.length < limit) {
          for (const candidate of candidates) {
            if (result.length >= limit) break;
            if (!result.includes(candidate)) {
              result.push(candidate);
            }
          }
        }
        return result;
      }
      // ================================================================================
      // DISCOVERY ALGORITHM - Content Rotation & Personalization (TikTok/Instagram-style)
      // ================================================================================
      /**
       * Record a content interaction (view, like, save, share, skip, rewatch)
       * This is the core data collection for the algorithm
       */
      async recordContentInteraction(data) {
        try {
          await db.execute(sql3`
        INSERT INTO content_interactions (
          id, user_id, content_id, content_type, interaction_type, 
          watch_time_ms, completion_rate, rewatch_count, skipped_at_ms,
          creator_id, session_id
        ) VALUES (
          ${crypto.randomUUID()}, ${data.userId}, ${data.contentId},
          ${data.contentType}::content_type, ${data.interactionType}::interaction_type,
          ${data.watchTimeMs || 0}, ${data.completionRate || 0}, ${data.rewatchCount || 0},
          ${data.skippedAtMs || null}, ${data.creatorId || null}, ${data.sessionId || null}
        )
      `);
          if (data.creatorId && ["LIKE", "SAVE", "SHARE", "COMMENT", "REWATCH"].includes(data.interactionType)) {
            await this.updateCreatorAffinity(data.userId, data.creatorId, data);
          }
          await this.updateUserInterestProfile(data.userId, data);
          await this.markContentAsSeen(data.userId, data.contentId, data.contentType, data.sessionId);
          await this.updateContentFatigue(data.contentId, data.contentType, data);
          await this.updateContentVelocity(data.contentId, data.contentType, data.interactionType);
        } catch (error) {
          console.error("recordContentInteraction error:", error);
        }
      }
      /**
       * Update content velocity for viral/trending detection
       * Tracks engagement per hour since content creation
       */
      async updateContentVelocity(contentId, contentType, interactionType) {
        try {
          const postResult = await db.execute(sql3`
        SELECT created_at FROM posts WHERE id = ${contentId} LIMIT 1
      `);
          if (!postResult.rows.length) return;
          const createdAt = new Date(postResult.rows[0].created_at);
          const now = /* @__PURE__ */ new Date();
          const hourNumber = Math.floor((now.getTime() - createdAt.getTime()) / (1e3 * 60 * 60));
          const fieldMapping = {
            "VIEW": "views",
            "LIKE": "likes",
            "SHARE": "shares",
            "SAVE": "saves",
            "COMMENT": "comments"
          };
          const field = fieldMapping[interactionType];
          if (!field) return;
          await db.execute(sql3`
        INSERT INTO content_velocity (id, content_id, content_type, hour_number, ${sql3.raw(field)}, velocity_score)
        VALUES (
          ${crypto.randomUUID()}, 
          ${contentId}, 
          ${contentType}::content_type, 
          ${hourNumber}, 
          1,
          1.0
        )
        ON CONFLICT ON CONSTRAINT content_velocity_content_hour 
        DO UPDATE SET 
          ${sql3.raw(field)} = content_velocity.${sql3.raw(field)} + 1,
          velocity_score = (
            (content_velocity.views + 1) * 1.0 + 
            (content_velocity.likes + 1) * 2.0 + 
            (content_velocity.saves + 1) * 3.0 + 
            (content_velocity.shares + 1) * 4.0 + 
            (content_velocity.comments + 1) * 2.5
          ) / GREATEST(1, ${hourNumber + 1})
      `);
        } catch (error) {
          console.error("updateContentVelocity error:", error);
        }
      }
      /**
       * Get high-velocity (viral) content IDs for boosting in feeds
       * Returns content that's gaining engagement faster than normal
       */
      async getViralContentIds(contentType, limit = 50) {
        try {
          const result = await db.execute(sql3`
        SELECT DISTINCT content_id 
        FROM content_velocity
        WHERE velocity_score > 5.0
          AND recorded_at > NOW() - INTERVAL '24 hours'
          ${contentType ? sql3`AND content_type = ${contentType}::content_type` : sql3``}
        ORDER BY velocity_score DESC
        LIMIT ${limit}
      `);
          return result.rows.map((row) => row.content_id);
        } catch (error) {
          console.error("getViralContentIds error:", error);
          return [];
        }
      }
      /**
       * Mark content as seen (prevents repeats within session/timeframe)
       */
      async markContentAsSeen(userId, contentId, contentType, sessionId) {
        const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1e3);
        await db.execute(sql3`
      INSERT INTO seen_content (id, user_id, content_id, content_type, session_id, expires_at)
      VALUES (${crypto.randomUUID()}, ${userId}, ${contentId}, ${contentType}::content_type, ${sessionId || null}, ${expiresAt})
      ON CONFLICT (user_id, content_id) DO UPDATE SET
        seen_at = NOW(),
        session_id = COALESCE(EXCLUDED.session_id, seen_content.session_id)
    `);
      }
      /**
       * Mark profile as seen in discovery (prevents repeats)
       */
      async markProfileAsSeen(userId, profileId, sessionId) {
        const expiresAt = new Date(Date.now() + 6 * 60 * 60 * 1e3);
        await db.execute(sql3`
      INSERT INTO seen_profiles (id, user_id, profile_id, session_id, expires_at)
      VALUES (${crypto.randomUUID()}, ${userId}, ${profileId}, ${sessionId || null}, ${expiresAt})
      ON CONFLICT (user_id, profile_id) DO UPDATE SET
        seen_at = NOW(),
        session_id = COALESCE(EXCLUDED.session_id, seen_profiles.session_id)
    `);
      }
      /**
       * Get list of seen content IDs for a user (to exclude from feeds)
       */
      async getSeenContentIds(userId, contentType) {
        const result = await db.execute(sql3`
      SELECT content_id FROM seen_content 
      WHERE user_id = ${userId} 
        AND expires_at > NOW()
        ${contentType ? sql3`AND content_type = ${contentType}::content_type` : sql3``}
    `);
        return result.rows.map((r) => r.content_id);
      }
      /**
       * Get list of seen profile IDs for a user (to exclude from suggestions)
       */
      async getSeenProfileIds(userId) {
        const result = await db.execute(sql3`
      SELECT profile_id FROM seen_profiles 
      WHERE user_id = ${userId} AND expires_at > NOW()
    `);
        return result.rows.map((r) => r.profile_id);
      }
      /**
       * Update or create user interest profile based on engagement
       */
      async updateUserInterestProfile(userId, interaction) {
        const existing = await db.execute(sql3`
      SELECT * FROM user_interest_profiles WHERE user_id = ${userId}
    `);
        let prefDelta = 0;
        if (interaction.interactionType === "SAVE") prefDelta = 10;
        else if (interaction.interactionType === "SHARE") prefDelta = 8;
        else if (interaction.interactionType === "COMMENT") prefDelta = 5;
        else if (interaction.interactionType === "LIKE") prefDelta = 3;
        else if (interaction.interactionType === "VIEW" && (interaction.completionRate || 0) > 0.8) prefDelta = 2;
        else if (interaction.interactionType === "SKIP") prefDelta = -5;
        else if (interaction.interactionType === "REWATCH") prefDelta = 15;
        const contentTypeField = interaction.contentType.toLowerCase() + "_preference";
        if (existing.rows.length === 0) {
          await db.execute(sql3`
        INSERT INTO user_interest_profiles (
          id, user_id, reel_preference, voice_preference, photo_preference, text_preference,
          avg_watch_time_ms, avg_completion_rate, total_interactions
        ) VALUES (
          ${crypto.randomUUID()}, ${userId}, 50, 50, 50, 50,
          ${interaction.watchTimeMs || 0}, ${interaction.completionRate || 0}, 1
        )
      `);
        } else {
          const profile = existing.rows[0];
          const newWatchTime = Math.round((profile.avg_watch_time_ms * profile.total_interactions + (interaction.watchTimeMs || 0)) / (profile.total_interactions + 1));
          const newCompletionRate = (profile.avg_completion_rate * profile.total_interactions + (interaction.completionRate || 0)) / (profile.total_interactions + 1);
          const updateField = (field, value) => {
            return sql3`${sql3.raw(field)} = LEAST(100, GREATEST(0, ${sql3.raw(field)} + ${value}))`;
          };
          await db.execute(sql3`
        UPDATE user_interest_profiles SET
          ${interaction.contentType === "REEL" ? sql3`reel_preference = LEAST(100, GREATEST(0, reel_preference + ${prefDelta})),` : sql3``}
          ${interaction.contentType === "VOICE" ? sql3`voice_preference = LEAST(100, GREATEST(0, voice_preference + ${prefDelta})),` : sql3``}
          ${interaction.contentType === "PHOTO" ? sql3`photo_preference = LEAST(100, GREATEST(0, photo_preference + ${prefDelta})),` : sql3``}
          ${interaction.contentType === "TEXT" ? sql3`text_preference = LEAST(100, GREATEST(0, text_preference + ${prefDelta})),` : sql3``}
          avg_watch_time_ms = ${newWatchTime},
          avg_completion_rate = ${newCompletionRate},
          total_interactions = total_interactions + 1,
          updated_at = NOW()
        WHERE user_id = ${userId}
      `);
        }
      }
      /**
       * Update creator affinity score (how much a user engages with a specific creator)
       */
      async updateCreatorAffinity(userId, creatorId, interaction) {
        let affinityDelta = 0;
        if (interaction.interactionType === "SAVE") affinityDelta = 20;
        else if (interaction.interactionType === "SHARE") affinityDelta = 15;
        else if (interaction.interactionType === "COMMENT") affinityDelta = 10;
        else if (interaction.interactionType === "LIKE") affinityDelta = 5;
        else if (interaction.interactionType === "REWATCH") affinityDelta = 25;
        await db.execute(sql3`
      INSERT INTO creator_affinities (
        id, user_id, creator_id, affinity_score, total_views, total_likes, total_shares, total_saves,
        avg_watch_time_ms, avg_completion_rate, last_interacted_at
      ) VALUES (
        ${crypto.randomUUID()}, ${userId}, ${creatorId}, ${affinityDelta}, 
        ${interaction.interactionType === "VIEW" ? 1 : 0},
        ${interaction.interactionType === "LIKE" ? 1 : 0},
        ${interaction.interactionType === "SHARE" ? 1 : 0},
        ${interaction.interactionType === "SAVE" ? 1 : 0},
        ${interaction.watchTimeMs || 0}, ${interaction.completionRate || 0}, NOW()
      )
      ON CONFLICT (user_id, creator_id) DO UPDATE SET
        affinity_score = creator_affinities.affinity_score + ${affinityDelta},
        total_views = creator_affinities.total_views + ${interaction.interactionType === "VIEW" ? 1 : 0},
        total_likes = creator_affinities.total_likes + ${interaction.interactionType === "LIKE" ? 1 : 0},
        total_shares = creator_affinities.total_shares + ${interaction.interactionType === "SHARE" ? 1 : 0},
        total_saves = creator_affinities.total_saves + ${interaction.interactionType === "SAVE" ? 1 : 0},
        avg_watch_time_ms = (creator_affinities.avg_watch_time_ms * creator_affinities.total_views + ${interaction.watchTimeMs || 0}) / (creator_affinities.total_views + 1),
        avg_completion_rate = (creator_affinities.avg_completion_rate * creator_affinities.total_views + ${interaction.completionRate || 0}) / (creator_affinities.total_views + 1),
        last_interacted_at = NOW(),
        updated_at = NOW()
    `);
      }
      /**
       * Update content fatigue score (prevents over-showing the same content)
       */
      async updateContentFatigue(contentId, contentType, interaction) {
        const isSkip = interaction.interactionType === "SKIP";
        await db.execute(sql3`
      INSERT INTO content_fatigue (
        id, content_id, content_type, total_impressions, total_skips, skip_rate,
        avg_watch_time_ms, avg_completion_rate, fatigue_score, last_shown_at
      ) VALUES (
        ${crypto.randomUUID()}, ${contentId}, ${contentType}::content_type, 1, ${isSkip ? 1 : 0}, ${isSkip ? 1 : 0},
        ${interaction.watchTimeMs || 0}, ${interaction.completionRate || 0}, ${isSkip ? 10 : -2}, NOW()
      )
      ON CONFLICT (content_id) DO UPDATE SET
        total_impressions = content_fatigue.total_impressions + 1,
        total_skips = content_fatigue.total_skips + ${isSkip ? 1 : 0},
        skip_rate = (content_fatigue.total_skips + ${isSkip ? 1 : 0})::REAL / (content_fatigue.total_impressions + 1)::REAL,
        avg_watch_time_ms = (content_fatigue.avg_watch_time_ms * content_fatigue.total_impressions + ${interaction.watchTimeMs || 0}) / (content_fatigue.total_impressions + 1),
        avg_completion_rate = (content_fatigue.avg_completion_rate * content_fatigue.total_impressions + ${interaction.completionRate || 0}) / (content_fatigue.total_impressions + 1),
        fatigue_score = LEAST(100, content_fatigue.fatigue_score + ${isSkip ? 10 : -2}),
        last_shown_at = NOW(),
        updated_at = NOW()
    `);
      }
      /**
       * Get top creator affinities for a user (who they engage with most)
       */
      async getTopCreatorAffinities(userId, limit = 20) {
        const result = await db.execute(sql3`
      SELECT creator_id FROM creator_affinities 
      WHERE user_id = ${userId}
      ORDER BY affinity_score DESC
      LIMIT ${limit}
    `);
        return result.rows.map((r) => r.creator_id);
      }
      /**
       * Get user's content type preferences
       */
      async getUserContentPreferences(userId) {
        const result = await db.execute(sql3`
      SELECT reel_preference, voice_preference, photo_preference, text_preference
      FROM user_interest_profiles WHERE user_id = ${userId}
    `);
        if (result.rows.length === 0) return null;
        const row = result.rows[0];
        return {
          reelPreference: row.reel_preference,
          voicePreference: row.voice_preference,
          photoPreference: row.photo_preference,
          textPreference: row.text_preference
        };
      }
      /**
       * Get personalized content feed with rotation (like TikTok/Instagram Reels)
       * This is the main recommendation engine
       */
      async getPersonalizedContentFeed(userId, contentType, options = {}) {
        const limit = options.limit || 20;
        const seenIds = await this.getSeenContentIds(userId, contentType);
        const notInterestedIds = await this.getNotInterestedContentIds(userId);
        const allExclusions = /* @__PURE__ */ new Set([...seenIds, ...notInterestedIds, ...options.excludeIds || []]);
        const topCreators = await this.getTopCreatorAffinities(userId, 10);
        const following = await this.getFollowing(userId);
        const followingIds = following.map((f) => f.id);
        let contentQuery;
        if (contentType === "REEL" || contentType === "VOICE") {
          contentQuery = sql3`
        SELECT p.*, u.username, u.display_name, u.avatar_url, u.verified,
          CASE 
            WHEN p.author_id = ANY(${followingIds}::varchar[]) THEN 100
            WHEN p.author_id = ANY(${topCreators}::varchar[]) THEN 80
            ELSE 0
          END as creator_boost,
          COALESCE(cf.fatigue_score, 0) as fatigue_penalty,
          (SELECT COUNT(*) FROM likes WHERE post_id = p.id) as like_count,
          (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count,
          EXTRACT(EPOCH FROM NOW() - p.created_at) / 3600 as hours_old
        FROM posts p
        LEFT JOIN users u ON p.author_id = u.id
        LEFT JOIN content_fatigue cf ON p.id = cf.content_id
        WHERE p.media_type = ${contentType}
          AND p.visibility = 'PUBLIC'
          AND p.id NOT IN (SELECT unnest(${[...allExclusions].length > 0 ? [...allExclusions] : [""]}::varchar[]))
          AND p.author_id != ${userId}
        ORDER BY 
          creator_boost DESC,
          (like_count + comment_count * 2) - fatigue_penalty DESC,
          RANDOM() * 10 DESC
        LIMIT ${limit * 2}
      `;
        } else {
          contentQuery = sql3`
        SELECT p.*, u.username, u.display_name, u.avatar_url, u.verified,
          CASE 
            WHEN p.author_id = ANY(${followingIds}::varchar[]) THEN 100
            WHEN p.author_id = ANY(${topCreators}::varchar[]) THEN 80
            ELSE 0
          END as creator_boost,
          COALESCE(cf.fatigue_score, 0) as fatigue_penalty,
          (SELECT COUNT(*) FROM likes WHERE post_id = p.id) as like_count,
          (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count
        FROM posts p
        LEFT JOIN users u ON p.author_id = u.id
        LEFT JOIN content_fatigue cf ON p.id = cf.content_id
        WHERE p.media_type = ${contentType}
          AND p.visibility = 'PUBLIC'
          AND p.id NOT IN (SELECT unnest(${[...allExclusions].length > 0 ? [...allExclusions] : [""]}::varchar[]))
          AND p.author_id != ${userId}
        ORDER BY 
          creator_boost DESC,
          (like_count + comment_count * 2) - fatigue_penalty DESC,
          RANDOM() * 10 DESC
        LIMIT ${limit * 2}
      `;
        }
        const result = await db.execute(contentQuery);
        let posts3 = result.rows;
        posts3 = this.shuffleWithSeed(posts3, options.sessionId || userId);
        return posts3.slice(0, limit);
      }
      /**
       * Shuffle array with consistent seed (same session = same shuffle)
       */
      shuffleWithSeed(array, seed) {
        const shuffled = [...array];
        let seedNum = this.hashCode(seed);
        for (let i = shuffled.length - 1; i > 0; i--) {
          seedNum = (seedNum * 9301 + 49297) % 233280;
          const j = Math.floor(seedNum / 233280 * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }
      hashCode(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          hash = (hash << 5) - hash + str.charCodeAt(i);
          hash = hash & hash;
        }
        return Math.abs(hash);
      }
      /**
       * Clean up expired seen content/profiles (run periodically)
       */
      async cleanupExpiredSeenItems() {
        await db.execute(sql3`DELETE FROM seen_content WHERE expires_at < NOW()`);
        await db.execute(sql3`DELETE FROM seen_profiles WHERE expires_at < NOW()`);
      }
      // ============================================
      // PASSWORD RESET & EMAIL VERIFICATION
      // ============================================
      /**
       * Create a password reset token (6-digit code)
       */
      async createPasswordResetToken(userId) {
        const token = Math.floor(1e5 + Math.random() * 9e5).toString();
        const expiresAt = new Date(Date.now() + 15 * 60 * 1e3);
        await db.update(passwordResetTokens).set({ usedAt: /* @__PURE__ */ new Date() }).where(and(
          eq2(passwordResetTokens.userId, userId),
          isNull(passwordResetTokens.usedAt)
        ));
        await db.insert(passwordResetTokens).values({
          userId,
          token,
          expiresAt
        });
        return token;
      }
      /**
       * Verify a password reset token
       */
      async verifyPasswordResetToken(email, token) {
        const user = await this.getUserByEmail(email);
        if (!user) {
          return { valid: false };
        }
        const [resetToken] = await db.select().from(passwordResetTokens).where(and(
          eq2(passwordResetTokens.userId, user.id),
          eq2(passwordResetTokens.token, token),
          isNull(passwordResetTokens.usedAt),
          gt(passwordResetTokens.expiresAt, /* @__PURE__ */ new Date())
        )).limit(1);
        if (!resetToken) {
          return { valid: false };
        }
        return { valid: true, userId: user.id };
      }
      /**
       * Mark password reset token as used
       */
      async markPasswordResetTokenUsed(userId, token) {
        await db.update(passwordResetTokens).set({ usedAt: /* @__PURE__ */ new Date() }).where(and(
          eq2(passwordResetTokens.userId, userId),
          eq2(passwordResetTokens.token, token)
        ));
      }
      /**
       * Create an email verification token (6-digit code)
       */
      async createEmailVerificationToken(userId, email) {
        const token = Math.floor(1e5 + Math.random() * 9e5).toString();
        const expiresAt = new Date(Date.now() + 10 * 60 * 1e3);
        await db.update(emailVerificationTokens).set({ verifiedAt: /* @__PURE__ */ new Date() }).where(and(
          eq2(emailVerificationTokens.userId, userId),
          isNull(emailVerificationTokens.verifiedAt)
        ));
        await db.insert(emailVerificationTokens).values({
          userId,
          email,
          token,
          expiresAt
        });
        return token;
      }
      /**
       * Verify an email verification token
       */
      async verifyEmailToken(userId, token) {
        const [verificationToken] = await db.select().from(emailVerificationTokens).where(and(
          eq2(emailVerificationTokens.userId, userId),
          eq2(emailVerificationTokens.token, token),
          isNull(emailVerificationTokens.verifiedAt),
          gt(emailVerificationTokens.expiresAt, /* @__PURE__ */ new Date())
        )).limit(1);
        if (!verificationToken) {
          return { valid: false };
        }
        await db.update(emailVerificationTokens).set({ verifiedAt: /* @__PURE__ */ new Date() }).where(eq2(emailVerificationTokens.id, verificationToken.id));
        return { valid: true, email: verificationToken.email };
      }
      /**
       * Update user password
       */
      async updateUserPassword(userId, hashedPassword) {
        await db.update(users).set({ password: hashedPassword }).where(eq2(users.id, userId));
      }
      // ===== PAYFAST ORDERS =====
      async createPayfastOrder(data) {
        const [order] = await db.insert(payfastOrders).values(data).returning();
        return order;
      }
      async getPayfastOrder(orderId) {
        const [order] = await db.select().from(payfastOrders).where(eq2(payfastOrders.id, orderId));
        return order;
      }
      async getPayfastOrderByPaymentId(pfPaymentId) {
        const [order] = await db.select().from(payfastOrders).where(eq2(payfastOrders.pfPaymentId, pfPaymentId));
        return order;
      }
      async updatePayfastOrder(orderId, data) {
        const [order] = await db.update(payfastOrders).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(payfastOrders.id, orderId)).returning();
        return order;
      }
      async completePayfastOrder(orderId, itnData) {
        const [order] = await db.update(payfastOrders).set({
          status: "COMPLETE",
          pfPaymentId: itnData.pfPaymentId,
          paymentStatus: itnData.paymentStatus,
          amountGross: itnData.amountGross,
          amountFee: itnData.amountFee,
          amountNet: itnData.amountNet,
          signature: itnData.signature,
          itnPayload: itnData.itnPayload,
          completedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(payfastOrders.id, orderId)).returning();
        return order;
      }
      async getUserPayfastOrders(userId) {
        return db.select().from(payfastOrders).where(eq2(payfastOrders.userId, userId)).orderBy(desc(payfastOrders.createdAt));
      }
      // ===== ADMIN 2FA MANAGEMENT =====
      async getAdmin2FAStats() {
        const totalResult = await db.select({ count: sql3`count(*)` }).from(users);
        const total = Number(totalResult[0]?.count || 0);
        const enabledResult = await db.select({ count: sql3`count(*)` }).from(totpSecrets).where(eq2(totpSecrets.isEnabled, true));
        const enabled = Number(enabledResult[0]?.count || 0);
        const disabled = total - enabled;
        return { total, enabled, disabled };
      }
      async getAdminTotpSecrets(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const search = options.search?.trim() || "";
        let baseQuery = db.select({
          totp: totpSecrets,
          user: users
        }).from(totpSecrets).innerJoin(users, eq2(totpSecrets.userId, users.id));
        if (search) {
          baseQuery = baseQuery.where(
            or(
              ilike(users.username, `%${search}%`),
              ilike(users.displayName, `%${search}%`),
              ilike(users.email, `%${search}%`)
            )
          );
        }
        const countResult = await db.select({ count: sql3`count(*)` }).from(totpSecrets).innerJoin(users, eq2(totpSecrets.userId, users.id)).where(search ? or(
          ilike(users.username, `%${search}%`),
          ilike(users.displayName, `%${search}%`),
          ilike(users.email, `%${search}%`)
        ) : void 0);
        const total = Number(countResult[0]?.count || 0);
        const results = await baseQuery.orderBy(desc(totpSecrets.createdAt)).limit(limit).offset(offset);
        const secrets = results.map((r) => ({
          ...r.totp,
          user: r.user
        }));
        return { secrets, total };
      }
      async adminReset2FA(userId) {
        await db.delete(backupCodes).where(eq2(backupCodes.userId, userId));
        await db.delete(totpSecrets).where(eq2(totpSecrets.userId, userId));
      }
      async getAdminUserBackupCodesCount(userId) {
        const result = await db.select({ count: sql3`count(*)` }).from(backupCodes).where(and(
          eq2(backupCodes.userId, userId),
          isNull(backupCodes.usedAt)
        ));
        return Number(result[0]?.count || 0);
      }
      // ===== ADMIN SESSION MANAGEMENT =====
      async getAdminSessionStats() {
        const totalResult = await db.select({ count: sql3`count(*)` }).from(loginSessions);
        const total = Number(totalResult[0]?.count || 0);
        const activeResult = await db.select({ count: sql3`count(*)` }).from(loginSessions).where(eq2(loginSessions.isActive, true));
        const active = Number(activeResult[0]?.count || 0);
        const inactive = total - active;
        return { total, active, inactive };
      }
      async getAdminLoginSessions(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const search = options.search?.trim() || "";
        const activeOnly = options.activeOnly || false;
        const conditions = [];
        if (activeOnly) {
          conditions.push(eq2(loginSessions.isActive, true));
        }
        if (search) {
          conditions.push(
            or(
              ilike(users.username, `%${search}%`),
              ilike(users.displayName, `%${search}%`),
              ilike(users.email, `%${search}%`)
            )
          );
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const countResult = await db.select({ count: sql3`count(*)` }).from(loginSessions).innerJoin(users, eq2(loginSessions.userId, users.id)).where(whereClause);
        const total = Number(countResult[0]?.count || 0);
        const results = await db.select({
          session: loginSessions,
          user: users
        }).from(loginSessions).innerJoin(users, eq2(loginSessions.userId, users.id)).where(whereClause).orderBy(desc(loginSessions.lastActiveAt)).limit(limit).offset(offset);
        const sessions = results.map((r) => ({
          ...r.session,
          user: r.user
        }));
        return { sessions, total };
      }
      async adminTerminateSession(sessionId) {
        await db.update(loginSessions).set({ isActive: false }).where(eq2(loginSessions.id, sessionId));
      }
      async adminTerminateAllUserSessions(userId) {
        const result = await db.update(loginSessions).set({ isActive: false }).where(and(
          eq2(loginSessions.userId, userId),
          eq2(loginSessions.isActive, true)
        )).returning({ id: loginSessions.id });
        return result.length;
      }
      // ===== ADMIN DEVICE MANAGEMENT =====
      async getAdminDeviceStats() {
        const totalResult = await db.select({ count: sql3`count(*)` }).from(trustedDevices);
        const total = Number(totalResult[0]?.count || 0);
        const thirtyDaysAgo = /* @__PURE__ */ new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const activeResult = await db.select({ count: sql3`count(*)` }).from(trustedDevices).where(gte(trustedDevices.lastUsedAt, thirtyDaysAgo));
        const activeLastMonth = Number(activeResult[0]?.count || 0);
        const deviceTypesResult = await db.select({
          deviceType: trustedDevices.deviceType,
          count: sql3`count(*)`
        }).from(trustedDevices).groupBy(trustedDevices.deviceType);
        const deviceTypes = {};
        for (const row of deviceTypesResult) {
          const type = row.deviceType || "unknown";
          deviceTypes[type] = Number(row.count);
        }
        return { total, activeLastMonth, deviceTypes };
      }
      async getAdminTrustedDevices(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const search = options.search?.trim() || "";
        const conditions = [];
        if (search) {
          conditions.push(
            or(
              ilike(users.username, `%${search}%`),
              ilike(users.displayName, `%${search}%`),
              ilike(users.email, `%${search}%`),
              ilike(trustedDevices.deviceName, `%${search}%`)
            )
          );
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const countResult = await db.select({ count: sql3`count(*)` }).from(trustedDevices).innerJoin(users, eq2(trustedDevices.userId, users.id)).where(whereClause);
        const total = Number(countResult[0]?.count || 0);
        const results = await db.select({
          device: trustedDevices,
          user: users
        }).from(trustedDevices).innerJoin(users, eq2(trustedDevices.userId, users.id)).where(whereClause).orderBy(desc(trustedDevices.lastUsedAt)).limit(limit).offset(offset);
        const devices = results.map((r) => ({
          ...r.device,
          user: r.user
        }));
        return { devices, total };
      }
      async adminRemoveTrustedDevice(deviceId) {
        await db.delete(trustedDevices).where(eq2(trustedDevices.id, deviceId));
      }
      async adminRemoveAllUserDevices(userId) {
        const result = await db.delete(trustedDevices).where(eq2(trustedDevices.userId, userId)).returning({ id: trustedDevices.id });
        return result.length;
      }
      async getAdminPaymentStats() {
        const totalResult = await db.select({ count: sql3`count(*)` }).from(payfastOrders);
        const totalOrders = Number(totalResult[0]?.count || 0);
        const pendingResult = await db.select({ count: sql3`count(*)` }).from(payfastOrders).where(eq2(payfastOrders.status, "PENDING"));
        const pendingOrders = Number(pendingResult[0]?.count || 0);
        const completedResult = await db.select({ count: sql3`count(*)` }).from(payfastOrders).where(eq2(payfastOrders.status, "COMPLETE"));
        const completedOrders = Number(completedResult[0]?.count || 0);
        const failedResult = await db.select({ count: sql3`count(*)` }).from(payfastOrders).where(eq2(payfastOrders.status, "FAILED"));
        const failedOrders = Number(failedResult[0]?.count || 0);
        const revenueResult = await db.select({ total: sql3`COALESCE(SUM(amount_cents), 0)` }).from(payfastOrders).where(eq2(payfastOrders.status, "COMPLETE"));
        const totalRevenue = Number(revenueResult[0]?.total || 0);
        const thirtyDaysAgo = /* @__PURE__ */ new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const last30DaysResult = await db.select({ total: sql3`COALESCE(SUM(amount_cents), 0)` }).from(payfastOrders).where(and(
          eq2(payfastOrders.status, "COMPLETE"),
          gte(payfastOrders.completedAt, thirtyDaysAgo)
        ));
        const last30DaysRevenue = Number(last30DaysResult[0]?.total || 0);
        return { totalOrders, pendingOrders, completedOrders, failedOrders, totalRevenue, last30DaysRevenue };
      }
      async getAdminPayfastOrders(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const search = options.search?.trim() || "";
        const status = options.status?.trim() || "";
        const conditions = [];
        if (search) {
          conditions.push(
            or(
              ilike(users.username, `%${search}%`),
              ilike(users.displayName, `%${search}%`),
              ilike(users.email, `%${search}%`),
              ilike(payfastOrders.itemName, `%${search}%`),
              ilike(payfastOrders.id, `%${search}%`)
            )
          );
        }
        if (status && ["PENDING", "COMPLETE", "FAILED", "CANCELLED"].includes(status.toUpperCase())) {
          conditions.push(eq2(payfastOrders.status, status.toUpperCase()));
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const countResult = await db.select({ count: sql3`count(*)` }).from(payfastOrders).innerJoin(users, eq2(payfastOrders.userId, users.id)).where(whereClause);
        const total = Number(countResult[0]?.count || 0);
        const results = await db.select({
          order: payfastOrders,
          user: users
        }).from(payfastOrders).innerJoin(users, eq2(payfastOrders.userId, users.id)).where(whereClause).orderBy(desc(payfastOrders.createdAt)).limit(limit).offset(offset);
        const orders = results.map((r) => ({
          ...r.order,
          user: r.user
        }));
        return { orders, total };
      }
      async getAdminPayfastOrder(orderId) {
        const result = await db.select({
          order: payfastOrders,
          user: users
        }).from(payfastOrders).innerJoin(users, eq2(payfastOrders.userId, users.id)).where(eq2(payfastOrders.id, orderId)).limit(1);
        if (result.length === 0) return void 0;
        return {
          ...result[0].order,
          user: result[0].user
        };
      }
      async adminUpdateOrderStatus(orderId, status, notes) {
        const validStatuses = ["PENDING", "COMPLETE", "FAILED", "CANCELLED"];
        if (!validStatuses.includes(status.toUpperCase())) {
          throw new Error("Invalid status");
        }
        const updateData = {
          status: status.toUpperCase(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (status.toUpperCase() === "COMPLETE") {
          updateData.completedAt = /* @__PURE__ */ new Date();
        }
        if (notes) {
          updateData.itemDescription = notes;
        }
        const result = await db.update(payfastOrders).set(updateData).where(eq2(payfastOrders.id, orderId)).returning();
        return result[0];
      }
      async getAdminGroupChatStats() {
        const totalGroupsResult = await db.select({ count: sql3`count(*)` }).from(groupConversations);
        const totalGroups = Number(totalGroupsResult[0]?.count || 0);
        const activeGroupsResult = await db.select({ count: sql3`count(*)` }).from(groupConversations).where(eq2(groupConversations.isActive, true));
        const activeGroups = Number(activeGroupsResult[0]?.count || 0);
        const totalMessagesResult = await db.select({ count: sql3`count(*)` }).from(groupMessages).where(eq2(groupMessages.isDeleted, false));
        const totalMessages = Number(totalMessagesResult[0]?.count || 0);
        const totalMembersResult = await db.select({ count: sql3`count(*)` }).from(groupConversationMembers);
        const totalMembers = Number(totalMembersResult[0]?.count || 0);
        return { totalGroups, activeGroups, totalMessages, totalMembers };
      }
      async getAdminGroupConversations(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const search = options.search?.trim() || "";
        const conditions = [];
        if (search) {
          conditions.push(ilike(groupConversations.name, `%${search}%`));
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const countResult = await db.select({ count: sql3`count(*)` }).from(groupConversations).where(whereClause);
        const total = Number(countResult[0]?.count || 0);
        const groups2 = await db.select().from(groupConversations).where(whereClause).orderBy(desc(groupConversations.lastMessageAt)).limit(limit).offset(offset);
        return { groups: groups2, total };
      }
      async getAdminGroupConversationDetails(groupId) {
        const groupResult = await db.select().from(groupConversations).where(eq2(groupConversations.id, groupId)).limit(1);
        if (groupResult.length === 0) return void 0;
        const membersResult = await db.select({
          member: groupConversationMembers,
          user: users
        }).from(groupConversationMembers).innerJoin(users, eq2(groupConversationMembers.userId, users.id)).where(eq2(groupConversationMembers.conversationId, groupId)).orderBy(groupConversationMembers.joinedAt);
        const members = membersResult.map((r) => ({
          ...r.member,
          user: r.user
        }));
        return { group: groupResult[0], members };
      }
      async getAdminGroupMessages(groupId, options) {
        const page = options.page || 1;
        const limit = options.limit || 50;
        const offset = (page - 1) * limit;
        const countResult = await db.select({ count: sql3`count(*)` }).from(groupMessages).where(eq2(groupMessages.conversationId, groupId));
        const total = Number(countResult[0]?.count || 0);
        const messagesResult = await db.select({
          message: groupMessages,
          sender: users
        }).from(groupMessages).innerJoin(users, eq2(groupMessages.senderId, users.id)).where(eq2(groupMessages.conversationId, groupId)).orderBy(desc(groupMessages.createdAt)).limit(limit).offset(offset);
        const messages4 = messagesResult.map((r) => ({
          ...r.message,
          sender: r.sender
        }));
        return { messages: messages4, total };
      }
      async adminDeleteGroupMessage(messageId) {
        await db.update(groupMessages).set({ isDeleted: true, content: "[Message deleted by admin]" }).where(eq2(groupMessages.id, messageId));
      }
      async adminRemoveGroupMember(groupId, userId) {
        await db.delete(groupConversationMembers).where(and(
          eq2(groupConversationMembers.conversationId, groupId),
          eq2(groupConversationMembers.userId, userId)
        ));
        await db.update(groupConversations).set({ memberCount: sql3`${groupConversations.memberCount} - 1` }).where(eq2(groupConversations.id, groupId));
      }
      // ===== ADMIN VIDEO CALLS =====
      async getAdminVideoCallStats() {
        const totalCallsResult = await db.select({ count: sql3`count(*)` }).from(videoCalls);
        const totalCalls = Number(totalCallsResult[0]?.count || 0);
        const activeCallsResult = await db.select({ count: sql3`count(*)` }).from(videoCalls).where(or(eq2(videoCalls.status, "RINGING"), eq2(videoCalls.status, "ONGOING")));
        const activeCalls = Number(activeCallsResult[0]?.count || 0);
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const completedTodayResult = await db.select({ count: sql3`count(*)` }).from(videoCalls).where(and(
          eq2(videoCalls.status, "ENDED"),
          gte(videoCalls.endedAt, today)
        ));
        const completedToday = Number(completedTodayResult[0]?.count || 0);
        const avgDurationResult = await db.select({ avg: sql3`coalesce(avg(${videoCalls.durationSeconds}), 0)` }).from(videoCalls).where(and(
          eq2(videoCalls.status, "ENDED"),
          isNotNull(videoCalls.durationSeconds)
        ));
        const avgDuration = Math.round(Number(avgDurationResult[0]?.avg || 0));
        return { totalCalls, activeCalls, completedToday, avgDuration };
      }
      async getAdminVideoCalls(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const search = options.search?.trim() || "";
        const status = options.status || "";
        const conditions = [];
        if (status && status !== "all") {
          conditions.push(eq2(videoCalls.status, status));
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const countResult = await db.select({ count: sql3`count(*)` }).from(videoCalls).where(whereClause);
        const total = Number(countResult[0]?.count || 0);
        const callerAlias = db.select().from(users).as("caller");
        const calleeAlias = db.select().from(users).as("callee");
        const callsResult = await db.select({
          call: videoCalls,
          caller: users
        }).from(videoCalls).innerJoin(users, eq2(videoCalls.callerId, users.id)).where(whereClause).orderBy(desc(videoCalls.createdAt)).limit(limit).offset(offset);
        const callsWithCallee = await Promise.all(callsResult.map(async (r) => {
          const [callee] = await db.select().from(users).where(eq2(users.id, r.call.calleeId));
          return {
            ...r.call,
            caller: r.caller,
            callee
          };
        }));
        const filteredCalls = search ? callsWithCallee.filter(
          (c) => c.caller.username.toLowerCase().includes(search.toLowerCase()) || c.callee?.username?.toLowerCase().includes(search.toLowerCase()) || c.caller.displayName.toLowerCase().includes(search.toLowerCase()) || c.callee?.displayName?.toLowerCase().includes(search.toLowerCase())
        ) : callsWithCallee;
        return { calls: filteredCalls, total: search ? filteredCalls.length : total };
      }
      async getAdminVideoCallDetails(callId) {
        const [callResult] = await db.select().from(videoCalls).where(eq2(videoCalls.id, callId));
        if (!callResult) return void 0;
        const [caller] = await db.select().from(users).where(eq2(users.id, callResult.callerId));
        const [callee] = await db.select().from(users).where(eq2(users.id, callResult.calleeId));
        return {
          ...callResult,
          caller,
          callee
        };
      }
      async adminEndVideoCall(callId) {
        await db.update(videoCalls).set({
          status: "ENDED",
          endedAt: /* @__PURE__ */ new Date()
        }).where(and(
          eq2(videoCalls.id, callId),
          or(eq2(videoCalls.status, "RINGING"), eq2(videoCalls.status, "ONGOING"))
        ));
      }
      // ===== ADMIN MESSAGE MODERATION FUNCTIONS =====
      async adminSearchMessages(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const search = options.search?.trim() || "";
        if (!search) {
          return { messages: [], total: 0 };
        }
        const searchPattern = `%${search}%`;
        const countResult = await db.select({ count: sql3`count(*)` }).from(messages).where(ilike(messages.content, searchPattern));
        const total = Number(countResult[0]?.count || 0);
        const messagesResult = await db.select().from(messages).where(ilike(messages.content, searchPattern)).orderBy(desc(messages.createdAt)).limit(limit).offset(offset);
        const messagesWithDetails = await Promise.all(messagesResult.map(async (msg) => {
          const [sender] = await db.select().from(users).where(eq2(users.id, msg.senderId));
          const [conversation] = await db.select().from(conversations).where(eq2(conversations.id, msg.conversationId));
          return {
            ...msg,
            sender,
            conversation
          };
        }));
        return { messages: messagesWithDetails, total };
      }
      async adminDeleteMessage(messageId) {
        await db.delete(messages).where(eq2(messages.id, messageId));
      }
      async getAdminConversationMessages(conversationId, options) {
        const page = options.page || 1;
        const limit = options.limit || 50;
        const offset = (page - 1) * limit;
        const countResult = await db.select({ count: sql3`count(*)` }).from(messages).where(eq2(messages.conversationId, conversationId));
        const total = Number(countResult[0]?.count || 0);
        const messagesResult = await db.select().from(messages).where(eq2(messages.conversationId, conversationId)).orderBy(desc(messages.createdAt)).limit(limit).offset(offset);
        const messagesWithSender = await Promise.all(messagesResult.map(async (msg) => {
          const [sender] = await db.select().from(users).where(eq2(users.id, msg.senderId));
          return {
            ...msg,
            sender
          };
        }));
        return { messages: messagesWithSender, total };
      }
      async adminFlagMessage(messageId, reason, adminId) {
        const [message] = await db.select().from(messages).where(eq2(messages.id, messageId));
        if (!message) {
          throw new Error("Message not found");
        }
        await db.insert(reports).values({
          reporterId: adminId,
          reportedUserId: message.senderId,
          reason: `[MESSAGE FLAG] ${reason}`,
          adminNotes: `Flagged message ID: ${messageId}
Message content: ${message.content?.substring(0, 500)}`,
          status: "PENDING"
        });
      }
      async getAdminFlaggedMessages(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const countResult = await db.select({ count: sql3`count(*)` }).from(reports).where(ilike(reports.reason, "[MESSAGE FLAG]%"));
        const total = Number(countResult[0]?.count || 0);
        const reportsResult = await db.select().from(reports).where(ilike(reports.reason, "[MESSAGE FLAG]%")).orderBy(desc(reports.createdAt)).limit(limit).offset(offset);
        const reportsWithUser = await Promise.all(reportsResult.map(async (report) => {
          let reportedUser = null;
          if (report.reportedUserId) {
            const [user] = await db.select().from(users).where(eq2(users.id, report.reportedUserId));
            reportedUser = user || null;
          }
          return {
            ...report,
            reportedUser
          };
        }));
        return { reports: reportsWithUser, total };
      }
      // ===== ADMIN THREADS & DUET/STITCH MODERATION =====
      async getAdminThreadStats() {
        const [threadsResult] = await db.select({ count: sql3`count(*)` }).from(postThreads);
        const [duetsResult] = await db.select({ count: sql3`count(*)` }).from(duetStitchPosts).where(eq2(duetStitchPosts.type, "DUET"));
        const [stitchesResult] = await db.select({ count: sql3`count(*)` }).from(duetStitchPosts).where(eq2(duetStitchPosts.type, "STITCH"));
        return {
          totalThreads: Number(threadsResult?.count || 0),
          totalDuets: Number(duetsResult?.count || 0),
          totalStitches: Number(stitchesResult?.count || 0)
        };
      }
      async getAdminPostThreads(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const search = options.search?.trim();
        let whereClause = void 0;
        if (search) {
          whereClause = ilike(postThreads.title, `%${search}%`);
        }
        const countResult = await db.select({ count: sql3`count(*)` }).from(postThreads).where(whereClause);
        const total = Number(countResult[0]?.count || 0);
        const threadsResult = whereClause ? await db.select().from(postThreads).where(whereClause).orderBy(desc(postThreads.createdAt)).limit(limit).offset(offset) : await db.select().from(postThreads).orderBy(desc(postThreads.createdAt)).limit(limit).offset(offset);
        const threadsWithDetails = await Promise.all(threadsResult.map(async (thread) => {
          const [author] = await db.select().from(users).where(eq2(users.id, thread.authorId));
          const threadPostsResult = await db.select().from(threadPosts).where(eq2(threadPosts.threadId, thread.id)).orderBy(threadPosts.position);
          const postsInThread = await Promise.all(threadPostsResult.map(async (tp) => {
            const [post] = await db.select().from(posts).where(eq2(posts.id, tp.postId));
            return post;
          }));
          return {
            ...thread,
            author: author || {},
            posts: postsInThread.filter(Boolean)
          };
        }));
        return { threads: threadsWithDetails, total };
      }
      async getAdminDuetStitchPosts(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const typeFilter = options.type;
        let whereClause = void 0;
        if (typeFilter) {
          whereClause = eq2(duetStitchPosts.type, typeFilter.toUpperCase());
        }
        const countResult = await db.select({ count: sql3`count(*)` }).from(duetStitchPosts).where(whereClause);
        const total = Number(countResult[0]?.count || 0);
        const duetStitchResult = whereClause ? await db.select().from(duetStitchPosts).where(whereClause).orderBy(desc(duetStitchPosts.createdAt)).limit(limit).offset(offset) : await db.select().from(duetStitchPosts).orderBy(desc(duetStitchPosts.createdAt)).limit(limit).offset(offset);
        const postsWithDetails = await Promise.all(duetStitchResult.map(async (ds) => {
          const [post] = await db.select().from(posts).where(eq2(posts.id, ds.postId));
          const [originalPost] = await db.select().from(posts).where(eq2(posts.id, ds.originalPostId));
          let author = null;
          if (post?.authorId) {
            const [authorResult] = await db.select().from(users).where(eq2(users.id, post.authorId));
            author = authorResult || null;
          }
          return {
            ...ds,
            post: post || {},
            author: author || {},
            originalPost: originalPost || {}
          };
        }));
        return { posts: postsWithDetails, total };
      }
      async adminDeleteDuetStitch(duetStitchId) {
        const [duetStitch] = await db.select().from(duetStitchPosts).where(eq2(duetStitchPosts.id, duetStitchId));
        if (!duetStitch) {
          throw new Error("Duet/Stitch not found");
        }
        await db.delete(duetStitchPosts).where(eq2(duetStitchPosts.id, duetStitchId));
        await db.delete(posts).where(eq2(posts.id, duetStitch.postId));
      }
      async adminDeleteThread(threadId) {
        const [thread] = await db.select().from(postThreads).where(eq2(postThreads.id, threadId));
        if (!thread) {
          throw new Error("Thread not found");
        }
        const threadPostsResult = await db.select().from(threadPosts).where(eq2(threadPosts.threadId, threadId));
        for (const tp of threadPostsResult) {
          await db.delete(posts).where(eq2(posts.id, tp.postId));
        }
        await db.delete(postThreads).where(eq2(postThreads.id, threadId));
      }
      // Admin: Get platform usage overview
      async getAdminPlatformAnalytics() {
        const now = /* @__PURE__ */ new Date();
        const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const sevenDaysAgo = new Date(startOfToday);
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        const thirtyDaysAgo = new Date(startOfToday);
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const dauResult = await db.select({ count: sql3`count(distinct ${users.id})` }).from(users).where(gte(users.lastActiveAt, startOfToday));
        const dau = Number(dauResult[0]?.count || 0);
        const wauResult = await db.select({ count: sql3`count(distinct ${users.id})` }).from(users).where(gte(users.lastActiveAt, sevenDaysAgo));
        const wau = Number(wauResult[0]?.count || 0);
        const mauResult = await db.select({ count: sql3`count(distinct ${users.id})` }).from(users).where(gte(users.lastActiveAt, thirtyDaysAgo));
        const mau = Number(mauResult[0]?.count || 0);
        const totalUsersResult = await db.select({ count: sql3`count(*)` }).from(users);
        const totalUsers = Number(totalUsersResult[0]?.count || 0);
        const totalPostsResult = await db.select({ count: sql3`count(*)` }).from(posts);
        const totalPosts = Number(totalPostsResult[0]?.count || 0);
        const totalMessagesResult = await db.select({ count: sql3`count(*)` }).from(messages);
        const totalMessages = Number(totalMessagesResult[0]?.count || 0);
        const avgSessionResult = await db.select({
          avg: sql3`coalesce(avg(${usageStats.screenTimeMinutes}), 0)`
        }).from(usageStats).where(gte(usageStats.date, thirtyDaysAgo));
        const avgSessionDuration = Math.round(Number(avgSessionResult[0]?.avg || 0));
        return {
          dau,
          wau,
          mau,
          totalUsers,
          totalPosts,
          totalMessages,
          avgSessionDuration
        };
      }
      // Admin: Get usage trends (last N days)
      async getAdminUsageTrends(days = 30) {
        const now = /* @__PURE__ */ new Date();
        const startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        startDate.setDate(startDate.getDate() - days);
        const trends = [];
        for (let i = 0; i < days; i++) {
          const dayStart = new Date(startDate);
          dayStart.setDate(startDate.getDate() + i);
          const dayEnd = new Date(dayStart);
          dayEnd.setDate(dayEnd.getDate() + 1);
          const dateStr = dayStart.toISOString().split("T")[0];
          const activeResult = await db.select({ count: sql3`count(distinct ${users.id})` }).from(users).where(and(
            gte(users.lastActiveAt, dayStart),
            lt(users.lastActiveAt, dayEnd)
          ));
          const activeUsers = Number(activeResult[0]?.count || 0);
          const newUsersResult = await db.select({ count: sql3`count(*)` }).from(users).where(and(
            gte(users.createdAt, dayStart),
            lt(users.createdAt, dayEnd)
          ));
          const newUsers = Number(newUsersResult[0]?.count || 0);
          const postsResult = await db.select({ count: sql3`count(*)` }).from(posts).where(and(
            gte(posts.createdAt, dayStart),
            lt(posts.createdAt, dayEnd)
          ));
          const postsCount = Number(postsResult[0]?.count || 0);
          const messagesResult = await db.select({ count: sql3`count(*)` }).from(messages).where(and(
            gte(messages.createdAt, dayStart),
            lt(messages.createdAt, dayEnd)
          ));
          const messagesCount = Number(messagesResult[0]?.count || 0);
          trends.push({
            date: dateStr,
            activeUsers,
            newUsers,
            posts: postsCount,
            messages: messagesCount
          });
        }
        return trends;
      }
      // Admin: Get user retention metrics
      async getAdminRetentionMetrics() {
        const now = /* @__PURE__ */ new Date();
        const calculateRetention = async (daysAgo) => {
          const signupStart = new Date(now);
          signupStart.setDate(signupStart.getDate() - daysAgo - 7);
          const signupEnd = new Date(now);
          signupEnd.setDate(signupEnd.getDate() - daysAgo);
          const retentionCheckStart = new Date(signupEnd);
          const signedUpUsers = await db.select({ id: users.id }).from(users).where(and(
            gte(users.createdAt, signupStart),
            lt(users.createdAt, signupEnd)
          ));
          if (signedUpUsers.length === 0) return 0;
          const retainedUsers = await db.select({ count: sql3`count(*)` }).from(users).where(and(
            inArray(users.id, signedUpUsers.map((u) => u.id)),
            gte(users.lastActiveAt, retentionCheckStart)
          ));
          const retained = Number(retainedUsers[0]?.count || 0);
          return Math.round(retained / signedUpUsers.length * 100);
        };
        const day1Retention = await calculateRetention(1);
        const day7Retention = await calculateRetention(7);
        const day30Retention = await calculateRetention(30);
        return {
          day1Retention,
          day7Retention,
          day30Retention
        };
      }
      // Admin: Get trending/viral content stats
      async getAdminContentVelocityStats() {
        const now = /* @__PURE__ */ new Date();
        const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
        const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1e3);
        const trendingResult = await db.select({ count: sql3`count(distinct ${contentVelocity.contentId})` }).from(contentVelocity).where(and(
          gte(contentVelocity.recordedAt, oneHourAgo),
          gt(contentVelocity.velocityScore, 5)
        ));
        const trendingNow = Number(trendingResult[0]?.count || 0);
        const viralResult = await db.select({ count: sql3`count(distinct ${contentVelocity.contentId})` }).from(contentVelocity).where(and(
          gte(contentVelocity.recordedAt, oneDayAgo),
          gt(contentVelocity.velocityScore, 20)
        ));
        const viralToday = Number(viralResult[0]?.count || 0);
        const postsWithEngagement = await db.select({
          avgRate: sql3`avg((${posts.likesCount} + ${posts.commentsCount} + ${posts.sharesCount})::float / nullif(${posts.viewsCount}, 0) * 100)`
        }).from(posts).where(and(
          gte(posts.createdAt, oneDayAgo),
          isNull(posts.deletedAt),
          gt(posts.viewsCount, 0)
        ));
        const avgEngagementRate = Math.round((postsWithEngagement[0]?.avgRate || 0) * 100) / 100;
        return {
          trendingNow,
          viralToday,
          avgEngagementRate
        };
      }
      // Admin: Get trending posts (high velocity)
      async getAdminTrendingPosts(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const timeframe = options.timeframe || "24h";
        let timeThreshold = /* @__PURE__ */ new Date();
        switch (timeframe) {
          case "1h":
            timeThreshold = new Date(timeThreshold.getTime() - 60 * 60 * 1e3);
            break;
          case "6h":
            timeThreshold = new Date(timeThreshold.getTime() - 6 * 60 * 60 * 1e3);
            break;
          case "7d":
            timeThreshold = new Date(timeThreshold.getTime() - 7 * 24 * 60 * 60 * 1e3);
            break;
          default:
            timeThreshold = new Date(timeThreshold.getTime() - 24 * 60 * 60 * 1e3);
        }
        const trendingPosts = await db.select({
          post: posts,
          author: users,
          velocityScore: sql3`coalesce(max(${contentVelocity.velocityScore}), 0)`
        }).from(posts).innerJoin(users, eq2(posts.authorId, users.id)).leftJoin(contentVelocity, eq2(posts.id, contentVelocity.contentId)).where(and(
          gte(posts.createdAt, timeThreshold),
          isNull(posts.deletedAt),
          eq2(posts.isHidden, false)
        )).groupBy(posts.id, users.id).orderBy(desc(sql3`coalesce(max(${contentVelocity.velocityScore}), (${posts.likesCount} + ${posts.commentsCount} * 2 + ${posts.sharesCount} * 3)::float / greatest(extract(epoch from (now() - ${posts.createdAt})) / 3600, 1))`)).limit(limit).offset(offset);
        const totalResult = await db.select({ count: sql3`count(*)` }).from(posts).where(and(
          gte(posts.createdAt, timeThreshold),
          isNull(posts.deletedAt),
          eq2(posts.isHidden, false)
        ));
        const total = Number(totalResult[0]?.count || 0);
        const postsWithVelocity = trendingPosts.map((row) => {
          const totalEngagement = row.post.likesCount + row.post.commentsCount + row.post.sharesCount;
          const engagementRate = row.post.viewsCount > 0 ? Math.round(totalEngagement / row.post.viewsCount * 1e4) / 100 : 0;
          const hoursOld = Math.max(1, (Date.now() - new Date(row.post.createdAt).getTime()) / (1e3 * 60 * 60));
          const velocity = row.velocityScore || Math.round(totalEngagement / hoursOld * 100) / 100;
          return {
            ...row.post,
            author: row.author,
            velocity,
            engagementRate
          };
        });
        return { posts: postsWithVelocity, total };
      }
      // Admin: Get daily trends
      async getAdminDailyTrends(days = 7) {
        const results = [];
        for (let i = 0; i < days; i++) {
          const date2 = /* @__PURE__ */ new Date();
          date2.setDate(date2.getDate() - i);
          const dateStr = date2.toISOString().split("T")[0];
          const dayStart = new Date(dateStr);
          const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1e3);
          const dailyTrends = await db.select().from(trendsDaily).where(and(
            gte(trendsDaily.windowStart, dayStart),
            lt(trendsDaily.windowStart, dayEnd)
          )).orderBy(desc(trendsDaily.score)).limit(10);
          const topPostsResult = await db.select({
            id: posts.id,
            content: posts.content,
            caption: posts.caption,
            engagement: sql3`(${posts.likesCount} + ${posts.commentsCount} * 2 + ${posts.sharesCount} * 3)::int`
          }).from(posts).where(and(
            gte(posts.createdAt, dayStart),
            lt(posts.createdAt, dayEnd),
            isNull(posts.deletedAt)
          )).orderBy(desc(sql3`${posts.likesCount} + ${posts.commentsCount} * 2 + ${posts.sharesCount} * 3`)).limit(5);
          results.push({
            date: dateStr,
            topHashtags: dailyTrends.map((t) => ({ tag: t.topic, count: t.postCount })),
            topPosts: topPostsResult.map((p) => ({
              postId: p.id,
              title: (p.caption || p.content || "").slice(0, 50) + ((p.caption || p.content || "").length > 50 ? "..." : ""),
              engagement: p.engagement
            }))
          });
        }
        return results;
      }
      // Admin: Get content velocity for a specific post
      async getAdminPostVelocity(postId) {
        const post = await db.select().from(posts).where(eq2(posts.id, postId)).limit(1);
        if (!post[0]) return null;
        const velocityRecords = await db.select().from(contentVelocity).where(eq2(contentVelocity.contentId, postId)).orderBy(desc(contentVelocity.velocityScore)).limit(1);
        const hoursOld = Math.max(1, (Date.now() - new Date(post[0].createdAt).getTime()) / (1e3 * 60 * 60));
        const totalEngagement = post[0].likesCount + post[0].commentsCount + post[0].sharesCount;
        const calculatedVelocity = Math.round(totalEngagement / hoursOld * 100) / 100;
        return {
          likes: post[0].likesCount,
          comments: post[0].commentsCount,
          shares: post[0].sharesCount,
          velocityScore: velocityRecords[0]?.velocityScore || calculatedVelocity,
          peakTime: velocityRecords[0]?.recordedAt || null
        };
      }
      // ===== ADMIN LOCATION MANAGEMENT =====
      async getAdminLocationStats() {
        const [venueStats] = await db.select({
          total: sql3`count(*)::int`,
          verified: sql3`count(*) filter (where ${venues.isVerified} = true)::int`
        }).from(venues);
        const [checkInStats] = await db.select({
          total: sql3`count(*)::int`
        }).from(checkIns);
        const [locationStats] = await db.select({
          active: sql3`count(*) filter (where ${userLocations.isSharing} = true)::int`
        }).from(userLocations);
        return {
          totalVenues: venueStats?.total || 0,
          verifiedVenues: venueStats?.verified || 0,
          totalCheckIns: checkInStats?.total || 0,
          activeLocations: locationStats?.active || 0
        };
      }
      async getAdminVenues(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const conditions = [];
        if (options.search) {
          conditions.push(
            or(
              ilike(venues.name, `%${options.search}%`),
              ilike(venues.address, `%${options.search}%`),
              ilike(venues.city, `%${options.search}%`)
            )
          );
        }
        if (options.verified !== void 0) {
          conditions.push(eq2(venues.isVerified, options.verified));
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const [venuesList, countResult] = await Promise.all([
          db.select().from(venues).where(whereClause).orderBy(desc(venues.createdAt)).limit(limit).offset(offset),
          db.select({ count: sql3`count(*)::int` }).from(venues).where(whereClause)
        ]);
        return {
          venues: venuesList,
          total: countResult[0]?.count || 0
        };
      }
      async adminCreateVenue(data) {
        const [venue] = await db.insert(venues).values({
          name: data.name,
          address: data.address,
          latitude: data.lat,
          longitude: data.lng,
          category: data.category || null,
          city: data.city || null,
          country: data.country || null,
          isVerified: false,
          checkInCount: 0
        }).returning();
        return venue;
      }
      async adminUpdateVenue(venueId, data) {
        const updateData = {};
        if (data.name !== void 0) updateData.name = data.name;
        if (data.address !== void 0) updateData.address = data.address;
        if (data.category !== void 0) updateData.category = data.category;
        if (data.city !== void 0) updateData.city = data.city;
        if (data.country !== void 0) updateData.country = data.country;
        if (data.latitude !== void 0) updateData.latitude = data.latitude;
        if (data.longitude !== void 0) updateData.longitude = data.longitude;
        if (data.photoUrl !== void 0) updateData.photoUrl = data.photoUrl;
        if (data.isVerified !== void 0) updateData.isVerified = data.isVerified;
        if (Object.keys(updateData).length === 0) {
          const existing = await db.select().from(venues).where(eq2(venues.id, venueId)).limit(1);
          return existing[0];
        }
        const [updated] = await db.update(venues).set(updateData).where(eq2(venues.id, venueId)).returning();
        return updated;
      }
      async adminVerifyVenue(venueId, verified) {
        const [updated] = await db.update(venues).set({ isVerified: verified }).where(eq2(venues.id, venueId)).returning();
        return updated;
      }
      async adminDeleteVenue(venueId) {
        await db.delete(venues).where(eq2(venues.id, venueId));
      }
      async getAdminCheckIns(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const conditions = [];
        if (options.venueId) {
          conditions.push(eq2(checkIns.venueId, options.venueId));
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const [checkInsList, countResult] = await Promise.all([
          db.select({
            checkIn: checkIns,
            user: users,
            venue: venues
          }).from(checkIns).leftJoin(users, eq2(checkIns.userId, users.id)).leftJoin(venues, eq2(checkIns.venueId, venues.id)).where(whereClause).orderBy(desc(checkIns.createdAt)).limit(limit).offset(offset),
          db.select({ count: sql3`count(*)::int` }).from(checkIns).where(whereClause)
        ]);
        return {
          checkIns: checkInsList.map((row) => ({
            ...row.checkIn,
            user: row.user,
            venue: row.venue
          })),
          total: countResult[0]?.count || 0
        };
      }
      async adminDeleteCheckIn(checkInId) {
        const checkIn = await db.select().from(checkIns).where(eq2(checkIns.id, checkInId)).limit(1);
        if (checkIn[0]?.venueId) {
          await db.update(venues).set({ checkInCount: sql3`${venues.checkInCount} - 1` }).where(eq2(venues.id, checkIn[0].venueId));
        }
        await db.delete(checkIns).where(eq2(checkIns.id, checkInId));
      }
      // ===== ADMIN AR FILTERS =====
      async getAdminARFilterStats() {
        const [stats] = await db.select({
          totalFilters: sql3`count(*)::int`,
          activeFilters: sql3`count(*) filter (where ${arFilters.isActive} = true)::int`,
          featuredFilters: sql3`count(*) filter (where ${arFilters.isFeatured} = true)::int`,
          totalUsage: sql3`coalesce(sum(${arFilters.usageCount}), 0)::int`
        }).from(arFilters);
        return {
          totalFilters: stats?.totalFilters || 0,
          activeFilters: stats?.activeFilters || 0,
          featuredFilters: stats?.featuredFilters || 0,
          totalUsage: stats?.totalUsage || 0
        };
      }
      async getAdminARFilters(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const conditions = [];
        if (options.search) {
          conditions.push(
            or(
              ilike(arFilters.name, `%${options.search}%`),
              ilike(arFilters.description, `%${options.search}%`),
              ilike(arFilters.category, `%${options.search}%`)
            )
          );
        }
        if (options.featured !== void 0) {
          conditions.push(eq2(arFilters.isFeatured, options.featured));
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const [filtersList, countResult] = await Promise.all([
          db.select().from(arFilters).where(whereClause).orderBy(desc(arFilters.createdAt)).limit(limit).offset(offset),
          db.select({ count: sql3`count(*)::int` }).from(arFilters).where(whereClause)
        ]);
        return {
          filters: filtersList,
          total: countResult[0]?.count || 0
        };
      }
      async adminCreateARFilter(data) {
        const [filter] = await db.insert(arFilters).values({
          name: data.name,
          description: data.description || null,
          thumbnailUrl: data.previewUrl,
          filterUrl: data.filterUrl,
          category: data.category || null,
          creatorId: data.creatorId || null,
          isActive: true,
          isFeatured: false,
          usageCount: 0
        }).returning();
        return filter;
      }
      async adminUpdateARFilter(filterId, data) {
        const updateData = {};
        if (data.name !== void 0) updateData.name = data.name;
        if (data.description !== void 0) updateData.description = data.description;
        if (data.thumbnailUrl !== void 0) updateData.thumbnailUrl = data.thumbnailUrl;
        if (data.filterUrl !== void 0) updateData.filterUrl = data.filterUrl;
        if (data.category !== void 0) updateData.category = data.category;
        if (data.isActive !== void 0) updateData.isActive = data.isActive;
        if (data.isFeatured !== void 0) updateData.isFeatured = data.isFeatured;
        if (Object.keys(updateData).length === 0) {
          const existing = await db.select().from(arFilters).where(eq2(arFilters.id, filterId)).limit(1);
          return existing[0];
        }
        const [updated] = await db.update(arFilters).set(updateData).where(eq2(arFilters.id, filterId)).returning();
        return updated;
      }
      async adminFeatureARFilter(filterId, featured) {
        const [updated] = await db.update(arFilters).set({ isFeatured: featured }).where(eq2(arFilters.id, filterId)).returning();
        return updated;
      }
      async adminToggleARFilter(filterId, active) {
        const [updated] = await db.update(arFilters).set({ isActive: active }).where(eq2(arFilters.id, filterId)).returning();
        return updated;
      }
      async adminDeleteARFilter(filterId) {
        await db.delete(arFilters).where(eq2(arFilters.id, filterId));
      }
      // ===== ADMIN AI CONTENT MANAGEMENT =====
      async getAdminAIContentStats() {
        const [avatarCountResult] = await db.select({ count: sql3`count(*)::int` }).from(aiAvatars);
        const [translationCountResult] = await db.select({ count: sql3`count(*)::int` }).from(aiTranslations);
        const [pendingResult] = await db.select({ count: sql3`count(*)::int` }).from(aiAvatars).where(eq2(aiAvatars.isActive, false));
        const [flaggedResult] = await db.select({ count: sql3`count(*)::int` }).from(aiAvatars).where(eq2(aiAvatars.isActive, false));
        return {
          totalAvatars: avatarCountResult?.count || 0,
          totalTranslations: translationCountResult?.count || 0,
          pendingReview: pendingResult?.count || 0,
          flaggedContent: flaggedResult?.count || 0
        };
      }
      async getAdminAIAvatars(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        let conditions = [];
        if (options.status === "active") {
          conditions.push(eq2(aiAvatars.isActive, true));
        } else if (options.status === "inactive") {
          conditions.push(eq2(aiAvatars.isActive, false));
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const avatarsData = await db.select({
          avatar: aiAvatars,
          user: users
        }).from(aiAvatars).leftJoin(users, eq2(aiAvatars.userId, users.id)).where(whereClause).orderBy(desc(aiAvatars.createdAt)).limit(limit).offset(offset);
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(aiAvatars).where(whereClause);
        const avatars = avatarsData.map((row) => ({
          ...row.avatar,
          user: row.user
        }));
        return {
          avatars,
          total: countResult?.count || 0
        };
      }
      async getAdminAITranslations(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const translations = await db.select().from(aiTranslations).orderBy(desc(aiTranslations.createdAt)).limit(limit).offset(offset);
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(aiTranslations);
        return {
          translations,
          total: countResult?.count || 0
        };
      }
      async adminReviewAIAvatar(avatarId, status, reason) {
        const isActive = status === "approved";
        const [updated] = await db.update(aiAvatars).set({ isActive }).where(eq2(aiAvatars.id, avatarId)).returning();
        return updated;
      }
      async adminDeleteAIAvatar(avatarId) {
        await db.delete(aiAvatars).where(eq2(aiAvatars.id, avatarId));
      }
      async getAIAvatarById(avatarId) {
        const [avatar] = await db.select().from(aiAvatars).where(eq2(aiAvatars.id, avatarId)).limit(1);
        return avatar;
      }
      // ===== ADMIN EXPLORE CATEGORIES MANAGEMENT =====
      async getAdminExploreCategoryStats() {
        const [totalResult] = await db.select({ count: sql3`count(*)::int` }).from(exploreCategories);
        const [activeResult] = await db.select({ count: sql3`count(*)::int` }).from(exploreCategories).where(eq2(exploreCategories.isActive, true));
        const [featuredResult] = await db.select({ count: sql3`count(*)::int` }).from(exploreCategories).where(and(eq2(exploreCategories.isActive, true), lte(exploreCategories.sortOrder, 5)));
        return {
          totalCategories: totalResult?.count || 0,
          activeCategories: activeResult?.count || 0,
          featuredCategories: featuredResult?.count || 0
        };
      }
      async getAdminExploreCategories(options) {
        const page = options.page || 1;
        const limit = options.limit || 50;
        const offset = (page - 1) * limit;
        const categories = await db.select().from(exploreCategories).orderBy(exploreCategories.sortOrder, desc(exploreCategories.createdAt)).limit(limit).offset(offset);
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(exploreCategories);
        return {
          categories,
          total: countResult?.count || 0
        };
      }
      async adminCreateExploreCategory(data) {
        const [maxOrderResult] = await db.select({ maxOrder: sql3`coalesce(max(sort_order), 0)::int` }).from(exploreCategories);
        const nextOrder = data.order !== void 0 ? data.order : (maxOrderResult?.maxOrder || 0) + 1;
        const [category] = await db.insert(exploreCategories).values({
          name: data.name,
          slug: data.slug,
          description: data.description || null,
          iconName: data.iconUrl || null,
          coverUrl: data.color || null,
          sortOrder: nextOrder,
          isActive: true
        }).returning();
        return category;
      }
      async adminUpdateExploreCategory(categoryId, data) {
        const updateData = {};
        if (data.name !== void 0) updateData.name = data.name;
        if (data.slug !== void 0) updateData.slug = data.slug;
        if (data.description !== void 0) updateData.description = data.description;
        if (data.iconUrl !== void 0) updateData.iconName = data.iconUrl;
        if (data.color !== void 0) updateData.coverUrl = data.color;
        if (data.order !== void 0) updateData.sortOrder = data.order;
        if (data.isActive !== void 0) updateData.isActive = data.isActive;
        if (Object.keys(updateData).length === 0) {
          const [existing] = await db.select().from(exploreCategories).where(eq2(exploreCategories.id, categoryId)).limit(1);
          return existing;
        }
        const [updated] = await db.update(exploreCategories).set(updateData).where(eq2(exploreCategories.id, categoryId)).returning();
        return updated;
      }
      async adminReorderExploreCategories(categoryIds) {
        for (let i = 0; i < categoryIds.length; i++) {
          await db.update(exploreCategories).set({ sortOrder: i }).where(eq2(exploreCategories.id, categoryIds[i]));
        }
      }
      async adminDeleteExploreCategory(categoryId) {
        await db.delete(exploreCategories).where(eq2(exploreCategories.id, categoryId));
      }
      async getExploreCategoryById(categoryId) {
        const [category] = await db.select().from(exploreCategories).where(eq2(exploreCategories.id, categoryId)).limit(1);
        return category;
      }
      // ===== ADMIN STORY EXTENDED FEATURES =====
      async getAdminStoryExtendedStats() {
        const [highlightsResult] = await db.select({ count: sql3`count(*)::int` }).from(storyHighlights);
        const [stickersResult] = await db.select({ count: sql3`count(*)::int` }).from(storyStickers);
        const [responsesResult] = await db.select({ count: sql3`count(*)::int` }).from(storyStickerResponses);
        const [tipsResult] = await db.select({
          count: sql3`count(*)::int`,
          totalAmount: sql3`coalesce(sum(amount), 0)::int`
        }).from(storyTips);
        return {
          totalHighlights: highlightsResult?.count || 0,
          totalStickers: stickersResult?.count || 0,
          totalStickerResponses: responsesResult?.count || 0,
          totalTips: tipsResult?.count || 0,
          totalTipAmount: tipsResult?.totalAmount || 0
        };
      }
      async getAdminStoryHighlights(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const conditions = [];
        if (options.search) {
          conditions.push(ilike(storyHighlights.name, `%${options.search}%`));
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(storyHighlights).where(whereClause);
        const highlightsResult = await db.select().from(storyHighlights).where(whereClause).orderBy(desc(storyHighlights.createdAt)).limit(limit).offset(offset);
        const highlightsWithUsers = await Promise.all(
          highlightsResult.map(async (highlight) => {
            const [user] = await db.select().from(users).where(eq2(users.id, highlight.userId)).limit(1);
            const [itemCountResult] = await db.select({ count: sql3`count(*)::int` }).from(storyHighlightItems).where(eq2(storyHighlightItems.highlightId, highlight.id));
            return {
              ...highlight,
              user,
              itemCount: itemCountResult?.count || 0
            };
          })
        );
        return {
          highlights: highlightsWithUsers,
          total: countResult?.count || 0
        };
      }
      async adminDeleteStoryHighlight(highlightId) {
        await db.delete(storyHighlightItems).where(eq2(storyHighlightItems.highlightId, highlightId));
        await db.delete(storyHighlights).where(eq2(storyHighlights.id, highlightId));
      }
      async getAdminStoryStickers(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(storyStickers);
        const stickersResult = await db.select().from(storyStickers).orderBy(desc(storyStickers.createdAt)).limit(limit).offset(offset);
        const stickersWithResponses = await Promise.all(
          stickersResult.map(async (sticker) => {
            const [responsesCountResult] = await db.select({ count: sql3`count(*)::int` }).from(storyStickerResponses).where(eq2(storyStickerResponses.stickerId, sticker.id));
            return {
              ...sticker,
              responsesCount: responsesCountResult?.count || 0
            };
          })
        );
        return {
          stickers: stickersWithResponses,
          total: countResult?.count || 0
        };
      }
      async getAdminStoryTips(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(storyTips);
        const tipsResult = await db.select().from(storyTips).orderBy(desc(storyTips.createdAt)).limit(limit).offset(offset);
        const tipsWithUsers = await Promise.all(
          tipsResult.map(async (tip) => {
            const [sender] = await db.select().from(users).where(eq2(users.id, tip.senderId)).limit(1);
            const [recipient] = await db.select().from(users).where(eq2(users.id, tip.recipientId)).limit(1);
            return {
              ...tip,
              sender,
              recipient
            };
          })
        );
        return {
          tips: tipsWithUsers,
          total: countResult?.count || 0
        };
      }
      // ===== ADMIN USER PROFILE FEATURES =====
      async getAdminUserProfileStats() {
        const [introCountResult] = await db.select({ count: sql3`count(*)::int` }).from(featuredIntros);
        const [linkedCountResult] = await db.select({ count: sql3`count(*)::int` }).from(linkedAccounts);
        const [notesCountResult] = await db.select({ count: sql3`count(*)::int` }).from(userNotes).where(gt(userNotes.expiresAt, /* @__PURE__ */ new Date()));
        return {
          totalFeaturedIntros: introCountResult?.count || 0,
          pendingIntros: 0,
          totalLinkedAccounts: linkedCountResult?.count || 0,
          totalUserNotes: notesCountResult?.count || 0
        };
      }
      async getAdminFeaturedIntros(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(featuredIntros);
        const introsResult = await db.select({
          intro: featuredIntros,
          user: users
        }).from(featuredIntros).leftJoin(users, eq2(featuredIntros.userId, users.id)).orderBy(desc(featuredIntros.updatedAt)).limit(limit).offset(offset);
        const intros = introsResult.map((row) => ({
          ...row.intro,
          user: row.user
        }));
        return {
          intros,
          total: countResult?.count || 0
        };
      }
      async adminDeleteFeaturedIntro(introId) {
        await db.delete(featuredIntros).where(eq2(featuredIntros.id, introId));
      }
      async getAdminLinkedAccounts(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(linkedAccounts);
        const accountsResult = await db.select().from(linkedAccounts).orderBy(desc(linkedAccounts.linkedAt)).limit(limit).offset(offset);
        const accountsWithUsers = await Promise.all(
          accountsResult.map(async (account) => {
            const [primaryUser] = await db.select().from(users).where(eq2(users.id, account.primaryUserId)).limit(1);
            const [linkedUser] = await db.select().from(users).where(eq2(users.id, account.linkedUserId)).limit(1);
            return {
              ...account,
              primaryUser,
              linkedUser
            };
          })
        );
        if (options.search) {
          const search = options.search.toLowerCase();
          const filtered = accountsWithUsers.filter(
            (a) => a.primaryUser?.username?.toLowerCase().includes(search) || a.linkedUser?.username?.toLowerCase().includes(search)
          );
          return {
            accounts: filtered,
            total: filtered.length
          };
        }
        return {
          accounts: accountsWithUsers,
          total: countResult?.count || 0
        };
      }
      async adminUnlinkAccount(accountId) {
        await db.delete(linkedAccounts).where(eq2(linkedAccounts.id, accountId));
      }
      async getAdminUserNotesList(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(userNotes);
        const notesResult = await db.select({
          note: userNotes,
          user: users
        }).from(userNotes).leftJoin(users, eq2(userNotes.userId, users.id)).orderBy(desc(userNotes.createdAt)).limit(limit).offset(offset);
        const notes = notesResult.map((row) => ({
          ...row.note,
          user: row.user
        }));
        return {
          notes,
          total: countResult?.count || 0
        };
      }
      async adminDeleteUserNote(noteId) {
        await db.delete(userNotes).where(eq2(userNotes.id, noteId));
      }
      // ===== ADMIN DEVELOPER API MANAGEMENT =====
      async getAdminDevApiStats() {
        const [webhooksCount] = await db.select({ count: sql3`count(*)::int` }).from(webhooks);
        const [activeCount] = await db.select({ count: sql3`count(*)::int` }).from(webhooks).where(eq2(webhooks.isActive, true));
        const [tokensCount] = await db.select({ count: sql3`count(*)::int` }).from(apiAccessTokens).where(eq2(apiAccessTokens.isRevoked, false));
        const [deliveriesCount] = await db.select({ count: sql3`count(*)::int` }).from(webhookDeliveries);
        const [failedCount] = await db.select({ count: sql3`count(*)::int` }).from(webhookDeliveries).where(eq2(webhookDeliveries.success, false));
        return {
          totalWebhooks: webhooksCount?.count || 0,
          activeWebhooks: activeCount?.count || 0,
          totalApiTokens: tokensCount?.count || 0,
          totalDeliveries: deliveriesCount?.count || 0,
          failedDeliveries: failedCount?.count || 0
        };
      }
      async getAdminWebhooks(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        let baseQuery = db.select({ count: sql3`count(*)::int` }).from(webhooks);
        if (options.search) {
          baseQuery = baseQuery.where(ilike(webhooks.url, `%${options.search}%`));
        }
        const [countResult] = await baseQuery;
        let webhooksQuery = db.select({
          webhook: webhooks,
          user: users
        }).from(webhooks).leftJoin(users, eq2(webhooks.userId, users.id)).orderBy(desc(webhooks.createdAt)).limit(limit).offset(offset);
        if (options.search) {
          webhooksQuery = webhooksQuery.where(ilike(webhooks.url, `%${options.search}%`));
        }
        const webhooksResult = await webhooksQuery;
        const result = webhooksResult.map((row) => ({
          ...row.webhook,
          user: row.user
        }));
        return {
          webhooks: result,
          total: countResult?.count || 0
        };
      }
      async adminToggleWebhook(webhookId, enabled) {
        const [updated] = await db.update(webhooks).set({ isActive: enabled, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(webhooks.id, webhookId)).returning();
        return updated;
      }
      async adminDeleteWebhook(webhookId) {
        await db.delete(webhooks).where(eq2(webhooks.id, webhookId));
      }
      async getAdminWebhookDeliveryLogs(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const conditions = [];
        if (options.webhookId) {
          conditions.push(eq2(webhookDeliveries.webhookId, options.webhookId));
        }
        if (options.status === "success") {
          conditions.push(eq2(webhookDeliveries.success, true));
        } else if (options.status === "failed") {
          conditions.push(eq2(webhookDeliveries.success, false));
        }
        let countQuery = db.select({ count: sql3`count(*)::int` }).from(webhookDeliveries);
        if (conditions.length > 0) {
          countQuery = countQuery.where(and(...conditions));
        }
        const [countResult] = await countQuery;
        let logsQuery = db.select({
          delivery: webhookDeliveries,
          webhook: webhooks
        }).from(webhookDeliveries).leftJoin(webhooks, eq2(webhookDeliveries.webhookId, webhooks.id)).orderBy(desc(webhookDeliveries.createdAt)).limit(limit).offset(offset);
        if (conditions.length > 0) {
          logsQuery = logsQuery.where(and(...conditions));
        }
        const logsResult = await logsQuery;
        const logs = logsResult.map((row) => ({
          ...row.delivery,
          webhook: row.webhook || void 0
        }));
        return {
          logs,
          total: countResult?.count || 0
        };
      }
      async getAdminApiAccessTokens(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(apiAccessTokens);
        let tokensQuery = db.select({
          token: apiAccessTokens,
          user: users
        }).from(apiAccessTokens).leftJoin(users, eq2(apiAccessTokens.userId, users.id)).orderBy(desc(apiAccessTokens.createdAt)).limit(limit).offset(offset);
        if (options.search) {
          tokensQuery = tokensQuery.where(
            or(
              ilike(apiAccessTokens.name, `%${options.search}%`),
              ilike(users.username, `%${options.search}%`)
            )
          );
        }
        const tokensResult = await tokensQuery;
        const tokens = tokensResult.map((row) => ({
          ...row.token,
          user: row.user
        }));
        return {
          tokens,
          total: countResult?.count || 0
        };
      }
      async adminRevokeApiToken(tokenId) {
        await db.update(apiAccessTokens).set({ isRevoked: true }).where(eq2(apiAccessTokens.id, tokenId));
      }
      async getAdminDataPrivacyStats() {
        const [exportResult] = await db.select({ count: sql3`count(*)::int` }).from(dataExportRequests);
        const [pendingResult] = await db.select({ count: sql3`count(*)::int` }).from(dataExportRequests).where(eq2(dataExportRequests.status, "PENDING"));
        const [completedResult] = await db.select({ count: sql3`count(*)::int` }).from(dataExportRequests).where(eq2(dataExportRequests.status, "COMPLETED"));
        const [backupResult] = await db.select({ count: sql3`count(*)::int` }).from(accountBackups);
        const [importResult] = await db.select({ count: sql3`count(*)::int` }).from(platformImports);
        return {
          totalExportRequests: exportResult?.count || 0,
          pendingExports: pendingResult?.count || 0,
          completedExports: completedResult?.count || 0,
          totalBackups: backupResult?.count || 0,
          totalImports: importResult?.count || 0
        };
      }
      async getAdminExportRequests(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const conditions = [];
        if (options.status) {
          conditions.push(eq2(dataExportRequests.status, options.status));
        }
        let countQuery = db.select({ count: sql3`count(*)::int` }).from(dataExportRequests);
        if (conditions.length > 0) {
          countQuery = countQuery.where(and(...conditions));
        }
        const [countResult] = await countQuery;
        let requestsQuery = db.select({
          request: dataExportRequests,
          user: users
        }).from(dataExportRequests).leftJoin(users, eq2(dataExportRequests.userId, users.id)).orderBy(desc(dataExportRequests.createdAt)).limit(limit).offset(offset);
        if (conditions.length > 0) {
          requestsQuery = requestsQuery.where(and(...conditions));
        }
        const requestsResult = await requestsQuery;
        const requests = requestsResult.map((row) => ({
          ...row.request,
          user: row.user
        }));
        return {
          requests,
          total: countResult?.count || 0
        };
      }
      async adminUpdateExportRequestStatus(requestId, status) {
        const updateData = { status };
        if (status === "COMPLETED") {
          updateData.completedAt = /* @__PURE__ */ new Date();
          updateData.expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3);
        }
        const [updated] = await db.update(dataExportRequests).set(updateData).where(eq2(dataExportRequests.id, requestId)).returning();
        return updated;
      }
      async getAdminAccountBackups(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(accountBackups);
        const backupsResult = await db.select({
          backup: accountBackups,
          user: users
        }).from(accountBackups).leftJoin(users, eq2(accountBackups.userId, users.id)).orderBy(desc(accountBackups.createdAt)).limit(limit).offset(offset);
        const backups = backupsResult.map((row) => ({
          ...row.backup,
          user: row.user
        }));
        return {
          backups,
          total: countResult?.count || 0
        };
      }
      async getAdminPlatformImports(options) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const offset = (page - 1) * limit;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(platformImports);
        const importsResult = await db.select({
          import: platformImports,
          user: users
        }).from(platformImports).leftJoin(users, eq2(platformImports.userId, users.id)).orderBy(desc(platformImports.createdAt)).limit(limit).offset(offset);
        const imports = importsResult.map((row) => ({
          ...row.import,
          user: row.user
        }));
        return {
          imports,
          total: countResult?.count || 0
        };
      }
      async adminProcessExportRequest(requestId) {
        await db.update(dataExportRequests).set({
          status: "PROCESSING"
        }).where(eq2(dataExportRequests.id, requestId));
      }
      // ===== PLATFORM SETTINGS: WORD FILTERS =====
      async getAdminWordFilters(options) {
        const page = options.page || 1;
        const limit = options.limit || 50;
        const offset = (page - 1) * limit;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(wordFilters);
        const filters = await db.select().from(wordFilters).orderBy(desc(wordFilters.createdAt)).limit(limit).offset(offset);
        return {
          filters,
          total: countResult?.count || 0
        };
      }
      async adminCreateWordFilter(data) {
        const [filter] = await db.insert(wordFilters).values({
          word: data.word.toLowerCase().trim(),
          action: data.action,
          replacement: data.replacement || null,
          createdBy: data.createdBy || null
        }).returning();
        return filter;
      }
      async adminUpdateWordFilter(filterId, data) {
        const updateData = { ...data, updatedAt: /* @__PURE__ */ new Date() };
        if (data.word) {
          updateData.word = data.word.toLowerCase().trim();
        }
        const [updated] = await db.update(wordFilters).set(updateData).where(eq2(wordFilters.id, filterId)).returning();
        return updated;
      }
      async adminDeleteWordFilter(filterId) {
        await db.delete(wordFilters).where(eq2(wordFilters.id, filterId));
      }
      // ===== PLATFORM SETTINGS: ADMIN KEYWORD FILTERS =====
      async getAdminKeywordFilters(options) {
        const page = options.page || 1;
        const limit = options.limit || 50;
        const offset = (page - 1) * limit;
        const [countResult] = await db.select({ count: sql3`count(*)::int` }).from(adminKeywordFilters);
        const filters = await db.select().from(adminKeywordFilters).orderBy(desc(adminKeywordFilters.createdAt)).limit(limit).offset(offset);
        return {
          filters,
          total: countResult?.count || 0
        };
      }
      async adminCreateKeywordFilter(data) {
        const [filter] = await db.insert(adminKeywordFilters).values({
          keyword: data.keyword.toLowerCase().trim(),
          action: data.action,
          createdBy: data.createdBy || null
        }).returning();
        return filter;
      }
      async adminUpdateKeywordFilter(filterId, data) {
        const updateData = { ...data, updatedAt: /* @__PURE__ */ new Date() };
        if (data.keyword) {
          updateData.keyword = data.keyword.toLowerCase().trim();
        }
        const [updated] = await db.update(adminKeywordFilters).set(updateData).where(eq2(adminKeywordFilters.id, filterId)).returning();
        return updated;
      }
      async adminDeleteKeywordFilter(filterId) {
        await db.delete(adminKeywordFilters).where(eq2(adminKeywordFilters.id, filterId));
      }
      // ===== PLATFORM SETTINGS: APP SETTINGS =====
      async getAdminAppSettings() {
        return db.select().from(appSettings).orderBy(appSettings.key);
      }
      async adminUpdateAppSetting(key, value, updatedBy) {
        const [existing] = await db.select().from(appSettings).where(eq2(appSettings.key, key));
        if (existing) {
          const [updated] = await db.update(appSettings).set({ value, updatedAt: /* @__PURE__ */ new Date(), updatedBy: updatedBy || null }).where(eq2(appSettings.key, key)).returning();
          return updated;
        } else {
          const [created] = await db.insert(appSettings).values({ key, value, updatedBy: updatedBy || null }).returning();
          return created;
        }
      }
      async adminCreateAppSetting(data) {
        const [setting] = await db.insert(appSettings).values({
          key: data.key,
          value: data.value,
          type: data.type || "string",
          description: data.description || null,
          updatedBy: data.updatedBy || null
        }).returning();
        return setting;
      }
      // ===== PLATFORM SETTINGS: NOTIFICATION DEFAULTS =====
      async getAdminNotificationDefaults() {
        return db.select().from(notificationDefaults).orderBy(notificationDefaults.category, notificationDefaults.key);
      }
      async adminUpdateNotificationDefault(id, enabled, updatedBy) {
        const [updated] = await db.update(notificationDefaults).set({ defaultEnabled: enabled, updatedAt: /* @__PURE__ */ new Date(), updatedBy: updatedBy || null }).where(eq2(notificationDefaults.id, id)).returning();
        return updated;
      }
      async adminCreateNotificationDefault(data) {
        const [setting] = await db.insert(notificationDefaults).values({
          key: data.key,
          name: data.name,
          description: data.description || null,
          category: data.category,
          defaultEnabled: data.defaultEnabled !== false,
          canUserDisable: data.canUserDisable !== false,
          updatedBy: data.updatedBy || null
        }).returning();
        return setting;
      }
      async adminDeleteNotificationDefault(id) {
        await db.delete(notificationDefaults).where(eq2(notificationDefaults.id, id));
      }
      // ===== ADVANCED DASHBOARD ANALYTICS =====
      async getAdvancedDashboardStats() {
        const now = /* @__PURE__ */ new Date();
        const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const weekStart = new Date(todayStart);
        weekStart.setDate(weekStart.getDate() - 7);
        const lastWeekStart = new Date(weekStart);
        lastWeekStart.setDate(lastWeekStart.getDate() - 7);
        const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
        const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
        const safeCount = async (queryFn) => {
          try {
            const [result] = await queryFn();
            return result?.count || 0;
          } catch (e) {
            console.error("[Dashboard] Query error:", e);
            return 0;
          }
        };
        const safeSum = async (queryFn) => {
          try {
            const [result] = await queryFn();
            return result?.sum || 0;
          } catch (e) {
            console.error("[Dashboard] Sum query error:", e);
            return 0;
          }
        };
        const totalUsersCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(users));
        const usersTodayCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(users).where(gte(users.createdAt, todayStart)));
        const usersThisWeekCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(users).where(gte(users.createdAt, weekStart)));
        const usersLastWeekCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(users).where(and(gte(users.createdAt, lastWeekStart), lt(users.createdAt, weekStart))));
        const userGrowth = usersLastWeekCount > 0 ? (usersThisWeekCount - usersLastWeekCount) / usersLastWeekCount * 100 : 0;
        const totalPostsCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(posts));
        const postsTodayCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(posts).where(gte(posts.createdAt, todayStart)));
        const postsThisWeekCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(posts).where(gte(posts.createdAt, weekStart)));
        const postsLastWeekCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(posts).where(and(gte(posts.createdAt, lastWeekStart), lt(posts.createdAt, weekStart))));
        const postGrowth = postsLastWeekCount > 0 ? (postsThisWeekCount - postsLastWeekCount) / postsLastWeekCount * 100 : 0;
        const totalLikesCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(likes));
        const totalCommentsCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(comments));
        const totalSharesCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(shares));
        const avgEngagementRate = totalPostsCount > 0 ? (totalLikesCount + totalCommentsCount + totalSharesCount) / totalPostsCount : 0;
        const totalRevenueSum = await safeSum(() => db.select({ sum: sql3`COALESCE(sum(net_worth_gained), 0)::int` }).from(mallPurchases));
        const revenueThisMonthSum = await safeSum(() => db.select({ sum: sql3`COALESCE(sum(net_worth_gained), 0)::int` }).from(mallPurchases).where(gte(mallPurchases.createdAt, monthStart)));
        const revenueLastMonthSum = await safeSum(() => db.select({ sum: sql3`COALESCE(sum(net_worth_gained), 0)::int` }).from(mallPurchases).where(and(gte(mallPurchases.createdAt, lastMonthStart), lte(mallPurchases.createdAt, lastMonthEnd))));
        const revenueGrowth = revenueLastMonthSum > 0 ? (revenueThisMonthSum - revenueLastMonthSum) / revenueLastMonthSum * 100 : 0;
        let contentBreakdown = [];
        try {
          const contentCounts = await db.select({
            type: posts.type,
            count: sql3`count(*)::int`
          }).from(posts).groupBy(posts.type);
          const totalPostCount = contentCounts.reduce((sum, c) => sum + c.count, 0);
          contentBreakdown = contentCounts.map((c) => ({
            type: c.type || "TEXT",
            count: c.count,
            percentage: totalPostCount > 0 ? Math.round(c.count / totalPostCount * 100) : 0
          }));
        } catch (e) {
          console.error("[Dashboard] Content breakdown error:", e);
        }
        const pendingReportsCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(reports).where(eq2(reports.status, "PENDING")));
        const resolvedTodayCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(reports).where(and(eq2(reports.status, "RESOLVED"), gte(reports.resolvedAt, todayStart))));
        const flaggedContentCount = await safeCount(() => db.select({ count: sql3`count(*)::int` }).from(posts).where(eq2(posts.isHidden, true)));
        return {
          users: {
            total: totalUsersCount,
            today: usersTodayCount,
            thisWeek: usersThisWeekCount,
            lastWeek: usersLastWeekCount,
            growth: Math.round(userGrowth * 10) / 10
          },
          posts: {
            total: totalPostsCount,
            today: postsTodayCount,
            thisWeek: postsThisWeekCount,
            lastWeek: postsLastWeekCount,
            growth: Math.round(postGrowth * 10) / 10
          },
          engagement: {
            likes: totalLikesCount,
            comments: totalCommentsCount,
            shares: totalSharesCount,
            avgEngagementRate: Math.round(avgEngagementRate * 100) / 100
          },
          revenue: {
            total: totalRevenueSum,
            thisMonth: revenueThisMonthSum,
            lastMonth: revenueLastMonthSum,
            growth: Math.round(revenueGrowth * 10) / 10
          },
          contentBreakdown,
          moderation: {
            pendingReports: pendingReportsCount,
            resolvedToday: resolvedTodayCount,
            flaggedContent: flaggedContentCount
          }
        };
      }
      async getDashboardUserGrowth(days) {
        const now = /* @__PURE__ */ new Date();
        const startDate = new Date(now);
        startDate.setDate(startDate.getDate() - days);
        const dailyNewUsers = await db.select({
          date: sql3`DATE(created_at)::text`,
          count: sql3`count(*)::int`
        }).from(users).where(gte(users.createdAt, startDate)).groupBy(sql3`DATE(created_at)`).orderBy(sql3`DATE(created_at)`);
        const [usersBefore] = await db.select({ count: sql3`count(*)::int` }).from(users).where(lt(users.createdAt, startDate));
        let runningTotal = usersBefore?.count || 0;
        const labels = [];
        const newUsers = [];
        const totalUsers = [];
        const dataMap = new Map(dailyNewUsers.map((d) => [d.date, d.count]));
        for (let i = 0; i < days; i++) {
          const date2 = new Date(startDate);
          date2.setDate(date2.getDate() + i);
          const dateStr = date2.toISOString().split("T")[0];
          const dayCount = dataMap.get(dateStr) || 0;
          labels.push(dateStr);
          newUsers.push(dayCount);
          runningTotal += dayCount;
          totalUsers.push(runningTotal);
        }
        return { labels, newUsers, totalUsers };
      }
      async getDashboardEngagementTrends(days) {
        const now = /* @__PURE__ */ new Date();
        const startDate = new Date(now);
        startDate.setDate(startDate.getDate() - days);
        const dailyLikes = await db.select({
          date: sql3`DATE(created_at)::text`,
          count: sql3`count(*)::int`
        }).from(likes).where(gte(likes.createdAt, startDate)).groupBy(sql3`DATE(created_at)`);
        const dailyComments = await db.select({
          date: sql3`DATE(created_at)::text`,
          count: sql3`count(*)::int`
        }).from(comments).where(gte(comments.createdAt, startDate)).groupBy(sql3`DATE(created_at)`);
        const dailyPosts = await db.select({
          date: sql3`DATE(created_at)::text`,
          count: sql3`count(*)::int`
        }).from(posts).where(gte(posts.createdAt, startDate)).groupBy(sql3`DATE(created_at)`);
        const likesMap = new Map(dailyLikes.map((d) => [d.date, d.count]));
        const commentsMap = new Map(dailyComments.map((d) => [d.date, d.count]));
        const postsMap = new Map(dailyPosts.map((d) => [d.date, d.count]));
        const labels = [];
        const likesArr = [];
        const commentsArr = [];
        const postsArr = [];
        for (let i = 0; i < days; i++) {
          const date2 = new Date(startDate);
          date2.setDate(date2.getDate() + i);
          const dateStr = date2.toISOString().split("T")[0];
          labels.push(dateStr);
          likesArr.push(likesMap.get(dateStr) || 0);
          commentsArr.push(commentsMap.get(dateStr) || 0);
          postsArr.push(postsMap.get(dateStr) || 0);
        }
        return { labels, likes: likesArr, comments: commentsArr, posts: postsArr };
      }
      async getDashboardActivityFeed(limit) {
        const activities = [];
        const recentUsers = await db.select({
          id: users.id,
          username: users.username,
          displayName: users.displayName,
          createdAt: users.createdAt
        }).from(users).orderBy(desc(users.createdAt)).limit(Math.ceil(limit / 5));
        for (const user of recentUsers) {
          if (user.createdAt) {
            activities.push({
              id: `user-${user.id}`,
              type: "new_user",
              message: `${user.displayName || user.username} joined the platform`,
              timestamp: user.createdAt,
              userId: user.id,
              userName: user.username
            });
          }
        }
        const recentPosts = await db.select({
          id: posts.id,
          type: posts.type,
          authorId: posts.authorId,
          createdAt: posts.createdAt
        }).from(posts).orderBy(desc(posts.createdAt)).limit(Math.ceil(limit / 5));
        for (const post of recentPosts) {
          const author = await this.getUser(post.authorId);
          if (post.createdAt) {
            activities.push({
              id: `post-${post.id}`,
              type: "new_post",
              message: `${author?.displayName || "User"} created a ${post.type?.toLowerCase() || "text"} post`,
              timestamp: post.createdAt,
              userId: post.authorId,
              userName: author?.username
            });
          }
        }
        const recentReports = await db.select({
          id: reports.id,
          reporterId: reports.reporterId,
          reason: reports.reason,
          createdAt: reports.createdAt
        }).from(reports).orderBy(desc(reports.createdAt)).limit(Math.ceil(limit / 5));
        for (const report of recentReports) {
          if (report.createdAt) {
            activities.push({
              id: `report-${report.id}`,
              type: "report",
              message: `New report: ${report.reason.substring(0, 50)}${report.reason.length > 50 ? "..." : ""}`,
              timestamp: report.createdAt,
              userId: report.reporterId
            });
          }
        }
        const recentVerifications = await db.select({
          id: verificationRequests.id,
          userId: verificationRequests.userId,
          status: verificationRequests.status,
          updatedAt: verificationRequests.updatedAt
        }).from(verificationRequests).orderBy(desc(verificationRequests.updatedAt)).limit(Math.ceil(limit / 5));
        for (const verification of recentVerifications) {
          const user = await this.getUser(verification.userId);
          if (verification.updatedAt) {
            activities.push({
              id: `verification-${verification.id}`,
              type: "verification",
              message: `${user?.displayName || "User"} submitted verification request`,
              timestamp: verification.updatedAt,
              userId: verification.userId,
              userName: user?.username
            });
          }
        }
        const recentPurchases = await db.select({
          id: mallPurchases.id,
          userId: mallPurchases.userId,
          netWorthGained: mallPurchases.netWorthGained,
          createdAt: mallPurchases.createdAt
        }).from(mallPurchases).orderBy(desc(mallPurchases.createdAt)).limit(Math.ceil(limit / 5));
        for (const purchase of recentPurchases) {
          const user = await this.getUser(purchase.userId);
          if (purchase.createdAt) {
            activities.push({
              id: `purchase-${purchase.id}`,
              type: "purchase",
              message: `${user?.displayName || "User"} made a purchase worth ${purchase.netWorthGained.toLocaleString()} net worth`,
              timestamp: purchase.createdAt,
              userId: purchase.userId,
              userName: user?.username
            });
          }
        }
        return activities.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime()).slice(0, limit);
      }
      async getDashboardTopPerformers() {
        const topUsersByFollowers = await db.select({
          userId: follows.followingId,
          followers: sql3`count(*)::int`
        }).from(follows).groupBy(follows.followingId).orderBy(desc(sql3`count(*)`)).limit(10);
        const topUsers = [];
        for (const u of topUsersByFollowers) {
          const user = await this.getUser(u.userId);
          if (user) {
            const [postCount] = await db.select({ count: sql3`count(*)::int` }).from(posts).where(eq2(posts.authorId, user.id));
            const [likeCount] = await db.select({ count: sql3`count(*)::int` }).from(likes).innerJoin(posts, eq2(likes.postId, posts.id)).where(eq2(posts.authorId, user.id));
            topUsers.push({
              id: user.id,
              name: user.displayName || user.username,
              username: user.username,
              avatar: user.avatarUrl || "",
              followers: u.followers,
              posts: postCount?.count || 0,
              engagement: likeCount?.count || 0
            });
          }
        }
        const topPostsByLikes = await db.select({
          postId: likes.postId,
          likeCount: sql3`count(*)::int`
        }).from(likes).groupBy(likes.postId).orderBy(desc(sql3`count(*)`)).limit(10);
        const topPosts = [];
        for (const p of topPostsByLikes) {
          const post = await this.getPost(p.postId);
          if (post) {
            const [commentCount] = await db.select({ count: sql3`count(*)::int` }).from(comments).where(eq2(comments.postId, post.id));
            topPosts.push({
              id: post.id,
              userId: post.authorId,
              userName: post.author?.displayName || post.author?.username || "Unknown",
              type: post.type || "TEXT",
              likes: p.likeCount,
              comments: commentCount?.count || 0,
              createdAt: post.createdAt
            });
          }
        }
        const now = /* @__PURE__ */ new Date();
        const weekAgo = new Date(now);
        weekAgo.setDate(weekAgo.getDate() - 7);
        const twoWeeksAgo = new Date(weekAgo);
        twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 7);
        const currentTrends = await db.select({
          topic: trendsDaily.topic,
          count: sql3`sum(post_count)::int`
        }).from(trendsDaily).where(gte(trendsDaily.windowStart, weekAgo)).groupBy(trendsDaily.topic).orderBy(desc(sql3`sum(post_count)`)).limit(10);
        const lastWeekTrends = await db.select({
          topic: trendsDaily.topic,
          count: sql3`sum(post_count)::int`
        }).from(trendsDaily).where(and(gte(trendsDaily.windowStart, twoWeeksAgo), lt(trendsDaily.windowStart, weekAgo))).groupBy(trendsDaily.topic);
        const lastWeekMap = new Map(lastWeekTrends.map((t) => [t.topic, t.count]));
        const topHashtags = currentTrends.map((t) => {
          const lastWeekCount = lastWeekMap.get(t.topic) || 0;
          const growth = lastWeekCount > 0 ? (t.count - lastWeekCount) / lastWeekCount * 100 : 0;
          return {
            name: t.topic,
            postCount: t.count,
            growth: Math.round(growth * 10) / 10
          };
        });
        return { topUsers, topPosts, topHashtags };
      }
      async getDashboardContentDistribution() {
        const distribution = await db.select({
          type: posts.type,
          count: sql3`count(*)::int`
        }).from(posts).groupBy(posts.type).orderBy(desc(sql3`count(*)`));
        const labels = distribution.map((d) => d.type || "TEXT");
        const data = distribution.map((d) => d.count);
        return { labels, data };
      }
      async getDashboardPeakHours() {
        const postActivity = await db.select({
          hour: sql3`EXTRACT(HOUR FROM created_at)::int`,
          dayOfWeek: sql3`EXTRACT(DOW FROM created_at)::int`,
          count: sql3`count(*)::int`
        }).from(posts).where(gte(posts.createdAt, sql3`NOW() - INTERVAL '30 days'`)).groupBy(sql3`EXTRACT(HOUR FROM created_at)`, sql3`EXTRACT(DOW FROM created_at)`);
        const likeActivity = await db.select({
          hour: sql3`EXTRACT(HOUR FROM created_at)::int`,
          dayOfWeek: sql3`EXTRACT(DOW FROM created_at)::int`,
          count: sql3`count(*)::int`
        }).from(likes).where(gte(likes.createdAt, sql3`NOW() - INTERVAL '30 days'`)).groupBy(sql3`EXTRACT(HOUR FROM created_at)`, sql3`EXTRACT(DOW FROM created_at)`);
        const activityMap = /* @__PURE__ */ new Map();
        for (const p of postActivity) {
          const key = `${p.hour}-${p.dayOfWeek}`;
          activityMap.set(key, (activityMap.get(key) || 0) + p.count);
        }
        for (const l of likeActivity) {
          const key = `${l.hour}-${l.dayOfWeek}`;
          activityMap.set(key, (activityMap.get(key) || 0) + l.count);
        }
        const result = [];
        for (let day = 0; day < 7; day++) {
          for (let hour = 0; hour < 24; hour++) {
            const key = `${hour}-${day}`;
            result.push({
              hour,
              dayOfWeek: day,
              activity: activityMap.get(key) || 0
            });
          }
        }
        return result;
      }
      // ===== WALLET & COIN OPERATIONS =====
      async getOrCreateWallet(userId) {
        const existing = await db.select().from(wallets).where(eq2(wallets.userId, userId)).limit(1);
        if (existing.length > 0) {
          return existing[0];
        }
        const [wallet] = await db.insert(wallets).values({
          userId,
          coinBalance: 0,
          lifetimeEarned: 0,
          lifetimeSpent: 0,
          isFrozen: false
        }).returning();
        return wallet;
      }
      async getWallet(userId) {
        const result = await db.select().from(wallets).where(eq2(wallets.userId, userId)).limit(1);
        return result[0] || null;
      }
      async addCoins(userId, amount, type, description, referenceType, referenceId) {
        if (amount <= 0) throw new Error("Amount must be positive");
        const wallet = await this.getOrCreateWallet(userId);
        if (wallet.isFrozen) throw new Error("Wallet is frozen");
        const [updatedWallet] = await db.update(wallets).set({
          coinBalance: sql3`${wallets.coinBalance} + ${amount}`,
          lifetimeEarned: sql3`${wallets.lifetimeEarned} + ${amount}`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(wallets.userId, userId)).returning();
        const [transaction] = await db.insert(coinTransactions).values({
          walletId: wallet.id,
          amount,
          type,
          description,
          balanceAfter: updatedWallet.coinBalance,
          referenceType,
          referenceId
        }).returning();
        return { wallet: updatedWallet, transaction };
      }
      async deductCoins(userId, amount, type, description, referenceType, referenceId) {
        if (amount <= 0) throw new Error("Amount must be positive");
        const wallet = await this.getOrCreateWallet(userId);
        if (wallet.isFrozen) throw new Error("Wallet is frozen");
        if (wallet.coinBalance < amount) throw new Error("Insufficient balance");
        const [updatedWallet] = await db.update(wallets).set({
          coinBalance: sql3`${wallets.coinBalance} - ${amount}`,
          lifetimeSpent: sql3`${wallets.lifetimeSpent} + ${amount}`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(wallets.userId, userId)).returning();
        const [transaction] = await db.insert(coinTransactions).values({
          walletId: wallet.id,
          amount: -amount,
          type,
          description,
          balanceAfter: updatedWallet.coinBalance,
          referenceType,
          referenceId
        }).returning();
        return { wallet: updatedWallet, transaction };
      }
      async adminAdjustWallet(userId, amount, reason, adminId) {
        const wallet = await this.getOrCreateWallet(userId);
        const newBalance = wallet.coinBalance + amount;
        if (newBalance < 0) throw new Error("Cannot set negative balance");
        const [updatedWallet] = await db.update(wallets).set({
          coinBalance: newBalance,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(wallets.userId, userId)).returning();
        await db.insert(coinTransactions).values({
          walletId: wallet.id,
          amount,
          type: amount > 0 ? "ADMIN_CREDIT" : "ADMIN_DEBIT",
          description: `Admin adjustment: ${reason}`,
          balanceAfter: newBalance,
          referenceType: "admin",
          referenceId: adminId
        });
        return updatedWallet;
      }
      async freezeWallet(userId, frozen) {
        const [wallet] = await db.update(wallets).set({ isFrozen: frozen, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(wallets.userId, userId)).returning();
        return wallet;
      }
      async getCoinTransactions(userId, limit = 50, offset = 0) {
        const wallet = await this.getWallet(userId);
        if (!wallet) return [];
        return db.select().from(coinTransactions).where(eq2(coinTransactions.walletId, wallet.id)).orderBy(desc(coinTransactions.createdAt)).limit(limit).offset(offset);
      }
      // ===== COIN BUNDLES =====
      async getCoinBundles(activeOnly = true) {
        const query = activeOnly ? db.select().from(coinBundles).where(eq2(coinBundles.isActive, true)) : db.select().from(coinBundles);
        return query.orderBy(coinBundles.sortOrder);
      }
      async getCoinBundle(id) {
        const result = await db.select().from(coinBundles).where(eq2(coinBundles.id, id)).limit(1);
        return result[0] || null;
      }
      async createCoinBundle(data) {
        const [bundle] = await db.insert(coinBundles).values(data).returning();
        return bundle;
      }
      async updateCoinBundle(id, data) {
        const [bundle] = await db.update(coinBundles).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(coinBundles.id, id)).returning();
        return bundle;
      }
      async createCoinPurchase(userId, bundleId, coinsReceived, amountPaidRands, paymentReference) {
        const [purchase] = await db.insert(coinPurchases).values({
          userId,
          bundleId,
          coinsReceived,
          amountPaidRands,
          paymentReference,
          status: "pending"
        }).returning();
        return purchase;
      }
      async getCoinPurchase(id) {
        const result = await db.select().from(coinPurchases).where(eq2(coinPurchases.id, id)).limit(1);
        return result[0] || null;
      }
      async getCoinPurchaseByReference(paymentReference) {
        const result = await db.select().from(coinPurchases).where(eq2(coinPurchases.paymentReference, paymentReference)).limit(1);
        return result[0] || null;
      }
      async completeCoinPurchase(paymentReference) {
        const [purchase] = await db.select().from(coinPurchases).where(and(eq2(coinPurchases.paymentReference, paymentReference), eq2(coinPurchases.status, "pending"))).limit(1);
        if (!purchase) return null;
        const [updatedPurchase] = await db.update(coinPurchases).set({ status: "completed", completedAt: /* @__PURE__ */ new Date() }).where(eq2(coinPurchases.id, purchase.id)).returning();
        const { wallet } = await this.addCoins(
          purchase.userId,
          purchase.coinsReceived,
          "PURCHASE",
          `Coin bundle purchase`,
          "coin_purchase",
          purchase.id
        );
        await db.insert(platformRevenue).values({
          source: "COIN_PURCHASE",
          amountRands: purchase.amountPaidRands,
          referenceType: "coin_purchase",
          referenceId: purchase.id,
          userId: purchase.userId
        });
        return { purchase: updatedPurchase, wallet };
      }
      // ===== DAILY REWARDS =====
      async getDailyRewardStatus(userId) {
        const result = await db.select().from(dailyRewards).where(eq2(dailyRewards.userId, userId)).limit(1);
        return result[0] || null;
      }
      async getDailyRewardConfig() {
        return db.select().from(dailyRewardConfig).where(eq2(dailyRewardConfig.isActive, true)).orderBy(dailyRewardConfig.dayNumber);
      }
      async claimDailyReward(userId) {
        const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        let status = await this.getDailyRewardStatus(userId);
        if (status?.lastClaimDate === today) {
          throw new Error("Already claimed today");
        }
        const configs = await this.getDailyRewardConfig();
        const yesterday = new Date(Date.now() - 864e5).toISOString().split("T")[0];
        let newStreak = 1;
        if (status?.lastClaimDate === yesterday) {
          newStreak = status.currentStreak + 1;
        }
        const dayConfig = configs.find((c) => c.dayNumber === (newStreak - 1) % 7 + 1) || configs[0];
        const coinsEarned = (dayConfig?.baseCoins || 10) + (dayConfig?.streakBonus || 0) * Math.floor(newStreak / 7);
        if (status) {
          const [updated] = await db.update(dailyRewards).set({
            lastClaimDate: today,
            currentStreak: newStreak,
            longestStreak: Math.max(status.longestStreak, newStreak),
            totalClaimed: status.totalClaimed + 1,
            totalCoinsEarned: status.totalCoinsEarned + coinsEarned,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq2(dailyRewards.userId, userId)).returning();
          status = updated;
        } else {
          const [created] = await db.insert(dailyRewards).values({
            userId,
            lastClaimDate: today,
            currentStreak: 1,
            longestStreak: 1,
            totalClaimed: 1,
            totalCoinsEarned: coinsEarned
          }).returning();
          status = created;
        }
        const { wallet } = await this.addCoins(userId, coinsEarned, "DAILY_REWARD", `Day ${newStreak} daily reward`);
        return { reward: status, coinsEarned, wallet };
      }
      // ===== MALL WISHLISTS & REVIEWS =====
      async addToWishlist(userId, itemId) {
        const [wishlist] = await db.insert(mallWishlists).values({ userId, itemId }).returning();
        return wishlist;
      }
      async removeFromWishlist(userId, itemId) {
        await db.delete(mallWishlists).where(and(eq2(mallWishlists.userId, userId), eq2(mallWishlists.itemId, itemId)));
      }
      async getWishlist(userId) {
        return db.select().from(mallWishlists).where(eq2(mallWishlists.userId, userId)).orderBy(desc(mallWishlists.createdAt));
      }
      async createReview(userId, itemId, rating, review) {
        const purchases = await db.select().from(mallPurchases).where(and(eq2(mallPurchases.userId, userId), eq2(mallPurchases.itemId, itemId))).limit(1);
        const [created] = await db.insert(mallReviews).values({
          userId,
          itemId,
          rating,
          review,
          isVerifiedPurchase: purchases.length > 0
        }).returning();
        return created;
      }
      async getItemReviews(itemId, limit = 20) {
        return db.select().from(mallReviews).where(and(eq2(mallReviews.itemId, itemId), eq2(mallReviews.isHidden, false))).orderBy(desc(mallReviews.createdAt)).limit(limit);
      }
      // ===== GIFT OPERATIONS =====
      async getGiftTypes(activeOnly = true) {
        const query = activeOnly ? db.select().from(giftTypes).where(eq2(giftTypes.isActive, true)) : db.select().from(giftTypes);
        return query.orderBy(giftTypes.sortOrder);
      }
      async getGiftType(id) {
        const result = await db.select().from(giftTypes).where(eq2(giftTypes.id, id)).limit(1);
        return result[0] || null;
      }
      async sendGift(senderId, recipientId, giftTypeId, quantity, contextType, contextId, message) {
        const gift = await this.getGiftType(giftTypeId);
        if (!gift) throw new Error("Gift type not found");
        if (!gift.isActive) throw new Error("Gift type is disabled");
        const totalCoins = gift.coinCost * quantity;
        const netWorthValue = gift.netWorthValue * quantity;
        const { wallet: senderWallet } = await this.deductCoins(
          senderId,
          totalCoins,
          "GIFT_SENT",
          `Sent ${quantity}x ${gift.name} gift`,
          "gift",
          giftTypeId
        );
        const [transaction] = await db.insert(giftTransactions).values({
          senderId,
          recipientId,
          giftTypeId,
          quantity,
          totalCoins,
          contextType,
          contextId,
          message
        }).returning();
        if (netWorthValue > 0) {
          await db.update(users).set({ netWorth: sql3`${users.netWorth} + ${netWorthValue}` }).where(eq2(users.id, recipientId));
          await db.insert(netWorthLedger).values({
            userId: recipientId,
            delta: netWorthValue,
            reason: "GIFT",
            refType: "gift_transaction",
            refId: transaction.id
          });
        }
        return { transaction, senderWallet };
      }
      // ===== WITHDRAWALS =====
      async createWithdrawalRequest(userId, bankAccountId, amountCoins) {
        const wallet = await this.getOrCreateWallet(userId);
        if (wallet.isFrozen) throw new Error("Wallet is frozen");
        if (wallet.coinBalance < amountCoins) throw new Error("Insufficient balance");
        const kyc = await db.select().from(userKyc).where(eq2(userKyc.userId, userId)).limit(1);
        if (!kyc[0] || kyc[0].status !== "APPROVED") throw new Error("KYC verification required");
        const platformFeeCoins = Math.floor(amountCoins * 0.5);
        const netAmountCoins = amountCoins - platformFeeCoins;
        const amountRands = Math.floor(netAmountCoins / 100);
        await this.deductCoins(userId, amountCoins, "WITHDRAWAL", "Withdrawal request", "withdrawal", "pending");
        const [request] = await db.insert(withdrawalRequests).values({
          userId,
          bankAccountId,
          amountCoins,
          platformFeeCoins,
          netAmountCoins,
          amountRands,
          status: "PENDING"
        }).returning();
        return request;
      }
      async getWithdrawalRequests(userId, status, limit = 50) {
        let query = db.select().from(withdrawalRequests);
        const conditions = [];
        if (userId) conditions.push(eq2(withdrawalRequests.userId, userId));
        if (status) conditions.push(eq2(withdrawalRequests.status, status));
        if (conditions.length > 0) {
          query = query.where(and(...conditions));
        }
        return query.orderBy(desc(withdrawalRequests.createdAt)).limit(limit);
      }
      async approveWithdrawal(requestId, adminId, paymentReference) {
        const [request] = await db.update(withdrawalRequests).set({
          status: "APPROVED",
          processedBy: adminId,
          processedAt: /* @__PURE__ */ new Date(),
          paymentReference,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(withdrawalRequests.id, requestId)).returning();
        await db.insert(platformRevenue).values({
          source: "WITHDRAWAL_FEE",
          amountRands: Math.floor(request.platformFeeCoins / 100),
          referenceType: "withdrawal",
          referenceId: requestId,
          userId: request.userId
        });
        return request;
      }
      async rejectWithdrawal(requestId, adminId, reason) {
        const [existing] = await db.select().from(withdrawalRequests).where(eq2(withdrawalRequests.id, requestId)).limit(1);
        if (!existing) throw new Error("Request not found");
        await this.addCoins(existing.userId, existing.amountCoins, "WITHDRAWAL_REFUND", "Withdrawal rejected - refund", "withdrawal", requestId);
        const [request] = await db.update(withdrawalRequests).set({
          status: "REJECTED",
          processedBy: adminId,
          processedAt: /* @__PURE__ */ new Date(),
          rejectionReason: reason,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(withdrawalRequests.id, requestId)).returning();
        return request;
      }
      // ===== BANK ACCOUNTS & KYC =====
      async addBankAccount(userId, data) {
        const existing = await db.select().from(userBankAccounts).where(eq2(userBankAccounts.userId, userId));
        const isPrimary = existing.length === 0;
        const [account] = await db.insert(userBankAccounts).values({
          ...data,
          userId,
          isPrimary
        }).returning();
        return account;
      }
      async getUserBankAccounts(userId) {
        return db.select().from(userBankAccounts).where(eq2(userBankAccounts.userId, userId)).orderBy(desc(userBankAccounts.createdAt));
      }
      async getBankAccountById(bankAccountId) {
        const [account] = await db.select().from(userBankAccounts).where(eq2(userBankAccounts.id, bankAccountId)).limit(1);
        return account;
      }
      async deleteBankAccount(userId, bankAccountId) {
        const account = await this.getBankAccountById(bankAccountId);
        if (!account || account.userId !== userId) return false;
        const pendingWithdrawals = await db.select().from(withdrawalRequests).where(and(
          eq2(withdrawalRequests.bankAccountId, bankAccountId),
          inArray(withdrawalRequests.status, ["PENDING", "PROCESSING"])
        )).limit(1);
        if (pendingWithdrawals.length > 0) {
          throw new Error("Cannot delete bank account with pending withdrawals");
        }
        await db.delete(userBankAccounts).where(eq2(userBankAccounts.id, bankAccountId));
        if (account.isPrimary) {
          const remaining = await this.getUserBankAccounts(userId);
          if (remaining.length > 0) {
            await db.update(userBankAccounts).set({ isPrimary: true, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(userBankAccounts.id, remaining[0].id));
          }
        }
        return true;
      }
      async setPrimaryBankAccount(userId, bankAccountId) {
        const account = await this.getBankAccountById(bankAccountId);
        if (!account || account.userId !== userId) {
          throw new Error("Bank account not found");
        }
        await db.update(userBankAccounts).set({ isPrimary: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(userBankAccounts.userId, userId));
        const [updated] = await db.update(userBankAccounts).set({ isPrimary: true, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(userBankAccounts.id, bankAccountId)).returning();
        return updated;
      }
      async getWithdrawalById(withdrawalId) {
        const [request] = await db.select().from(withdrawalRequests).where(eq2(withdrawalRequests.id, withdrawalId)).limit(1);
        return request;
      }
      async processWithdrawal(requestId, adminId, paymentReference) {
        const existing = await this.getWithdrawalById(requestId);
        if (!existing) throw new Error("Withdrawal request not found");
        if (existing.status !== "APPROVED") throw new Error("Only approved withdrawals can be processed");
        const [request] = await db.update(withdrawalRequests).set({
          status: "COMPLETED",
          paymentReference,
          processedBy: adminId,
          processedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(withdrawalRequests.id, requestId)).returning();
        return request;
      }
      async getOrCreateKyc(userId) {
        const existing = await db.select().from(userKyc).where(eq2(userKyc.userId, userId)).limit(1);
        if (existing.length > 0) return existing[0];
        const [kyc] = await db.insert(userKyc).values({ userId }).returning();
        return kyc;
      }
      async updateKyc(userId, data) {
        const [kyc] = await db.update(userKyc).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(userKyc.userId, userId)).returning();
        return kyc;
      }
      async submitKyc(userId, data) {
        const [kyc] = await db.update(userKyc).set({
          ...data,
          status: "PENDING",
          submittedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(userKyc.userId, userId)).returning();
        return kyc;
      }
      async reviewKyc(userId, status, adminId, rejectionReason) {
        const [kyc] = await db.update(userKyc).set({
          status,
          reviewedBy: adminId,
          reviewedAt: /* @__PURE__ */ new Date(),
          rejectionReason: status === "REJECTED" ? rejectionReason : null,
          expiresAt: status === "APPROVED" ? new Date(Date.now() + 365 * 864e5) : null,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq2(userKyc.userId, userId)).returning();
        return kyc;
      }
      async getPendingKycReviews(limit = 50) {
        return db.select().from(userKyc).where(eq2(userKyc.status, "PENDING")).orderBy(userKyc.submittedAt).limit(limit);
      }
      // ===== PLATFORM STATS =====
      async getEconomyStats() {
        const [walletStats] = await db.select({
          total: sql3`COALESCE(SUM(${wallets.coinBalance}), 0)`,
          count: sql3`COUNT(*)`,
          avg: sql3`COALESCE(AVG(${wallets.coinBalance}), 0)`
        }).from(wallets);
        const [revenueStats] = await db.select({
          total: sql3`COALESCE(SUM(${platformRevenue.amountRands}), 0)`
        }).from(platformRevenue);
        const [withdrawalStats] = await db.select({
          pending: sql3`COUNT(*)`
        }).from(withdrawalRequests).where(eq2(withdrawalRequests.status, "PENDING"));
        return {
          totalCoinsInCirculation: Number(walletStats.total),
          totalWallets: Number(walletStats.count),
          totalRevenue: Number(revenueStats.total),
          pendingWithdrawals: Number(withdrawalStats.pending),
          averageBalance: Math.floor(Number(walletStats.avg))
        };
      }
      async getRevenueBySource(startDate, endDate) {
        let query = db.select({
          source: platformRevenue.source,
          total: sql3`SUM(${platformRevenue.amountRands})`
        }).from(platformRevenue);
        const conditions = [];
        if (startDate) conditions.push(gte(platformRevenue.createdAt, startDate));
        if (endDate) conditions.push(lte(platformRevenue.createdAt, endDate));
        if (conditions.length > 0) {
          query = query.where(and(...conditions));
        }
        return query.groupBy(platformRevenue.source);
      }
      async getGiftStats() {
        const [stats] = await db.select({
          total: sql3`COUNT(*)`,
          coins: sql3`COALESCE(SUM(${giftTransactions.totalCoins}), 0)`
        }).from(giftTransactions);
        const topGifts = await db.select({
          giftTypeId: giftTransactions.giftTypeId,
          name: giftTypes.name,
          count: sql3`COUNT(*)`
        }).from(giftTransactions).leftJoin(giftTypes, eq2(giftTransactions.giftTypeId, giftTypes.id)).groupBy(giftTransactions.giftTypeId, giftTypes.name).orderBy(desc(sql3`COUNT(*)`)).limit(10);
        return {
          totalGiftsSent: Number(stats.total),
          totalCoinsGifted: Number(stats.coins),
          topGiftTypes: topGifts.map((g) => ({
            giftTypeId: g.giftTypeId,
            name: g.name || "Unknown",
            count: Number(g.count)
          }))
        };
      }
      // ===== PLATFORM CONFIG =====
      async getPlatformConfig(category) {
        if (category) {
          return db.select().from(platformConfig).where(eq2(platformConfig.category, category));
        }
        return db.select().from(platformConfig);
      }
      async setPlatformConfig(key, value, category, adminId) {
        const existing = await db.select().from(platformConfig).where(eq2(platformConfig.key, key)).limit(1);
        if (existing.length > 0) {
          const [updated] = await db.update(platformConfig).set({ value, updatedBy: adminId, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(platformConfig.key, key)).returning();
          return updated;
        }
        const [created] = await db.insert(platformConfig).values({
          key,
          value,
          category,
          updatedBy: adminId
        }).returning();
        return created;
      }
      // ===== WEALTH CLUBS =====
      async getWealthClubs() {
        return db.select().from(wealthClubs).orderBy(wealthClubs.minNetWorth);
      }
      async getUserWealthClub(userId) {
        const result = await db.select().from(userWealthClub).innerJoin(wealthClubs, eq2(userWealthClub.clubId, wealthClubs.id)).where(eq2(userWealthClub.userId, userId)).limit(1);
        if (result.length === 0) return null;
        return {
          ...result[0].user_wealth_club,
          ...result[0].wealth_clubs
        };
      }
      async updateUserWealthClub(userId) {
        const user = await this.getUser(userId);
        if (!user) return;
        const clubs = await this.getWealthClubs();
        let matchingClub = null;
        for (const club of clubs) {
          if (user.netWorth >= club.minNetWorth) {
            if (!club.maxNetWorth || user.netWorth <= club.maxNetWorth) {
              matchingClub = club;
            }
          }
        }
        if (!matchingClub) return;
        const existing = await db.select().from(userWealthClub).where(eq2(userWealthClub.userId, userId)).limit(1);
        if (existing.length > 0) {
          if (existing[0].clubId !== matchingClub.id) {
            await db.update(userWealthClub).set({ clubId: matchingClub.id, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(userWealthClub.userId, userId));
          }
        } else {
          await db.insert(userWealthClub).values({
            userId,
            clubId: matchingClub.id
          });
        }
      }
      // ===== GIFT STAKING =====
      async getStakingTiers() {
        return db.select().from(stakingTiers).where(eq2(stakingTiers.isActive, true)).orderBy(stakingTiers.sortOrder);
      }
      async createGiftStake(userId, giftTransactionId, tierId) {
        const tier = await db.select().from(stakingTiers).where(eq2(stakingTiers.id, tierId)).limit(1);
        if (tier.length === 0) {
          throw new Error("Invalid staking tier");
        }
        const transaction = await db.select().from(giftTransactions).where(eq2(giftTransactions.id, giftTransactionId)).limit(1);
        if (transaction.length === 0) {
          throw new Error("Invalid gift transaction");
        }
        const stakedCoins = transaction[0].totalCoins;
        const bonusPercent = tier[0].bonusPercent;
        const expectedReturn = Math.floor(stakedCoins * (1 + bonusPercent / 100));
        const maturesAt = /* @__PURE__ */ new Date();
        maturesAt.setDate(maturesAt.getDate() + tier[0].durationDays);
        const [stake] = await db.insert(giftStakes).values({
          userId,
          giftTransactionId,
          stakedCoins,
          stakeDurationDays: tier[0].durationDays,
          bonusPercent,
          expectedReturn,
          maturesAt
        }).returning();
        return stake;
      }
      async getUserStakes(userId) {
        return db.select().from(giftStakes).where(and(
          eq2(giftStakes.userId, userId),
          eq2(giftStakes.status, "ACTIVE")
        )).orderBy(giftStakes.maturesAt);
      }
      async claimMaturedStake(stakeId, userId) {
        const [stake] = await db.select().from(giftStakes).where(and(
          eq2(giftStakes.id, stakeId),
          eq2(giftStakes.userId, userId)
        )).limit(1);
        if (!stake) {
          throw new Error("Stake not found");
        }
        if (stake.status !== "ACTIVE") {
          throw new Error("Stake is not active");
        }
        if (/* @__PURE__ */ new Date() < stake.maturesAt) {
          throw new Error("Stake has not matured yet");
        }
        const [updatedStake] = await db.update(giftStakes).set({ status: "CLAIMED", claimedAt: /* @__PURE__ */ new Date() }).where(eq2(giftStakes.id, stakeId)).returning();
        const wallet = await this.getOrCreateWallet(userId);
        const newBalance = wallet.coinBalance + stake.expectedReturn;
        await db.update(wallets).set({ coinBalance: newBalance, lifetimeEarned: sql3`${wallets.lifetimeEarned} + ${stake.expectedReturn}` }).where(eq2(wallets.userId, userId));
        await db.insert(coinTransactions).values({
          walletId: wallet.id,
          type: "ADMIN_CREDIT",
          amount: stake.expectedReturn,
          balanceAfter: newBalance,
          description: `Staking reward claimed`
        });
        return { stake: updatedStake, coinsEarned: stake.expectedReturn };
      }
      // ===== CREATOR MONETIZATION =====
      async getOrCreateCreatorEarnings(userId) {
        const existing = await db.select().from(creatorEarnings).where(eq2(creatorEarnings.userId, userId)).limit(1);
        if (existing.length > 0) {
          return existing[0];
        }
        const [created] = await db.insert(creatorEarnings).values({
          userId,
          totalEarningsCoins: 0,
          pendingWithdrawalCoins: 0,
          withdrawnCoins: 0,
          platformFeePaid: 0
        }).returning();
        return created;
      }
      async addCreatorEarning(userId, amount, sourceType, sourceId, description) {
        const earnings = await this.getOrCreateCreatorEarnings(userId);
        await db.update(creatorEarnings).set({
          totalEarningsCoins: earnings.totalEarningsCoins + amount,
          pendingWithdrawalCoins: earnings.pendingWithdrawalCoins + amount,
          lastUpdated: /* @__PURE__ */ new Date()
        }).where(eq2(creatorEarnings.userId, userId));
        await db.insert(earningsHistory).values({
          userId,
          amount,
          sourceType,
          sourceId,
          description
        });
      }
      async getCreatorEarningsHistory(userId, limit = 50, offset = 0) {
        return db.select().from(earningsHistory).where(eq2(earningsHistory.userId, userId)).orderBy(desc(earningsHistory.createdAt)).limit(limit).offset(offset);
      }
      // ===== ACHIEVEMENTS =====
      async getAchievements() {
        return db.select().from(achievements).where(eq2(achievements.isActive, true)).orderBy(achievements.sortOrder);
      }
      async getUserAchievements(userId) {
        return db.select().from(userAchievements).where(eq2(userAchievements.userId, userId)).orderBy(desc(userAchievements.updatedAt));
      }
      async checkAndAwardAchievements(userId) {
        const allAchievements = await this.getAchievements();
        const userAchievementsList = await this.getUserAchievements(userId);
        const existingAchievementIds = new Set(userAchievementsList.map((ua) => ua.achievementId));
        const newlyCompleted = [];
        for (const achievement of allAchievements) {
          if (existingAchievementIds.has(achievement.id)) continue;
          const userAchievement = userAchievementsList.find((ua) => ua.achievementId === achievement.id);
          if (userAchievement?.isCompleted) continue;
          const progressMax = parseInt(achievement.requirement) || 1;
          if (!userAchievement) {
            await db.insert(userAchievements).values({
              userId,
              achievementId: achievement.id,
              progress: 0,
              progressMax,
              isCompleted: false
            });
          }
        }
        for (const userAchievement of userAchievementsList) {
          if (!userAchievement.isCompleted && userAchievement.progress >= userAchievement.progressMax) {
            await db.update(userAchievements).set({
              isCompleted: true,
              completedAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq2(userAchievements.id, userAchievement.id));
            const achievement = allAchievements.find((a) => a.id === userAchievement.achievementId);
            if (achievement) {
              newlyCompleted.push(achievement);
            }
          }
        }
        return newlyCompleted;
      }
      async claimAchievementReward(userId, achievementId) {
        const [userAchievement] = await db.select().from(userAchievements).where(and(
          eq2(userAchievements.userId, userId),
          eq2(userAchievements.achievementId, achievementId)
        )).limit(1);
        if (!userAchievement) {
          throw new Error("Achievement not found for user");
        }
        if (!userAchievement.isCompleted) {
          throw new Error("Achievement not completed");
        }
        if (userAchievement.rewardClaimed) {
          throw new Error("Reward already claimed");
        }
        const [achievement] = await db.select().from(achievements).where(eq2(achievements.id, achievementId)).limit(1);
        if (!achievement) {
          throw new Error("Achievement not found");
        }
        await db.update(userAchievements).set({ rewardClaimed: true, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(userAchievements.id, userAchievement.id));
        if (achievement.rewardCoins > 0) {
          const wallet = await this.getOrCreateWallet(userId);
          const newBalance = wallet.coinBalance + achievement.rewardCoins;
          await db.update(wallets).set({ coinBalance: newBalance, lifetimeEarned: sql3`${wallets.lifetimeEarned} + ${achievement.rewardCoins}` }).where(eq2(wallets.userId, userId));
          await db.insert(coinTransactions).values({
            walletId: wallet.id,
            type: "ADMIN_CREDIT",
            amount: achievement.rewardCoins,
            balanceAfter: newBalance,
            description: `Achievement reward: ${achievement.name}`
          });
        }
        return achievement.rewardCoins;
      }
      // ===== PLATFORM BATTLES =====
      async getActiveBattles() {
        const now = /* @__PURE__ */ new Date();
        return db.select().from(platformBattles).where(and(
          eq2(platformBattles.status, "ACTIVE"),
          lte(platformBattles.startsAt, now),
          gte(platformBattles.endsAt, now)
        )).orderBy(platformBattles.startsAt);
      }
      async createBattle(creatorId, data) {
        const [battle] = await db.insert(platformBattles).values({
          creatorId,
          name: data.name,
          description: data.description,
          entryFeeCoins: data.entryFeeCoins || 0,
          maxParticipants: data.maxParticipants,
          startsAt: data.startsAt,
          endsAt: data.endsAt,
          status: "PENDING",
          prizePoolCoins: 0
        }).returning();
        return battle;
      }
      async joinBattle(battleId, userId) {
        const [battle] = await db.select().from(platformBattles).where(eq2(platformBattles.id, battleId)).limit(1);
        if (!battle) {
          throw new Error("Battle not found");
        }
        if (battle.status !== "PENDING" && battle.status !== "ACTIVE") {
          throw new Error("Battle is not accepting participants");
        }
        const existingParticipant = await db.select().from(battleParticipants).where(and(
          eq2(battleParticipants.battleId, battleId),
          eq2(battleParticipants.userId, userId)
        )).limit(1);
        if (existingParticipant.length > 0) {
          throw new Error("Already joined this battle");
        }
        if (battle.maxParticipants) {
          const currentCount = await db.select({ count: sql3`COUNT(*)` }).from(battleParticipants).where(eq2(battleParticipants.battleId, battleId));
          if (Number(currentCount[0].count) >= battle.maxParticipants) {
            throw new Error("Battle is full");
          }
        }
        if (battle.entryFeeCoins > 0) {
          const wallet = await this.getOrCreateWallet(userId);
          if (wallet.coinBalance < battle.entryFeeCoins) {
            throw new Error("Insufficient coins for entry fee");
          }
          const newBalance = wallet.coinBalance - battle.entryFeeCoins;
          await db.update(wallets).set({ coinBalance: newBalance, lifetimeSpent: sql3`${wallets.lifetimeSpent} + ${battle.entryFeeCoins}` }).where(eq2(wallets.userId, userId));
          await db.insert(coinTransactions).values({
            walletId: wallet.id,
            type: "ADMIN_DEBIT",
            amount: -battle.entryFeeCoins,
            balanceAfter: newBalance,
            description: `Battle entry fee: ${battle.name}`
          });
          await db.update(platformBattles).set({ prizePoolCoins: battle.prizePoolCoins + battle.entryFeeCoins }).where(eq2(platformBattles.id, battleId));
        }
        const [participant] = await db.insert(battleParticipants).values({
          battleId,
          userId,
          totalGiftsReceived: 0,
          totalCoinsReceived: 0
        }).returning();
        return participant;
      }
      async recordBattleGift(battleId, recipientId, coins) {
        const [participant] = await db.select().from(battleParticipants).where(and(
          eq2(battleParticipants.battleId, battleId),
          eq2(battleParticipants.userId, recipientId)
        )).limit(1);
        if (!participant) {
          throw new Error("Recipient is not a battle participant");
        }
        await db.update(battleParticipants).set({
          totalGiftsReceived: participant.totalGiftsReceived + 1,
          totalCoinsReceived: participant.totalCoinsReceived + coins
        }).where(eq2(battleParticipants.id, participant.id));
        await db.update(platformBattles).set({ prizePoolCoins: sql3`${platformBattles.prizePoolCoins} + ${coins}` }).where(eq2(platformBattles.id, battleId));
      }
      async endBattle(battleId) {
        const [battle] = await db.select().from(platformBattles).where(eq2(platformBattles.id, battleId)).limit(1);
        if (!battle) {
          throw new Error("Battle not found");
        }
        const participants = await db.select().from(battleParticipants).where(eq2(battleParticipants.battleId, battleId)).orderBy(desc(battleParticipants.totalCoinsReceived));
        for (let i = 0; i < participants.length; i++) {
          await db.update(battleParticipants).set({ rank: i + 1 }).where(eq2(battleParticipants.id, participants[i].id));
        }
        const winner = participants[0];
        let updatedBattle;
        if (winner && battle.prizePoolCoins > 0) {
          const platformFee = Math.floor(battle.prizePoolCoins * (battle.platformFeePercent / 100));
          const winnerPrize = battle.prizePoolCoins - platformFee;
          const wallet = await this.getOrCreateWallet(winner.userId);
          const newBalance = wallet.coinBalance + winnerPrize;
          await db.update(wallets).set({ coinBalance: newBalance, lifetimeEarned: sql3`${wallets.lifetimeEarned} + ${winnerPrize}` }).where(eq2(wallets.userId, winner.userId));
          await db.insert(coinTransactions).values({
            walletId: wallet.id,
            type: "ADMIN_CREDIT",
            amount: winnerPrize,
            balanceAfter: newBalance,
            description: `Battle winner prize: ${battle.name}`
          });
          if (platformFee > 0) {
            await db.insert(platformRevenue).values({
              source: "BATTLE_FEE",
              amountRands: Math.floor(platformFee / 100),
              referenceId: battleId,
              referenceType: "battle"
            });
          }
          [updatedBattle] = await db.update(platformBattles).set({
            status: "COMPLETED",
            winnerId: winner.userId
          }).where(eq2(platformBattles.id, battleId)).returning();
        } else {
          [updatedBattle] = await db.update(platformBattles).set({ status: "COMPLETED" }).where(eq2(platformBattles.id, battleId)).returning();
        }
        return updatedBattle;
      }
      // ===== ECONOMY CONFIG =====
      async getEconomyConfig() {
        const configs = await db.select().from(economyConfig);
        const result = {};
        for (const config of configs) {
          result[config.key] = config.value;
        }
        return result;
      }
      async setEconomyConfig(key, value, adminId) {
        const existing = await db.select().from(economyConfig).where(eq2(economyConfig.key, key)).limit(1);
        if (existing.length > 0) {
          await db.update(economyConfig).set({ value, updatedBy: adminId, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(economyConfig.key, key));
        } else {
          await db.insert(economyConfig).values({
            key,
            value,
            updatedBy: adminId
          });
        }
      }
      async isFeatureEnabled(key) {
        const [config] = await db.select().from(economyConfig).where(eq2(economyConfig.key, key)).limit(1);
        if (!config) return true;
        return config.value.toLowerCase() === "true" || config.value === "1" || config.value.toLowerCase() === "enabled";
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/ads-storage.ts
import { eq as eq7, desc as desc5, and as and6, sql as sql7, gte as gte3, lte as lte4, gt as gt4, or as or4, isNull as isNull4, asc as asc3, count as count2 } from "drizzle-orm";
async function createAdvertiser(data) {
  const [advertiser] = await db.insert(advertisers).values({
    ...data,
    userId: data.userId
  }).returning();
  return advertiser;
}
async function getAdvertiserById(id) {
  const [advertiser] = await db.select().from(advertisers).where(eq7(advertisers.id, id));
  return advertiser;
}
async function getAdvertiserByUserId(userId) {
  const [advertiser] = await db.select().from(advertisers).where(eq7(advertisers.userId, userId));
  return advertiser;
}
async function updateAdvertiser(id, data) {
  const [updated] = await db.update(advertisers).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(advertisers.id, id)).returning();
  return updated;
}
async function getAllAdvertisers(options = {}) {
  const conditions = [];
  if (options.status) {
    conditions.push(eq7(advertisers.status, options.status));
  }
  if (options.verificationStatus) {
    conditions.push(eq7(advertisers.verificationStatus, options.verificationStatus));
  }
  const query = db.select().from(advertisers);
  const countQuery = db.select({ count: count2() }).from(advertisers);
  if (conditions.length > 0) {
    const whereClause = and6(...conditions);
    const results2 = await query.where(whereClause).limit(options.limit || 50).offset(options.offset || 0).orderBy(desc5(advertisers.createdAt));
    const [{ count: total2 }] = await countQuery.where(whereClause);
    return { advertisers: results2, total: total2 };
  }
  const results = await query.limit(options.limit || 50).offset(options.offset || 0).orderBy(desc5(advertisers.createdAt));
  const [{ count: total }] = await countQuery;
  return { advertisers: results, total };
}
async function createAdvertisingTerms(data) {
  const [terms] = await db.insert(advertisingTerms).values({
    ...data,
    version: data.version,
    title: data.title,
    content: data.content,
    effectiveDate: data.effectiveDate
  }).returning();
  return terms;
}
async function getActiveAdvertisingTerms() {
  const [terms] = await db.select().from(advertisingTerms).where(and6(eq7(advertisingTerms.isActive, true), lte4(advertisingTerms.effectiveDate, /* @__PURE__ */ new Date()))).orderBy(desc5(advertisingTerms.effectiveDate)).limit(1);
  return terms;
}
async function getAllAdvertisingTerms() {
  return db.select().from(advertisingTerms).orderBy(desc5(advertisingTerms.effectiveDate));
}
async function setActiveTerms(id) {
  await db.update(advertisingTerms).set({ isActive: false }).where(eq7(advertisingTerms.isActive, true));
  await db.update(advertisingTerms).set({ isActive: true, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(advertisingTerms.id, id));
}
async function createAdPolicy(data) {
  const [policy] = await db.insert(adPolicies).values({
    ...data,
    category: data.category,
    name: data.name,
    description: data.description
  }).returning();
  return policy;
}
async function getAdPolicies(category) {
  const query = db.select().from(adPolicies);
  if (category) {
    return query.where(and6(eq7(adPolicies.category, category), eq7(adPolicies.isActive, true))).orderBy(adPolicies.sortOrder);
  }
  return query.where(eq7(adPolicies.isActive, true)).orderBy(adPolicies.sortOrder);
}
async function updateAdPolicy(id, data) {
  const [updated] = await db.update(adPolicies).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(adPolicies.id, id)).returning();
  return updated;
}
async function createWalletAccount(advertiserId) {
  const [wallet] = await db.insert(adWalletAccounts).values({ advertiserId }).returning();
  return wallet;
}
async function getWalletByAdvertiserId(advertiserId) {
  const [wallet] = await db.select().from(adWalletAccounts).where(eq7(adWalletAccounts.advertiserId, advertiserId));
  return wallet;
}
async function getWalletById(walletId) {
  const [wallet] = await db.select().from(adWalletAccounts).where(eq7(adWalletAccounts.id, walletId));
  return wallet;
}
async function updateWalletBalance(walletId, amount, type) {
  const [wallet] = await db.select().from(adWalletAccounts).where(eq7(adWalletAccounts.id, walletId));
  if (!wallet) return void 0;
  if (wallet.isFrozen) {
    throw new Error("Wallet is frozen and cannot be modified");
  }
  if (type === "debit") {
    const currentBalance = wallet.balance || 0;
    if (currentBalance < amount) {
      throw new Error(`Insufficient balance. Have ${currentBalance}, need ${amount}`);
    }
  }
  const [updated] = await db.update(adWalletAccounts).set({
    balance: type === "credit" ? sql7`COALESCE(${adWalletAccounts.balance}, 0) + ${amount}` : sql7`COALESCE(${adWalletAccounts.balance}, 0) - ${amount}`,
    lifetimeDeposits: type === "credit" ? sql7`COALESCE(${adWalletAccounts.lifetimeDeposits}, 0) + ${amount}` : sql7`${adWalletAccounts.lifetimeDeposits}`,
    lifetimeSpend: type === "debit" ? sql7`COALESCE(${adWalletAccounts.lifetimeSpend}, 0) + ${amount}` : sql7`${adWalletAccounts.lifetimeSpend}`,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(
    and6(
      eq7(adWalletAccounts.id, walletId),
      eq7(adWalletAccounts.isFrozen, false),
      type === "debit" ? gte3(adWalletAccounts.balance, amount) : sql7`TRUE`
    )
  ).returning();
  if (!updated) {
    throw new Error("Failed to update wallet balance - wallet may be frozen or have insufficient funds");
  }
  return updated;
}
async function freezeWallet(walletId, reason, frozenById) {
  const [updated] = await db.update(adWalletAccounts).set({ isFrozen: true, frozenReason: reason, frozenAt: /* @__PURE__ */ new Date(), frozenById, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(adWalletAccounts.id, walletId)).returning();
  return updated;
}
async function unfreezeWallet(walletId) {
  const [updated] = await db.update(adWalletAccounts).set({ isFrozen: false, frozenReason: null, frozenAt: null, frozenById: null, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(adWalletAccounts.id, walletId)).returning();
  return updated;
}
async function createWalletTransaction(data) {
  const [tx] = await db.insert(adWalletTransactions).values(data).returning();
  return tx;
}
async function getWalletTransactions(walletId, options = {}) {
  return db.select().from(adWalletTransactions).where(eq7(adWalletTransactions.walletId, walletId)).orderBy(desc5(adWalletTransactions.createdAt)).limit(options.limit || 50).offset(options.offset || 0);
}
async function getTransactionById(id) {
  const [tx] = await db.select().from(adWalletTransactions).where(eq7(adWalletTransactions.id, id));
  return tx;
}
async function updateTransaction(id, data) {
  const [updated] = await db.update(adWalletTransactions).set({ ...data }).where(eq7(adWalletTransactions.id, id)).returning();
  return updated;
}
async function createCampaign(data) {
  const [campaign] = await db.insert(adCampaigns).values(data).returning();
  return campaign;
}
async function getCampaignById(id) {
  const [campaign] = await db.select().from(adCampaigns).where(eq7(adCampaigns.id, id));
  return campaign;
}
async function getCampaignsByAdvertiser(advertiserId, options = {}) {
  const conditions = [eq7(adCampaigns.advertiserId, advertiserId)];
  if (options.status) {
    conditions.push(eq7(adCampaigns.status, options.status));
  }
  const campaigns = await db.select().from(adCampaigns).where(and6(...conditions)).orderBy(desc5(adCampaigns.createdAt)).limit(options.limit || 50).offset(options.offset || 0);
  const campaignsWithAdStatus = await Promise.all(
    campaigns.map(async (campaign) => {
      const [ad] = await db.select({ status: ads.status }).from(ads).where(eq7(ads.campaignId, campaign.id)).limit(1);
      return {
        ...campaign,
        adStatus: ad?.status || void 0
      };
    })
  );
  return campaignsWithAdStatus;
}
async function getAllCampaigns(options = {}) {
  const conditions = [];
  if (options.status) {
    conditions.push(eq7(adCampaigns.status, options.status));
  }
  const query = db.select().from(adCampaigns);
  const countQuery = db.select({ count: count2() }).from(adCampaigns);
  if (conditions.length > 0) {
    const whereClause = and6(...conditions);
    const results2 = await query.where(whereClause).limit(options.limit || 50).offset(options.offset || 0).orderBy(desc5(adCampaigns.createdAt));
    const [{ count: total2 }] = await countQuery.where(whereClause);
    return { campaigns: results2, total: total2 };
  }
  const results = await query.limit(options.limit || 50).offset(options.offset || 0).orderBy(desc5(adCampaigns.createdAt));
  const [{ count: total }] = await countQuery;
  return { campaigns: results, total };
}
async function updateCampaign(id, data) {
  const [updated] = await db.update(adCampaigns).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(adCampaigns.id, id)).returning();
  return updated;
}
async function updateCampaignStatus(id, status, reviewerId, reason) {
  const updates = { status, updatedAt: /* @__PURE__ */ new Date() };
  if (status === "APPROVED" || status === "REJECTED") {
    updates.reviewedAt = /* @__PURE__ */ new Date();
    updates.reviewedById = reviewerId;
  }
  if (status === "REJECTED" && reason) {
    updates.rejectionReason = reason;
  }
  if (status === "PAUSED") {
    updates.pausedAt = /* @__PURE__ */ new Date();
    updates.pausedById = reviewerId;
  }
  const [updated] = await db.update(adCampaigns).set(updates).where(eq7(adCampaigns.id, id)).returning();
  return updated;
}
async function createAdGroup(data) {
  const [adGroup] = await db.insert(adGroups).values(data).returning();
  return adGroup;
}
async function getAdGroupById(id) {
  const [adGroup] = await db.select().from(adGroups).where(eq7(adGroups.id, id));
  return adGroup;
}
async function getAdGroupsByCampaign(campaignId) {
  return db.select().from(adGroups).where(eq7(adGroups.campaignId, campaignId)).orderBy(desc5(adGroups.createdAt));
}
async function updateAdGroup(id, data) {
  const [updated] = await db.update(adGroups).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(adGroups.id, id)).returning();
  return updated;
}
async function generateAdNumber() {
  const result = await db.select({ adNumber: ads.adNumber }).from(ads).where(sql7`ad_number IS NOT NULL`).orderBy(desc5(ads.adNumber)).limit(1);
  let nextNumber = 1;
  if (result.length > 0 && result[0].adNumber) {
    const match = result[0].adNumber.match(/AD-(\d+)/);
    if (match) {
      nextNumber = parseInt(match[1], 10) + 1;
    }
  }
  return `AD-${String(nextNumber).padStart(6, "0")}`;
}
async function createAd(data) {
  const adNumber = await generateAdNumber();
  const [ad] = await db.insert(ads).values({ ...data, adNumber }).returning();
  console.log(`[Ad Created] Ad ${adNumber} (${ad.id}) created for campaign ${ad.campaignId}`);
  return ad;
}
async function getAdById(id) {
  const [ad] = await db.select().from(ads).where(eq7(ads.id, id));
  return ad;
}
async function getAdsByAdGroup(adGroupId) {
  return db.select().from(ads).where(eq7(ads.adGroupId, adGroupId)).orderBy(desc5(ads.createdAt));
}
async function getAdsByCampaign(campaignId) {
  return db.select().from(ads).where(eq7(ads.campaignId, campaignId)).orderBy(desc5(ads.createdAt));
}
async function getAllAds(options = {}) {
  const conditions = [];
  if (options.status) {
    conditions.push(eq7(ads.status, options.status));
  }
  if (options.format) {
    conditions.push(eq7(ads.format, options.format));
  }
  const query = db.select().from(ads);
  const countQuery = db.select({ count: count2() }).from(ads);
  if (conditions.length > 0) {
    const whereClause = and6(...conditions);
    const results2 = await query.where(whereClause).limit(options.limit || 50).offset(options.offset || 0).orderBy(desc5(ads.createdAt));
    const [{ count: total2 }] = await countQuery.where(whereClause);
    return { ads: results2, total: total2 };
  }
  const results = await query.limit(options.limit || 50).offset(options.offset || 0).orderBy(desc5(ads.createdAt));
  const [{ count: total }] = await countQuery;
  return { ads: results, total };
}
async function updateAd(id, data) {
  const [updated] = await db.update(ads).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(ads.id, id)).returning();
  return updated;
}
async function updateAdStatus(id, status, reviewerId, reason) {
  const updates = { status, updatedAt: /* @__PURE__ */ new Date() };
  if (status === "APPROVED" || status === "REJECTED") {
    updates.reviewedAt = /* @__PURE__ */ new Date();
    updates.reviewedById = reviewerId;
  }
  if (status === "REJECTED" && reason) {
    updates.rejectionReason = reason;
  }
  if (status === "PAUSED") {
    updates.pausedAt = /* @__PURE__ */ new Date();
    updates.pausedById = reviewerId;
  }
  const [updated] = await db.update(ads).set(updates).where(eq7(ads.id, id)).returning();
  return updated;
}
async function getCampaignStats(campaignId, startDate, endDate) {
  return db.select().from(adStatsDaily).where(and6(
    eq7(adStatsDaily.campaignId, campaignId),
    gte3(adStatsDaily.date, startDate),
    lte4(adStatsDaily.date, endDate)
  )).orderBy(asc3(adStatsDaily.date));
}
async function createCustomAudience(data) {
  const [audience] = await db.insert(adCustomAudiences).values({
    ...data,
    advertiserId: data.advertiserId,
    name: data.name
  }).returning();
  return audience;
}
async function getCustomAudiencesByAdvertiser(advertiserId) {
  return db.select().from(adCustomAudiences).where(eq7(adCustomAudiences.advertiserId, advertiserId)).orderBy(desc5(adCustomAudiences.createdAt));
}
async function createReviewHistory(data) {
  const [history] = await db.insert(adReviewHistory).values({
    ...data,
    adId: data.adId,
    campaignId: data.campaignId,
    action: data.action
  }).returning();
  return history;
}
async function getReviewHistoryByAd(adId) {
  return db.select().from(adReviewHistory).where(eq7(adReviewHistory.adId, adId)).orderBy(desc5(adReviewHistory.createdAt));
}
async function getCampaignDiagnostics(campaignId) {
  return db.select().from(adDeliveryDiagnostics).where(and6(eq7(adDeliveryDiagnostics.campaignId, campaignId), eq7(adDeliveryDiagnostics.isResolved, false))).orderBy(desc5(adDeliveryDiagnostics.createdAt));
}
async function getAdvertiserAchievements(advertiserId) {
  return db.select().from(advertiserAchievements).where(eq7(advertiserAchievements.advertiserId, advertiserId)).orderBy(desc5(advertiserAchievements.earnedAt));
}
async function createAdAuditLog(data) {
  const [log3] = await db.insert(adAuditLogs).values(data).returning();
  return log3;
}
async function getAdAuditLogs(options = {}) {
  const conditions = [];
  if (options.advertiserId) {
    conditions.push(eq7(adAuditLogs.advertiserId, options.advertiserId));
  }
  if (options.action) {
    conditions.push(eq7(adAuditLogs.action, options.action));
  }
  const query = db.select().from(adAuditLogs);
  const countQuery = db.select({ count: count2() }).from(adAuditLogs);
  if (conditions.length > 0) {
    const whereClause = and6(...conditions);
    const results2 = await query.where(whereClause).limit(options.limit || 50).offset(options.offset || 0).orderBy(desc5(adAuditLogs.createdAt));
    const [{ count: total2 }] = await countQuery.where(whereClause);
    return { logs: results2, total: total2 };
  }
  const results = await query.limit(options.limit || 50).offset(options.offset || 0).orderBy(desc5(adAuditLogs.createdAt));
  const [{ count: total }] = await countQuery;
  return { logs: results, total };
}
async function getSystemSetting(key) {
  const [setting] = await db.select().from(adSystemSettings).where(eq7(adSystemSettings.key, key));
  return setting;
}
async function updateSystemSetting(key, value, updatedById, description) {
  const existing = await getSystemSetting(key);
  if (existing) {
    const [updated] = await db.update(adSystemSettings).set({ value, updatedById, updatedAt: /* @__PURE__ */ new Date() }).where(eq7(adSystemSettings.key, key)).returning();
    return updated;
  }
  const [created] = await db.insert(adSystemSettings).values({ key, value, description, updatedById }).returning();
  return created;
}
async function getAllSystemSettings(category) {
  if (category) {
    return db.select().from(adSystemSettings).where(eq7(adSystemSettings.category, category));
  }
  return db.select().from(adSystemSettings);
}
async function createConversionPixel(data) {
  const pixelCode = `RC-${Math.random().toString(36).substring(2, 10).toUpperCase()}`;
  const [pixel] = await db.insert(adConversionPixels).values({
    ...data,
    advertiserId: data.advertiserId,
    name: data.name,
    pixelCode
  }).returning();
  return pixel;
}
async function getConversionPixelsByAdvertiser(advertiserId) {
  return db.select().from(adConversionPixels).where(eq7(adConversionPixels.advertiserId, advertiserId)).orderBy(desc5(adConversionPixels.createdAt));
}
async function getConversionPixelByCode(code) {
  const [pixel] = await db.select().from(adConversionPixels).where(eq7(adConversionPixels.pixelCode, code));
  return pixel;
}
async function incrementPixelFires(pixelId) {
  await db.update(adConversionPixels).set({ totalFires: sql7`${adConversionPixels.totalFires} + 1`, lastFiredAt: /* @__PURE__ */ new Date() }).where(eq7(adConversionPixels.id, pixelId));
}
async function createPromoCode(data) {
  const [promo] = await db.insert(adPromoCodes).values({
    ...data,
    code: data.code,
    amount: data.amount
  }).returning();
  return promo;
}
async function getPromoCodeByCode(code) {
  const [promo] = await db.select().from(adPromoCodes).where(and6(eq7(adPromoCodes.code, code.toUpperCase()), eq7(adPromoCodes.isActive, true)));
  return promo;
}
async function getAllPromoCodes() {
  return db.select().from(adPromoCodes).orderBy(desc5(adPromoCodes.createdAt));
}
async function atomicRedeemPromoCode(promoCodeId, advertiserId, walletId, promoAmount, usageLimit) {
  const [existingRedemption] = await db.select().from(adPromoCodeRedemptions).where(and6(
    eq7(adPromoCodeRedemptions.promoCodeId, promoCodeId),
    eq7(adPromoCodeRedemptions.advertiserId, advertiserId)
  ));
  if (existingRedemption) {
    return { success: false, error: "You have already redeemed this promo code" };
  }
  const updateResult = await db.update(adPromoCodes).set({ usageCount: sql7`COALESCE(${adPromoCodes.usageCount}, 0) + 1` }).where(
    and6(
      eq7(adPromoCodes.id, promoCodeId),
      usageLimit ? sql7`COALESCE(${adPromoCodes.usageCount}, 0) < ${usageLimit}` : sql7`TRUE`
    )
  ).returning();
  if (!updateResult.length) {
    return { success: false, error: "Promo code usage limit reached" };
  }
  try {
    await db.insert(adPromoCodeRedemptions).values({
      promoCodeId,
      advertiserId,
      amountCredited: promoAmount
    });
  } catch (error) {
    if (error.code === "23505") {
      await db.update(adPromoCodes).set({ usageCount: sql7`GREATEST(COALESCE(${adPromoCodes.usageCount}, 0) - 1, 0)` }).where(eq7(adPromoCodes.id, promoCodeId));
      return { success: false, error: "You have already redeemed this promo code" };
    }
    throw error;
  }
  return { success: true };
}
async function getPendingReviewAds() {
  return db.select().from(ads).where(eq7(ads.status, "PENDING_REVIEW")).orderBy(asc3(ads.submittedAt));
}
async function getPendingReviewCampaigns() {
  return db.select().from(adCampaigns).where(eq7(adCampaigns.status, "PENDING_REVIEW")).orderBy(asc3(adCampaigns.submittedAt));
}
async function getAdsOverview() {
  const [advertiserStats] = await db.select({
    total: count2(),
    active: sql7`COUNT(*) FILTER (WHERE status = 'ACTIVE')`
  }).from(advertisers);
  const [campaignStats] = await db.select({
    total: count2(),
    active: sql7`COUNT(*) FILTER (WHERE status = 'ACTIVE')`
  }).from(adCampaigns);
  const [adStats] = await db.select({
    total: count2(),
    active: sql7`COUNT(*) FILTER (WHERE status = 'ACTIVE')`,
    pending: sql7`COUNT(*) FILTER (WHERE status = 'PENDING_REVIEW')`,
    totalSpend: sql7`COALESCE(SUM(spend), 0)`,
    totalImpressions: sql7`COALESCE(SUM(impressions), 0)`,
    totalClicks: sql7`COALESCE(SUM(clicks), 0)`
  }).from(ads);
  return {
    totalAdvertisers: advertiserStats.total,
    activeAdvertisers: advertiserStats.active,
    totalCampaigns: campaignStats.total,
    activeCampaigns: campaignStats.active,
    totalAds: adStats.total,
    activeAds: adStats.active,
    pendingReview: adStats.pending,
    totalSpend: adStats.totalSpend,
    totalImpressions: adStats.totalImpressions,
    totalClicks: adStats.totalClicks
  };
}
async function getCtaPerformanceStats() {
  const result = await db.select({
    callToAction: ads.callToAction,
    impressions: sql7`COALESCE(SUM(${ads.impressions}), 0)`,
    clicks: sql7`COALESCE(SUM(${ads.clicks}), 0)`,
    conversions: sql7`COALESCE(SUM(${ads.conversions}), 0)`
  }).from(ads).where(sql7`${ads.callToAction} IS NOT NULL`).groupBy(ads.callToAction).orderBy(sql7`SUM(${ads.clicks}) DESC`);
  return result.map((r) => ({
    callToAction: r.callToAction || "UNKNOWN",
    impressions: Number(r.impressions) || 0,
    clicks: Number(r.clicks) || 0,
    conversions: Number(r.conversions) || 0
  }));
}
async function getDestinationPerformanceStats() {
  const result = await db.select({
    url: ads.destinationUrl,
    clicks: sql7`COALESCE(SUM(${ads.clicks}), 0)`,
    conversions: sql7`COALESCE(SUM(${ads.conversions}), 0)`,
    adCount: sql7`COUNT(*)`
  }).from(ads).where(sql7`${ads.destinationUrl} IS NOT NULL AND ${ads.destinationUrl} LIKE 'http%'`).groupBy(ads.destinationUrl).orderBy(sql7`SUM(${ads.clicks}) DESC`).limit(50);
  return result.map((r) => ({
    url: r.url || "",
    clicks: Number(r.clicks) || 0,
    conversions: Number(r.conversions) || 0,
    adCount: Number(r.adCount) || 1
  }));
}
var init_ads_storage = __esm({
  "server/ads-storage.ts"() {
    "use strict";
    init_db();
    init_schema();
  }
});

// server/services/payfast.ts
var payfast_exports = {};
__export(payfast_exports, {
  createPaymentData: () => createPaymentData,
  formatAmountCents: () => formatAmountCents,
  generateSignature: () => generateSignature,
  getPayFastUrl: () => getPayFastUrl,
  isPayFastConfigured: () => isPayFastConfigured,
  parseAmountToRands: () => parseAmountToRands,
  validateITNSignature: () => validateITNSignature
});
import crypto3 from "crypto";
function isPayFastConfigured() {
  return !!(PAYFAST_MERCHANT_ID && PAYFAST_MERCHANT_KEY);
}
function getPayFastUrl() {
  return SANDBOX_MODE ? PAYFAST_SANDBOX_URL : PAYFAST_LIVE_URL;
}
function generateSignature(data, passphrase) {
  const orderedKeys = [
    "merchant_id",
    "merchant_key",
    "return_url",
    "cancel_url",
    "notify_url",
    "name_first",
    "name_last",
    "email_address",
    "cell_number",
    "m_payment_id",
    "amount",
    "item_name",
    "item_description",
    "custom_str1",
    "custom_str2",
    "custom_str3",
    "custom_str4",
    "custom_str5",
    "custom_int1",
    "custom_int2",
    "custom_int3",
    "custom_int4",
    "custom_int5",
    "email_confirmation",
    "confirmation_address"
  ];
  let pfOutput = "";
  for (const key of orderedKeys) {
    if (data[key] !== void 0 && data[key] !== "") {
      pfOutput += `${key}=${encodeURIComponent(String(data[key]).trim()).replace(/%20/g, "+")}&`;
    }
  }
  pfOutput = pfOutput.slice(0, -1);
  if (passphrase) {
    pfOutput += `&passphrase=${encodeURIComponent(passphrase.trim()).replace(/%20/g, "+")}`;
  }
  return crypto3.createHash("md5").update(pfOutput).digest("hex");
}
function validateITNSignature(data) {
  const receivedSignature = data.signature;
  const dataForSignature = { ...data };
  delete dataForSignature.signature;
  let pfParamString = "";
  for (const [key, value] of Object.entries(dataForSignature)) {
    if (value !== void 0 && value !== "") {
      pfParamString += `${key}=${encodeURIComponent(String(value).trim()).replace(/%20/g, "+")}&`;
    }
  }
  pfParamString = pfParamString.slice(0, -1);
  if (PAYFAST_PASSPHRASE) {
    pfParamString += `&passphrase=${encodeURIComponent(PAYFAST_PASSPHRASE.trim()).replace(/%20/g, "+")}`;
  }
  const calculatedSignature = crypto3.createHash("md5").update(pfParamString).digest("hex");
  return calculatedSignature === receivedSignature;
}
function createPaymentData(options) {
  if (!PAYFAST_MERCHANT_ID || !PAYFAST_MERCHANT_KEY) {
    throw new Error("PayFast credentials not configured");
  }
  const data = {
    merchant_id: PAYFAST_MERCHANT_ID,
    merchant_key: PAYFAST_MERCHANT_KEY,
    return_url: options.returnUrl,
    cancel_url: options.cancelUrl,
    notify_url: options.notifyUrl,
    m_payment_id: options.orderId,
    amount: options.amount.toFixed(2),
    item_name: options.itemName.substring(0, 100),
    item_description: options.itemDescription?.substring(0, 255),
    email_address: options.email,
    name_first: options.firstName,
    name_last: options.lastName,
    custom_str1: options.userId
  };
  data.signature = generateSignature(data, PAYFAST_PASSPHRASE);
  return data;
}
function formatAmountCents(amountCents) {
  return amountCents / 100;
}
function parseAmountToRands(amountString) {
  return parseFloat(amountString);
}
var PAYFAST_MERCHANT_ID, PAYFAST_MERCHANT_KEY, PAYFAST_PASSPHRASE, PAYFAST_SANDBOX_URL, PAYFAST_LIVE_URL, SANDBOX_MODE;
var init_payfast = __esm({
  "server/services/payfast.ts"() {
    "use strict";
    PAYFAST_MERCHANT_ID = process.env.PAYFAST_MERCHANT_ID;
    PAYFAST_MERCHANT_KEY = process.env.PAYFAST_MERCHANT_KEY;
    PAYFAST_PASSPHRASE = process.env.PAYFAST_PASSPHRASE;
    PAYFAST_SANDBOX_URL = "https://sandbox.payfast.co.za/eng/process";
    PAYFAST_LIVE_URL = "https://www.payfast.co.za/eng/process";
    SANDBOX_MODE = process.env.NODE_ENV !== "production";
  }
});

// server/ads-engine.ts
var ads_engine_exports = {};
__export(ads_engine_exports, {
  adsEngine: () => adsEngine,
  expireEndedCampaigns: () => expireEndedCampaigns,
  getAdsForFeed: () => getAdsForFeed,
  getDiscoverAd: () => getDiscoverAd,
  getEligibleAds: () => getEligibleAds,
  getMessagesAd: () => getMessagesAd,
  getPlatformRevenue: () => getPlatformRevenue,
  getReelAd: () => getReelAd,
  getStoryAd: () => getStoryAd,
  getZeroDeliveryCampaigns: () => getZeroDeliveryCampaigns,
  recordClick: () => recordClick,
  recordConversion: () => recordConversion,
  recordEngagement: () => recordEngagement,
  recordImpression: () => recordImpression,
  selectAdForUser: () => selectAdForUser
});
import { eq as eq8, and as and7, gte as gte4, lte as lte5, sql as sql8, desc as desc6, inArray as inArray7, or as or5, isNull as isNull5 } from "drizzle-orm";
async function isFeatureEnabled(key, defaultValue = true) {
  try {
    const setting = await getSystemSetting(key);
    if (!setting) return defaultValue;
    return setting.value === true || setting.value === "true";
  } catch {
    return defaultValue;
  }
}
function calculateQualityScore(ad, ctr, engagementRate) {
  let score = 0.5;
  if (ctr > 0.05) score += 0.2;
  else if (ctr > 0.02) score += 0.1;
  if (engagementRate > 0.1) score += 0.15;
  else if (engagementRate > 0.05) score += 0.08;
  if (ad.headline && ad.description) score += 0.1;
  if (ad.primaryMediaUrl) score += 0.05;
  return Math.min(1, Math.max(0.1, score));
}
function matchesTargeting(targeting, context) {
  let score = 1;
  let matches = true;
  if (!targeting) return { matches: true, score: 1 };
  if (targeting.netWorthTiers && Array.isArray(targeting.netWorthTiers) && targeting.netWorthTiers.length > 0) {
    if (!context.netWorthTier || !targeting.netWorthTiers.includes(context.netWorthTier)) {
      matches = false;
    } else {
      score += 0.2;
    }
  }
  if (targeting.minInfluenceScore && context.influenceScore !== void 0) {
    if (context.influenceScore < targeting.minInfluenceScore) {
      matches = false;
    } else {
      score += 0.1;
    }
  }
  if (targeting.interests && Array.isArray(targeting.interests) && targeting.interests.length > 0 && context.interests) {
    const matchingInterests = targeting.interests.filter(
      (i) => context.interests.includes(i)
    );
    if (matchingInterests.length === 0) {
      score *= 0.5;
    } else {
      score += 0.1 * Math.min(matchingInterests.length, 3);
    }
  }
  if (targeting.industries && Array.isArray(targeting.industries) && targeting.industries.length > 0) {
    if (context.industry && targeting.industries.includes(context.industry)) {
      score += 0.15;
    } else {
      score *= 0.7;
    }
  }
  if (targeting.countries && Array.isArray(targeting.countries) && targeting.countries.length > 0) {
    if (!context.country || !targeting.countries.includes(context.country)) {
      matches = false;
    }
  }
  if (targeting.cities && Array.isArray(targeting.cities) && targeting.cities.length > 0) {
    if (context.city && targeting.cities.includes(context.city)) {
      score += 0.1;
    }
  }
  if (targeting.platforms && Array.isArray(targeting.platforms) && targeting.platforms.length > 0) {
    if (!context.platform || !targeting.platforms.includes(context.platform)) {
      matches = false;
    }
  }
  if (targeting.deviceTypes && Array.isArray(targeting.deviceTypes) && targeting.deviceTypes.length > 0) {
    if (!context.deviceType || !targeting.deviceTypes.includes(context.deviceType)) {
      matches = false;
    }
  }
  return { matches, score };
}
async function checkFrequencyCap(adGroupId, userId, cap, windowHours) {
  if (!cap || cap <= 0) return true;
  const windowStart = new Date(Date.now() - windowHours * 60 * 60 * 1e3);
  const impressionCount = await db.select({ count: sql8`count(*)` }).from(adEvents).where(
    and7(
      eq8(adEvents.adGroupId, adGroupId),
      eq8(adEvents.userId, userId),
      eq8(adEvents.eventType, "IMPRESSION"),
      gte4(adEvents.createdAt, windowStart)
    )
  );
  return (impressionCount[0]?.count || 0) < cap;
}
async function isDuplicateEvent(adId, userId, eventType, windowHours = 1) {
  const windowStart = new Date(Date.now() - windowHours * 60 * 60 * 1e3);
  const existingEvent = await db.select({ count: sql8`count(*)` }).from(adEvents).where(
    and7(
      eq8(adEvents.adId, adId),
      eq8(adEvents.userId, userId),
      eq8(adEvents.eventType, eventType),
      gte4(adEvents.createdAt, windowStart)
    )
  );
  return (existingEvent[0]?.count || 0) > 0;
}
async function expireEndedCampaigns() {
  const now = /* @__PURE__ */ new Date();
  const expiredCampaigns = await db.select({ id: adCampaigns.id, name: adCampaigns.name }).from(adCampaigns).where(
    and7(
      eq8(adCampaigns.status, AD_CAMPAIGN_STATUS.ACTIVE),
      lte5(adCampaigns.endDate, now)
    )
  );
  for (const campaign of expiredCampaigns) {
    await db.update(adCampaigns).set({
      status: AD_CAMPAIGN_STATUS.COMPLETED,
      updatedAt: now
    }).where(eq8(adCampaigns.id, campaign.id));
    console.log(`[Auto-Expire] Campaign ${campaign.id} (${campaign.name}) has ended`);
  }
  return { expired: expiredCampaigns.length, details: expiredCampaigns };
}
async function getZeroDeliveryCampaigns(hoursThreshold = 24) {
  const thresholdTime = new Date(Date.now() - hoursThreshold * 60 * 60 * 1e3);
  const activeCampaigns = await db.select().from(adCampaigns).where(
    and7(
      eq8(adCampaigns.status, AD_CAMPAIGN_STATUS.ACTIVE),
      lte5(adCampaigns.createdAt, thresholdTime)
    )
  );
  const zeroDelivery = activeCampaigns.filter(
    (c) => (c.impressions || 0) === 0 && (c.clicks || 0) === 0
  );
  return zeroDelivery;
}
async function getPlatformRevenue(startDate, endDate) {
  const conditions = [eq8(adWalletTransactions.type, "AD_SPEND")];
  if (startDate) conditions.push(gte4(adWalletTransactions.createdAt, startDate));
  if (endDate) conditions.push(lte5(adWalletTransactions.createdAt, endDate));
  const result = await db.select({
    totalSpend: sql8`COALESCE(SUM(ABS(${adWalletTransactions.amount})), 0)`,
    transactionCount: sql8`COUNT(*)`,
    uniqueAdvertisers: sql8`COUNT(DISTINCT ${adWalletTransactions.walletId})`
  }).from(adWalletTransactions).where(and7(...conditions));
  return {
    totalAdSpend: Number(result[0]?.totalSpend) || 0,
    transactionCount: Number(result[0]?.transactionCount) || 0,
    uniqueAdvertisers: Number(result[0]?.uniqueAdvertisers) || 0
  };
}
async function checkBudgetAvailable(advertiserId, bidAmount) {
  const [wallet] = await db.select().from(adWalletAccounts).where(eq8(adWalletAccounts.advertiserId, advertiserId));
  if (!wallet) return false;
  if (wallet.isFrozen) return false;
  return (wallet.balance || 0) >= bidAmount;
}
async function deductFromWallet(advertiserId, amount, details) {
  const [wallet] = await db.select().from(adWalletAccounts).where(eq8(adWalletAccounts.advertiserId, advertiserId));
  if (!wallet) {
    console.error("[deductFromWallet] Wallet not found for advertiser:", advertiserId);
    return false;
  }
  if (wallet.isFrozen) {
    console.error("[deductFromWallet] Wallet is frozen:", wallet.id);
    return false;
  }
  const currentBalance = wallet.balance || 0;
  if (currentBalance < amount) {
    console.error("[deductFromWallet] Insufficient balance:", currentBalance, "< ", amount);
    return false;
  }
  const result = await db.update(adWalletAccounts).set({
    balance: sql8`COALESCE(${adWalletAccounts.balance}, 0) - ${amount}`,
    lifetimeSpend: sql8`COALESCE(${adWalletAccounts.lifetimeSpend}, 0) + ${amount}`,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(
    and7(
      eq8(adWalletAccounts.id, wallet.id),
      eq8(adWalletAccounts.isFrozen, false),
      gte4(adWalletAccounts.balance, amount)
    )
  ).returning();
  if (!result.length) {
    console.error("[deductFromWallet] Atomic update failed - balance may have changed or wallet frozen");
    return false;
  }
  const updatedWallet = result[0];
  await db.insert(adWalletTransactions).values({
    walletId: wallet.id,
    type: "AD_SPEND",
    amount: -amount,
    balanceBefore: currentBalance,
    balanceAfter: updatedWallet.balance || 0,
    status: "COMPLETED",
    description: details.description,
    campaignId: details.campaignId
  });
  return true;
}
async function getAdStats(adId) {
  const stats = await db.select().from(adStatsDaily).where(eq8(adStatsDaily.adId, adId)).orderBy(desc6(adStatsDaily.date)).limit(7);
  let totalImpressions = 0;
  let totalClicks = 0;
  let totalEngagements = 0;
  for (const s of stats) {
    totalImpressions += s.impressions || 0;
    totalClicks += s.clicks || 0;
    totalEngagements += s.saves || 0;
  }
  const ctr = totalImpressions > 0 ? totalClicks / totalImpressions : 0.02;
  const engagementRate = totalImpressions > 0 ? totalEngagements / totalImpressions : 0.05;
  return { ctr, engagementRate };
}
async function runAuction(eligibleAds, context, placement) {
  if (eligibleAds.length === 0) return null;
  const auctionCandidates = [];
  for (const item of eligibleAds) {
    const { ad, adGroup, campaign } = item;
    const { ctr, engagementRate } = await getAdStats(ad.id);
    const qualityScore = calculateQualityScore(ad, ctr, engagementRate);
    const targeting = adGroup.targeting || {};
    const { matches, score: targetingScore } = matchesTargeting(targeting, context);
    if (!matches) continue;
    const passFrequency = await checkFrequencyCap(
      adGroup.id,
      context.userId,
      adGroup.frequencyCapImpressions || 0,
      adGroup.frequencyCapPeriodHours || 24
    );
    if (!passFrequency) continue;
    let baseBid = adGroup.bidAmount || campaign.budgetAmount / 1e3 || 100;
    let effectiveBid = baseBid;
    const billingModel = adGroup.billingModel || "CPM";
    if (billingModel === "CPM") {
      effectiveBid = baseBid;
    } else if (billingModel === "CPC") {
      effectiveBid = baseBid * 10;
    } else if (billingModel === "CPE") {
      effectiveBid = baseBid * 5;
    }
    effectiveBid *= targetingScore;
    const adRank = effectiveBid * qualityScore * (1 + Math.random() * 0.1);
    auctionCandidates.push({
      ad,
      adGroup,
      campaign,
      effectiveBid,
      qualityScore,
      adRank,
      targetingScore
    });
  }
  if (auctionCandidates.length === 0) return null;
  auctionCandidates.sort((a, b) => b.adRank - a.adRank);
  const winner = auctionCandidates[0];
  const secondPrice = auctionCandidates.length > 1 ? auctionCandidates[1].adRank / winner.qualityScore + 1 : winner.effectiveBid * 0.8;
  const winningBid = Math.min(secondPrice, winner.effectiveBid);
  return {
    adId: winner.ad.id,
    adGroupId: winner.adGroup.id,
    campaignId: winner.campaign.id,
    advertiserId: winner.campaign.advertiserId,
    effectiveBid: winner.effectiveBid,
    qualityScore: winner.qualityScore,
    adRank: winner.adRank,
    winningBid: Math.round(winningBid),
    format: winner.ad.format,
    creative: {
      headline: winner.ad.headline,
      description: winner.ad.description,
      mediaUrl: winner.ad.primaryMediaUrl,
      thumbnailUrl: winner.ad.primaryMediaThumbnail,
      callToAction: winner.ad.callToAction,
      destinationUrl: winner.ad.destinationUrl
    }
  };
}
async function getEligibleAds(placement) {
  const now = /* @__PURE__ */ new Date();
  const eligibleCampaigns = await db.select().from(adCampaigns).where(
    and7(
      eq8(adCampaigns.status, AD_CAMPAIGN_STATUS.ACTIVE),
      or5(isNull5(adCampaigns.startDate), lte5(adCampaigns.startDate, now)),
      or5(isNull5(adCampaigns.endDate), gte4(adCampaigns.endDate, now))
    )
  );
  if (eligibleCampaigns.length === 0) return [];
  const campaignIds = eligibleCampaigns.map((c) => c.id);
  const eligibleAdGroups = await db.select().from(adGroups).where(
    and7(
      inArray7(adGroups.campaignId, campaignIds),
      eq8(adGroups.status, "ACTIVE")
    )
  );
  if (eligibleAdGroups.length === 0) return [];
  const adGroupIds = eligibleAdGroups.map((g) => g.id);
  const eligibleAds = await db.select().from(ads).where(
    and7(
      inArray7(ads.adGroupId, adGroupIds),
      eq8(ads.status, AD_STATUS.APPROVED)
    )
  );
  const result = [];
  for (const ad of eligibleAds) {
    const adGroup = eligibleAdGroups.find((g) => g.id === ad.adGroupId);
    const campaign = eligibleCampaigns.find((c) => c.id === adGroup?.campaignId);
    if (adGroup && campaign) {
      const budgetSpent = campaign.budgetSpent || 0;
      const budgetAmount = campaign.budgetAmount || 0;
      if (budgetAmount > 0 && budgetSpent >= budgetAmount) {
        console.log(`[getEligibleAds] Campaign ${campaign.id} budget exhausted (${budgetSpent}/${budgetAmount})`);
        continue;
      }
      const hasBalance = await checkBudgetAvailable(campaign.advertiserId, 100);
      if (hasBalance) {
        result.push({ ad, adGroup, campaign });
      } else {
        console.log(`[getEligibleAds] Advertiser ${campaign.advertiserId} has insufficient wallet balance`);
      }
    }
  }
  return result;
}
async function selectAdForUser(userId, placement = "feed") {
  const [user] = await db.select().from(users).where(eq8(users.id, userId));
  if (!user) return null;
  const userInterestRows = await db.select().from(userInterests).where(eq8(userInterests.userId, userId));
  const interests = userInterestRows.map((ui) => ui.interest);
  const context = {
    userId,
    netWorthTier: user.netWorthTier || "BUILDING",
    influenceScore: user.influenceScore || 0,
    interests,
    industry: user.industry || void 0,
    country: user.country || void 0,
    deviceType: "mobile",
    platform: "ios"
  };
  const eligibleAds = await getEligibleAds(placement);
  if (eligibleAds.length === 0) return null;
  const userAdvertiser = await getAdvertiserByUserId(userId);
  const filteredAds = userAdvertiser ? eligibleAds.filter((item) => item.campaign.advertiserId !== userAdvertiser.id) : eligibleAds;
  if (filteredAds.length === 0) return null;
  const result = await runAuction(filteredAds, context, placement);
  return result;
}
async function recordImpression(result, userId, placement) {
  const selfEngagementPrevention = await isFeatureEnabled("ads_self_engagement_prevention", true);
  if (selfEngagementPrevention) {
    const userAdvertiser = await getAdvertiserByUserId(userId);
    if (userAdvertiser && userAdvertiser.id === result.advertiserId) {
      console.log("[recordImpression] Ignoring self-impression from advertiser:", userId);
      return;
    }
  }
  const hasBalance = await checkBudgetAvailable(result.advertiserId, result.winningBid);
  if (!hasBalance) {
    await pauseCampaignForLowBalance(result.campaignId);
    return;
  }
  const deductionSuccess = await deductFromWallet(result.advertiserId, result.winningBid, {
    type: "AD_SPEND",
    description: `Impression on ${placement} for ad #${result.adId}`,
    campaignId: result.campaignId
  });
  if (!deductionSuccess) {
    console.log("[recordImpression] Wallet deduction failed, not recording impression");
    await pauseCampaignForLowBalance(result.campaignId);
    return;
  }
  await db.insert(adEvents).values({
    adId: result.adId,
    adGroupId: result.adGroupId,
    campaignId: result.campaignId,
    advertiserId: result.advertiserId,
    userId,
    eventType: "IMPRESSION",
    placement: placement === "feed" ? "FEED" : placement === "stories" ? "STORIES" : placement === "reels" ? "REELS" : placement === "discover" ? "DISCOVER" : "FEED",
    costAmount: result.winningBid,
    metadata: {
      qualityScore: result.qualityScore,
      adRank: result.adRank,
      effectiveBid: result.effectiveBid
    }
  });
  await db.update(adCampaigns).set({
    budgetSpent: sql8`COALESCE(${adCampaigns.budgetSpent}, 0) + ${result.winningBid}`,
    impressions: sql8`COALESCE(${adCampaigns.impressions}, 0) + 1`,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq8(adCampaigns.id, result.campaignId));
  await updateAdStats(result.adId, result.adGroupId, result.campaignId, result.advertiserId, "impression", result.winningBid);
}
async function recordClick(adId, userId, placement) {
  const [ad] = await db.select().from(ads).where(eq8(ads.id, adId));
  if (!ad) return;
  const [adGroup] = await db.select().from(adGroups).where(eq8(adGroups.id, ad.adGroupId));
  if (!adGroup) return;
  const [campaign] = await db.select().from(adCampaigns).where(eq8(adCampaigns.id, adGroup.campaignId));
  if (!campaign) return;
  const selfEngagementPrevention = await isFeatureEnabled("ads_self_engagement_prevention", true);
  if (selfEngagementPrevention) {
    const userAdvertiser = await getAdvertiserByUserId(userId);
    if (userAdvertiser && userAdvertiser.id === campaign.advertiserId) {
      console.log("[recordClick] Ignoring self-click from advertiser:", userId);
      return;
    }
  }
  const isDuplicate = await isDuplicateEvent(adId, userId, "CLICK", 1);
  if (isDuplicate) {
    console.log("[recordClick] Duplicate click detected, ignoring:", { adId, userId });
    return;
  }
  let clickCost = 0;
  if (adGroup.billingModel === "CPC") {
    clickCost = adGroup.bidAmount || 50;
    const hasBalance = await checkBudgetAvailable(campaign.advertiserId, clickCost);
    if (!hasBalance) {
      await pauseCampaignForLowBalance(campaign.id);
      return;
    }
    const deductionSuccess = await deductFromWallet(campaign.advertiserId, clickCost, {
      type: "AD_SPEND",
      description: `Click on ad #${adId}`,
      campaignId: campaign.id
    });
    if (!deductionSuccess) {
      console.log("[recordClick] Wallet deduction failed, not recording click");
      await pauseCampaignForLowBalance(campaign.id);
      return;
    }
  }
  await db.insert(adEvents).values({
    adId,
    adGroupId: adGroup.id,
    campaignId: campaign.id,
    advertiserId: campaign.advertiserId,
    userId,
    eventType: "CLICK",
    placement: placement === "feed" ? "FEED" : placement === "stories" ? "STORIES" : placement === "reels" ? "REELS" : placement === "discover" ? "DISCOVER" : "FEED",
    costAmount: clickCost,
    metadata: {}
  });
  await updateAdStats(adId, adGroup.id, campaign.id, campaign.advertiserId, "click", clickCost);
}
async function recordConversion(adId, userId, conversionType, value) {
  const [ad] = await db.select().from(ads).where(eq8(ads.id, adId));
  if (!ad) return;
  const [adGroup] = await db.select().from(adGroups).where(eq8(adGroups.id, ad.adGroupId));
  if (!adGroup) return;
  const [campaign] = await db.select().from(adCampaigns).where(eq8(adCampaigns.id, adGroup.campaignId));
  if (!campaign) return;
  const selfEngagementPrevention = await isFeatureEnabled("ads_self_engagement_prevention", true);
  if (selfEngagementPrevention) {
    const userAdvertiser = await getAdvertiserByUserId(userId);
    if (userAdvertiser && userAdvertiser.id === campaign.advertiserId) {
      console.log("[recordConversion] Ignoring self-conversion from advertiser:", userId);
      return;
    }
  }
  await db.insert(adEvents).values({
    adId,
    adGroupId: adGroup.id,
    campaignId: campaign.id,
    advertiserId: campaign.advertiserId,
    userId,
    eventType: "CONVERSION",
    placement: "FEED",
    conversionType,
    conversionValue: value,
    metadata: {}
  });
  await updateAdStats(adId, adGroup.id, campaign.id, campaign.advertiserId, "conversion", 0);
}
async function recordEngagement(adId, userId, engagementType) {
  const [ad] = await db.select().from(ads).where(eq8(ads.id, adId));
  if (!ad) return;
  const [adGroup] = await db.select().from(adGroups).where(eq8(adGroups.id, ad.adGroupId));
  if (!adGroup) return;
  const [campaign] = await db.select().from(adCampaigns).where(eq8(adCampaigns.id, adGroup.campaignId));
  if (!campaign) return;
  const selfEngagementPrevention = await isFeatureEnabled("ads_self_engagement_prevention", true);
  if (selfEngagementPrevention) {
    const userAdvertiser = await getAdvertiserByUserId(userId);
    if (userAdvertiser && userAdvertiser.id === campaign.advertiserId) {
      console.log("[recordEngagement] Ignoring self-engagement from advertiser:", userId);
      return;
    }
  }
  let engagementCost = 0;
  if (adGroup.billingModel === "CPA") {
    engagementCost = Math.round((adGroup.bidAmount || 20) * 0.3);
    const hasBalance = await checkBudgetAvailable(campaign.advertiserId, engagementCost);
    if (hasBalance) {
      const deductionSuccess = await deductFromWallet(campaign.advertiserId, engagementCost, {
        type: "AD_SPEND",
        description: `${engagementType} on ad #${adId}`,
        campaignId: campaign.id
      });
      if (!deductionSuccess) {
        engagementCost = 0;
      }
    } else {
      engagementCost = 0;
    }
  }
  await db.insert(adEvents).values({
    adId,
    adGroupId: adGroup.id,
    campaignId: campaign.id,
    advertiserId: campaign.advertiserId,
    userId,
    eventType: "SAVE",
    placement: "FEED",
    metadata: { engagementType }
  });
  await updateAdStats(adId, adGroup.id, campaign.id, campaign.advertiserId, engagementType, engagementCost);
}
async function updateAdStats(adId, adGroupId, campaignId, advertiserId, eventType, cost) {
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const [existing] = await db.select().from(adStatsDaily).where(and7(eq8(adStatsDaily.adId, adId), eq8(adStatsDaily.date, today)));
  if (existing) {
    const updates = { spend: sql8`${adStatsDaily.spend} + ${cost}` };
    if (eventType === "impression") updates.impressions = sql8`${adStatsDaily.impressions} + 1`;
    if (eventType === "click") updates.clicks = sql8`${adStatsDaily.clicks} + 1`;
    if (eventType === "conversion") updates.conversions = sql8`${adStatsDaily.conversions} + 1`;
    if (eventType === "save") updates.saves = sql8`${adStatsDaily.saves} + 1`;
    await db.update(adStatsDaily).set(updates).where(eq8(adStatsDaily.id, existing.id));
  } else {
    await db.insert(adStatsDaily).values({
      adId,
      adGroupId,
      campaignId,
      advertiserId,
      date: today,
      impressions: eventType === "impression" ? 1 : 0,
      clicks: eventType === "click" ? 1 : 0,
      conversions: eventType === "conversion" ? 1 : 0,
      saves: eventType === "save" ? 1 : 0,
      spend: cost,
      reach: eventType === "impression" ? 1 : 0
    });
  }
}
async function pauseCampaignForLowBalance(campaignId) {
  await db.update(adCampaigns).set({
    status: AD_CAMPAIGN_STATUS.PAUSED,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq8(adCampaigns.id, campaignId));
}
async function getAdsForFeed(userId, feedLength = 20, adFrequency = 5) {
  const numAdsToServe = Math.floor(feedLength / adFrequency);
  const results = [];
  for (let i = 0; i < numAdsToServe; i++) {
    const position = (i + 1) * adFrequency;
    const adResult = await selectAdForUser(userId, "feed");
    if (adResult) {
      results.push({ ...adResult, position });
    }
  }
  return results;
}
async function getStoryAd(userId) {
  return selectAdForUser(userId, "stories");
}
async function getReelAd(userId) {
  return selectAdForUser(userId, "reels");
}
async function getDiscoverAd(userId) {
  return selectAdForUser(userId, "discover");
}
async function getMessagesAd(userId) {
  return selectAdForUser(userId, "messages");
}
var AD_CAMPAIGN_STATUS, AD_STATUS, adsEngine;
var init_ads_engine = __esm({
  "server/ads-engine.ts"() {
    "use strict";
    init_db();
    init_ads_storage();
    init_ads_schema();
    init_schema();
    AD_CAMPAIGN_STATUS = {
      ACTIVE: "ACTIVE",
      PAUSED: "PAUSED",
      COMPLETED: "COMPLETED",
      DRAFT: "DRAFT",
      PENDING_REVIEW: "PENDING_REVIEW",
      REJECTED: "REJECTED",
      ARCHIVED: "ARCHIVED"
    };
    AD_STATUS = {
      APPROVED: "APPROVED"
    };
    adsEngine = {
      selectAdForUser,
      recordImpression,
      recordClick,
      recordConversion,
      recordEngagement,
      getAdsForFeed,
      getStoryAd,
      getReelAd,
      getDiscoverAd,
      getMessagesAd,
      getEligibleAds,
      expireEndedCampaigns,
      getZeroDeliveryCampaigns,
      getPlatformRevenue
    };
  }
});

// server/legal/terms-of-service.ts
var TERMS_VERSION, TERMS_EFFECTIVE_DATE, TERMS_OF_SERVICE;
var init_terms_of_service = __esm({
  "server/legal/terms-of-service.ts"() {
    "use strict";
    TERMS_VERSION = "1.0";
    TERMS_EFFECTIVE_DATE = "January 24, 2026";
    TERMS_OF_SERVICE = `
# RabitChat Terms of Service

**Effective Date:** ${TERMS_EFFECTIVE_DATE}
**Version:** ${TERMS_VERSION}

Welcome to RabitChat. By accessing or using our platform, you agree to be bound by these Terms of Service ("Terms"). Please read them carefully.

## 1. Acceptance of Terms

By creating an account, accessing, or using RabitChat ("the Platform," "we," "us," or "our"), you agree to comply with and be bound by these Terms, our Privacy Policy, and Community Guidelines. If you do not agree, you may not use our services.

## 2. Eligibility

To use RabitChat, you must:
- Be at least 18 years of age
- Have the legal capacity to enter into a binding agreement
- Not be prohibited from using the Platform under applicable laws
- Provide accurate and complete registration information

## 3. Account Registration and Security

### 3.1 Account Types
RabitChat offers three account types:
- **Personal Elite:** For individual networking and social connections
- **Creator:** For influencers, artists, and content creators
- **Business:** For companies, brands, and commercial entities

### 3.2 Account Security
You are responsible for:
- Maintaining the confidentiality of your login credentials
- All activities that occur under your account
- Immediately notifying us of any unauthorized use
- Using strong, unique passwords

### 3.3 Verification
Verified badges are granted at our sole discretion. Falsely claiming verification or impersonating verified accounts is prohibited.

## 4. User Content

### 4.1 Content Ownership
You retain ownership of content you post. By posting content, you grant RabitChat a non-exclusive, worldwide, royalty-free license to use, display, reproduce, modify, and distribute your content on the Platform.

### 4.2 Content Responsibility
You are solely responsible for content you post and must ensure it:
- Does not violate any laws or third-party rights
- Does not contain false or misleading information
- Complies with our Community Guidelines
- Does not infringe intellectual property rights

### 4.3 Content Removal
We reserve the right to remove any content that violates these Terms or our Community Guidelines without prior notice.

## 5. Prohibited Conduct

You agree NOT to:
- Post illegal, harmful, threatening, abusive, or harassing content
- Impersonate any person or entity
- Post spam, advertisements, or unauthorized commercial content
- Attempt to access other users' accounts
- Use automated systems to access the Platform without permission
- Interfere with or disrupt Platform security or operations
- Collect user data without consent
- Engage in fraudulent activities
- Circumvent any access restrictions or security measures

## 6. Net Worth and Influence Features

### 6.1 Net Worth Display
Net worth information displayed on profiles is user-provided and not independently verified by RabitChat. We make no representations about the accuracy of such information.

### 6.2 Influence Scores
Influence scores are calculated based on Platform engagement and do not represent real-world influence, authority, or credibility.

## 7. Gossip Feature (South Africa Only)

### 7.1 Anonymous Posting
The Gossip feature allows anonymous posting within South African locations. Users are still bound by all Terms and Community Guidelines when using this feature.

### 7.2 Content Expiration
"Whisper Mode" posts automatically expire after 24 hours. Standard gossip posts may remain indefinitely.

### 7.3 Liability
Anonymous posting does not exempt users from legal liability for defamatory, false, or illegal content.

## 8. Mall and Purchases

### 8.1 Transactions
All purchases made through RabitChat Mall are final unless otherwise stated. We are not responsible for the quality, safety, or legality of items listed.

### 8.2 Payment Processing
Payment processing is handled by third-party providers. Your use of payment services is subject to their terms.

### 8.3 Virtual Currency
Any virtual currency or credits purchased are non-refundable and have no real-world monetary value outside the Platform.

## 9. Intellectual Property

### 9.1 RabitChat Property
The Platform, including its design, features, and content created by us, is protected by copyright, trademark, and other intellectual property laws.

### 9.2 User License
We grant you a limited, non-exclusive, non-transferable license to access and use the Platform for personal, non-commercial purposes.

## 10. Privacy

Your privacy is important to us. Please review our Privacy Policy to understand how we collect, use, and protect your information.

## 11. Termination

### 11.1 By You
You may delete your account at any time through your account settings.

### 11.2 By Us
We may suspend or terminate your account at any time for:
- Violation of these Terms or Community Guidelines
- Fraudulent, abusive, or illegal activity
- Extended inactivity
- Any reason at our sole discretion

### 11.3 Effect of Termination
Upon termination, your right to use the Platform ceases immediately. Some provisions of these Terms survive termination.

## 12. Disclaimers

### 12.1 "As Is" Service
THE PLATFORM IS PROVIDED "AS IS" WITHOUT WARRANTIES OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.

### 12.2 No Guarantee
We do not guarantee:
- Uninterrupted or error-free service
- Accuracy of user-provided content
- Security of your data (though we implement reasonable measures)
- Results from using the Platform

## 13. Limitation of Liability

TO THE MAXIMUM EXTENT PERMITTED BY LAW, RABITCHAT SHALL NOT BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, INCLUDING LOSS OF PROFITS, DATA, OR GOODWILL.

Our total liability shall not exceed the greater of (a) the amount you paid us in the past 12 months, or (b) $100.

## 14. Indemnification

You agree to indemnify and hold harmless RabitChat, its affiliates, officers, directors, employees, and agents from any claims, damages, losses, or expenses arising from:
- Your use of the Platform
- Your violation of these Terms
- Your violation of any third-party rights

## 15. Dispute Resolution

### 15.1 Governing Law
These Terms are governed by the laws of South Africa, without regard to conflict of law principles.

### 15.2 Arbitration
Any disputes shall be resolved through binding arbitration, except where prohibited by law.

### 15.3 Class Action Waiver
You agree to resolve disputes individually and waive any right to participate in class action lawsuits.

## 16. Changes to Terms

We may modify these Terms at any time. We will notify you of material changes through the Platform or email. Continued use after changes constitutes acceptance.

## 17. General Provisions

### 17.1 Entire Agreement
These Terms, along with our Privacy Policy and Community Guidelines, constitute the entire agreement between you and RabitChat.

### 17.2 Severability
If any provision is found unenforceable, the remaining provisions remain in effect.

### 17.3 Waiver
Our failure to enforce any right does not constitute a waiver of that right.

### 17.4 Assignment
You may not assign your rights under these Terms. We may assign our rights without restriction.

## 18. Contact Us

For questions about these Terms, contact us at:
- Email: legal@rabitchat.com
- In-App: Settings > Help > Contact Support

---

*By using RabitChat, you acknowledge that you have read, understood, and agree to be bound by these Terms of Service.*
`;
  }
});

// server/legal/privacy-policy.ts
var PRIVACY_VERSION, PRIVACY_EFFECTIVE_DATE, PRIVACY_POLICY;
var init_privacy_policy = __esm({
  "server/legal/privacy-policy.ts"() {
    "use strict";
    PRIVACY_VERSION = "1.0";
    PRIVACY_EFFECTIVE_DATE = "January 24, 2026";
    PRIVACY_POLICY = `
# RabitChat Privacy Policy

**Effective Date:** ${PRIVACY_EFFECTIVE_DATE}
**Version:** ${PRIVACY_VERSION}

RabitChat ("we," "us," or "our") is committed to protecting your privacy. This Privacy Policy explains how we collect, use, disclose, and safeguard your information when you use our mobile application and services.

This policy complies with the Protection of Personal Information Act (POPIA) of South Africa and other applicable data protection regulations.

## 1. Information We Collect

### 1.1 Information You Provide

**Account Information:**
- Name and display name
- Email address
- Phone number (optional)
- Password (encrypted)
- Profile photo and cover image
- Bio and headline
- Location (country, province, city)
- Birthday
- Gender

**Account Type Information:**
- Personal Elite: Networking preferences, interests
- Creator: Creator category, portfolio, platforms, content language
- Business: Business category, establishment date, business hours, website

**Financial Information:**
- Net worth tier (self-reported)
- Purchase history within the Mall
- Payment information (processed by third-party providers)

**Content:**
- Posts, photos, videos, and voice recordings
- Comments and reactions
- Stories and reels
- Messages and chat history
- Gossip posts (South Africa only)

### 1.2 Information Collected Automatically

**Device Information:**
- Device type and model
- Operating system and version
- Unique device identifiers
- Mobile network information

**Usage Information:**
- Features used and time spent
- Content viewed and interactions
- Search queries
- App crashes and performance data

**Location Information:**
- Approximate location from IP address
- Precise location (with your permission)
- Location for gossip feature (South Africa)

### 1.3 Information from Third Parties

- Social media login providers (Google, Apple)
- Payment processors
- Analytics providers

## 2. How We Use Your Information

We use your information to:

### 2.1 Provide and Improve Services
- Create and manage your account
- Enable social features (posts, messages, following)
- Process transactions in the Mall
- Personalize your feed and recommendations
- Develop new features and improve existing ones

### 2.2 Communication
- Send service-related notifications
- Respond to your inquiries and support requests
- Send marketing communications (with your consent)
- Alert you to security issues

### 2.3 Safety and Security
- Detect and prevent fraud, abuse, and violations
- Enforce our Terms of Service and Community Guidelines
- Protect users and the Platform
- Comply with legal obligations

### 2.4 Analytics and Research
- Analyze usage patterns and trends
- Conduct research to improve our services
- Generate aggregated, anonymized insights

## 3. How We Share Your Information

### 3.1 With Other Users
- Your public profile information
- Posts and content you share publicly
- Interactions visible to other users

### 3.2 With Service Providers
We share information with third-party providers who assist us with:
- Cloud hosting and storage (Cloudinary)
- Payment processing
- Analytics and crash reporting
- Email and SMS services (Resend, Twilio)
- AI content analysis (OpenAI, Google Gemini)

### 3.3 For Legal Reasons
We may disclose information:
- To comply with legal obligations
- To respond to lawful requests from authorities
- To protect our rights, privacy, safety, or property
- In connection with legal proceedings

### 3.4 Business Transfers
If RabitChat is involved in a merger, acquisition, or sale, your information may be transferred as part of that transaction.

### 3.5 With Your Consent
We may share information with third parties when you give us explicit consent.

## 4. Data Retention

We retain your information for as long as:
- Your account is active
- Necessary to provide our services
- Required by law or for legitimate business purposes

After account deletion:
- Most personal data is deleted within 30 days
- Some data may be retained for legal compliance
- Aggregated, anonymized data may be kept indefinitely

## 5. Your Rights (POPIA Compliance)

Under the Protection of Personal Information Act (POPIA) and other applicable laws, you have the right to:

### 5.1 Access
Request a copy of your personal information we hold.

### 5.2 Correction
Request correction of inaccurate or incomplete information.

### 5.3 Deletion
Request deletion of your personal information, subject to legal requirements.

### 5.4 Objection
Object to processing of your personal information for certain purposes.

### 5.5 Restriction
Request restriction of processing in certain circumstances.

### 5.6 Data Portability
Receive your data in a structured, commonly used format.

### 5.7 Withdraw Consent
Withdraw consent for processing based on consent, without affecting prior processing.

To exercise these rights, contact us at privacy@rabitchat.com or through Settings > Privacy > Data Requests.

## 6. Data Security

We implement appropriate technical and organizational measures to protect your information, including:
- Encryption of data in transit and at rest
- Secure authentication systems
- Regular security assessments
- Access controls and monitoring
- Employee training on data protection

However, no system is completely secure. We cannot guarantee absolute security of your information.

## 7. International Data Transfers

Your information may be transferred to and processed in countries other than your own. We ensure appropriate safeguards are in place for such transfers, including:
- Standard contractual clauses
- Data processing agreements
- Compliance with applicable regulations

## 8. Children's Privacy

RabitChat is not intended for users under 18 years of age. We do not knowingly collect information from children. If we discover we have collected information from a child, we will delete it promptly.

## 9. Third-Party Links and Services

Our Platform may contain links to third-party websites or services. We are not responsible for their privacy practices. We encourage you to review their privacy policies.

## 10. Cookies and Tracking Technologies

We use cookies and similar technologies to:
- Remember your preferences
- Analyze usage and performance
- Provide personalized content
- Measure advertising effectiveness

You can control cookies through your device settings, but some features may not function properly without them.

## 11. Push Notifications

With your permission, we send push notifications for:
- New messages and interactions
- Security alerts
- Feature updates
- Promotional content (with separate consent)

You can manage notification preferences in your device settings or the app.

## 12. Location-Based Features

### 12.1 General Location
We use approximate location to:
- Show relevant content
- Enable location tags on posts
- Comply with regional regulations

### 12.2 Gossip Feature (South Africa)
For the Gossip feature, we collect precise location to:
- Verify South African location requirement
- Enable location-based gossip segments
- Ensure regional compliance

You can disable location access in your device settings.

## 13. AI and Automated Processing

We use artificial intelligence for:
- Content moderation and safety
- Feed personalization
- Language detection
- Content categorization

Automated decisions that significantly affect you are subject to human review upon request.

## 14. Marketing Communications

With your consent, we may send:
- Product updates and new features
- Promotional offers
- Partner communications

You can opt out at any time through Settings > Notifications or by clicking "unsubscribe" in emails.

## 15. Changes to This Policy

We may update this Privacy Policy periodically. We will notify you of material changes through:
- In-app notifications
- Email to your registered address
- Prominent notice on the Platform

Continued use after changes constitutes acceptance of the updated policy.

## 16. Contact Us

For privacy-related questions or to exercise your rights:

**Data Protection Officer:**
- Email: privacy@rabitchat.com
- In-App: Settings > Privacy > Contact DPO

**Information Regulator (South Africa):**
- Website: https://inforegulator.org.za
- Email: inforeg@justice.gov.za

## 17. Specific Regional Provisions

### 17.1 South Africa (POPIA)
This policy complies with the Protection of Personal Information Act, 2013. Our Information Officer can be contacted at privacy@rabitchat.com.

### 17.2 European Users (GDPR)
If you are in the EEA, you have additional rights under the General Data Protection Regulation. Contact us for more information.

---

*By using RabitChat, you acknowledge that you have read and understood this Privacy Policy.*
`;
  }
});

// server/legal/community-guidelines.ts
var GUIDELINES_VERSION, GUIDELINES_EFFECTIVE_DATE, COMMUNITY_GUIDELINES;
var init_community_guidelines = __esm({
  "server/legal/community-guidelines.ts"() {
    "use strict";
    GUIDELINES_VERSION = "1.0";
    GUIDELINES_EFFECTIVE_DATE = "January 24, 2026";
    COMMUNITY_GUIDELINES = `
# RabitChat Community Guidelines

**Effective Date:** ${GUIDELINES_EFFECTIVE_DATE}
**Version:** ${GUIDELINES_VERSION}

RabitChat is a premium social platform designed for connection, creativity, and celebration of success. These Community Guidelines help maintain a respectful, authentic, and safe environment for all members.

## Our Core Values

- **Authenticity:** Be genuine in your interactions and content
- **Respect:** Treat all members with dignity and courtesy
- **Excellence:** Uphold high standards in content and conduct
- **Safety:** Protect yourself and others from harm
- **Privacy:** Respect the privacy and boundaries of others

## Content Guidelines

### What We Encourage

**Authentic Self-Expression:**
- Share your journey, achievements, and lifestyle
- Post original photos, videos, and creative content
- Engage meaningfully with other members
- Celebrate milestones and successes

**Positive Engagement:**
- Support and uplift fellow members
- Provide constructive feedback
- Build genuine connections
- Share knowledge and expertise

**Quality Content:**
- High-quality photos and videos
- Thoughtful captions and discussions
- Accurate information and honest representations
- Content that adds value to the community

### What We Prohibit

#### 1. Harmful Content

**Violence and Threats:**
- Threats of violence against individuals or groups
- Graphic violence or gore
- Glorification of violence or self-harm
- Instructions for weapons or explosives

**Harassment and Bullying:**
- Targeted harassment of any individual
- Cyberbullying, including coordinated attacks
- Intimidation or threats
- Stalking behavior

**Hate Speech:**
- Content attacking people based on race, ethnicity, nationality, religion, gender, sexual orientation, disability, or other protected characteristics
- Slurs, stereotypes, or dehumanizing language
- Symbols or imagery associated with hate groups

#### 2. Dangerous or Illegal Content

**Illegal Activities:**
- Drug trafficking or promotion of illegal drugs
- Weapons sales or trafficking
- Human trafficking or exploitation
- Fraud, scams, or financial crimes

**Regulated Goods:**
- Unauthorized sale of regulated items
- Counterfeit goods or services
- Prescription medications without authorization

#### 3. Deceptive Content

**Misinformation:**
- False information that could cause harm
- Manipulated media presented as authentic
- Conspiracy theories that could endanger others
- Medical misinformation

**Fraud and Scams:**
- Phishing or impersonation
- Fraudulent schemes or Ponzi schemes
- False investment advice
- Fake giveaways or promotions

**Impersonation:**
- Pretending to be another person
- Fake verified accounts
- Misleading claims about identity or affiliation

#### 4. Adult and Sensitive Content

**Sexual Content:**
- Nudity or sexually explicit content
- Sexual solicitation
- Non-consensual intimate imagery
- Sexual exploitation

**Sensitive Content:**
- Graphic medical or surgical content
- Content depicting extreme suffering
- Disturbing or shocking content

#### 5. Privacy Violations

**Personal Information:**
- Sharing others' private information without consent
- Doxxing or exposing personal details
- Sharing private messages or content without permission

**Unauthorized Recording:**
- Content recorded without consent
- Revenge content
- Voyeuristic content

#### 6. Spam and Manipulation

**Spam:**
- Repetitive or unwanted content
- Fake engagement (buying followers, likes, or comments)
- Automated posting or bot activity
- Unsolicited advertisements

**Platform Manipulation:**
- Creating multiple accounts to evade bans
- Coordinated inauthentic behavior
- Artificially inflating metrics
- Gaming algorithms

### Specific Feature Guidelines

#### Gossip Feature (South Africa Only)

The Gossip feature allows anonymous posting within South African locations. Additional rules apply:

**Permitted:**
- Entertainment and light commentary
- Community observations
- Harmless humor

**Prohibited:**
- Defamatory statements about identifiable individuals
- False accusations or rumors
- Content that could cause real-world harm
- Hate speech and harassment (anonymity does not exempt you)

**Remember:** Anonymous posting does not protect you from legal liability. False, defamatory, or illegal content can still be traced and may result in legal action.

#### Stories and Reels

- Music must not infringe copyright
- Transitions and effects should not contain prohibited content
- Duets and collaborations require consent from featured individuals

#### Mall and Commerce

- Accurate product descriptions
- No counterfeit or stolen goods
- Clear pricing and terms
- Genuine reviews and ratings only

#### Voice Features

- Voice posts and bios must comply with all guidelines
- No audio designed to harass or disturb
- Respect audio copyright

### Net Worth and Influence

- Net worth claims should be honest
- Do not manipulate influence scores
- Respect privacy regarding others' financial information
- No financial advice that could cause harm

## Enforcement

### What Happens When You Violate Guidelines

Depending on severity and frequency, consequences may include:

**Warning:**
- First-time minor violations
- Educational notice about the violation

**Content Removal:**
- Immediate removal of violating content
- Notification of the violation

**Feature Restrictions:**
- Temporary loss of specific features
- Limited posting abilities
- Shadow restrictions on reach

**Account Suspension:**
- Temporary account suspension (24 hours to 30 days)
- Review required before reinstatement

**Permanent Ban:**
- Permanent removal from the platform
- No appeal for severe violations

### Appeals Process

If you believe enforcement was incorrect:
1. Go to Settings > Account > Appeals
2. Provide context and explanation
3. Wait for review (typically 48-72 hours)
4. Accept the final decision

### Reporting Violations

To report content or accounts:
1. Tap the three dots (...) on the content
2. Select "Report"
3. Choose the violation category
4. Provide additional details if needed

All reports are reviewed by our Trust & Safety team. Report in good faith\u2014false reporting may result in action against your account.

## Best Practices

### Building a Positive Presence

1. **Be Authentic:** Share your genuine self and story
2. **Engage Thoughtfully:** Quality over quantity in interactions
3. **Respect Boundaries:** Not everyone will want to connect
4. **Stay Professional:** Remember this is a premium platform
5. **Give Credit:** Acknowledge others' content and contributions

### Protecting Yourself

1. **Guard Your Privacy:** Be selective about personal information
2. **Verify Before Trusting:** Be cautious of requests for money or information
3. **Use Strong Security:** Enable two-factor authentication
4. **Trust Your Instincts:** Report suspicious behavior
5. **Block Freely:** You don't owe anyone access to your profile

### Contributing to the Community

1. **Welcome Newcomers:** Help new members feel included
2. **Share Knowledge:** Your expertise benefits everyone
3. **Report Violations:** Help keep the community safe
4. **Provide Feedback:** Help us improve the platform
5. **Lead by Example:** Your conduct influences others

## Updates to Guidelines

These guidelines may be updated to address new challenges and improve our community. We will notify you of significant changes. Continued use of RabitChat constitutes acceptance of current guidelines.

## Contact Us

Questions about these guidelines?
- Email: community@rabitchat.com
- In-App: Settings > Help > Community Guidelines

---

*By using RabitChat, you agree to follow these Community Guidelines and help us maintain a safe, respectful, and premium community for all members.*
`;
  }
});

// server/legal/index.ts
var legal_exports = {};
__export(legal_exports, {
  COMMUNITY_GUIDELINES: () => COMMUNITY_GUIDELINES,
  CURRENT_LEGAL_VERSION: () => CURRENT_LEGAL_VERSION,
  GUIDELINES_EFFECTIVE_DATE: () => GUIDELINES_EFFECTIVE_DATE,
  GUIDELINES_VERSION: () => GUIDELINES_VERSION,
  PRIVACY_EFFECTIVE_DATE: () => PRIVACY_EFFECTIVE_DATE,
  PRIVACY_POLICY: () => PRIVACY_POLICY,
  PRIVACY_VERSION: () => PRIVACY_VERSION,
  TERMS_EFFECTIVE_DATE: () => TERMS_EFFECTIVE_DATE,
  TERMS_OF_SERVICE: () => TERMS_OF_SERVICE,
  TERMS_VERSION: () => TERMS_VERSION
});
var CURRENT_LEGAL_VERSION;
var init_legal = __esm({
  "server/legal/index.ts"() {
    "use strict";
    init_terms_of_service();
    init_privacy_policy();
    init_community_guidelines();
    CURRENT_LEGAL_VERSION = "1.0";
  }
});

// server/index.ts
import express from "express";
import helmet from "helmet";

// server/routes.ts
init_storage();
import { createServer } from "node:http";
import { WebSocketServer, WebSocket } from "ws";
import session from "express-session";
import connectPgSimple from "connect-pg-simple";
import bcrypt2 from "bcrypt";
import multer from "multer";
import OpenAI2 from "openai";

// server/gossip-storage.ts
init_db();
init_schema();
import { eq as eq3, desc as desc2, asc, and as and2, or as or2, sql as sql4, gte as gte2, lte as lte2, gt as gt2, like, isNotNull as isNotNull2 } from "drizzle-orm";
var GossipStorage = class {
  async getCountries(activeOnly = true) {
    if (activeOnly) {
      return db.select().from(countries).where(eq3(countries.isActive, true)).orderBy(asc(countries.sortOrder));
    }
    return db.select().from(countries).orderBy(asc(countries.sortOrder));
  }
  async getCountryByCode(code) {
    const [country] = await db.select().from(countries).where(eq3(countries.code, code));
    return country;
  }
  async getZaLocations(filters = {}) {
    const conditions = [eq3(zaLocations.isActive, true)];
    if (filters.province) {
      conditions.push(eq3(zaLocations.province, filters.province));
    }
    if (filters.city) {
      conditions.push(eq3(zaLocations.city, filters.city));
    }
    if (filters.level !== void 0) {
      conditions.push(eq3(zaLocations.level, filters.level));
    }
    return db.select().from(zaLocations).where(and2(...conditions)).orderBy(asc(zaLocations.fullPath));
  }
  async getZaLocationById(id) {
    const [location] = await db.select().from(zaLocations).where(eq3(zaLocations.id, id));
    return location;
  }
  async searchZaLocations(query, limit = 20) {
    return db.select().from(zaLocations).where(and2(
      eq3(zaLocations.isActive, true),
      like(zaLocations.fullPath, `%${query}%`)
    )).orderBy(asc(zaLocations.level), asc(zaLocations.fullPath)).limit(limit);
  }
  async detectLocationFromCoords(latitude, longitude) {
    const southernAfricaBounds = {
      ZA: { minLat: -35, maxLat: -22, minLng: 16, maxLng: 33 },
      BW: { minLat: -27, maxLat: -18, minLng: 20, maxLng: 29.5 },
      LS: { minLat: -30.7, maxLat: -28.5, minLng: 27, maxLng: 29.5 },
      SZ: { minLat: -27.3, maxLat: -25.7, minLng: 30.8, maxLng: 32.2 },
      NA: { minLat: -29, maxLat: -17, minLng: 11.5, maxLng: 25.5 },
      ZW: { minLat: -22.5, maxLat: -15.5, minLng: 25, maxLng: 33 },
      MZ: { minLat: -27, maxLat: -10.5, minLng: 30, maxLng: 41 },
      MW: { minLat: -17.2, maxLat: -9.3, minLng: 32.5, maxLng: 36 },
      ZM: { minLat: -18.1, maxLat: -8.2, minLng: 22, maxLng: 33.7 },
      AO: { minLat: -18.1, maxLat: -4.4, minLng: 11.7, maxLng: 24.1 }
    };
    let detectedCountryCode = null;
    for (const [code, bounds] of Object.entries(southernAfricaBounds)) {
      if (latitude >= bounds.minLat && latitude <= bounds.maxLat && longitude >= bounds.minLng && longitude <= bounds.maxLng) {
        detectedCountryCode = code;
        break;
      }
    }
    if (!detectedCountryCode) {
      return null;
    }
    const country = await this.getCountryByCode(detectedCountryCode);
    if (!country || !country.isActive) {
      return null;
    }
    if (detectedCountryCode === "ZA") {
      const allLocations = await db.select().from(zaLocations).where(and2(
        eq3(zaLocations.isActive, true),
        eq3(zaLocations.level, 3),
        isNotNull2(zaLocations.latitude),
        isNotNull2(zaLocations.longitude)
      ));
      let nearestLocation = null;
      let minDistance = Infinity;
      for (const loc of allLocations) {
        if (loc.latitude !== null && loc.longitude !== null) {
          const distance = Math.sqrt(
            Math.pow(latitude - loc.latitude, 2) + Math.pow(longitude - loc.longitude, 2)
          );
          if (distance < minDistance) {
            minDistance = distance;
            nearestLocation = loc;
          }
        }
      }
      if (nearestLocation && minDistance < 1.5) {
        return {
          countryCode: "ZA",
          countryName: country.name,
          province: nearestLocation.province,
          city: nearestLocation.city || void 0,
          kasi: nearestLocation.kasi || void 0,
          zaLocationId: nearestLocation.id,
          locationDisplay: nearestLocation.fullPath
        };
      }
      const provinceBounds = {
        "Gauteng": { minLat: -27, maxLat: -25, minLng: 27, maxLng: 29.5 },
        "Western Cape": { minLat: -35, maxLat: -31, minLng: 17, maxLng: 24 },
        "KwaZulu-Natal": { minLat: -31.5, maxLat: -26.5, minLng: 28.5, maxLng: 33 },
        "Eastern Cape": { minLat: -34.5, maxLat: -30, minLng: 23.5, maxLng: 30.5 },
        "Mpumalanga": { minLat: -27.5, maxLat: -24, minLng: 28.5, maxLng: 32.5 },
        "Limpopo": { minLat: -25.5, maxLat: -22, minLng: 26, maxLng: 32 },
        "Free State": { minLat: -31, maxLat: -26, minLng: 24, maxLng: 30 },
        "North West": { minLat: -28.5, maxLat: -24, minLng: 22, maxLng: 28.5 },
        "Northern Cape": { minLat: -33, maxLat: -26, minLng: 16, maxLng: 25 }
      };
      for (const [province, bounds] of Object.entries(provinceBounds)) {
        if (latitude >= bounds.minLat && latitude <= bounds.maxLat && longitude >= bounds.minLng && longitude <= bounds.maxLng) {
          const cities = await db.select().from(zaLocations).where(and2(
            eq3(zaLocations.isActive, true),
            eq3(zaLocations.province, province),
            eq3(zaLocations.level, 2)
          )).limit(1);
          if (cities.length > 0 && cities[0].city) {
            const kasis = await db.select().from(zaLocations).where(and2(
              eq3(zaLocations.isActive, true),
              eq3(zaLocations.province, province),
              eq3(zaLocations.city, cities[0].city),
              eq3(zaLocations.level, 3)
            )).limit(1);
            if (kasis.length > 0) {
              return {
                countryCode: "ZA",
                countryName: country.name,
                province: kasis[0].province,
                city: kasis[0].city || void 0,
                kasi: kasis[0].kasi || void 0,
                zaLocationId: kasis[0].id,
                locationDisplay: kasis[0].fullPath
              };
            }
          }
          return {
            countryCode: "ZA",
            countryName: country.name,
            province,
            locationDisplay: `South Africa > ${province}`
          };
        }
      }
      return {
        countryCode: "ZA",
        countryName: country.name,
        locationDisplay: "South Africa"
      };
    }
    return {
      countryCode: detectedCountryCode,
      countryName: country.name,
      locationDisplay: country.name
    };
  }
  async getSetting(key) {
    const [setting] = await db.select().from(gossipSettings).where(eq3(gossipSettings.key, key));
    return setting?.value ?? null;
  }
  async updateSetting(key, value, updatedBy) {
    const [setting] = await db.update(gossipSettings).set({ value, updatedBy, updatedAt: /* @__PURE__ */ new Date() }).where(eq3(gossipSettings.key, key)).returning();
    return setting;
  }
  async getAllSettings() {
    return db.select().from(gossipSettings);
  }
  async getBlockedWords() {
    return db.select().from(gossipBlockedWords).orderBy(asc(gossipBlockedWords.word));
  }
  async addBlockedWord(word, isRegex = false, severity = 1, addedBy) {
    const [blocked] = await db.insert(gossipBlockedWords).values({ word: word.toLowerCase(), isRegex, severity, addedBy }).onConflictDoNothing().returning();
    return blocked;
  }
  async removeBlockedWord(id) {
    const result = await db.delete(gossipBlockedWords).where(eq3(gossipBlockedWords.id, id));
    return true;
  }
  async checkContentAgainstBlockedWords(content) {
    const words = await this.getBlockedWords();
    const lowerContent = content.toLowerCase();
    const matchedWords = [];
    let maxSeverity = 0;
    for (const blocked of words) {
      let matched = false;
      if (blocked.isRegex) {
        try {
          const regex = new RegExp(blocked.word, "i");
          matched = regex.test(content);
        } catch {
          matched = lowerContent.includes(blocked.word);
        }
      } else {
        matched = lowerContent.includes(blocked.word);
      }
      if (matched) {
        matchedWords.push(blocked.word);
        maxSeverity = Math.max(maxSeverity, blocked.severity);
      }
    }
    return {
      isBlocked: matchedWords.length > 0,
      matchedWords,
      severity: maxSeverity
    };
  }
  async checkRateLimit(deviceHash) {
    const maxPostsStr = await this.getSetting("max_posts_per_hour") || "10";
    const maxPosts = parseInt(maxPostsStr, 10);
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1e3);
    const [result] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipPosts).where(and2(
      eq3(anonGossipPosts.deviceHash, deviceHash),
      gte2(anonGossipPosts.createdAt, oneHourAgo)
    ));
    const count5 = result?.count || 0;
    const remaining = Math.max(0, maxPosts - count5);
    const resetAt = new Date(Date.now() + 60 * 60 * 1e3);
    return {
      allowed: count5 < maxPosts,
      remaining,
      resetAt
    };
  }
  async createAnonPost(input) {
    let whisperExpiresAt = null;
    if (input.isWhisper) {
      const durationStr = await this.getSetting("whisper_duration_hours") || "24";
      const hours = parseInt(durationStr, 10);
      whisperExpiresAt = new Date(Date.now() + hours * 60 * 60 * 1e3);
    }
    const [post] = await db.insert(anonGossipPosts).values({
      deviceHash: input.deviceHash,
      countryCode: input.countryCode,
      zaLocationId: input.zaLocationId,
      locationDisplay: input.locationDisplay,
      type: input.type,
      content: input.content,
      mediaUrl: input.mediaUrl,
      thumbnailUrl: input.thumbnailUrl,
      durationMs: input.durationMs,
      isWhisper: input.isWhisper || false,
      whisperExpiresAt
    }).returning();
    if (post && input.zaLocationId) {
      await this.incrementLocationStats(input.zaLocationId, input.locationDisplay || "");
    } else if (post && input.countryCode) {
      await this.incrementLocationStats(`country_${input.countryCode}`, input.countryCode);
    }
    return post;
  }
  async getAnonPost(id, deviceHash) {
    const [post] = await db.select().from(anonGossipPosts).where(and2(
      eq3(anonGossipPosts.id, id),
      eq3(anonGossipPosts.isHidden, false),
      eq3(anonGossipPosts.isRemovedByAdmin, false)
    ));
    if (!post) return void 0;
    const myReactions = [];
    if (deviceHash) {
      const reactions = await db.select({ reactionType: anonGossipReactions.reactionType }).from(anonGossipReactions).where(and2(
        eq3(anonGossipReactions.postId, id),
        eq3(anonGossipReactions.deviceHash, deviceHash)
      ));
      myReactions.push(...reactions.map((r) => r.reactionType));
    }
    return { ...post, myReactions };
  }
  async getAnonFeed(filters) {
    const conditions = [
      eq3(anonGossipPosts.isHidden, false),
      eq3(anonGossipPosts.isRemovedByAdmin, false)
    ];
    if (filters.countryCode) {
      conditions.push(eq3(anonGossipPosts.countryCode, filters.countryCode));
    }
    if (filters.zaLocationId) {
      conditions.push(eq3(anonGossipPosts.zaLocationId, filters.zaLocationId));
    }
    if (filters.isWhisper !== void 0) {
      conditions.push(eq3(anonGossipPosts.isWhisper, filters.isWhisper));
    }
    conditions.push(
      or2(
        eq3(anonGossipPosts.isWhisper, false),
        and2(
          eq3(anonGossipPosts.isWhisper, true),
          gte2(anonGossipPosts.whisperExpiresAt, /* @__PURE__ */ new Date())
        )
      )
    );
    let orderBy;
    switch (filters.sortBy) {
      case "trending":
        orderBy = desc2(anonGossipPosts.teaMeter);
        break;
      case "hottest":
        orderBy = desc2(sql4`${anonGossipPosts.fireCount} + ${anonGossipPosts.mindblownCount}`);
        break;
      case "latest":
      default:
        orderBy = desc2(anonGossipPosts.createdAt);
    }
    const posts3 = await db.select().from(anonGossipPosts).where(and2(...conditions)).orderBy(orderBy).limit(filters.limit || 20).offset(filters.offset || 0);
    const postsWithMeta = [];
    for (const post of posts3) {
      const myReactions = [];
      if (filters.deviceHash) {
        const reactions = await db.select({ reactionType: anonGossipReactions.reactionType }).from(anonGossipReactions).where(and2(
          eq3(anonGossipReactions.postId, post.id),
          eq3(anonGossipReactions.deviceHash, filters.deviceHash)
        ));
        myReactions.push(...reactions.map((r) => r.reactionType));
      }
      postsWithMeta.push({ ...post, myReactions });
    }
    return postsWithMeta;
  }
  async toggleReaction(postId, deviceHash, reactionType) {
    const [existing] = await db.select().from(anonGossipReactions).where(and2(
      eq3(anonGossipReactions.postId, postId),
      eq3(anonGossipReactions.deviceHash, deviceHash),
      eq3(anonGossipReactions.reactionType, reactionType)
    ));
    const columnMap = {
      FIRE: "fire_count",
      MINDBLOWN: "mindblown_count",
      LAUGH: "laugh_count",
      SKULL: "skull_count",
      EYES: "eyes_count"
    };
    const colName = columnMap[reactionType];
    if (existing) {
      await db.delete(anonGossipReactions).where(eq3(anonGossipReactions.id, existing.id));
      await db.execute(sql4.raw(`UPDATE anon_gossip_posts SET ${colName} = GREATEST(0, ${colName} - 1) WHERE id = '${postId}'`));
      const [post] = await db.select().from(anonGossipPosts).where(eq3(anonGossipPosts.id, postId));
      await this.recalculateTeaMeter(postId);
      return { added: false, post };
    } else {
      await db.insert(anonGossipReactions).values({ postId, deviceHash, reactionType });
      await db.execute(sql4.raw(`UPDATE anon_gossip_posts SET ${colName} = ${colName} + 1 WHERE id = '${postId}'`));
      const [post] = await db.select().from(anonGossipPosts).where(eq3(anonGossipPosts.id, postId));
      await this.recalculateTeaMeter(postId);
      await this.recordVelocity(postId);
      return { added: true, post };
    }
  }
  async recalculateTeaMeter(postId) {
    const [post] = await db.select().from(anonGossipPosts).where(eq3(anonGossipPosts.id, postId));
    if (!post) return;
    const hoursOld = (Date.now() - new Date(post.createdAt).getTime()) / (1e3 * 60 * 60);
    const teaMeter = Math.max(0, Math.floor(
      post.fireCount * 3 + post.mindblownCount * 3 + post.laughCount * 2 + post.skullCount * 2 + post.eyesCount * 1 + post.replyCount * 2 - hoursOld * 1
    ));
    await db.update(anonGossipPosts).set({ teaMeter, updatedAt: /* @__PURE__ */ new Date() }).where(eq3(anonGossipPosts.id, postId));
  }
  async recordVelocity(postId) {
    const [post] = await db.select().from(anonGossipPosts).where(eq3(anonGossipPosts.id, postId));
    if (!post) return;
    const hourNumber = Math.floor((Date.now() - new Date(post.createdAt).getTime()) / (1e3 * 60 * 60));
    if (hourNumber > 24) return;
    const velocityScore = hourNumber === 0 ? 3 : hourNumber <= 1 ? 2 : 1;
    await db.insert(gossipEngagementVelocity).values({
      postId,
      hourNumber,
      reactions: 1,
      replies: 0,
      views: 0,
      velocityScore
    }).onConflictDoUpdate({
      target: [gossipEngagementVelocity.postId, gossipEngagementVelocity.hourNumber],
      set: {
        reactions: sql4`${gossipEngagementVelocity.reactions} + 1`,
        recordedAt: /* @__PURE__ */ new Date()
      }
    });
  }
  async createReply(postId, deviceHash, content, parentReplyId) {
    const maxDepthStr = await this.getSetting("max_reply_depth") || "2";
    const maxDepth = parseInt(maxDepthStr, 10);
    let depth = 1;
    if (parentReplyId) {
      const [parentReply] = await db.select().from(anonGossipReplies).where(eq3(anonGossipReplies.id, parentReplyId));
      if (!parentReply) return void 0;
      if (parentReply.depth >= maxDepth) return void 0;
      depth = parentReply.depth + 1;
    }
    const [reply] = await db.insert(anonGossipReplies).values({
      postId,
      parentReplyId,
      deviceHash,
      content,
      depth
    }).returning();
    if (reply) {
      await db.execute(sql4.raw(`UPDATE anon_gossip_posts SET reply_count = reply_count + 1 WHERE id = '${postId}'`));
      await this.recalculateTeaMeter(postId);
    }
    return reply;
  }
  async getReplies(postId, deviceHash) {
    const replies = await db.select().from(anonGossipReplies).where(and2(
      eq3(anonGossipReplies.postId, postId),
      eq3(anonGossipReplies.isHidden, false),
      eq3(anonGossipReplies.isRemovedByAdmin, false)
    )).orderBy(asc(anonGossipReplies.createdAt));
    return replies;
  }
  async toggleReplyReaction(replyId, deviceHash, reactionType) {
    const [existing] = await db.select().from(anonGossipReplyReactions).where(and2(
      eq3(anonGossipReplyReactions.replyId, replyId),
      eq3(anonGossipReplyReactions.deviceHash, deviceHash),
      eq3(anonGossipReplyReactions.reactionType, reactionType)
    ));
    const columnMap = {
      FIRE: "fire_count",
      MINDBLOWN: "mindblown_count",
      LAUGH: "laugh_count",
      SKULL: "skull_count",
      EYES: "eyes_count"
    };
    const colName = columnMap[reactionType];
    if (existing) {
      await db.delete(anonGossipReplyReactions).where(eq3(anonGossipReplyReactions.id, existing.id));
      await db.execute(sql4.raw(`UPDATE anon_gossip_replies SET ${colName} = GREATEST(0, ${colName} - 1) WHERE id = '${replyId}'`));
      return { added: false };
    } else {
      await db.insert(anonGossipReplyReactions).values({ replyId, deviceHash, reactionType });
      await db.execute(sql4.raw(`UPDATE anon_gossip_replies SET ${colName} = ${colName} + 1 WHERE id = '${replyId}'`));
      return { added: true };
    }
  }
  async reportPost(postId, deviceHash, reason) {
    const [report] = await db.insert(anonGossipReports).values({
      postId,
      deviceHash,
      reason
    }).returning();
    if (report) {
      await db.update(anonGossipPosts).set({ reportCount: sql4`${anonGossipPosts.reportCount} + 1` }).where(eq3(anonGossipPosts.id, postId));
      const reportsToHideStr = await this.getSetting("reports_to_auto_hide") || "5";
      const reportsToHide = parseInt(reportsToHideStr, 10);
      const [post] = await db.select({ reportCount: anonGossipPosts.reportCount }).from(anonGossipPosts).where(eq3(anonGossipPosts.id, postId));
      if (post && post.reportCount >= reportsToHide) {
        await db.update(anonGossipPosts).set({ isHidden: true }).where(eq3(anonGossipPosts.id, postId));
      }
    }
    return report;
  }
  async reportReply(replyId, deviceHash, reason) {
    const [report] = await db.insert(anonGossipReports).values({
      replyId,
      deviceHash,
      reason
    }).returning();
    return report;
  }
  async getPendingReports(limit = 50, offset = 0) {
    return db.select().from(anonGossipReports).where(eq3(anonGossipReports.status, "PENDING")).orderBy(desc2(anonGossipReports.createdAt)).limit(limit).offset(offset);
  }
  async reviewReport(reportId, status, reviewedBy, notes) {
    const [report] = await db.update(anonGossipReports).set({
      status,
      reviewedBy,
      reviewedAt: /* @__PURE__ */ new Date(),
      reviewNotes: notes
    }).where(eq3(anonGossipReports.id, reportId)).returning();
    if (report && status === "REMOVED") {
      if (report.postId) {
        await db.update(anonGossipPosts).set({
          isRemovedByAdmin: true,
          removedReason: notes,
          removedAt: /* @__PURE__ */ new Date(),
          removedBy: reviewedBy
        }).where(eq3(anonGossipPosts.id, report.postId));
      }
      if (report.replyId) {
        await db.update(anonGossipReplies).set({
          isRemovedByAdmin: true,
          removedReason: notes,
          removedAt: /* @__PURE__ */ new Date(),
          removedBy: reviewedBy
        }).where(eq3(anonGossipReplies.id, report.replyId));
      }
    }
    return report;
  }
  async removePost(postId, reason, removedBy) {
    const [post] = await db.update(anonGossipPosts).set({
      isRemovedByAdmin: true,
      removedReason: reason,
      removedAt: /* @__PURE__ */ new Date(),
      removedBy
    }).where(eq3(anonGossipPosts.id, postId)).returning();
    return post;
  }
  async incrementLocationStats(locationId, locationDisplay) {
    const locationType = locationId.startsWith("country_") ? "country" : locationId.startsWith("prov_") ? "province" : locationId.startsWith("city_") ? "city" : "kasi";
    await db.insert(gossipLocationStats).values({
      locationType,
      locationId,
      locationDisplay,
      totalPosts: 1,
      postsToday: 1,
      postsThisWeek: 1,
      lastPostAt: /* @__PURE__ */ new Date()
    }).onConflictDoUpdate({
      target: [gossipLocationStats.locationType, gossipLocationStats.locationId],
      set: {
        totalPosts: sql4`${gossipLocationStats.totalPosts} + 1`,
        postsToday: sql4`${gossipLocationStats.postsToday} + 1`,
        postsThisWeek: sql4`${gossipLocationStats.postsThisWeek} + 1`,
        lastPostAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    await this.checkMilestones(locationId);
  }
  async checkMilestones(locationId) {
    const milestonesStr = await this.getSetting("milestones") || "100,500,1000,5000,10000";
    const milestones = milestonesStr.split(",").map((m) => parseInt(m.trim(), 10)).sort((a, b) => b - a);
    const [stats] = await db.select().from(gossipLocationStats).where(eq3(gossipLocationStats.locationId, locationId));
    if (!stats) return null;
    for (const milestone of milestones) {
      if (stats.totalPosts >= milestone && stats.milestoneReached < milestone) {
        await db.update(gossipLocationStats).set({ milestoneReached: milestone }).where(eq3(gossipLocationStats.id, stats.id));
        return milestone;
      }
    }
    return null;
  }
  async getTrendingLocations(limit = 10) {
    return db.select().from(gossipLocationStats).orderBy(desc2(gossipLocationStats.trendingScore)).limit(limit);
  }
  async getLeaderboard(limit = 10) {
    return db.select().from(gossipLocationStats).orderBy(desc2(gossipLocationStats.totalPosts)).limit(limit);
  }
  async getStreakLeaders(limit = 10) {
    return db.select().from(gossipLocationStats).where(gte2(gossipLocationStats.streakDays, 1)).orderBy(desc2(gossipLocationStats.streakDays)).limit(limit);
  }
  async cleanupExpiredWhispers() {
    const result = await db.delete(anonGossipPosts).where(and2(
      eq3(anonGossipPosts.isWhisper, true),
      lte2(anonGossipPosts.whisperExpiresAt, /* @__PURE__ */ new Date())
    ));
    return 0;
  }
  async recalculateTrendingScores() {
    const now = /* @__PURE__ */ new Date();
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
    const stats = await db.select().from(gossipLocationStats);
    for (const stat of stats) {
      const [postsCount] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipPosts).where(and2(
        eq3(anonGossipPosts.zaLocationId, stat.locationId),
        gte2(anonGossipPosts.createdAt, oneDayAgo)
      ));
      const recentPosts = postsCount?.count || 0;
      const trendingScore = recentPosts * 2 + stat.streakDays * 0.5;
      await db.update(gossipLocationStats).set({
        postsToday: recentPosts,
        trendingScore,
        lastCalculatedAt: now
      }).where(eq3(gossipLocationStats.id, stat.id));
    }
  }
  async updateDailyStreaks() {
    const now = /* @__PURE__ */ new Date();
    const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
    const stats = await db.select().from(gossipLocationStats);
    for (const stat of stats) {
      if (stat.lastPostAt && stat.lastPostAt >= yesterday) {
        await db.update(gossipLocationStats).set({
          streakDays: stat.streakDays + 1,
          postsThisWeek: stat.postsThisWeek,
          updatedAt: now
        }).where(eq3(gossipLocationStats.id, stat.id));
      } else if (stat.lastPostAt && stat.lastPostAt < yesterday) {
        await db.update(gossipLocationStats).set({
          streakDays: 0,
          updatedAt: now
        }).where(eq3(gossipLocationStats.id, stat.id));
      }
    }
  }
  async resetWeeklyStats() {
    await db.update(gossipLocationStats).set({ postsThisWeek: 0 });
  }
  async getGossipAnalytics() {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const [totalPostsResult] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipPosts);
    const [postsTodayResult] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipPosts).where(gte2(anonGossipPosts.createdAt, today));
    const [reactionsResult] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipReactions);
    const [pendingResult] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipReports).where(eq3(anonGossipReports.status, "PENDING"));
    const [locationsResult] = await db.select({ count: sql4`count(*)::int` }).from(gossipLocationStats);
    const [whisperResult] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipPosts).where(eq3(anonGossipPosts.isWhisper, true));
    return {
      totalPosts: totalPostsResult?.count || 0,
      postsToday: postsTodayResult?.count || 0,
      totalReactions: reactionsResult?.count || 0,
      pendingReports: pendingResult?.count || 0,
      activeLocations: locationsResult?.count || 0,
      whisperPosts: whisperResult?.count || 0
    };
  }
  // Admin Panel Methods
  async getAdminStats() {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const [total] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipPosts);
    const [todayCount] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipPosts).where(gte2(anonGossipPosts.createdAt, today));
    const [reported] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipPosts).where(gt2(anonGossipPosts.reportCount, 0));
    const [hidden] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipPosts).where(eq3(anonGossipPosts.isHidden, true));
    const [whispers] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipPosts).where(and2(
      eq3(anonGossipPosts.isWhisper, true),
      isNotNull2(anonGossipPosts.whisperExpiresAt)
    ));
    const [reactions] = await db.select({ count: sql4`count(*)::int` }).from(anonGossipReactions);
    return {
      totalPosts: total?.count || 0,
      postsToday: todayCount?.count || 0,
      reportedPosts: reported?.count || 0,
      hiddenPosts: hidden?.count || 0,
      activeWhispers: whispers?.count || 0,
      totalReactions: reactions?.count || 0
    };
  }
  async getAdminPosts(filter) {
    let query = db.select().from(anonGossipPosts);
    switch (filter) {
      case "reported":
        query = query.where(gt2(anonGossipPosts.reportCount, 0));
        break;
      case "hidden":
        query = query.where(eq3(anonGossipPosts.isHidden, true));
        break;
      case "removed":
        query = query.where(eq3(anonGossipPosts.isRemovedByAdmin, true));
        break;
      case "all":
      default:
        break;
    }
    return query.orderBy(desc2(anonGossipPosts.createdAt)).limit(100);
  }
  async hidePost(postId) {
    await db.update(anonGossipPosts).set({ isHidden: true, updatedAt: /* @__PURE__ */ new Date() }).where(eq3(anonGossipPosts.id, postId));
  }
  async unhidePost(postId) {
    await db.update(anonGossipPosts).set({ isHidden: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq3(anonGossipPosts.id, postId));
  }
  async getLocationStatsForAdmin() {
    return db.select().from(gossipLocationStats).orderBy(desc2(gossipLocationStats.totalPosts)).limit(50);
  }
};
var gossipStorage = new GossipStorage();

// server/gossip-routes.ts
import { z } from "zod";
import crypto2 from "crypto";
function generateDeviceHash(req) {
  const forwarded = req.headers["x-forwarded-for"];
  const ip = typeof forwarded === "string" ? forwarded.split(",")[0] : req.socket.remoteAddress || "";
  const userAgent = req.headers["user-agent"] || "";
  const acceptLanguage = req.headers["accept-language"] || "";
  const fingerprint = `${ip}:${userAgent}:${acceptLanguage}`;
  return crypto2.createHash("sha256").update(fingerprint).digest("hex");
}
var createPostSchema = z.object({
  countryCode: z.string().length(2).optional(),
  zaLocationId: z.string().optional(),
  locationDisplay: z.string().max(300).optional(),
  type: z.enum(["TEXT", "VOICE"]).default("TEXT"),
  content: z.string().max(1e3).optional(),
  mediaUrl: z.string().url().optional(),
  thumbnailUrl: z.string().url().optional(),
  durationMs: z.number().positive().optional(),
  isWhisper: z.boolean().default(false)
});
var reactionSchema = z.object({
  reactionType: z.enum(["FIRE", "MINDBLOWN", "LAUGH", "SKULL", "EYES"])
});
var replySchema = z.object({
  content: z.string().min(1).max(500),
  parentReplyId: z.string().optional()
});
var reportSchema = z.object({
  reason: z.string().min(5).max(500)
});
var reviewReportSchema = z.object({
  status: z.enum(["REVIEWED", "DISMISSED", "REMOVED"]),
  notes: z.string().optional()
});
function registerGossipRoutes(app2, requireAdmin) {
  app2.get("/api/gossip/countries", async (req, res) => {
    try {
      const countries2 = await gossipStorage.getCountries();
      res.json(countries2);
    } catch (error) {
      console.error("Failed to get countries:", error);
      res.status(500).json({ message: "Failed to get countries" });
    }
  });
  app2.get("/api/gossip/za-locations", async (req, res) => {
    try {
      const { province, city, level } = req.query;
      console.log("[Gossip API] /za-locations request:", { province, city, level });
      const locations = await gossipStorage.getZaLocations({
        province,
        city,
        level: level ? parseInt(level, 10) : void 0
      });
      console.log("[Gossip API] /za-locations response count:", locations.length);
      res.json(locations);
    } catch (error) {
      console.error("Failed to get locations:", error);
      res.status(500).json({ message: "Failed to get locations" });
    }
  });
  app2.get("/api/gossip/za-locations/search", async (req, res) => {
    try {
      const { q, limit } = req.query;
      if (!q || typeof q !== "string") {
        return res.status(400).json({ message: "Search query required" });
      }
      const locations = await gossipStorage.searchZaLocations(q, limit ? parseInt(limit, 10) : 20);
      res.json(locations);
    } catch (error) {
      console.error("Failed to search locations:", error);
      res.status(500).json({ message: "Failed to search locations" });
    }
  });
  app2.get("/api/gossip/za-locations/:id", async (req, res) => {
    try {
      const location = await gossipStorage.getZaLocationById(req.params.id);
      if (!location) {
        return res.status(404).json({ message: "Location not found" });
      }
      res.json(location);
    } catch (error) {
      console.error("Failed to get location:", error);
      res.status(500).json({ message: "Failed to get location" });
    }
  });
  app2.post("/api/gossip/posts", async (req, res) => {
    try {
      const deviceHash = generateDeviceHash(req);
      const rateCheck = await gossipStorage.checkRateLimit(deviceHash);
      if (!rateCheck.allowed) {
        return res.status(429).json({
          message: "Rate limit exceeded. Please wait before posting again.",
          remaining: rateCheck.remaining,
          resetAt: rateCheck.resetAt
        });
      }
      const parsed = createPostSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid request", errors: parsed.error.errors });
      }
      const { content, type, ...rest } = parsed.data;
      if (!content && type === "TEXT") {
        return res.status(400).json({ message: "Content is required for text posts" });
      }
      if (!rest.mediaUrl && type === "VOICE") {
        return res.status(400).json({ message: "Media URL is required for voice posts" });
      }
      if (content) {
        const modCheck = await gossipStorage.checkContentAgainstBlockedWords(content);
        if (modCheck.isBlocked) {
          return res.status(400).json({
            message: "Your post contains prohibited content",
            blocked: true
          });
        }
      }
      const post = await gossipStorage.createAnonPost({
        deviceHash,
        content,
        type,
        ...rest
      });
      res.status(201).json(post);
    } catch (error) {
      console.error("Failed to create post:", error);
      res.status(500).json({ message: "Failed to create post" });
    }
  });
  app2.get("/api/gossip/posts", async (req, res) => {
    try {
      const deviceHash = generateDeviceHash(req);
      const { countryCode, zaLocationId, province, city, kasi, isWhisper, sortBy, limit, offset } = req.query;
      const posts3 = await gossipStorage.getAnonFeed({
        countryCode,
        zaLocationId,
        province,
        city,
        kasi,
        isWhisper: isWhisper === "true" ? true : isWhisper === "false" ? false : void 0,
        sortBy: sortBy || "latest",
        limit: limit ? parseInt(limit, 10) : 20,
        offset: offset ? parseInt(offset, 10) : 0,
        deviceHash
      });
      res.json(posts3);
    } catch (error) {
      console.error("Failed to get posts:", error);
      res.status(500).json({ message: "Failed to get posts" });
    }
  });
  app2.get("/api/gossip/posts/:id", async (req, res) => {
    try {
      const deviceHash = generateDeviceHash(req);
      const post = await gossipStorage.getAnonPost(req.params.id, deviceHash);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      res.json(post);
    } catch (error) {
      console.error("Failed to get post:", error);
      res.status(500).json({ message: "Failed to get post" });
    }
  });
  app2.post("/api/gossip/posts/:id/reactions", async (req, res) => {
    try {
      const deviceHash = generateDeviceHash(req);
      const parsed = reactionSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid reaction type" });
      }
      const result = await gossipStorage.toggleReaction(req.params.id, deviceHash, parsed.data.reactionType);
      res.json({ added: result.added, post: result.post });
    } catch (error) {
      console.error("Failed to toggle reaction:", error);
      res.status(500).json({ message: "Failed to toggle reaction" });
    }
  });
  app2.get("/api/gossip/posts/:id/replies", async (req, res) => {
    try {
      const deviceHash = generateDeviceHash(req);
      const replies = await gossipStorage.getReplies(req.params.id, deviceHash);
      res.json(replies);
    } catch (error) {
      console.error("Failed to get replies:", error);
      res.status(500).json({ message: "Failed to get replies" });
    }
  });
  app2.post("/api/gossip/posts/:id/replies", async (req, res) => {
    try {
      const deviceHash = generateDeviceHash(req);
      const parsed = replySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid reply", errors: parsed.error.errors });
      }
      const modCheck = await gossipStorage.checkContentAgainstBlockedWords(parsed.data.content);
      if (modCheck.isBlocked) {
        return res.status(400).json({
          message: "Your reply contains prohibited content",
          blocked: true
        });
      }
      const reply = await gossipStorage.createReply(
        req.params.id,
        deviceHash,
        parsed.data.content,
        parsed.data.parentReplyId
      );
      if (!reply) {
        return res.status(400).json({ message: "Failed to create reply. Max depth may be exceeded." });
      }
      res.status(201).json(reply);
    } catch (error) {
      console.error("Failed to create reply:", error);
      res.status(500).json({ message: "Failed to create reply" });
    }
  });
  app2.post("/api/gossip/replies/:id/reactions", async (req, res) => {
    try {
      const deviceHash = generateDeviceHash(req);
      const parsed = reactionSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid reaction type" });
      }
      const result = await gossipStorage.toggleReplyReaction(req.params.id, deviceHash, parsed.data.reactionType);
      res.json(result);
    } catch (error) {
      console.error("Failed to toggle reply reaction:", error);
      res.status(500).json({ message: "Failed to toggle reply reaction" });
    }
  });
  app2.post("/api/gossip/posts/:id/report", async (req, res) => {
    try {
      const deviceHash = generateDeviceHash(req);
      const parsed = reportSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid report", errors: parsed.error.errors });
      }
      const report = await gossipStorage.reportPost(req.params.id, deviceHash, parsed.data.reason);
      res.status(201).json({ message: "Report submitted", report });
    } catch (error) {
      console.error("Failed to report post:", error);
      res.status(500).json({ message: "Failed to report post" });
    }
  });
  app2.post("/api/gossip/replies/:id/report", async (req, res) => {
    try {
      const deviceHash = generateDeviceHash(req);
      const parsed = reportSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid report", errors: parsed.error.errors });
      }
      const report = await gossipStorage.reportReply(req.params.id, deviceHash, parsed.data.reason);
      res.status(201).json({ message: "Report submitted", report });
    } catch (error) {
      console.error("Failed to report reply:", error);
      res.status(500).json({ message: "Failed to report reply" });
    }
  });
  app2.get("/api/gossip/trending", async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit, 10) : 10;
      const trending = await gossipStorage.getTrendingLocations(limit);
      res.json(trending);
    } catch (error) {
      console.error("Failed to get trending:", error);
      res.status(500).json({ message: "Failed to get trending locations" });
    }
  });
  app2.get("/api/gossip/leaderboard", async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit, 10) : 10;
      const leaderboard = await gossipStorage.getLeaderboard(limit);
      res.json(leaderboard);
    } catch (error) {
      console.error("Failed to get leaderboard:", error);
      res.status(500).json({ message: "Failed to get leaderboard" });
    }
  });
  app2.get("/api/gossip/streaks", async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit, 10) : 10;
      const streaks = await gossipStorage.getStreakLeaders(limit);
      res.json(streaks);
    } catch (error) {
      console.error("Failed to get streaks:", error);
      res.status(500).json({ message: "Failed to get streak leaders" });
    }
  });
  app2.get("/api/admin/gossip/reports", requireAdmin, async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit, 10) : 50;
      const offset = req.query.offset ? parseInt(req.query.offset, 10) : 0;
      const reports2 = await gossipStorage.getPendingReports(limit, offset);
      res.json(reports2);
    } catch (error) {
      console.error("Failed to get reports:", error);
      res.status(500).json({ message: "Failed to get reports" });
    }
  });
  app2.post("/api/admin/gossip/reports/:id/review", requireAdmin, async (req, res) => {
    try {
      const parsed = reviewReportSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "Invalid review", errors: parsed.error.errors });
      }
      const report = await gossipStorage.reviewReport(
        req.params.id,
        parsed.data.status,
        req.session.userId,
        parsed.data.notes
      );
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      res.json(report);
    } catch (error) {
      console.error("Failed to review report:", error);
      res.status(500).json({ message: "Failed to review report" });
    }
  });
  app2.delete("/api/admin/gossip/posts/:id", requireAdmin, async (req, res) => {
    try {
      const { reason } = req.body;
      const post = await gossipStorage.removePost(
        req.params.id,
        reason || "Removed by admin",
        req.session.userId
      );
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      res.json({ message: "Post removed", post });
    } catch (error) {
      console.error("Failed to remove post:", error);
      res.status(500).json({ message: "Failed to remove post" });
    }
  });
  app2.get("/api/admin/gossip/settings", requireAdmin, async (req, res) => {
    try {
      const settings = await gossipStorage.getAllSettings();
      res.json(settings);
    } catch (error) {
      console.error("Failed to get settings:", error);
      res.status(500).json({ message: "Failed to get settings" });
    }
  });
  app2.patch("/api/admin/gossip/settings/:key", requireAdmin, async (req, res) => {
    try {
      const { value } = req.body;
      if (value === void 0) {
        return res.status(400).json({ message: "Value is required" });
      }
      const setting = await gossipStorage.updateSetting(
        req.params.key,
        String(value),
        req.session.userId
      );
      if (!setting) {
        return res.status(404).json({ message: "Setting not found" });
      }
      res.json(setting);
    } catch (error) {
      console.error("Failed to update setting:", error);
      res.status(500).json({ message: "Failed to update setting" });
    }
  });
  app2.get("/api/admin/gossip/blocked-words", requireAdmin, async (req, res) => {
    try {
      const words = await gossipStorage.getBlockedWords();
      res.json(words);
    } catch (error) {
      console.error("Failed to get blocked words:", error);
      res.status(500).json({ message: "Failed to get blocked words" });
    }
  });
  app2.post("/api/admin/gossip/blocked-words", requireAdmin, async (req, res) => {
    try {
      const { word, isRegex, severity } = req.body;
      if (!word) {
        return res.status(400).json({ message: "Word is required" });
      }
      const blocked = await gossipStorage.addBlockedWord(
        word,
        isRegex || false,
        severity || 1,
        req.session.userId
      );
      res.status(201).json(blocked);
    } catch (error) {
      console.error("Failed to add blocked word:", error);
      res.status(500).json({ message: "Failed to add blocked word" });
    }
  });
  app2.delete("/api/admin/gossip/blocked-words/:id", requireAdmin, async (req, res) => {
    try {
      await gossipStorage.removeBlockedWord(req.params.id);
      res.json({ message: "Blocked word removed" });
    } catch (error) {
      console.error("Failed to remove blocked word:", error);
      res.status(500).json({ message: "Failed to remove blocked word" });
    }
  });
  app2.get("/api/admin/gossip/analytics", requireAdmin, async (req, res) => {
    try {
      const analytics = await gossipStorage.getGossipAnalytics();
      res.json(analytics);
    } catch (error) {
      console.error("Failed to get analytics:", error);
      res.status(500).json({ message: "Failed to get analytics" });
    }
  });
  app2.get("/api/gossip/admin/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await gossipStorage.getAdminStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get admin stats:", error);
      res.status(500).json({ message: "Failed to get admin stats" });
    }
  });
  app2.get("/api/gossip/admin/posts", requireAdmin, async (req, res) => {
    try {
      const filter = req.query.filter || "all";
      const posts3 = await gossipStorage.getAdminPosts(filter);
      res.json(posts3);
    } catch (error) {
      console.error("Failed to get admin posts:", error);
      res.status(500).json({ message: "Failed to get admin posts" });
    }
  });
  app2.post("/api/gossip/admin/posts/:id/hide", requireAdmin, async (req, res) => {
    try {
      await gossipStorage.hidePost(req.params.id);
      res.json({ message: "Post hidden" });
    } catch (error) {
      console.error("Failed to hide post:", error);
      res.status(500).json({ message: "Failed to hide post" });
    }
  });
  app2.post("/api/gossip/admin/posts/:id/unhide", requireAdmin, async (req, res) => {
    try {
      await gossipStorage.unhidePost(req.params.id);
      res.json({ message: "Post unhidden" });
    } catch (error) {
      console.error("Failed to unhide post:", error);
      res.status(500).json({ message: "Failed to unhide post" });
    }
  });
  app2.post("/api/gossip/admin/posts/:id/remove", requireAdmin, async (req, res) => {
    try {
      const { reason } = req.body;
      await gossipStorage.removePost(req.params.id, req.session.userId, reason);
      res.json({ message: "Post removed" });
    } catch (error) {
      console.error("Failed to remove post:", error);
      res.status(500).json({ message: "Failed to remove post" });
    }
  });
  app2.get("/api/gossip/admin/blocked-words", requireAdmin, async (req, res) => {
    try {
      const words = await gossipStorage.getBlockedWords();
      res.json(words);
    } catch (error) {
      console.error("Failed to get blocked words:", error);
      res.status(500).json({ message: "Failed to get blocked words" });
    }
  });
  app2.post("/api/gossip/admin/blocked-words", requireAdmin, async (req, res) => {
    try {
      const { word, isRegex, severity } = req.body;
      if (!word) {
        return res.status(400).json({ message: "Word is required" });
      }
      const blocked = await gossipStorage.addBlockedWord(
        word,
        isRegex || false,
        severity || 1,
        req.session.userId
      );
      res.status(201).json(blocked);
    } catch (error) {
      console.error("Failed to add blocked word:", error);
      res.status(500).json({ message: "Failed to add blocked word" });
    }
  });
  app2.delete("/api/gossip/admin/blocked-words/:id", requireAdmin, async (req, res) => {
    try {
      await gossipStorage.removeBlockedWord(req.params.id);
      res.json({ message: "Blocked word removed" });
    } catch (error) {
      console.error("Failed to remove blocked word:", error);
      res.status(500).json({ message: "Failed to remove blocked word" });
    }
  });
  app2.get("/api/gossip/admin/location-stats", requireAdmin, async (req, res) => {
    try {
      const stats = await gossipStorage.getLocationStatsForAdmin();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get location stats:", error);
      res.status(500).json({ message: "Failed to get location stats" });
    }
  });
  const detectLocationSchema = z.object({
    latitude: z.number().min(-90).max(90),
    longitude: z.number().min(-180).max(180)
  });
  app2.post("/api/gossip/detect-location", async (req, res) => {
    try {
      const { latitude, longitude } = detectLocationSchema.parse(req.body);
      const location = await gossipStorage.detectLocationFromCoords(latitude, longitude);
      if (location) {
        res.json({ success: true, location });
      } else {
        res.json({
          success: false,
          message: "Could not detect a supported location. Make sure you are in Southern Africa."
        });
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid coordinates", errors: error.errors });
      }
      console.error("Failed to detect location:", error);
      res.status(500).json({ message: "Failed to detect location" });
    }
  });
  console.log("Gossip routes registered");
}

// server/storage-advanced.ts
init_schema();
init_db();
import { eq as eq4, desc as desc3, and as and3, sql as sql5, inArray as inArray3, gt as gt3, lte as lte3, ne as ne2 } from "drizzle-orm";
var AdvancedStorage = class {
  // ============================================
  // VIRTUAL CURRENCY / WALLETS
  // ============================================
  async getOrCreateWallet(userId) {
    const [existing] = await db.select().from(wallets).where(eq4(wallets.userId, userId)).limit(1);
    if (existing) return existing;
    const [wallet] = await db.insert(wallets).values({ userId }).returning();
    return wallet;
  }
  async getWallet(userId) {
    const [wallet] = await db.select().from(wallets).where(eq4(wallets.userId, userId)).limit(1);
    return wallet;
  }
  async addCoins(userId, amount, type, description, referenceId, referenceType) {
    const wallet = await this.getOrCreateWallet(userId);
    const newBalance = wallet.coinBalance + amount;
    await db.update(wallets).set({
      coinBalance: newBalance,
      lifetimeEarned: wallet.lifetimeEarned + (amount > 0 ? amount : 0),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq4(wallets.id, wallet.id));
    const [transaction] = await db.insert(coinTransactions).values({
      walletId: wallet.id,
      type,
      amount,
      balanceAfter: newBalance,
      description,
      referenceId,
      referenceType
    }).returning();
    return transaction;
  }
  async deductCoins(userId, amount, type, description, referenceId, referenceType) {
    const wallet = await this.getOrCreateWallet(userId);
    if (wallet.coinBalance < amount) return null;
    const newBalance = wallet.coinBalance - amount;
    await db.update(wallets).set({
      coinBalance: newBalance,
      lifetimeSpent: wallet.lifetimeSpent + amount,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq4(wallets.id, wallet.id));
    const [transaction] = await db.insert(coinTransactions).values({
      walletId: wallet.id,
      type,
      amount: -amount,
      balanceAfter: newBalance,
      description,
      referenceId,
      referenceType
    }).returning();
    return transaction;
  }
  async getCoinTransactions(userId, limit = 50) {
    const wallet = await this.getWallet(userId);
    if (!wallet) return [];
    return db.select().from(coinTransactions).where(eq4(coinTransactions.walletId, wallet.id)).orderBy(desc3(coinTransactions.createdAt)).limit(limit);
  }
  // ============================================
  // GIFT TYPES & TRANSACTIONS
  // ============================================
  async getGiftTypes(category) {
    if (category) {
      return db.select().from(giftTypes).where(and3(eq4(giftTypes.isActive, true), eq4(giftTypes.category, category))).orderBy(giftTypes.sortOrder);
    }
    return db.select().from(giftTypes).where(eq4(giftTypes.isActive, true)).orderBy(giftTypes.sortOrder);
  }
  async getGiftType(id) {
    const [gift] = await db.select().from(giftTypes).where(eq4(giftTypes.id, id)).limit(1);
    return gift;
  }
  async sendGift(senderId, recipientId, giftTypeId, quantity = 1, contextType, contextId, message) {
    const giftType = await this.getGiftType(giftTypeId);
    if (!giftType) return null;
    const totalCoins = giftType.coinCost * quantity;
    const deduction = await this.deductCoins(senderId, totalCoins, "GIFT_SENT", `Sent ${quantity}x ${giftType.name}`, giftTypeId, "gift");
    if (!deduction) return null;
    await this.addCoins(recipientId, totalCoins, "GIFT_RECEIVED", `Received ${quantity}x ${giftType.name} from user`, giftTypeId, "gift");
    const [transaction] = await db.insert(giftTransactions).values({
      senderId,
      recipientId,
      giftTypeId,
      quantity,
      totalCoins,
      contextType,
      contextId,
      message
    }).returning();
    return transaction;
  }
  async getReceivedGifts(userId, limit = 50) {
    const transactions = await db.select().from(giftTransactions).where(eq4(giftTransactions.recipientId, userId)).orderBy(desc3(giftTransactions.createdAt)).limit(limit);
    const result = [];
    for (const t of transactions) {
      const [sender] = await db.select().from(users).where(eq4(users.id, t.senderId)).limit(1);
      const [giftType] = await db.select().from(giftTypes).where(eq4(giftTypes.id, t.giftTypeId)).limit(1);
      if (sender && giftType) {
        result.push({ ...t, sender, giftType });
      }
    }
    return result;
  }
  // ============================================
  // LIVE STREAMING
  // ============================================
  async createLiveStream(hostId, title, description) {
    const streamKey = `stream_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const [stream] = await db.insert(liveStreams).values({
      hostId,
      title,
      description,
      streamKey,
      status: "PREPARING"
    }).returning();
    return stream;
  }
  async getLiveStream(id) {
    const [stream] = await db.select().from(liveStreams).where(eq4(liveStreams.id, id)).limit(1);
    return stream;
  }
  async getActiveLiveStreams(limit = 20) {
    const streams = await db.select().from(liveStreams).where(eq4(liveStreams.status, "LIVE")).orderBy(desc3(liveStreams.viewerCount)).limit(limit);
    const result = [];
    for (const s of streams) {
      const [host] = await db.select().from(users).where(eq4(users.id, s.hostId)).limit(1);
      if (host) {
        const { password, ...safeHost } = host;
        result.push({ ...s, host: safeHost });
      }
    }
    return result;
  }
  async getUserLiveStreams(userId) {
    return db.select().from(liveStreams).where(eq4(liveStreams.hostId, userId)).orderBy(desc3(liveStreams.createdAt));
  }
  async startLiveStream(streamId) {
    const [stream] = await db.update(liveStreams).set({ status: "LIVE", startedAt: /* @__PURE__ */ new Date() }).where(eq4(liveStreams.id, streamId)).returning();
    return stream;
  }
  async endLiveStream(streamId, saveToProfile = false) {
    const stream = await this.getLiveStream(streamId);
    if (!stream) return void 0;
    const durationSeconds = stream.startedAt ? Math.floor((Date.now() - stream.startedAt.getTime()) / 1e3) : 0;
    const [updated] = await db.update(liveStreams).set({
      status: "ENDED",
      endedAt: /* @__PURE__ */ new Date(),
      durationSeconds,
      savedToProfile: saveToProfile
    }).where(eq4(liveStreams.id, streamId)).returning();
    return updated;
  }
  async joinLiveStream(streamId, userId) {
    const [existing] = await db.select().from(liveStreamViewers).where(and3(eq4(liveStreamViewers.streamId, streamId), eq4(liveStreamViewers.userId, userId))).limit(1);
    if (existing) {
      const [updated] = await db.update(liveStreamViewers).set({ joinedAt: /* @__PURE__ */ new Date(), leftAt: null }).where(eq4(liveStreamViewers.id, existing.id)).returning();
      return updated;
    }
    const [viewer] = await db.insert(liveStreamViewers).values({ streamId, userId }).returning();
    await db.update(liveStreams).set({ viewerCount: sql5`viewer_count + 1`, totalViews: sql5`total_views + 1` }).where(eq4(liveStreams.id, streamId));
    const stream = await this.getLiveStream(streamId);
    if (stream && stream.viewerCount > stream.peakViewerCount) {
      await db.update(liveStreams).set({ peakViewerCount: stream.viewerCount }).where(eq4(liveStreams.id, streamId));
    }
    return viewer;
  }
  async leaveLiveStream(streamId, userId) {
    const [viewer] = await db.select().from(liveStreamViewers).where(and3(eq4(liveStreamViewers.streamId, streamId), eq4(liveStreamViewers.userId, userId))).limit(1);
    if (viewer && !viewer.leftAt) {
      const watchTime = Math.floor((Date.now() - viewer.joinedAt.getTime()) / 1e3);
      await db.update(liveStreamViewers).set({ leftAt: /* @__PURE__ */ new Date(), watchTimeSeconds: watchTime }).where(eq4(liveStreamViewers.id, viewer.id));
      await db.update(liveStreams).set({ viewerCount: sql5`GREATEST(viewer_count - 1, 0)` }).where(eq4(liveStreams.id, streamId));
    }
  }
  async addLiveStreamComment(streamId, userId, content) {
    const [comment] = await db.insert(liveStreamComments).values({ streamId, userId, content }).returning();
    await db.update(liveStreams).set({ commentsCount: sql5`comments_count + 1` }).where(eq4(liveStreams.id, streamId));
    return comment;
  }
  async getLiveStreamComments(streamId, limit = 100) {
    const comments3 = await db.select().from(liveStreamComments).where(and3(eq4(liveStreamComments.streamId, streamId), eq4(liveStreamComments.isHidden, false))).orderBy(desc3(liveStreamComments.createdAt)).limit(limit);
    const result = [];
    for (const c of comments3) {
      const [user] = await db.select().from(users).where(eq4(users.id, c.userId)).limit(1);
      if (user) {
        result.push({ ...c, user });
      }
    }
    return result;
  }
  async addLiveStreamReaction(streamId, userId, reactionType) {
    const [reaction] = await db.insert(liveStreamReactions).values({ streamId, userId, reactionType }).returning();
    await db.update(liveStreams).set({ likesCount: sql5`likes_count + 1` }).where(eq4(liveStreams.id, streamId));
    return reaction;
  }
  // ============================================
  // GROUPS / ELITE CIRCLES
  // ============================================
  async createGroup(ownerId, name, description, privacy = "PUBLIC", netWorthRequirement) {
    const [group] = await db.insert(groups).values({
      ownerId,
      name,
      description,
      privacy,
      netWorthRequirement
    }).returning();
    await db.insert(groupMembers).values({
      groupId: group.id,
      userId: ownerId,
      role: "OWNER"
    });
    return group;
  }
  async getGroup(id) {
    const [group] = await db.select().from(groups).where(eq4(groups.id, id)).limit(1);
    return group;
  }
  async getPublicGroups(limit = 20) {
    const groupList = await db.select().from(groups).where(and3(eq4(groups.privacy, "PUBLIC"), eq4(groups.isArchived, false))).orderBy(desc3(groups.memberCount)).limit(limit);
    const result = [];
    for (const g of groupList) {
      const [owner] = await db.select().from(users).where(eq4(users.id, g.ownerId)).limit(1);
      if (owner) {
        result.push({ ...g, owner });
      }
    }
    return result;
  }
  async getUserGroups(userId) {
    const memberships = await db.select().from(groupMembers).where(eq4(groupMembers.userId, userId));
    const result = [];
    for (const m of memberships) {
      const group = await this.getGroup(m.groupId);
      if (group && !group.isArchived) {
        result.push({ ...group, role: m.role });
      }
    }
    return result;
  }
  async joinGroup(groupId, userId) {
    const group = await this.getGroup(groupId);
    if (!group) return null;
    if (group.requireApproval || group.privacy === "PRIVATE") {
      const [existing] = await db.select().from(groupJoinRequests).where(and3(eq4(groupJoinRequests.groupId, groupId), eq4(groupJoinRequests.userId, userId))).limit(1);
      if (existing) return existing;
      const [request] = await db.insert(groupJoinRequests).values({ groupId, userId }).returning();
      return request;
    }
    const [member] = await db.insert(groupMembers).values({ groupId, userId }).returning();
    await db.update(groups).set({ memberCount: sql5`member_count + 1` }).where(eq4(groups.id, groupId));
    return member;
  }
  async leaveGroup(groupId, userId) {
    const [member] = await db.select().from(groupMembers).where(and3(eq4(groupMembers.groupId, groupId), eq4(groupMembers.userId, userId))).limit(1);
    if (member && member.role !== "OWNER") {
      await db.delete(groupMembers).where(eq4(groupMembers.id, member.id));
      await db.update(groups).set({ memberCount: sql5`GREATEST(member_count - 1, 0)` }).where(eq4(groups.id, groupId));
    }
  }
  async getGroupMembers(groupId) {
    const members = await db.select().from(groupMembers).where(eq4(groupMembers.groupId, groupId)).orderBy(groupMembers.role, groupMembers.joinedAt);
    const result = [];
    for (const m of members) {
      const [user] = await db.select().from(users).where(eq4(users.id, m.userId)).limit(1);
      if (user) {
        result.push({ ...m, user });
      }
    }
    return result;
  }
  async isGroupMember(groupId, userId) {
    const [member] = await db.select().from(groupMembers).where(and3(eq4(groupMembers.groupId, groupId), eq4(groupMembers.userId, userId))).limit(1);
    return !!member;
  }
  async getGroupMemberRole(groupId, userId) {
    const [member] = await db.select().from(groupMembers).where(and3(eq4(groupMembers.groupId, groupId), eq4(groupMembers.userId, userId))).limit(1);
    return member?.role || null;
  }
  // ============================================
  // EVENTS
  // ============================================
  async createEvent(hostId, data) {
    const [event] = await db.insert(events).values({
      hostId,
      title: data.title || "Untitled Event",
      description: data.description,
      eventType: data.eventType || "IN_PERSON",
      startsAt: data.startsAt || /* @__PURE__ */ new Date(),
      endsAt: data.endsAt,
      locationName: data.locationName,
      locationAddress: data.locationAddress,
      locationLat: data.locationLat,
      locationLng: data.locationLng,
      virtualLink: data.virtualLink,
      maxAttendees: data.maxAttendees,
      isPrivate: data.isPrivate || false,
      ticketPrice: data.ticketPrice,
      status: "DRAFT"
    }).returning();
    return event;
  }
  async getEvent(id) {
    const [event] = await db.select().from(events).where(eq4(events.id, id)).limit(1);
    return event;
  }
  async getUpcomingEvents(limit = 20) {
    const eventList = await db.select().from(events).where(and3(
      eq4(events.status, "PUBLISHED"),
      eq4(events.isPrivate, false),
      gt3(events.startsAt, /* @__PURE__ */ new Date())
    )).orderBy(events.startsAt).limit(limit);
    const result = [];
    for (const e of eventList) {
      const [host] = await db.select().from(users).where(eq4(users.id, e.hostId)).limit(1);
      if (host) {
        result.push({ ...e, host });
      }
    }
    return result;
  }
  async rsvpEvent(eventId, userId, status) {
    const [existing] = await db.select().from(eventRsvps).where(and3(eq4(eventRsvps.eventId, eventId), eq4(eventRsvps.userId, userId))).limit(1);
    if (existing) {
      const oldStatus = existing.status;
      const [updated] = await db.update(eventRsvps).set({ status, updatedAt: /* @__PURE__ */ new Date() }).where(eq4(eventRsvps.id, existing.id)).returning();
      if (oldStatus !== status) {
        if (oldStatus === "GOING") {
          await db.update(events).set({ goingCount: sql5`GREATEST(going_count - 1, 0)` }).where(eq4(events.id, eventId));
        } else if (oldStatus === "INTERESTED") {
          await db.update(events).set({ interestedCount: sql5`GREATEST(interested_count - 1, 0)` }).where(eq4(events.id, eventId));
        }
        if (status === "GOING") {
          await db.update(events).set({ goingCount: sql5`going_count + 1` }).where(eq4(events.id, eventId));
        } else if (status === "INTERESTED") {
          await db.update(events).set({ interestedCount: sql5`interested_count + 1` }).where(eq4(events.id, eventId));
        }
      }
      return updated;
    }
    const [rsvp] = await db.insert(eventRsvps).values({ eventId, userId, status }).returning();
    if (status === "GOING") {
      await db.update(events).set({ goingCount: sql5`going_count + 1` }).where(eq4(events.id, eventId));
    } else if (status === "INTERESTED") {
      await db.update(events).set({ interestedCount: sql5`interested_count + 1` }).where(eq4(events.id, eventId));
    }
    return rsvp;
  }
  // ============================================
  // SUBSCRIPTIONS / SUPER FOLLOWS
  // ============================================
  async createSubscriptionTier(creatorId, name, monthlyPriceCoins, description, benefits) {
    const [tier] = await db.insert(subscriptionTiers).values({
      creatorId,
      name,
      monthlyPriceCoins,
      description,
      benefits: benefits || []
    }).returning();
    return tier;
  }
  async getCreatorSubscriptionTiers(creatorId) {
    return db.select().from(subscriptionTiers).where(and3(eq4(subscriptionTiers.creatorId, creatorId), eq4(subscriptionTiers.isActive, true))).orderBy(subscriptionTiers.sortOrder);
  }
  async subscribe(subscriberId, creatorId, tierId) {
    const tier = await db.select().from(subscriptionTiers).where(eq4(subscriptionTiers.id, tierId)).limit(1);
    if (!tier[0]) return null;
    const deduction = await this.deductCoins(subscriberId, tier[0].monthlyPriceCoins, "SUBSCRIPTION_PAYMENT", `Subscription to creator`, tierId, "subscription");
    if (!deduction) return null;
    await this.addCoins(creatorId, tier[0].monthlyPriceCoins, "GIFT_RECEIVED", "Subscription payment", tierId, "subscription");
    const periodEnd = /* @__PURE__ */ new Date();
    periodEnd.setMonth(periodEnd.getMonth() + 1);
    const [subscription] = await db.insert(subscriptions).values({
      subscriberId,
      creatorId,
      tierId,
      currentPeriodStart: /* @__PURE__ */ new Date(),
      currentPeriodEnd: periodEnd
    }).returning();
    await db.update(subscriptionTiers).set({ subscriberCount: sql5`subscriber_count + 1` }).where(eq4(subscriptionTiers.id, tierId));
    return subscription;
  }
  async isSubscribed(subscriberId, creatorId) {
    const [sub] = await db.select().from(subscriptions).where(and3(
      eq4(subscriptions.subscriberId, subscriberId),
      eq4(subscriptions.creatorId, creatorId),
      eq4(subscriptions.status, "ACTIVE")
    )).limit(1);
    return !!sub;
  }
  // ============================================
  // BROADCAST CHANNELS
  // ============================================
  async createBroadcastChannel(ownerId, name, description) {
    const [channel] = await db.insert(broadcastChannels).values({
      ownerId,
      name,
      description
    }).returning();
    return channel;
  }
  async getBroadcastChannel(id) {
    const [channel] = await db.select().from(broadcastChannels).where(eq4(broadcastChannels.id, id)).limit(1);
    return channel;
  }
  async subscribeToBroadcastChannel(channelId, userId) {
    const [sub] = await db.insert(broadcastChannelSubscribers).values({ channelId, userId }).returning();
    await db.update(broadcastChannels).set({ subscriberCount: sql5`subscriber_count + 1` }).where(eq4(broadcastChannels.id, channelId));
    return sub;
  }
  async sendBroadcastMessage(channelId, content, mediaUrl, mediaType) {
    const [message] = await db.insert(broadcastMessages).values({
      channelId,
      content,
      mediaUrl,
      mediaType
    }).returning();
    await db.update(broadcastChannels).set({ messageCount: sql5`message_count + 1` }).where(eq4(broadcastChannels.id, channelId));
    return message;
  }
  async getBroadcastMessages(channelId, limit = 50) {
    return db.select().from(broadcastMessages).where(eq4(broadcastMessages.channelId, channelId)).orderBy(desc3(broadcastMessages.createdAt)).limit(limit);
  }
  // ============================================
  // POST REACTIONS
  // ============================================
  async addPostReaction(postId, userId, reactionType) {
    await db.delete(postReactions).where(and3(eq4(postReactions.postId, postId), eq4(postReactions.userId, userId)));
    const [reaction] = await db.insert(postReactions).values({
      postId,
      userId,
      reactionType
    }).returning();
    return reaction;
  }
  async removePostReaction(postId, userId) {
    await db.delete(postReactions).where(and3(eq4(postReactions.postId, postId), eq4(postReactions.userId, userId)));
  }
  async getPostReactions(postId) {
    const reactions = await db.select().from(postReactions).where(eq4(postReactions.postId, postId));
    const grouped = {};
    for (const r of reactions) {
      if (!grouped[r.reactionType]) grouped[r.reactionType] = [];
      grouped[r.reactionType].push(r.userId);
    }
    const result = [];
    for (const [type, userIds] of Object.entries(grouped)) {
      const userList = await db.select().from(users).where(inArray3(users.id, userIds.slice(0, 10)));
      result.push({
        type,
        count: userIds.length,
        users: userList
      });
    }
    return result;
  }
  // ============================================
  // LOCATION SHARING
  // ============================================
  async updateUserLocation(userId, latitude, longitude, locationName) {
    const [existing] = await db.select().from(userLocations).where(eq4(userLocations.userId, userId)).limit(1);
    if (existing) {
      const [updated] = await db.update(userLocations).set({ latitude, longitude, locationName, updatedAt: /* @__PURE__ */ new Date() }).where(eq4(userLocations.id, existing.id)).returning();
      return updated;
    }
    const [location] = await db.insert(userLocations).values({
      userId,
      latitude,
      longitude,
      locationName,
      isSharing: false
    }).returning();
    return location;
  }
  async setLocationSharing(userId, isSharing, sharingMode, expiresAt) {
    const [updated] = await db.update(userLocations).set({ isSharing, sharingMode: sharingMode || "FRIENDS", expiresAt, updatedAt: /* @__PURE__ */ new Date() }).where(eq4(userLocations.userId, userId)).returning();
    return updated;
  }
  async getNearbyUsers(userId, radiusKm = 10) {
    const [myLocation] = await db.select().from(userLocations).where(eq4(userLocations.userId, userId)).limit(1);
    if (!myLocation) return [];
    const locations = await db.select().from(userLocations).where(and3(
      eq4(userLocations.isSharing, true),
      ne2(userLocations.userId, userId)
    ));
    const result = [];
    for (const loc of locations) {
      const distance = this.calculateDistance(myLocation.latitude, myLocation.longitude, loc.latitude, loc.longitude);
      if (distance <= radiusKm) {
        const [user] = await db.select().from(users).where(eq4(users.id, loc.userId)).limit(1);
        if (user) {
          result.push({ ...loc, user });
        }
      }
    }
    return result;
  }
  calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  // ============================================
  // CHECK-INS & VENUES
  // ============================================
  async createVenue(name, category, address, city, country, latitude, longitude) {
    const [venue] = await db.insert(venues).values({
      name,
      category,
      address,
      city,
      country,
      latitude,
      longitude
    }).returning();
    return venue;
  }
  async getVenue(id) {
    const [venue] = await db.select().from(venues).where(eq4(venues.id, id)).limit(1);
    return venue;
  }
  async searchVenues(query, limit = 20) {
    return db.select().from(venues).where(sql5`name ILIKE ${"%" + query + "%"}`).orderBy(desc3(venues.checkInCount)).limit(limit);
  }
  async checkIn(userId, venueId, customLocationName, latitude, longitude, postId, caption) {
    const [checkIn] = await db.insert(checkIns).values({
      userId,
      venueId,
      customLocationName,
      latitude,
      longitude,
      postId,
      caption
    }).returning();
    if (venueId) {
      await db.update(venues).set({ checkInCount: sql5`check_in_count + 1` }).where(eq4(venues.id, venueId));
    }
    return checkIn;
  }
  async getUserCheckIns(userId, limit = 20) {
    const checkInList = await db.select().from(checkIns).where(eq4(checkIns.userId, userId)).orderBy(desc3(checkIns.createdAt)).limit(limit);
    const result = [];
    for (const c of checkInList) {
      let venue;
      if (c.venueId) {
        venue = await this.getVenue(c.venueId);
      }
      result.push({ ...c, venue });
    }
    return result;
  }
  // ============================================
  // GROUP CONVERSATIONS
  // ============================================
  async createGroupConversation(creatorId, name, memberIds = []) {
    const [conversation] = await db.insert(groupConversations).values({
      creatorId,
      name,
      memberCount: memberIds.length + 1
    }).returning();
    await db.insert(groupConversationMembers).values({
      conversationId: conversation.id,
      userId: creatorId,
      role: "ADMIN"
    });
    for (const memberId of memberIds) {
      await db.insert(groupConversationMembers).values({
        conversationId: conversation.id,
        userId: memberId,
        role: "MEMBER"
      });
    }
    return conversation;
  }
  async getGroupConversation(id) {
    const [conversation] = await db.select().from(groupConversations).where(eq4(groupConversations.id, id)).limit(1);
    return conversation;
  }
  async getUserGroupConversations(userId) {
    const memberships = await db.select().from(groupConversationMembers).where(eq4(groupConversationMembers.userId, userId));
    const result = [];
    for (const m of memberships) {
      const conversation = await this.getGroupConversation(m.conversationId);
      if (conversation && conversation.isActive) {
        const memberList = await db.select().from(groupConversationMembers).where(eq4(groupConversationMembers.conversationId, conversation.id));
        const memberUsers = [];
        for (const mem of memberList) {
          const [user] = await db.select().from(users).where(eq4(users.id, mem.userId)).limit(1);
          if (user) memberUsers.push(user);
        }
        result.push({ ...conversation, members: memberUsers });
      }
    }
    return result;
  }
  async sendGroupMessage(conversationId, senderId, content, messageType = "TEXT", mediaUrl) {
    const [message] = await db.insert(groupMessages).values({
      conversationId,
      senderId,
      content,
      messageType,
      mediaUrl
    }).returning();
    await db.update(groupConversations).set({ messageCount: sql5`message_count + 1`, lastMessageAt: /* @__PURE__ */ new Date() }).where(eq4(groupConversations.id, conversationId));
    return message;
  }
  async getGroupMessages(conversationId, limit = 50) {
    const messageList = await db.select().from(groupMessages).where(and3(eq4(groupMessages.conversationId, conversationId), eq4(groupMessages.isDeleted, false))).orderBy(desc3(groupMessages.createdAt)).limit(limit);
    const result = [];
    for (const m of messageList) {
      const [sender] = await db.select().from(users).where(eq4(users.id, m.senderId)).limit(1);
      if (sender) {
        result.push({ ...m, sender });
      }
    }
    return result.reverse();
  }
  // ============================================
  // VIDEO CALLS
  // ============================================
  async initiateCall(callerId, calleeId, callType = "VIDEO") {
    const roomId = `call_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const [call] = await db.insert(videoCalls).values({
      callerId,
      calleeId,
      callType,
      roomId,
      status: "RINGING"
    }).returning();
    return call;
  }
  async getCall(id) {
    const [call] = await db.select().from(videoCalls).where(eq4(videoCalls.id, id)).limit(1);
    return call;
  }
  async answerCall(callId) {
    const [call] = await db.update(videoCalls).set({ status: "ONGOING", startedAt: /* @__PURE__ */ new Date() }).where(eq4(videoCalls.id, callId)).returning();
    return call;
  }
  async endCall(callId, status = "ENDED") {
    const call = await this.getCall(callId);
    if (!call) return void 0;
    const durationSeconds = call.startedAt ? Math.floor((Date.now() - call.startedAt.getTime()) / 1e3) : 0;
    const [updated] = await db.update(videoCalls).set({ status, endedAt: /* @__PURE__ */ new Date(), durationSeconds }).where(eq4(videoCalls.id, callId)).returning();
    return updated;
  }
  async getUserCallHistory(userId, limit = 50) {
    const calls = await db.select().from(videoCalls).where(sql5`caller_id = ${userId} OR callee_id = ${userId}`).orderBy(desc3(videoCalls.createdAt)).limit(limit);
    const result = [];
    for (const c of calls) {
      const [caller] = await db.select().from(users).where(eq4(users.id, c.callerId)).limit(1);
      const [callee] = await db.select().from(users).where(eq4(users.id, c.calleeId)).limit(1);
      if (caller && callee) {
        result.push({ ...c, caller, callee });
      }
    }
    return result;
  }
  // ============================================
  // FEATURE FLAGS
  // ============================================
  async getFeatureFlag(key) {
    const [flag] = await db.select().from(featureFlags).where(eq4(featureFlags.key, key)).limit(1);
    return flag;
  }
  async isFeatureEnabled(key, userId) {
    const flag = await this.getFeatureFlag(key);
    if (!flag || !flag.isEnabled) return false;
    if (userId) {
      const blockedIds = flag.blockedUserIds || [];
      if (blockedIds.includes(userId)) return false;
      const allowedIds = flag.allowedUserIds || [];
      if (allowedIds.length > 0 && !allowedIds.includes(userId)) {
        return Math.random() * 100 < (flag.rolloutPercentage || 100);
      }
    }
    return Math.random() * 100 < (flag.rolloutPercentage || 100);
  }
  async getAllFeatureFlags() {
    return db.select().from(featureFlags).orderBy(featureFlags.key);
  }
  async updateFeatureFlag(key, data) {
    const [updated] = await db.update(featureFlags).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq4(featureFlags.key, key)).returning();
    return updated;
  }
  async createFeatureFlag(key, name, description) {
    const [flag] = await db.insert(featureFlags).values({
      key,
      name,
      description,
      isEnabled: false
    }).returning();
    return flag;
  }
  // ============================================
  // HASHTAGS
  // ============================================
  async getOrCreateHashtag(tag) {
    const normalizedTag = tag.toLowerCase().replace(/^#/, "");
    const [existing] = await db.select().from(hashtags).where(eq4(hashtags.tag, normalizedTag)).limit(1);
    if (existing) return existing;
    const [hashtag] = await db.insert(hashtags).values({ tag: normalizedTag }).returning();
    return hashtag;
  }
  async addPostHashtags(postId, tags) {
    for (const tag of tags) {
      const hashtag = await this.getOrCreateHashtag(tag);
      await db.insert(postHashtags).values({ postId, hashtagId: hashtag.id }).onConflictDoNothing();
      await db.update(hashtags).set({
        postCount: sql5`post_count + 1`,
        weeklyPostCount: sql5`weekly_post_count + 1`,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq4(hashtags.id, hashtag.id));
    }
  }
  async getTrendingHashtags(limit = 20) {
    return db.select().from(hashtags).where(eq4(hashtags.isBlocked, false)).orderBy(desc3(hashtags.weeklyPostCount)).limit(limit);
  }
  async searchHashtags(query, limit = 20) {
    return db.select().from(hashtags).where(sql5`tag ILIKE ${"%" + query.toLowerCase() + "%"} AND is_blocked = false`).orderBy(desc3(hashtags.postCount)).limit(limit);
  }
  // ============================================
  // USAGE STATS & FOCUS MODE
  // ============================================
  async recordUsageStat(userId, stat) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const [existing] = await db.select().from(usageStats).where(and3(eq4(usageStats.userId, userId), eq4(usageStats.date, today))).limit(1);
    if (existing) {
      const [updated] = await db.update(usageStats).set({
        screenTimeMinutes: sql5`screen_time_minutes + ${stat.screenTimeMinutes || 0}`,
        sessionsCount: sql5`sessions_count + ${stat.sessionsCount || 0}`,
        postsViewed: sql5`posts_viewed + ${stat.postsViewed || 0}`,
        storiesViewed: sql5`stories_viewed + ${stat.storiesViewed || 0}`,
        messagesSent: sql5`messages_sent + ${stat.messagesSent || 0}`,
        notificationsReceived: sql5`notifications_received + ${stat.notificationsReceived || 0}`
      }).where(eq4(usageStats.id, existing.id)).returning();
      return updated;
    }
    const [newStat] = await db.insert(usageStats).values({
      userId,
      date: today,
      ...stat
    }).returning();
    return newStat;
  }
  async getUserUsageStats(userId, days = 7) {
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - days);
    return db.select().from(usageStats).where(and3(eq4(usageStats.userId, userId), gt3(usageStats.date, startDate))).orderBy(desc3(usageStats.date));
  }
  async getFocusModeSettings(userId) {
    const [settings] = await db.select().from(focusModeSettings).where(eq4(focusModeSettings.userId, userId)).limit(1);
    return settings;
  }
  async updateFocusModeSettings(userId, data) {
    const [existing] = await db.select().from(focusModeSettings).where(eq4(focusModeSettings.userId, userId)).limit(1);
    if (existing) {
      const [updated] = await db.update(focusModeSettings).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq4(focusModeSettings.id, existing.id)).returning();
      return updated;
    }
    const [newSettings] = await db.insert(focusModeSettings).values({
      userId,
      ...data
    }).returning();
    return newSettings;
  }
  // ============================================
  // POKES / WAVES
  // ============================================
  async sendPoke(senderId, recipientId, pokeType = "WAVE") {
    const [poke] = await db.insert(pokes).values({
      senderId,
      recipientId,
      pokeType
    }).returning();
    return poke;
  }
  async getReceivedPokes(userId, limit = 20) {
    const pokeList = await db.select().from(pokes).where(eq4(pokes.recipientId, userId)).orderBy(desc3(pokes.createdAt)).limit(limit);
    const result = [];
    for (const p of pokeList) {
      const [sender] = await db.select().from(users).where(eq4(users.id, p.senderId)).limit(1);
      if (sender) {
        result.push({ ...p, sender });
      }
    }
    return result;
  }
  async markPokeAsSeen(pokeId) {
    await db.update(pokes).set({ seenAt: /* @__PURE__ */ new Date() }).where(eq4(pokes.id, pokeId));
  }
  // ============================================
  // EXPLORE CATEGORIES
  // ============================================
  async getExploreCategories() {
    return db.select().from(exploreCategories).where(eq4(exploreCategories.isActive, true)).orderBy(exploreCategories.sortOrder);
  }
  async createExploreCategory(name, slug, description, iconName) {
    const [category] = await db.insert(exploreCategories).values({
      name,
      slug,
      description,
      iconName
    }).returning();
    return category;
  }
  // ============================================
  // VANISH MODE SETTINGS
  // ============================================
  async getVanishModeSettings(userId, conversationId) {
    const [settings] = await db.select().from(vanishModeSettings).where(eq4(vanishModeSettings.conversationId, conversationId)).limit(1);
    return settings;
  }
  async setVanishMode(userId, conversationId, enabled) {
    const [existing] = await db.select().from(vanishModeSettings).where(eq4(vanishModeSettings.conversationId, conversationId)).limit(1);
    if (existing) {
      const [updated] = await db.update(vanishModeSettings).set({
        isEnabled: enabled,
        enabledById: enabled ? userId : existing.enabledById,
        enabledAt: enabled ? /* @__PURE__ */ new Date() : existing.enabledAt,
        disabledAt: enabled ? null : /* @__PURE__ */ new Date()
      }).where(eq4(vanishModeSettings.id, existing.id)).returning();
      return updated;
    }
    const [newSettings] = await db.insert(vanishModeSettings).values({
      conversationId,
      isEnabled: enabled,
      enabledById: enabled ? userId : null,
      enabledAt: enabled ? /* @__PURE__ */ new Date() : null
    }).returning();
    return newSettings;
  }
  // ============================================
  // SCHEDULED MESSAGES
  // ============================================
  async createScheduledMessage(senderId, conversationId, content, scheduledFor) {
    const [msg] = await db.insert(scheduledMessages).values({
      senderId,
      conversationId,
      content,
      scheduledFor
    }).returning();
    return msg;
  }
  async getScheduledMessages(userId) {
    return db.select().from(scheduledMessages).where(and3(eq4(scheduledMessages.senderId, userId), eq4(scheduledMessages.isCancelled, false))).orderBy(scheduledMessages.scheduledFor);
  }
  async cancelScheduledMessage(messageId) {
    await db.update(scheduledMessages).set({ isCancelled: true }).where(eq4(scheduledMessages.id, messageId));
  }
  async getPendingScheduledMessages(before) {
    return db.select().from(scheduledMessages).where(and3(eq4(scheduledMessages.isCancelled, false), lte3(scheduledMessages.scheduledFor, before))).orderBy(scheduledMessages.scheduledFor);
  }
  // ============================================
  // PINNED MESSAGES
  // ============================================
  async pinMessage(conversationId, messageId, pinnedBy) {
    const [pinned] = await db.insert(pinnedMessages).values({
      conversationId,
      messageId,
      pinnedById: pinnedBy
    }).returning();
    return pinned;
  }
  async unpinMessage(conversationId, messageId) {
    await db.delete(pinnedMessages).where(and3(eq4(pinnedMessages.conversationId, conversationId), eq4(pinnedMessages.messageId, messageId)));
  }
  async getPinnedMessages(conversationId) {
    return db.select().from(pinnedMessages).where(eq4(pinnedMessages.conversationId, conversationId)).orderBy(desc3(pinnedMessages.pinnedAt));
  }
  // ============================================
  // CHAT FOLDERS
  // ============================================
  async createChatFolder(userId, name, iconName) {
    const [folder] = await db.insert(chatFolders).values({
      userId,
      name,
      iconName
    }).returning();
    return folder;
  }
  async getUserChatFolders(userId) {
    return db.select().from(chatFolders).where(eq4(chatFolders.userId, userId)).orderBy(chatFolders.sortOrder);
  }
  async addConversationToFolder(folderId, conversationId) {
    await db.insert(chatFolderConversations).values({
      folderId,
      conversationId
    }).onConflictDoNothing();
  }
  async removeConversationFromFolder(folderId, conversationId) {
    await db.delete(chatFolderConversations).where(and3(eq4(chatFolderConversations.folderId, folderId), eq4(chatFolderConversations.conversationId, conversationId)));
  }
  async getConversationsInFolder(folderId) {
    const rows = await db.select({ conversationId: chatFolderConversations.conversationId }).from(chatFolderConversations).where(eq4(chatFolderConversations.folderId, folderId));
    return rows.map((r) => r.conversationId);
  }
  async deleteChatFolder(folderId) {
    await db.delete(chatFolderConversations).where(eq4(chatFolderConversations.folderId, folderId));
    await db.delete(chatFolders).where(eq4(chatFolders.id, folderId));
  }
  // ============================================
  // TWO-FACTOR AUTHENTICATION (2FA)
  // ============================================
  async createTotpSecret(userId, secret) {
    const [totp] = await db.insert(totpSecrets).values({
      userId,
      secret,
      isEnabled: false
    }).returning();
    return totp;
  }
  async getTotpSecret(userId) {
    const [totp] = await db.select().from(totpSecrets).where(eq4(totpSecrets.userId, userId)).limit(1);
    return totp;
  }
  async verifyTotp(userId) {
    await db.update(totpSecrets).set({ isEnabled: true, verifiedAt: /* @__PURE__ */ new Date() }).where(eq4(totpSecrets.userId, userId));
  }
  async deleteTotp(userId) {
    await db.delete(totpSecrets).where(eq4(totpSecrets.userId, userId));
  }
  async createBackupCodes(userId, codes) {
    const inserted = await db.insert(backupCodes).values(
      codes.map((code) => ({ userId, code }))
    ).returning();
    return inserted;
  }
  async getBackupCodes(userId) {
    return db.select().from(backupCodes).where(and3(eq4(backupCodes.userId, userId), sql5`${backupCodes.usedAt} IS NULL`));
  }
  async useBackupCode(userId, code) {
    const [existing] = await db.select().from(backupCodes).where(and3(eq4(backupCodes.userId, userId), eq4(backupCodes.code, code), sql5`${backupCodes.usedAt} IS NULL`)).limit(1);
    if (!existing) return false;
    await db.update(backupCodes).set({ usedAt: /* @__PURE__ */ new Date() }).where(eq4(backupCodes.id, existing.id));
    return true;
  }
  // ============================================
  // LINKED ACCOUNTS (Links multiple user accounts together)
  // ============================================
  async linkAccounts(primaryUserId, linkedUserId) {
    const [account] = await db.insert(linkedAccounts).values({
      primaryUserId,
      linkedUserId
    }).returning();
    return account;
  }
  async getLinkedAccounts(userId) {
    return db.select().from(linkedAccounts).where(eq4(linkedAccounts.primaryUserId, userId));
  }
  async unlinkAccount(primaryUserId, linkedUserId) {
    await db.delete(linkedAccounts).where(and3(eq4(linkedAccounts.primaryUserId, primaryUserId), eq4(linkedAccounts.linkedUserId, linkedUserId)));
  }
  async getLinkedAccountByUsers(primaryUserId, linkedUserId) {
    const [account] = await db.select().from(linkedAccounts).where(and3(eq4(linkedAccounts.primaryUserId, primaryUserId), eq4(linkedAccounts.linkedUserId, linkedUserId))).limit(1);
    return account;
  }
  // ============================================
  // HIDDEN WORDS
  // ============================================
  async addHiddenWord(userId, word) {
    const [hidden] = await db.insert(hiddenWords).values({
      userId,
      word: word.toLowerCase()
    }).returning();
    return hidden;
  }
  async getHiddenWords(userId) {
    return db.select().from(hiddenWords).where(eq4(hiddenWords.userId, userId));
  }
  async removeHiddenWord(wordId) {
    await db.delete(hiddenWords).where(eq4(hiddenWords.id, wordId));
  }
  // ============================================
  // POST THREADS
  // ============================================
  async createThread(userId, title) {
    const [thread] = await db.insert(postThreads).values({
      authorId: userId,
      title
    }).returning();
    return thread;
  }
  async addPostToThread(threadId, postId, position) {
    const [threadPost] = await db.insert(threadPosts).values({
      threadId,
      postId,
      position
    }).returning();
    return threadPost;
  }
  async getThread(threadId) {
    const [thread] = await db.select().from(postThreads).where(eq4(postThreads.id, threadId)).limit(1);
    if (!thread) return void 0;
    const posts3 = await db.select().from(threadPosts).where(eq4(threadPosts.threadId, threadId)).orderBy(threadPosts.position);
    return { ...thread, posts: posts3 };
  }
  async getUserThreads(userId) {
    return db.select().from(postThreads).where(eq4(postThreads.authorId, userId)).orderBy(desc3(postThreads.createdAt));
  }
  // ============================================
  // DUETS AND STITCHES
  // ============================================
  async createDuetStitch(type, originalPostId, newPostId) {
    const [duetStitch] = await db.insert(duetStitchPosts).values({
      type,
      originalPostId,
      postId: newPostId
    }).returning();
    return duetStitch;
  }
  async getDuetsForPost(postId) {
    return db.select().from(duetStitchPosts).where(and3(eq4(duetStitchPosts.originalPostId, postId), eq4(duetStitchPosts.type, "DUET")));
  }
  async getStitchesForPost(postId) {
    return db.select().from(duetStitchPosts).where(and3(eq4(duetStitchPosts.originalPostId, postId), eq4(duetStitchPosts.type, "STITCH")));
  }
  // ============================================
  // WEBHOOKS
  // ============================================
  async createWebhook(userId, url, events2, secret) {
    const [webhook] = await db.insert(webhooks).values({
      userId,
      url,
      events: events2,
      secret
    }).returning();
    return webhook;
  }
  async getUserWebhooks(userId) {
    return db.select().from(webhooks).where(eq4(webhooks.userId, userId));
  }
  async getWebhook(webhookId) {
    const [webhook] = await db.select().from(webhooks).where(eq4(webhooks.id, webhookId)).limit(1);
    return webhook;
  }
  async updateWebhook(webhookId, data) {
    const [updated] = await db.update(webhooks).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq4(webhooks.id, webhookId)).returning();
    return updated;
  }
  async deleteWebhook(webhookId) {
    await db.delete(webhookDeliveries).where(eq4(webhookDeliveries.webhookId, webhookId));
    await db.delete(webhooks).where(eq4(webhooks.id, webhookId));
  }
  async recordWebhookDelivery(webhookId, event, payload, responseStatus, responseBody) {
    const [delivery] = await db.insert(webhookDeliveries).values({
      webhookId,
      event,
      payload,
      responseStatus,
      responseBody,
      deliveredAt: /* @__PURE__ */ new Date()
    }).returning();
    return delivery;
  }
  async getWebhookDeliveries(webhookId, limit = 50) {
    return db.select().from(webhookDeliveries).where(eq4(webhookDeliveries.webhookId, webhookId)).orderBy(desc3(webhookDeliveries.deliveredAt)).limit(limit);
  }
  // ============================================
  // AR FILTERS
  // ============================================
  async getArFilters() {
    return db.select().from(arFilters).where(eq4(arFilters.isActive, true)).orderBy(desc3(arFilters.createdAt));
  }
  async createArFilter(name, category, thumbnailUrl, filterUrl, creatorId) {
    const [filter] = await db.insert(arFilters).values({
      name,
      category,
      thumbnailUrl,
      filterUrl,
      creatorId
    }).returning();
    return filter;
  }
  // ============================================
  // SECURITY CHECKUPS & ACCOUNT BACKUPS
  // ============================================
  async createSecurityCheckup(userId) {
    const [checkup] = await db.insert(securityCheckups).values({
      userId,
      passwordStrength: "UNKNOWN",
      twoFactorEnabled: false,
      recoveryEmailSet: false,
      loginAlertsEnabled: false,
      suspiciousActivityFound: false,
      recommendations: []
    }).returning();
    return checkup;
  }
  async getSecurityCheckup(userId) {
    const [checkup] = await db.select().from(securityCheckups).where(eq4(securityCheckups.userId, userId)).orderBy(desc3(securityCheckups.checkupDate)).limit(1);
    return checkup;
  }
  async updateSecurityCheckup(checkupId, data) {
    const [updated] = await db.update(securityCheckups).set(data).where(eq4(securityCheckups.id, checkupId)).returning();
    return updated;
  }
  async requestAccountBackup(userId, backupType = "FULL") {
    const [backup] = await db.insert(accountBackups).values({
      userId,
      backupType,
      status: "PENDING"
    }).returning();
    return backup;
  }
  async getAccountBackup(userId) {
    const [backup] = await db.select().from(accountBackups).where(eq4(accountBackups.userId, userId)).orderBy(desc3(accountBackups.createdAt)).limit(1);
    return backup;
  }
  async updateAccountBackup(backupId, status, downloadUrl) {
    const [updated] = await db.update(accountBackups).set({
      status,
      downloadUrl,
      completedAt: status === "COMPLETED" ? /* @__PURE__ */ new Date() : void 0,
      expiresAt: status === "COMPLETED" ? new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3) : void 0
    }).where(eq4(accountBackups.id, backupId)).returning();
    return updated;
  }
  // ============================================
  // LOGIN SESSIONS
  // ============================================
  async getLoginSessions(userId) {
    return db.select().from(loginSessions).where(eq4(loginSessions.userId, userId)).orderBy(desc3(loginSessions.lastActiveAt));
  }
  async createLoginSession(userId, sessionToken, deviceName, ipAddress, location) {
    const [session2] = await db.insert(loginSessions).values({
      userId,
      sessionToken,
      deviceName,
      ipAddress,
      location,
      isActive: true,
      lastActiveAt: /* @__PURE__ */ new Date()
    }).returning();
    return session2;
  }
  async updateLoginSession(sessionId) {
    const [updated] = await db.update(loginSessions).set({ lastActiveAt: /* @__PURE__ */ new Date() }).where(eq4(loginSessions.id, sessionId)).returning();
    return updated;
  }
  async deactivateLoginSession(userId, sessionId) {
    const result = await db.update(loginSessions).set({ isActive: false }).where(and3(eq4(loginSessions.id, sessionId), eq4(loginSessions.userId, userId)));
    return true;
  }
  async deactivateAllLoginSessions(userId, exceptSessionId) {
    if (exceptSessionId) {
      await db.update(loginSessions).set({ isActive: false }).where(and3(eq4(loginSessions.userId, userId), ne2(loginSessions.id, exceptSessionId)));
    } else {
      await db.update(loginSessions).set({ isActive: false }).where(eq4(loginSessions.userId, userId));
    }
    return true;
  }
  // ============================================
  // TRUSTED DEVICES
  // ============================================
  async getTrustedDevices(userId) {
    return db.select().from(trustedDevices).where(eq4(trustedDevices.userId, userId)).orderBy(desc3(trustedDevices.lastUsedAt));
  }
  async addTrustedDevice(userId, deviceId, deviceName, deviceType) {
    const [device] = await db.insert(trustedDevices).values({
      userId,
      deviceId,
      deviceName,
      deviceType,
      lastUsedAt: /* @__PURE__ */ new Date()
    }).returning();
    return device;
  }
  async removeTrustedDevice(userId, deviceRecordId) {
    await db.delete(trustedDevices).where(and3(eq4(trustedDevices.id, deviceRecordId), eq4(trustedDevices.userId, userId)));
    return true;
  }
  async isTrustedDevice(userId, deviceId) {
    const [device] = await db.select().from(trustedDevices).where(and3(eq4(trustedDevices.userId, userId), eq4(trustedDevices.deviceId, deviceId))).limit(1);
    return !!device;
  }
  async updateTrustedDeviceLastUsed(userId, deviceId) {
    await db.update(trustedDevices).set({ lastUsedAt: /* @__PURE__ */ new Date() }).where(and3(eq4(trustedDevices.userId, userId), eq4(trustedDevices.deviceId, deviceId)));
  }
};
var advancedStorage = new AdvancedStorage();

// server/routes-advanced.ts
init_storage();

// server/services/push-notifications.ts
init_db();
init_schema();
import { eq as eq5, and as and4, inArray as inArray4 } from "drizzle-orm";
var EXPO_PUSH_API = "https://exp.host/--/api/v2/push/send";
async function sendToExpo(messages4) {
  if (messages4.length === 0) return [];
  const chunks = [];
  const chunkSize = 100;
  for (let i = 0; i < messages4.length; i += chunkSize) {
    chunks.push(messages4.slice(i, i + chunkSize));
  }
  const tickets = [];
  for (const chunk of chunks) {
    try {
      const response = await fetch(EXPO_PUSH_API, {
        method: "POST",
        headers: {
          "Accept": "application/json",
          "Accept-Encoding": "gzip, deflate",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(chunk)
      });
      const result = await response.json();
      if (result.data) {
        tickets.push(...result.data);
      }
    } catch (error) {
      console.error("[Push] Failed to send to Expo:", error);
    }
  }
  return tickets;
}
async function handlePushReceipts(tickets, tokens) {
  for (let i = 0; i < tickets.length; i++) {
    const ticket = tickets[i];
    const token = tokens[i];
    if (ticket.status === "error") {
      console.error(`[Push] Error for token ${token}:`, ticket.message);
      if (ticket.details?.error === "DeviceNotRegistered" || ticket.details?.error === "InvalidCredentials") {
        await db.update(pushTokens).set({ isActive: false }).where(eq5(pushTokens.token, token));
        console.log(`[Push] Deactivated invalid token: ${token}`);
      }
    }
  }
}
async function getUserPushTokens(userId) {
  const tokens = await db.select({ token: pushTokens.token }).from(pushTokens).where(and4(
    eq5(pushTokens.userId, userId),
    eq5(pushTokens.isActive, true)
  ));
  return tokens.map((t) => t.token);
}
async function checkUserNotificationSettings(userId, type) {
  const settings = await db.select().from(userSettings).where(eq5(userSettings.userId, userId)).limit(1);
  if (settings.length === 0) return true;
  const pushPrefs = settings[0].pushNotifications;
  if (!pushPrefs) return true;
  switch (type) {
    case "FOLLOW":
      return pushPrefs.follows !== false && pushPrefs.newFollowers !== false;
    case "LIKE":
      return pushPrefs.likes !== false;
    case "COMMENT":
      return pushPrefs.comments !== false;
    case "MESSAGE":
      return pushPrefs.messages !== false;
    case "MENTION":
      return pushPrefs.mentions !== false;
    case "STORY_LIKE":
      return pushPrefs.storyViews !== false;
    case "STORY_REPLY":
      return pushPrefs.storyViews !== false;
    default:
      return true;
  }
}
var pushNotificationService = {
  async registerToken(userId, token, platform, deviceId, deviceName) {
    const existing = await db.select().from(pushTokens).where(eq5(pushTokens.token, token)).limit(1);
    if (existing.length > 0) {
      await db.update(pushTokens).set({
        userId,
        isActive: true,
        lastUsedAt: /* @__PURE__ */ new Date(),
        platform: platform || existing[0].platform,
        deviceId: deviceId || existing[0].deviceId,
        deviceName: deviceName || existing[0].deviceName
      }).where(eq5(pushTokens.token, token));
      return existing[0];
    }
    const [newToken] = await db.insert(pushTokens).values({
      userId,
      token,
      platform,
      deviceId,
      deviceName
    }).returning();
    console.log(`[Push] Registered new token for user ${userId}`);
    return newToken;
  },
  async unregisterToken(token) {
    await db.update(pushTokens).set({ isActive: false }).where(eq5(pushTokens.token, token));
    console.log(`[Push] Unregistered token: ${token}`);
  },
  async unregisterAllUserTokens(userId) {
    await db.update(pushTokens).set({ isActive: false }).where(eq5(pushTokens.userId, userId));
  },
  async sendToUser(userId, payload, notificationType) {
    if (notificationType) {
      const enabled = await checkUserNotificationSettings(userId, notificationType);
      if (!enabled) {
        console.log(`[Push] Notification type ${notificationType} disabled for user ${userId}`);
        return;
      }
    }
    const tokens = await getUserPushTokens(userId);
    if (tokens.length === 0) {
      return;
    }
    const messages4 = tokens.map((token) => ({
      to: token,
      title: payload.title,
      body: payload.body,
      data: payload.data,
      sound: payload.sound || "default",
      priority: payload.priority || "high",
      channelId: payload.channelId,
      categoryId: payload.categoryId
    }));
    const tickets = await sendToExpo(messages4);
    await handlePushReceipts(tickets, tokens);
  },
  async sendToMultipleUsers(userIds, payload, notificationType) {
    if (userIds.length === 0) return;
    const tokens = await db.select({ token: pushTokens.token, userId: pushTokens.userId }).from(pushTokens).where(and4(
      inArray4(pushTokens.userId, userIds),
      eq5(pushTokens.isActive, true)
    ));
    if (tokens.length === 0) return;
    const enabledUserIds = /* @__PURE__ */ new Set();
    for (const userId of new Set(tokens.map((t) => t.userId))) {
      if (notificationType) {
        const enabled = await checkUserNotificationSettings(userId, notificationType);
        if (enabled) enabledUserIds.add(userId);
      } else {
        enabledUserIds.add(userId);
      }
    }
    const filteredTokens = tokens.filter((t) => enabledUserIds.has(t.userId));
    if (filteredTokens.length === 0) return;
    const messages4 = filteredTokens.map((t) => ({
      to: t.token,
      title: payload.title,
      body: payload.body,
      data: payload.data,
      sound: payload.sound || "default",
      priority: payload.priority || "high"
    }));
    const tickets = await sendToExpo(messages4);
    await handlePushReceipts(tickets, filteredTokens.map((t) => t.token));
  },
  async notifyNewFollower(followedUserId, followerUsername, followerDisplayName, followerAvatarUrl) {
    await this.sendToUser(followedUserId, {
      title: "New Follower",
      body: `${followerDisplayName} (@${followerUsername}) started following you`,
      data: {
        type: "FOLLOW",
        screen: "Profile",
        params: { username: followerUsername }
      }
    }, "FOLLOW");
  },
  async notifyLike(postAuthorId, likerUsername, likerDisplayName, postId) {
    await this.sendToUser(postAuthorId, {
      title: "New Like",
      body: `${likerDisplayName} liked your post`,
      data: {
        type: "LIKE",
        screen: "Post",
        params: { postId }
      }
    }, "LIKE");
  },
  async notifyComment(postAuthorId, commenterUsername, commenterDisplayName, postId, commentPreview) {
    const preview = commentPreview.length > 50 ? commentPreview.slice(0, 47) + "..." : commentPreview;
    await this.sendToUser(postAuthorId, {
      title: `${commenterDisplayName} commented`,
      body: preview,
      data: {
        type: "COMMENT",
        screen: "Post",
        params: { postId }
      }
    }, "COMMENT");
  },
  async notifyMessage(recipientId, senderUsername, senderDisplayName, conversationId, messagePreview) {
    const preview = messagePreview.length > 50 ? messagePreview.slice(0, 47) + "..." : messagePreview;
    await this.sendToUser(recipientId, {
      title: senderDisplayName,
      body: preview,
      data: {
        type: "MESSAGE",
        screen: "Chat",
        params: { conversationId }
      }
    }, "MESSAGE");
  },
  async notifyMention(mentionedUserId, mentionerUsername, mentionerDisplayName, postId) {
    await this.sendToUser(mentionedUserId, {
      title: "You were mentioned",
      body: `${mentionerDisplayName} mentioned you in a post`,
      data: {
        type: "MENTION",
        screen: "Post",
        params: { postId }
      }
    }, "MENTION");
  },
  async notifyStoryLike(storyAuthorId, likerDisplayName, storyId) {
    await this.sendToUser(storyAuthorId, {
      title: "Story Reaction",
      body: `${likerDisplayName} liked your story`,
      data: {
        type: "STORY_LIKE",
        screen: "Story",
        params: { storyId }
      }
    }, "STORY_LIKE");
  },
  async notifyStoryReply(storyAuthorId, replierDisplayName, storyId, replyPreview) {
    const preview = replyPreview.length > 50 ? replyPreview.slice(0, 47) + "..." : replyPreview;
    await this.sendToUser(storyAuthorId, {
      title: `${replierDisplayName} replied to your story`,
      body: preview,
      data: {
        type: "STORY_REPLY",
        screen: "Story",
        params: { storyId }
      }
    }, "STORY_REPLY");
  },
  async getUserTokens(userId) {
    return db.select().from(pushTokens).where(eq5(pushTokens.userId, userId));
  }
};

// server/routes-advanced.ts
function requireAuth(req, res, next) {
  if (!req.session.userId) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  next();
}
function registerAdvancedRoutes(app2) {
  app2.get("/api/wallet", requireAuth, async (req, res) => {
    try {
      const wallet = await advancedStorage.getOrCreateWallet(req.session.userId);
      res.json(wallet);
    } catch (error) {
      console.error("Get wallet error:", error);
      res.status(500).json({ message: "Failed to get wallet" });
    }
  });
  app2.get("/api/wallet/transactions", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const transactions = await advancedStorage.getCoinTransactions(req.session.userId, limit);
      res.json(transactions);
    } catch (error) {
      console.error("Get transactions error:", error);
      res.status(500).json({ message: "Failed to get transactions" });
    }
  });
  app2.post("/api/wallet/add-coins", requireAuth, async (req, res) => {
    try {
      const { amount, type, description } = req.body;
      if (!amount || amount <= 0) {
        return res.status(400).json({ message: "Invalid amount" });
      }
      const transaction = await advancedStorage.addCoins(
        req.session.userId,
        amount,
        type || "PURCHASE",
        description
      );
      res.json(transaction);
    } catch (error) {
      console.error("Add coins error:", error);
      res.status(500).json({ message: "Failed to add coins" });
    }
  });
  app2.get("/api/gifts/types", async (req, res) => {
    try {
      const category = req.query.category;
      const giftTypes2 = await advancedStorage.getGiftTypes(category);
      res.json(giftTypes2);
    } catch (error) {
      console.error("Get gift types error:", error);
      res.status(500).json({ message: "Failed to get gift types" });
    }
  });
  app2.post("/api/gifts/send", requireAuth, async (req, res) => {
    try {
      const { recipientId, giftTypeId, quantity, contextType, contextId, message } = req.body;
      if (!recipientId || !giftTypeId) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      const transaction = await advancedStorage.sendGift(
        req.session.userId,
        recipientId,
        giftTypeId,
        quantity || 1,
        contextType,
        contextId,
        message
      );
      if (!transaction) {
        return res.status(400).json({ message: "Insufficient coins or invalid gift type" });
      }
      const sender = await storage.getUser(req.session.userId);
      pushNotificationService.sendToUser(recipientId, {
        title: "Gift Received!",
        body: `${sender?.displayName || sender?.username || "Someone"} sent you ${transaction.quantity} gift(s)`,
        data: { type: "gift_received", transactionId: transaction.id }
      });
      res.json(transaction);
    } catch (error) {
      console.error("Send gift error:", error);
      res.status(500).json({ message: "Failed to send gift" });
    }
  });
  app2.get("/api/gifts/received", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const gifts = await advancedStorage.getReceivedGifts(req.session.userId, limit);
      res.json(gifts);
    } catch (error) {
      console.error("Get received gifts error:", error);
      res.status(500).json({ message: "Failed to get received gifts" });
    }
  });
  app2.post("/api/live-streams", requireAuth, async (req, res) => {
    try {
      const { title, description } = req.body;
      const stream = await advancedStorage.createLiveStream(req.session.userId, title, description);
      res.json(stream);
    } catch (error) {
      console.error("Create live stream error:", error);
      res.status(500).json({ message: "Failed to create live stream" });
    }
  });
  app2.get("/api/live-streams", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 20;
      const streams = await advancedStorage.getActiveLiveStreams(limit);
      res.json(streams);
    } catch (error) {
      console.error("Get live streams error:", error);
      res.status(500).json({ message: "Failed to get live streams" });
    }
  });
  app2.get("/api/live-streams/:id", async (req, res) => {
    try {
      const stream = await advancedStorage.getLiveStream(req.params.id);
      if (!stream) {
        return res.status(404).json({ message: "Stream not found" });
      }
      res.json(stream);
    } catch (error) {
      console.error("Get live stream error:", error);
      res.status(500).json({ message: "Failed to get live stream" });
    }
  });
  app2.post("/api/live-streams/:id/start", requireAuth, async (req, res) => {
    try {
      const stream = await advancedStorage.getLiveStream(req.params.id);
      if (!stream || stream.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const updated = await advancedStorage.startLiveStream(req.params.id);
      const followers = await storage.getFollowers(req.session.userId);
      const host = await storage.getUser(req.session.userId);
      for (const follower of followers) {
        pushNotificationService.sendToUser(follower.id, {
          title: "Live Now!",
          body: `${host?.displayName || host?.username || "Someone"} started a live stream`,
          data: { type: "live_stream", streamId: req.params.id }
        });
      }
      res.json(updated);
    } catch (error) {
      console.error("Start live stream error:", error);
      res.status(500).json({ message: "Failed to start live stream" });
    }
  });
  app2.post("/api/live-streams/:id/end", requireAuth, async (req, res) => {
    try {
      const stream = await advancedStorage.getLiveStream(req.params.id);
      if (!stream || stream.hostId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const saveToProfile = req.body.saveToProfile || false;
      const updated = await advancedStorage.endLiveStream(req.params.id, saveToProfile);
      res.json(updated);
    } catch (error) {
      console.error("End live stream error:", error);
      res.status(500).json({ message: "Failed to end live stream" });
    }
  });
  app2.post("/api/live-streams/:id/join", requireAuth, async (req, res) => {
    try {
      const viewer = await advancedStorage.joinLiveStream(req.params.id, req.session.userId);
      res.json(viewer);
    } catch (error) {
      console.error("Join live stream error:", error);
      res.status(500).json({ message: "Failed to join live stream" });
    }
  });
  app2.post("/api/live-streams/:id/leave", requireAuth, async (req, res) => {
    try {
      await advancedStorage.leaveLiveStream(req.params.id, req.session.userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Leave live stream error:", error);
      res.status(500).json({ message: "Failed to leave live stream" });
    }
  });
  app2.post("/api/live-streams/:id/comments", requireAuth, async (req, res) => {
    try {
      const { content } = req.body;
      if (!content) {
        return res.status(400).json({ message: "Content required" });
      }
      const comment = await advancedStorage.addLiveStreamComment(req.params.id, req.session.userId, content);
      res.json(comment);
    } catch (error) {
      console.error("Add live stream comment error:", error);
      res.status(500).json({ message: "Failed to add comment" });
    }
  });
  app2.get("/api/live-streams/:id/comments", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 100;
      const comments3 = await advancedStorage.getLiveStreamComments(req.params.id, limit);
      res.json(comments3);
    } catch (error) {
      console.error("Get live stream comments error:", error);
      res.status(500).json({ message: "Failed to get comments" });
    }
  });
  app2.post("/api/live-streams/:id/reactions", requireAuth, async (req, res) => {
    try {
      const { reactionType } = req.body;
      const reaction = await advancedStorage.addLiveStreamReaction(req.params.id, req.session.userId, reactionType || "HEART");
      res.json(reaction);
    } catch (error) {
      console.error("Add live stream reaction error:", error);
      res.status(500).json({ message: "Failed to add reaction" });
    }
  });
  app2.post("/api/groups", requireAuth, async (req, res) => {
    try {
      const { name, description, privacy, netWorthRequirement } = req.body;
      if (!name) {
        return res.status(400).json({ message: "Name required" });
      }
      const group = await advancedStorage.createGroup(
        req.session.userId,
        name,
        description,
        privacy || "PUBLIC",
        netWorthRequirement
      );
      res.json(group);
    } catch (error) {
      console.error("Create group error:", error);
      res.status(500).json({ message: "Failed to create group" });
    }
  });
  app2.get("/api/groups", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 20;
      const groups2 = await advancedStorage.getPublicGroups(limit);
      res.json(groups2);
    } catch (error) {
      console.error("Get groups error:", error);
      res.status(500).json({ message: "Failed to get groups" });
    }
  });
  app2.get("/api/groups/my", requireAuth, async (req, res) => {
    try {
      const groups2 = await advancedStorage.getUserGroups(req.session.userId);
      res.json(groups2);
    } catch (error) {
      console.error("Get my groups error:", error);
      res.status(500).json({ message: "Failed to get groups" });
    }
  });
  app2.get("/api/groups/:id", async (req, res) => {
    try {
      const group = await advancedStorage.getGroup(req.params.id);
      if (!group) {
        return res.status(404).json({ message: "Group not found" });
      }
      res.json(group);
    } catch (error) {
      console.error("Get group error:", error);
      res.status(500).json({ message: "Failed to get group" });
    }
  });
  app2.get("/api/groups/:id/members", async (req, res) => {
    try {
      const members = await advancedStorage.getGroupMembers(req.params.id);
      res.json(members);
    } catch (error) {
      console.error("Get group members error:", error);
      res.status(500).json({ message: "Failed to get members" });
    }
  });
  app2.post("/api/groups/:id/join", requireAuth, async (req, res) => {
    try {
      const result = await advancedStorage.joinGroup(req.params.id, req.session.userId);
      if (!result) {
        return res.status(400).json({ message: "Cannot join group" });
      }
      res.json(result);
    } catch (error) {
      console.error("Join group error:", error);
      res.status(500).json({ message: "Failed to join group" });
    }
  });
  app2.post("/api/groups/:id/leave", requireAuth, async (req, res) => {
    try {
      await advancedStorage.leaveGroup(req.params.id, req.session.userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Leave group error:", error);
      res.status(500).json({ message: "Failed to leave group" });
    }
  });
  app2.post("/api/events", requireAuth, async (req, res) => {
    try {
      const event = await advancedStorage.createEvent(req.session.userId, req.body);
      res.json(event);
    } catch (error) {
      console.error("Create event error:", error);
      res.status(500).json({ message: "Failed to create event" });
    }
  });
  app2.get("/api/events", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 20;
      const events2 = await advancedStorage.getUpcomingEvents(limit);
      res.json(events2);
    } catch (error) {
      console.error("Get events error:", error);
      res.status(500).json({ message: "Failed to get events" });
    }
  });
  app2.get("/api/events/:id", async (req, res) => {
    try {
      const event = await advancedStorage.getEvent(req.params.id);
      if (!event) {
        return res.status(404).json({ message: "Event not found" });
      }
      res.json(event);
    } catch (error) {
      console.error("Get event error:", error);
      res.status(500).json({ message: "Failed to get event" });
    }
  });
  app2.post("/api/events/:id/rsvp", requireAuth, async (req, res) => {
    try {
      const { status } = req.body;
      if (!["GOING", "INTERESTED", "NOT_GOING"].includes(status)) {
        return res.status(400).json({ message: "Invalid RSVP status" });
      }
      const rsvp = await advancedStorage.rsvpEvent(req.params.id, req.session.userId, status);
      res.json(rsvp);
    } catch (error) {
      console.error("RSVP event error:", error);
      res.status(500).json({ message: "Failed to RSVP" });
    }
  });
  app2.get("/api/subscriptions/tiers/:creatorId", async (req, res) => {
    try {
      const tiers = await advancedStorage.getCreatorSubscriptionTiers(req.params.creatorId);
      res.json(tiers);
    } catch (error) {
      console.error("Get subscription tiers error:", error);
      res.status(500).json({ message: "Failed to get tiers" });
    }
  });
  app2.post("/api/subscriptions/tiers", requireAuth, async (req, res) => {
    try {
      const { name, monthlyPriceCoins, description, benefits } = req.body;
      if (!name || !monthlyPriceCoins) {
        return res.status(400).json({ message: "Name and price required" });
      }
      const tier = await advancedStorage.createSubscriptionTier(
        req.session.userId,
        name,
        monthlyPriceCoins,
        description,
        benefits
      );
      res.json(tier);
    } catch (error) {
      console.error("Create subscription tier error:", error);
      res.status(500).json({ message: "Failed to create tier" });
    }
  });
  app2.post("/api/subscriptions/subscribe", requireAuth, async (req, res) => {
    try {
      const { creatorId, tierId } = req.body;
      if (!creatorId || !tierId) {
        return res.status(400).json({ message: "Creator and tier required" });
      }
      const subscription = await advancedStorage.subscribe(req.session.userId, creatorId, tierId);
      if (!subscription) {
        return res.status(400).json({ message: "Insufficient coins or invalid tier" });
      }
      res.json(subscription);
    } catch (error) {
      console.error("Subscribe error:", error);
      res.status(500).json({ message: "Failed to subscribe" });
    }
  });
  app2.get("/api/subscriptions/check/:creatorId", requireAuth, async (req, res) => {
    try {
      const isSubscribed = await advancedStorage.isSubscribed(req.session.userId, req.params.creatorId);
      res.json({ isSubscribed });
    } catch (error) {
      console.error("Check subscription error:", error);
      res.status(500).json({ message: "Failed to check subscription" });
    }
  });
  app2.post("/api/broadcast-channels", requireAuth, async (req, res) => {
    try {
      const { name, description } = req.body;
      if (!name) {
        return res.status(400).json({ message: "Name required" });
      }
      const channel = await advancedStorage.createBroadcastChannel(req.session.userId, name, description);
      res.json(channel);
    } catch (error) {
      console.error("Create broadcast channel error:", error);
      res.status(500).json({ message: "Failed to create channel" });
    }
  });
  app2.get("/api/broadcast-channels/:id", async (req, res) => {
    try {
      const channel = await advancedStorage.getBroadcastChannel(req.params.id);
      if (!channel) {
        return res.status(404).json({ message: "Channel not found" });
      }
      res.json(channel);
    } catch (error) {
      console.error("Get broadcast channel error:", error);
      res.status(500).json({ message: "Failed to get channel" });
    }
  });
  app2.post("/api/broadcast-channels/:id/subscribe", requireAuth, async (req, res) => {
    try {
      const subscriber = await advancedStorage.subscribeToBroadcastChannel(req.params.id, req.session.userId);
      res.json(subscriber);
    } catch (error) {
      console.error("Subscribe to channel error:", error);
      res.status(500).json({ message: "Failed to subscribe" });
    }
  });
  app2.post("/api/broadcast-channels/:id/messages", requireAuth, async (req, res) => {
    try {
      const channel = await advancedStorage.getBroadcastChannel(req.params.id);
      if (!channel || channel.ownerId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const { content, mediaUrl, mediaType } = req.body;
      const message = await advancedStorage.sendBroadcastMessage(req.params.id, content, mediaUrl, mediaType);
      res.json(message);
    } catch (error) {
      console.error("Send broadcast message error:", error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });
  app2.get("/api/broadcast-channels/:id/messages", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const messages4 = await advancedStorage.getBroadcastMessages(req.params.id, limit);
      res.json(messages4);
    } catch (error) {
      console.error("Get broadcast messages error:", error);
      res.status(500).json({ message: "Failed to get messages" });
    }
  });
  app2.post("/api/posts/:id/reactions", requireAuth, async (req, res) => {
    try {
      const { reactionType } = req.body;
      if (!["LIKE", "LOVE", "HAHA", "WOW", "SAD", "ANGRY", "FIRE", "DIAMOND", "CROWN"].includes(reactionType)) {
        return res.status(400).json({ message: "Invalid reaction type" });
      }
      const reaction = await advancedStorage.addPostReaction(req.params.id, req.session.userId, reactionType);
      res.json(reaction);
    } catch (error) {
      console.error("Add post reaction error:", error);
      res.status(500).json({ message: "Failed to add reaction" });
    }
  });
  app2.delete("/api/posts/:id/reactions", requireAuth, async (req, res) => {
    try {
      await advancedStorage.removePostReaction(req.params.id, req.session.userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Remove post reaction error:", error);
      res.status(500).json({ message: "Failed to remove reaction" });
    }
  });
  app2.get("/api/posts/:id/reactions", async (req, res) => {
    try {
      const reactions = await advancedStorage.getPostReactions(req.params.id);
      res.json(reactions);
    } catch (error) {
      console.error("Get post reactions error:", error);
      res.status(500).json({ message: "Failed to get reactions" });
    }
  });
  app2.put("/api/location", requireAuth, async (req, res) => {
    try {
      const { latitude, longitude, locationName } = req.body;
      if (typeof latitude !== "number" || typeof longitude !== "number") {
        return res.status(400).json({ message: "Invalid coordinates" });
      }
      const location = await advancedStorage.updateUserLocation(req.session.userId, latitude, longitude, locationName);
      res.json(location);
    } catch (error) {
      console.error("Update location error:", error);
      res.status(500).json({ message: "Failed to update location" });
    }
  });
  app2.put("/api/location/sharing", requireAuth, async (req, res) => {
    try {
      const { isSharing, sharingMode, expiresAt } = req.body;
      const location = await advancedStorage.setLocationSharing(
        req.session.userId,
        isSharing,
        sharingMode,
        expiresAt ? new Date(expiresAt) : void 0
      );
      res.json(location);
    } catch (error) {
      console.error("Set location sharing error:", error);
      res.status(500).json({ message: "Failed to update sharing" });
    }
  });
  app2.get("/api/location/nearby", requireAuth, async (req, res) => {
    try {
      const radiusKm = parseFloat(req.query.radius) || 10;
      const nearbyUsers = await advancedStorage.getNearbyUsers(req.session.userId, radiusKm);
      res.json(nearbyUsers);
    } catch (error) {
      console.error("Get nearby users error:", error);
      res.status(500).json({ message: "Failed to get nearby users" });
    }
  });
  app2.get("/api/venues/search", async (req, res) => {
    try {
      const query = req.query.q;
      if (!query) {
        return res.status(400).json({ message: "Search query required" });
      }
      const venues2 = await advancedStorage.searchVenues(query);
      res.json(venues2);
    } catch (error) {
      console.error("Search venues error:", error);
      res.status(500).json({ message: "Failed to search venues" });
    }
  });
  app2.post("/api/venues", requireAuth, async (req, res) => {
    try {
      const { name, category, address, city, country, latitude, longitude } = req.body;
      if (!name) {
        return res.status(400).json({ message: "Name required" });
      }
      const venue = await advancedStorage.createVenue(name, category, address, city, country, latitude, longitude);
      res.json(venue);
    } catch (error) {
      console.error("Create venue error:", error);
      res.status(500).json({ message: "Failed to create venue" });
    }
  });
  app2.post("/api/check-ins", requireAuth, async (req, res) => {
    try {
      const { venueId, customLocationName, latitude, longitude, postId, caption } = req.body;
      const checkIn = await advancedStorage.checkIn(
        req.session.userId,
        venueId,
        customLocationName,
        latitude,
        longitude,
        postId,
        caption
      );
      res.json(checkIn);
    } catch (error) {
      console.error("Check-in error:", error);
      res.status(500).json({ message: "Failed to check in" });
    }
  });
  app2.get("/api/check-ins/my", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 20;
      const checkIns2 = await advancedStorage.getUserCheckIns(req.session.userId, limit);
      res.json(checkIns2);
    } catch (error) {
      console.error("Get check-ins error:", error);
      res.status(500).json({ message: "Failed to get check-ins" });
    }
  });
  app2.post("/api/group-conversations", requireAuth, async (req, res) => {
    try {
      const { name, memberIds } = req.body;
      const conversation = await advancedStorage.createGroupConversation(
        req.session.userId,
        name,
        memberIds || []
      );
      res.json(conversation);
    } catch (error) {
      console.error("Create group conversation error:", error);
      res.status(500).json({ message: "Failed to create conversation" });
    }
  });
  app2.get("/api/group-conversations", requireAuth, async (req, res) => {
    try {
      const conversations3 = await advancedStorage.getUserGroupConversations(req.session.userId);
      res.json(conversations3);
    } catch (error) {
      console.error("Get group conversations error:", error);
      res.status(500).json({ message: "Failed to get conversations" });
    }
  });
  app2.get("/api/group-conversations/:id/messages", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const messages4 = await advancedStorage.getGroupMessages(req.params.id, limit);
      res.json(messages4);
    } catch (error) {
      console.error("Get group messages error:", error);
      res.status(500).json({ message: "Failed to get messages" });
    }
  });
  app2.post("/api/group-conversations/:id/messages", requireAuth, async (req, res) => {
    try {
      const { content, messageType, mediaUrl } = req.body;
      const message = await advancedStorage.sendGroupMessage(
        req.params.id,
        req.session.userId,
        content,
        messageType,
        mediaUrl
      );
      res.json(message);
    } catch (error) {
      console.error("Send group message error:", error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });
  app2.post("/api/calls/initiate", requireAuth, async (req, res) => {
    try {
      const { calleeId, callType } = req.body;
      if (!calleeId) {
        return res.status(400).json({ message: "Callee required" });
      }
      const call = await advancedStorage.initiateCall(req.session.userId, calleeId, callType || "VIDEO");
      const caller = await storage.getUser(req.session.userId);
      pushNotificationService.sendToUser(calleeId, {
        title: "Incoming Call",
        body: `${caller?.displayName || caller?.username || "Someone"} is calling you`,
        data: { type: "incoming_call", callId: call.id, callType: callType || "VIDEO" }
      });
      res.json(call);
    } catch (error) {
      console.error("Initiate call error:", error);
      res.status(500).json({ message: "Failed to initiate call" });
    }
  });
  app2.post("/api/calls/:id/answer", requireAuth, async (req, res) => {
    try {
      const call = await advancedStorage.answerCall(req.params.id);
      res.json(call);
    } catch (error) {
      console.error("Answer call error:", error);
      res.status(500).json({ message: "Failed to answer call" });
    }
  });
  app2.post("/api/calls/:id/end", requireAuth, async (req, res) => {
    try {
      const { status } = req.body;
      const call = await advancedStorage.endCall(req.params.id, status || "ENDED");
      res.json(call);
    } catch (error) {
      console.error("End call error:", error);
      res.status(500).json({ message: "Failed to end call" });
    }
  });
  app2.get("/api/calls/history", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const calls = await advancedStorage.getUserCallHistory(req.session.userId, limit);
      res.json(calls);
    } catch (error) {
      console.error("Get call history error:", error);
      res.status(500).json({ message: "Failed to get call history" });
    }
  });
  app2.get("/api/admin/feature-flags", requireAuth, async (req, res) => {
    try {
      const flags = await advancedStorage.getAllFeatureFlags();
      res.json(flags);
    } catch (error) {
      console.error("Get feature flags error:", error);
      res.status(500).json({ message: "Failed to get feature flags" });
    }
  });
  app2.post("/api/admin/feature-flags", requireAuth, async (req, res) => {
    try {
      const { key, name, description } = req.body;
      if (!key || !name) {
        return res.status(400).json({ message: "Key and name required" });
      }
      const flag = await advancedStorage.createFeatureFlag(key, name, description);
      res.json(flag);
    } catch (error) {
      console.error("Create feature flag error:", error);
      res.status(500).json({ message: "Failed to create feature flag" });
    }
  });
  app2.put("/api/admin/feature-flags/:key", requireAuth, async (req, res) => {
    try {
      const flag = await advancedStorage.updateFeatureFlag(req.params.key, req.body);
      res.json(flag);
    } catch (error) {
      console.error("Update feature flag error:", error);
      res.status(500).json({ message: "Failed to update feature flag" });
    }
  });
  app2.get("/api/feature-flags/:key/enabled", async (req, res) => {
    try {
      const userId = req.session.userId;
      const enabled = await advancedStorage.isFeatureEnabled(req.params.key, userId);
      res.json({ enabled });
    } catch (error) {
      console.error("Check feature flag error:", error);
      res.status(500).json({ message: "Failed to check feature flag" });
    }
  });
  app2.get("/api/hashtags/trending", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 20;
      const hashtags2 = await advancedStorage.getTrendingHashtags(limit);
      res.json(hashtags2);
    } catch (error) {
      console.error("Get trending hashtags error:", error);
      res.status(500).json({ message: "Failed to get hashtags" });
    }
  });
  app2.get("/api/hashtags/search", async (req, res) => {
    try {
      const query = req.query.q;
      if (!query) {
        return res.status(400).json({ message: "Search query required" });
      }
      const hashtags2 = await advancedStorage.searchHashtags(query);
      res.json(hashtags2);
    } catch (error) {
      console.error("Search hashtags error:", error);
      res.status(500).json({ message: "Failed to search hashtags" });
    }
  });
  app2.post("/api/usage-stats", requireAuth, async (req, res) => {
    try {
      const stat = await advancedStorage.recordUsageStat(req.session.userId, req.body);
      res.json(stat);
    } catch (error) {
      console.error("Record usage stat error:", error);
      res.status(500).json({ message: "Failed to record stat" });
    }
  });
  app2.get("/api/usage-stats", requireAuth, async (req, res) => {
    try {
      const days = parseInt(req.query.days) || 7;
      const stats = await advancedStorage.getUserUsageStats(req.session.userId, days);
      res.json(stats);
    } catch (error) {
      console.error("Get usage stats error:", error);
      res.status(500).json({ message: "Failed to get stats" });
    }
  });
  app2.get("/api/focus-mode", requireAuth, async (req, res) => {
    try {
      const settings = await advancedStorage.getFocusModeSettings(req.session.userId);
      res.json(settings || {});
    } catch (error) {
      console.error("Get focus mode error:", error);
      res.status(500).json({ message: "Failed to get focus mode" });
    }
  });
  app2.put("/api/focus-mode", requireAuth, async (req, res) => {
    try {
      const settings = await advancedStorage.updateFocusModeSettings(req.session.userId, req.body);
      res.json(settings);
    } catch (error) {
      console.error("Update focus mode error:", error);
      res.status(500).json({ message: "Failed to update focus mode" });
    }
  });
  app2.post("/api/pokes", requireAuth, async (req, res) => {
    try {
      const { recipientId, pokeType } = req.body;
      if (!recipientId) {
        return res.status(400).json({ message: "Recipient required" });
      }
      const poke = await advancedStorage.sendPoke(req.session.userId, recipientId, pokeType || "WAVE");
      const sender = await storage.getUser(req.session.userId);
      pushNotificationService.sendToUser(recipientId, {
        title: pokeType === "WAVE" ? "\u{1F44B} Wave!" : "Poke!",
        body: `${sender?.displayName || sender?.username || "Someone"} sent you a ${pokeType?.toLowerCase() || "wave"}`,
        data: { type: "poke", pokeId: poke.id, pokeType: pokeType || "WAVE" }
      });
      res.json(poke);
    } catch (error) {
      console.error("Send poke error:", error);
      res.status(500).json({ message: "Failed to send poke" });
    }
  });
  app2.get("/api/pokes/received", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 20;
      const pokes2 = await advancedStorage.getReceivedPokes(req.session.userId, limit);
      res.json(pokes2);
    } catch (error) {
      console.error("Get received pokes error:", error);
      res.status(500).json({ message: "Failed to get pokes" });
    }
  });
  app2.post("/api/pokes/:id/seen", requireAuth, async (req, res) => {
    try {
      await advancedStorage.markPokeAsSeen(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Mark poke seen error:", error);
      res.status(500).json({ message: "Failed to mark poke as seen" });
    }
  });
  app2.get("/api/explore/categories", async (req, res) => {
    try {
      const categories = await advancedStorage.getExploreCategories();
      res.json(categories);
    } catch (error) {
      console.error("Get explore categories error:", error);
      res.status(500).json({ message: "Failed to get categories" });
    }
  });
  app2.post("/api/admin/explore/categories", requireAuth, async (req, res) => {
    try {
      const { name, slug, description, iconName } = req.body;
      if (!name || !slug) {
        return res.status(400).json({ message: "Name and slug required" });
      }
      const category = await advancedStorage.createExploreCategory(name, slug, description, iconName);
      res.json(category);
    } catch (error) {
      console.error("Create explore category error:", error);
      res.status(500).json({ message: "Failed to create category" });
    }
  });
  app2.get("/api/conversations/:id/vanish-mode", requireAuth, async (req, res) => {
    try {
      const settings = await advancedStorage.getVanishModeSettings(req.session.userId, req.params.id);
      res.json(settings || { isEnabled: false });
    } catch (error) {
      console.error("Get vanish mode error:", error);
      res.status(500).json({ message: "Failed to get vanish mode" });
    }
  });
  app2.put("/api/conversations/:id/vanish-mode", requireAuth, async (req, res) => {
    try {
      const { enabled } = req.body;
      const settings = await advancedStorage.setVanishMode(req.session.userId, req.params.id, enabled === true);
      res.json(settings);
    } catch (error) {
      console.error("Set vanish mode error:", error);
      res.status(500).json({ message: "Failed to set vanish mode" });
    }
  });
  app2.get("/api/scheduled-messages", requireAuth, async (req, res) => {
    try {
      const messages4 = await advancedStorage.getScheduledMessages(req.session.userId);
      res.json(messages4);
    } catch (error) {
      console.error("Get scheduled messages error:", error);
      res.status(500).json({ message: "Failed to get scheduled messages" });
    }
  });
  app2.post("/api/scheduled-messages", requireAuth, async (req, res) => {
    try {
      const { conversationId, content, scheduledFor } = req.body;
      if (!conversationId || !content || !scheduledFor) {
        return res.status(400).json({ message: "Conversation, content, and scheduled time required" });
      }
      const message = await advancedStorage.createScheduledMessage(
        req.session.userId,
        conversationId,
        content,
        new Date(scheduledFor)
      );
      res.json(message);
    } catch (error) {
      console.error("Create scheduled message error:", error);
      res.status(500).json({ message: "Failed to schedule message" });
    }
  });
  app2.delete("/api/scheduled-messages/:id", requireAuth, async (req, res) => {
    try {
      await advancedStorage.cancelScheduledMessage(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Cancel scheduled message error:", error);
      res.status(500).json({ message: "Failed to cancel scheduled message" });
    }
  });
  app2.get("/api/conversations/:id/pinned", requireAuth, async (req, res) => {
    try {
      const pinned = await advancedStorage.getPinnedMessages(req.params.id);
      res.json(pinned);
    } catch (error) {
      console.error("Get pinned messages error:", error);
      res.status(500).json({ message: "Failed to get pinned messages" });
    }
  });
  app2.post("/api/conversations/:conversationId/messages/:messageId/pin", requireAuth, async (req, res) => {
    try {
      const pinned = await advancedStorage.pinMessage(req.params.conversationId, req.params.messageId, req.session.userId);
      res.json(pinned);
    } catch (error) {
      console.error("Pin message error:", error);
      res.status(500).json({ message: "Failed to pin message" });
    }
  });
  app2.delete("/api/conversations/:conversationId/messages/:messageId/pin", requireAuth, async (req, res) => {
    try {
      await advancedStorage.unpinMessage(req.params.conversationId, req.params.messageId);
      res.json({ success: true });
    } catch (error) {
      console.error("Unpin message error:", error);
      res.status(500).json({ message: "Failed to unpin message" });
    }
  });
  app2.get("/api/chat-folders", requireAuth, async (req, res) => {
    try {
      const folders = await advancedStorage.getUserChatFolders(req.session.userId);
      res.json(folders);
    } catch (error) {
      console.error("Get chat folders error:", error);
      res.status(500).json({ message: "Failed to get chat folders" });
    }
  });
  app2.post("/api/chat-folders", requireAuth, async (req, res) => {
    try {
      const { name, color, iconName } = req.body;
      if (!name) {
        return res.status(400).json({ message: "Name required" });
      }
      const folder = await advancedStorage.createChatFolder(req.session.userId, name, iconName);
      res.json(folder);
    } catch (error) {
      console.error("Create chat folder error:", error);
      res.status(500).json({ message: "Failed to create chat folder" });
    }
  });
  app2.delete("/api/chat-folders/:id", requireAuth, async (req, res) => {
    try {
      await advancedStorage.deleteChatFolder(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Delete chat folder error:", error);
      res.status(500).json({ message: "Failed to delete chat folder" });
    }
  });
  app2.get("/api/chat-folders/:id/conversations", requireAuth, async (req, res) => {
    try {
      const conversationIds = await advancedStorage.getConversationsInFolder(req.params.id);
      res.json(conversationIds);
    } catch (error) {
      console.error("Get folder conversations error:", error);
      res.status(500).json({ message: "Failed to get folder conversations" });
    }
  });
  app2.post("/api/chat-folders/:folderId/conversations/:conversationId", requireAuth, async (req, res) => {
    try {
      await advancedStorage.addConversationToFolder(req.params.folderId, req.params.conversationId);
      res.json({ success: true });
    } catch (error) {
      console.error("Add to folder error:", error);
      res.status(500).json({ message: "Failed to add to folder" });
    }
  });
  app2.delete("/api/chat-folders/:folderId/conversations/:conversationId", requireAuth, async (req, res) => {
    try {
      await advancedStorage.removeConversationFromFolder(req.params.folderId, req.params.conversationId);
      res.json({ success: true });
    } catch (error) {
      console.error("Remove from folder error:", error);
      res.status(500).json({ message: "Failed to remove from folder" });
    }
  });
  app2.post("/api/security/2fa/setup", requireAuth, async (req, res) => {
    try {
      const { secret } = req.body;
      if (!secret) {
        return res.status(400).json({ message: "Secret required" });
      }
      const totp = await advancedStorage.createTotpSecret(req.session.userId, secret);
      res.json({ id: totp.id, created: true });
    } catch (error) {
      console.error("Setup 2FA error:", error);
      res.status(500).json({ message: "Failed to setup 2FA" });
    }
  });
  app2.get("/api/security/2fa", requireAuth, async (req, res) => {
    try {
      const totp = await advancedStorage.getTotpSecret(req.session.userId);
      res.json({ enabled: !!totp?.verifiedAt });
    } catch (error) {
      console.error("Get 2FA status error:", error);
      res.status(500).json({ message: "Failed to get 2FA status" });
    }
  });
  app2.post("/api/security/2fa/verify", requireAuth, async (req, res) => {
    try {
      await advancedStorage.verifyTotp(req.session.userId);
      res.json({ verified: true });
    } catch (error) {
      console.error("Verify 2FA error:", error);
      res.status(500).json({ message: "Failed to verify 2FA" });
    }
  });
  app2.delete("/api/security/2fa", requireAuth, async (req, res) => {
    try {
      await advancedStorage.deleteTotp(req.session.userId);
      res.json({ disabled: true });
    } catch (error) {
      console.error("Disable 2FA error:", error);
      res.status(500).json({ message: "Failed to disable 2FA" });
    }
  });
  app2.post("/api/security/backup-codes", requireAuth, async (req, res) => {
    try {
      const { codes } = req.body;
      if (!codes || !Array.isArray(codes)) {
        return res.status(400).json({ message: "Codes array required" });
      }
      const backupCodes2 = await advancedStorage.createBackupCodes(req.session.userId, codes);
      res.json(backupCodes2);
    } catch (error) {
      console.error("Create backup codes error:", error);
      res.status(500).json({ message: "Failed to create backup codes" });
    }
  });
  app2.get("/api/security/backup-codes", requireAuth, async (req, res) => {
    try {
      const codes = await advancedStorage.getBackupCodes(req.session.userId);
      res.json({ count: codes.length });
    } catch (error) {
      console.error("Get backup codes error:", error);
      res.status(500).json({ message: "Failed to get backup codes" });
    }
  });
  app2.post("/api/security/backup-codes/use", requireAuth, async (req, res) => {
    try {
      const { code } = req.body;
      if (!code) {
        return res.status(400).json({ message: "Code required" });
      }
      const success = await advancedStorage.useBackupCode(req.session.userId, code);
      if (!success) {
        return res.status(400).json({ message: "Invalid or already used code" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Use backup code error:", error);
      res.status(500).json({ message: "Failed to use backup code" });
    }
  });
  app2.get("/api/linked-accounts", requireAuth, async (req, res) => {
    try {
      const accounts = await advancedStorage.getLinkedAccounts(req.session.userId);
      res.json(accounts);
    } catch (error) {
      console.error("Get linked accounts error:", error);
      res.status(500).json({ message: "Failed to get linked accounts" });
    }
  });
  app2.post("/api/linked-accounts", requireAuth, async (req, res) => {
    try {
      const { provider, providerId, email, displayName, avatarUrl } = req.body;
      if (!provider || !providerId) {
        return res.status(400).json({ message: "Provider and provider ID required" });
      }
      const account = await advancedStorage.linkAccounts(req.session.userId, providerId);
      res.json(account);
    } catch (error) {
      console.error("Link account error:", error);
      res.status(500).json({ message: "Failed to link account" });
    }
  });
  app2.delete("/api/linked-accounts/:provider", requireAuth, async (req, res) => {
    try {
      await advancedStorage.unlinkAccount(req.session.userId, req.params.provider);
      res.json({ success: true });
    } catch (error) {
      console.error("Unlink account error:", error);
      res.status(500).json({ message: "Failed to unlink account" });
    }
  });
  app2.get("/api/hidden-words", requireAuth, async (req, res) => {
    try {
      const words = await advancedStorage.getHiddenWords(req.session.userId);
      res.json(words);
    } catch (error) {
      console.error("Get hidden words error:", error);
      res.status(500).json({ message: "Failed to get hidden words" });
    }
  });
  app2.post("/api/hidden-words", requireAuth, async (req, res) => {
    try {
      const { word } = req.body;
      if (!word) {
        return res.status(400).json({ message: "Word required" });
      }
      const hidden = await advancedStorage.addHiddenWord(req.session.userId, word);
      res.json(hidden);
    } catch (error) {
      console.error("Add hidden word error:", error);
      res.status(500).json({ message: "Failed to add hidden word" });
    }
  });
  app2.delete("/api/hidden-words/:id", requireAuth, async (req, res) => {
    try {
      await advancedStorage.removeHiddenWord(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Remove hidden word error:", error);
      res.status(500).json({ message: "Failed to remove hidden word" });
    }
  });
  app2.get("/api/threads", requireAuth, async (req, res) => {
    try {
      const threads = await advancedStorage.getUserThreads(req.session.userId);
      res.json(threads);
    } catch (error) {
      console.error("Get threads error:", error);
      res.status(500).json({ message: "Failed to get threads" });
    }
  });
  app2.post("/api/threads", requireAuth, async (req, res) => {
    try {
      const { title } = req.body;
      const thread = await advancedStorage.createThread(req.session.userId, title);
      res.json(thread);
    } catch (error) {
      console.error("Create thread error:", error);
      res.status(500).json({ message: "Failed to create thread" });
    }
  });
  app2.get("/api/threads/:id", async (req, res) => {
    try {
      const thread = await advancedStorage.getThread(req.params.id);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }
      res.json(thread);
    } catch (error) {
      console.error("Get thread error:", error);
      res.status(500).json({ message: "Failed to get thread" });
    }
  });
  app2.post("/api/threads/:id/posts", requireAuth, async (req, res) => {
    try {
      const { postId, position } = req.body;
      if (!postId) {
        return res.status(400).json({ message: "Post ID required" });
      }
      const threadPost = await advancedStorage.addPostToThread(req.params.id, postId, position || 0);
      res.json(threadPost);
    } catch (error) {
      console.error("Add post to thread error:", error);
      res.status(500).json({ message: "Failed to add post to thread" });
    }
  });
  app2.get("/api/posts/:id/duets", async (req, res) => {
    try {
      const duets = await advancedStorage.getDuetsForPost(req.params.id);
      res.json(duets);
    } catch (error) {
      console.error("Get duets error:", error);
      res.status(500).json({ message: "Failed to get duets" });
    }
  });
  app2.get("/api/posts/:id/stitches", async (req, res) => {
    try {
      const stitches = await advancedStorage.getStitchesForPost(req.params.id);
      res.json(stitches);
    } catch (error) {
      console.error("Get stitches error:", error);
      res.status(500).json({ message: "Failed to get stitches" });
    }
  });
  app2.post("/api/duets", requireAuth, async (req, res) => {
    try {
      const { originalPostId, responsePostId } = req.body;
      if (!originalPostId || !responsePostId) {
        return res.status(400).json({ message: "Original and response post IDs required" });
      }
      const duet = await advancedStorage.createDuetStitch("DUET", originalPostId, responsePostId);
      res.json(duet);
    } catch (error) {
      console.error("Create duet error:", error);
      res.status(500).json({ message: "Failed to create duet" });
    }
  });
  app2.post("/api/stitches", requireAuth, async (req, res) => {
    try {
      const { originalPostId, responsePostId } = req.body;
      if (!originalPostId || !responsePostId) {
        return res.status(400).json({ message: "Original and response post IDs required" });
      }
      const stitch = await advancedStorage.createDuetStitch("STITCH", originalPostId, responsePostId);
      res.json(stitch);
    } catch (error) {
      console.error("Create stitch error:", error);
      res.status(500).json({ message: "Failed to create stitch" });
    }
  });
  app2.get("/api/webhooks", requireAuth, async (req, res) => {
    try {
      const webhooks2 = await advancedStorage.getUserWebhooks(req.session.userId);
      res.json(webhooks2);
    } catch (error) {
      console.error("Get webhooks error:", error);
      res.status(500).json({ message: "Failed to get webhooks" });
    }
  });
  app2.post("/api/webhooks", requireAuth, async (req, res) => {
    try {
      const { url, events: events2, secret } = req.body;
      if (!url || !events2 || !Array.isArray(events2)) {
        return res.status(400).json({ message: "URL and events array required" });
      }
      const webhook = await advancedStorage.createWebhook(req.session.userId, url, events2, secret);
      res.json(webhook);
    } catch (error) {
      console.error("Create webhook error:", error);
      res.status(500).json({ message: "Failed to create webhook" });
    }
  });
  app2.get("/api/webhooks/:id", requireAuth, async (req, res) => {
    try {
      const webhook = await advancedStorage.getWebhook(req.params.id);
      if (!webhook) {
        return res.status(404).json({ message: "Webhook not found" });
      }
      res.json(webhook);
    } catch (error) {
      console.error("Get webhook error:", error);
      res.status(500).json({ message: "Failed to get webhook" });
    }
  });
  app2.put("/api/webhooks/:id", requireAuth, async (req, res) => {
    try {
      const updated = await advancedStorage.updateWebhook(req.params.id, req.body);
      res.json(updated);
    } catch (error) {
      console.error("Update webhook error:", error);
      res.status(500).json({ message: "Failed to update webhook" });
    }
  });
  app2.delete("/api/webhooks/:id", requireAuth, async (req, res) => {
    try {
      await advancedStorage.deleteWebhook(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Delete webhook error:", error);
      res.status(500).json({ message: "Failed to delete webhook" });
    }
  });
  app2.get("/api/webhooks/:id/deliveries", requireAuth, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const deliveries = await advancedStorage.getWebhookDeliveries(req.params.id, limit);
      res.json(deliveries);
    } catch (error) {
      console.error("Get webhook deliveries error:", error);
      res.status(500).json({ message: "Failed to get deliveries" });
    }
  });
  app2.get("/api/ar-filters", async (req, res) => {
    try {
      const filters = await advancedStorage.getArFilters();
      res.json(filters);
    } catch (error) {
      console.error("Get AR filters error:", error);
      res.status(500).json({ message: "Failed to get AR filters" });
    }
  });
  app2.post("/api/ar-filters", requireAuth, async (req, res) => {
    try {
      const { name, category, previewUrl, filterDataUrl } = req.body;
      if (!name || !category || !previewUrl || !filterDataUrl) {
        return res.status(400).json({ message: "Name, category, preview URL, and filter data URL required" });
      }
      const filter = await advancedStorage.createArFilter(name, category, previewUrl, filterDataUrl, req.session.userId);
      res.json(filter);
    } catch (error) {
      console.error("Create AR filter error:", error);
      res.status(500).json({ message: "Failed to create AR filter" });
    }
  });
  app2.get("/api/security/checkup", requireAuth, async (req, res) => {
    try {
      let checkup = await advancedStorage.getSecurityCheckup(req.session.userId);
      if (!checkup) {
        checkup = await advancedStorage.createSecurityCheckup(req.session.userId);
      }
      res.json(checkup);
    } catch (error) {
      console.error("Get security checkup error:", error);
      res.status(500).json({ message: "Failed to get security checkup" });
    }
  });
  app2.put("/api/security/checkup", requireAuth, async (req, res) => {
    try {
      const checkup = await advancedStorage.getSecurityCheckup(req.session.userId);
      if (!checkup) {
        return res.status(404).json({ message: "No security checkup found" });
      }
      const updated = await advancedStorage.updateSecurityCheckup(checkup.id, req.body);
      res.json(updated);
    } catch (error) {
      console.error("Update security checkup error:", error);
      res.status(500).json({ message: "Failed to update security checkup" });
    }
  });
  app2.post("/api/account/backup", requireAuth, async (req, res) => {
    try {
      const backup = await advancedStorage.requestAccountBackup(req.session.userId);
      res.json(backup);
    } catch (error) {
      console.error("Request account backup error:", error);
      res.status(500).json({ message: "Failed to request account backup" });
    }
  });
  app2.get("/api/account/backup", requireAuth, async (req, res) => {
    try {
      const backup = await advancedStorage.getAccountBackup(req.session.userId);
      res.json(backup || { status: "NONE" });
    } catch (error) {
      console.error("Get account backup error:", error);
      res.status(500).json({ message: "Failed to get account backup" });
    }
  });
  app2.get("/api/sessions", requireAuth, async (req, res) => {
    try {
      const sessions = await advancedStorage.getLoginSessions(req.session.userId);
      res.json(sessions);
    } catch (error) {
      console.error("Get login sessions error:", error);
      res.status(500).json({ message: "Failed to get login sessions" });
    }
  });
  app2.delete("/api/sessions/:sessionId", requireAuth, async (req, res) => {
    try {
      await advancedStorage.deactivateLoginSession(req.session.userId, req.params.sessionId);
      res.json({ success: true });
    } catch (error) {
      console.error("Deactivate session error:", error);
      res.status(500).json({ message: "Failed to deactivate session" });
    }
  });
  app2.delete("/api/sessions", requireAuth, async (req, res) => {
    try {
      const { exceptCurrent } = req.query;
      await advancedStorage.deactivateAllLoginSessions(
        req.session.userId,
        exceptCurrent ? req.session.id : void 0
      );
      res.json({ success: true });
    } catch (error) {
      console.error("Deactivate all sessions error:", error);
      res.status(500).json({ message: "Failed to deactivate sessions" });
    }
  });
  app2.get("/api/devices", requireAuth, async (req, res) => {
    try {
      const devices = await advancedStorage.getTrustedDevices(req.session.userId);
      res.json(devices);
    } catch (error) {
      console.error("Get trusted devices error:", error);
      res.status(500).json({ message: "Failed to get trusted devices" });
    }
  });
  app2.post("/api/devices", requireAuth, async (req, res) => {
    try {
      const { deviceFingerprint, deviceName, deviceType } = req.body;
      const device = await advancedStorage.addTrustedDevice(
        req.session.userId,
        deviceFingerprint,
        deviceName,
        deviceType
      );
      res.json(device);
    } catch (error) {
      console.error("Add trusted device error:", error);
      res.status(500).json({ message: "Failed to add trusted device" });
    }
  });
  app2.delete("/api/devices/:deviceId", requireAuth, async (req, res) => {
    try {
      await advancedStorage.removeTrustedDevice(req.session.userId, req.params.deviceId);
      res.json({ success: true });
    } catch (error) {
      console.error("Remove trusted device error:", error);
      res.status(500).json({ message: "Failed to remove trusted device" });
    }
  });
  console.log("Advanced routes registered successfully");
}

// server/routes-onboarding.ts
init_db();
init_schema();
import { eq as eq6, and as and5, desc as desc4, sql as sql6, inArray as inArray5, isNull as isNull3, or as or3, count } from "drizzle-orm";

// server/services/ai-moderation.ts
import { GoogleGenAI } from "@google/genai";
var ai = new GoogleGenAI({
  apiKey: process.env.AI_INTEGRATIONS_GEMINI_API_KEY,
  httpOptions: {
    apiVersion: "",
    baseUrl: process.env.AI_INTEGRATIONS_GEMINI_BASE_URL
  }
});
async function moderateText(content) {
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: [
        {
          role: "user",
          parts: [
            {
              text: `You are a content moderation AI for a luxury social network. Analyze this text for policy violations.

Content to analyze:
"${content}"

Check for:
1. Hate speech or discrimination
2. Harassment or bullying
3. Violent threats
4. Adult/explicit content
5. Spam or scams
6. Personal information exposure (doxxing)
7. Illegal activities

Respond in JSON format:
{
  "safe": true/false,
  "category": "none" or "hate_speech" or "harassment" or "violence" or "adult" or "spam" or "doxxing" or "illegal",
  "reason": "brief explanation if unsafe",
  "confidence": 0.0-1.0
}

Only respond with the JSON, no other text.`
            }
          ]
        }
      ]
    });
    const text3 = response.text || "";
    const jsonMatch = text3.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      return {
        safe: result.safe ?? true,
        category: result.category,
        reason: result.reason,
        confidence: result.confidence ?? 0.8
      };
    }
    return { safe: true, confidence: 0.5 };
  } catch (error) {
    console.error("[AI Moderation] Error moderating text:", error);
    return { safe: true, confidence: 0.3 };
  }
}
async function analyzeImage(imageUrl) {
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: [
        {
          role: "user",
          parts: [
            {
              text: `Analyze this image for a luxury social network. Provide a detailed analysis.

Image URL: ${imageUrl}

Respond in JSON format:
{
  "description": "detailed description of the image",
  "tags": ["tag1", "tag2", "tag3"],
  "isAppropriate": true/false,
  "suggestedCaption": "a suggested caption for social media",
  "detectedObjects": ["object1", "object2"],
  "mood": "luxurious/professional/casual/artistic/etc"
}

Only respond with the JSON, no other text.`
            }
          ]
        }
      ]
    });
    const text3 = response.text || "";
    const jsonMatch = text3.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      return {
        description: result.description || "Image analysis complete",
        tags: result.tags || [],
        isAppropriate: result.isAppropriate ?? true,
        suggestedCaption: result.suggestedCaption,
        detectedObjects: result.detectedObjects || [],
        mood: result.mood
      };
    }
    return {
      description: "Unable to analyze image",
      tags: [],
      isAppropriate: true,
      detectedObjects: []
    };
  } catch (error) {
    console.error("[AI Moderation] Error analyzing image:", error);
    return {
      description: "Analysis unavailable",
      tags: [],
      isAppropriate: true,
      detectedObjects: []
    };
  }
}
async function getContentSuggestions(content, context) {
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: [
        {
          role: "user",
          parts: [
            {
              text: `You are a social media expert for a luxury social network called RabitChat. Help improve this post.

Original content:
"${content}"

${context?.category ? `Post category: ${context.category}` : ""}
${context?.audience ? `Target audience: ${context.audience}` : ""}

Provide suggestions to make this post more engaging while maintaining a premium, sophisticated tone.

Respond in JSON format:
{
  "improvedText": "enhanced version of the post",
  "suggestions": ["suggestion 1", "suggestion 2", "suggestion 3"],
  "tone": "the detected/recommended tone",
  "hashtags": ["#hashtag1", "#hashtag2"]
}

Only respond with the JSON, no other text.`
            }
          ]
        }
      ]
    });
    const text3 = response.text || "";
    const jsonMatch = text3.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      return {
        improvedText: result.improvedText || content,
        suggestions: result.suggestions || [],
        tone: result.tone || "professional",
        hashtags: result.hashtags || []
      };
    }
    return {
      improvedText: content,
      suggestions: [],
      tone: "neutral",
      hashtags: []
    };
  } catch (error) {
    console.error("[AI Moderation] Error getting suggestions:", error);
    return {
      improvedText: content,
      suggestions: [],
      tone: "neutral",
      hashtags: []
    };
  }
}
async function summarizeContent(contents) {
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: [
        {
          role: "user",
          parts: [
            {
              text: `Summarize the following social media posts into a brief, engaging digest. Keep a luxury/premium tone.

Posts:
${contents.map((c, i) => `${i + 1}. "${c}"`).join("\n")}

Provide a 2-3 sentence summary highlighting the main themes and key points.`
            }
          ]
        }
      ]
    });
    return response.text || "Summary unavailable";
  } catch (error) {
    console.error("[AI Moderation] Error summarizing content:", error);
    return "Summary unavailable";
  }
}
async function detectLanguage(content) {
  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: [
        {
          role: "user",
          parts: [
            {
              text: `Detect the language of this text. Respond with JSON only:
{"language": "language name", "code": "ISO code", "confidence": 0.0-1.0}

Text: "${content}"`
            }
          ]
        }
      ]
    });
    const text3 = response.text || "";
    const jsonMatch = text3.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      return {
        language: result.language || "unknown",
        confidence: result.confidence ?? 0.8
      };
    }
    return { language: "unknown", confidence: 0.5 };
  } catch (error) {
    console.error("[AI Moderation] Error detecting language:", error);
    return { language: "unknown", confidence: 0.3 };
  }
}

// server/routes-onboarding.ts
import { z as z2 } from "zod";
var selectInterestsSchema = z2.object({
  interests: z2.array(z2.string()).min(1).max(15)
});
var updateIndustrySchema = z2.object({
  industry: z2.enum([
    "TECH",
    "FINANCE",
    "REAL_ESTATE",
    "ENTERTAINMENT",
    "SPORTS",
    "HEALTHCARE",
    "LEGAL",
    "FASHION",
    "HOSPITALITY",
    "MEDIA",
    "AUTOMOTIVE",
    "AVIATION",
    "ART",
    "EDUCATION",
    "CONSULTING",
    "CRYPTO",
    "VENTURE_CAPITAL",
    "PRIVATE_EQUITY",
    "PHILANTHROPY",
    "OTHER"
  ])
});
var updateNetWorthTierSchema = z2.object({
  tier: z2.enum(["BUILDING", "SILVER", "GOLD", "PLATINUM", "DIAMOND"])
});
var updatePrivacySchema = z2.object({
  netWorthVisibility: z2.enum(["EVERYONE", "FOLLOWERS", "NOBODY"]).optional(),
  profileVisibility: z2.enum(["EVERYONE", "FOLLOWERS", "NOBODY"]).optional()
});
var updateOnboardingStepSchema = z2.object({
  step: z2.number().min(0).max(10)
});
async function seedInterestCategories() {
  const categories = [
    { slug: "luxury-lifestyle", name: "Luxury Lifestyle", description: "High-end living, exclusive experiences", icon: "star", color: "#D4AF37", gradientColors: ["#D4AF37", "#FFF1B8"], order: 1 },
    { slug: "investments", name: "Investments & Finance", description: "Wealth management, stocks, portfolios", icon: "trending-up", color: "#10B981", gradientColors: ["#10B981", "#34D399"], order: 2 },
    { slug: "real-estate", name: "Real Estate", description: "Property, developments, architecture", icon: "home", color: "#8B5CF6", gradientColors: ["#8B5CF6", "#C4B5FD"], order: 3 },
    { slug: "yachts-aviation", name: "Yachts & Aviation", description: "Superyachts, private jets, travel", icon: "anchor", color: "#0EA5E9", gradientColors: ["#0EA5E9", "#7DD3FC"], order: 4 },
    { slug: "fine-dining", name: "Fine Dining & Wine", description: "Michelin stars, rare vintages, culinary art", icon: "coffee", color: "#EC4899", gradientColors: ["#EC4899", "#F9A8D4"], order: 5 },
    { slug: "fashion", name: "Fashion & Couture", description: "Haute couture, luxury brands, style", icon: "shopping-bag", color: "#F59E0B", gradientColors: ["#F59E0B", "#FCD34D"], order: 6 },
    { slug: "art-collectibles", name: "Art & Collectibles", description: "Fine art, antiques, rare collections", icon: "image", color: "#EF4444", gradientColors: ["#EF4444", "#FCA5A5"], order: 7 },
    { slug: "automotive", name: "Exotic Cars", description: "Supercars, classic cars, motorsport", icon: "zap", color: "#DC2626", gradientColors: ["#DC2626", "#F87171"], order: 8 },
    { slug: "watches-jewelry", name: "Watches & Jewelry", description: "Timepieces, diamonds, precious gems", icon: "watch", color: "#14B8A6", gradientColors: ["#14B8A6", "#5EEAD4"], order: 9 },
    { slug: "tech-innovation", name: "Tech & Innovation", description: "Startups, AI, cutting-edge technology", icon: "cpu", color: "#6366F1", gradientColors: ["#6366F1", "#A5B4FC"], order: 10 },
    { slug: "wellness-health", name: "Wellness & Health", description: "Biohacking, longevity, elite fitness", icon: "heart", color: "#F43F5E", gradientColors: ["#F43F5E", "#FDA4AF"], order: 11 },
    { slug: "entertainment", name: "Entertainment & Media", description: "Film, music, celebrities, events", icon: "film", color: "#A855F7", gradientColors: ["#A855F7", "#D8B4FE"], order: 12 },
    { slug: "sports", name: "Sports & Athletics", description: "Golf, polo, tennis, elite sports", icon: "award", color: "#22C55E", gradientColors: ["#22C55E", "#86EFAC"], order: 13 },
    { slug: "philanthropy", name: "Philanthropy & Impact", description: "Charitable giving, social impact", icon: "users", color: "#3B82F6", gradientColors: ["#3B82F6", "#93C5FD"], order: 14 },
    { slug: "crypto-web3", name: "Crypto & Web3", description: "Digital assets, blockchain, NFTs", icon: "database", color: "#8B5CF6", gradientColors: ["#F97316", "#FDBA74"], order: 15 }
  ];
  try {
    const existing = await db.select().from(interestCategories);
    if (existing.length === 0) {
      await db.insert(interestCategories).values(categories);
      console.log("Seeded interest categories successfully");
    }
  } catch (error) {
    console.error("Error seeding interest categories:", error);
  }
}
function registerOnboardingRoutes(app2) {
  seedInterestCategories();
  app2.get("/api/interests/categories", async (req, res) => {
    try {
      const categories = await db.select().from(interestCategories).where(eq6(interestCategories.isActive, true)).orderBy(interestCategories.order);
      res.json(categories);
    } catch (error) {
      console.error("Error fetching interest categories:", error);
      res.status(500).json({ error: "Failed to fetch categories" });
    }
  });
  app2.get("/api/interests/me", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      const interests = await db.select({
        id: userInterests.id,
        interest: userInterests.interest,
        categoryId: userInterests.categoryId,
        affinityScore: userInterests.affinityScore,
        order: userInterests.order,
        category: interestCategories
      }).from(userInterests).leftJoin(interestCategories, eq6(userInterests.categoryId, interestCategories.id)).where(eq6(userInterests.userId, userId)).orderBy(userInterests.order);
      res.json(interests);
    } catch (error) {
      console.error("Error fetching user interests:", error);
      res.status(500).json({ error: "Failed to fetch interests" });
    }
  });
  app2.post("/api/interests/select", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      const { interests } = selectInterestsSchema.parse(req.body);
      const categoryList = await db.select().from(interestCategories).where(inArray5(interestCategories.slug, interests));
      const categoryMap = new Map(categoryList.map((c) => [c.slug, c]));
      await db.delete(userInterests).where(eq6(userInterests.userId, userId));
      const insertItems = interests.map((slug, idx) => {
        const category = categoryMap.get(slug);
        return {
          userId,
          interest: slug,
          categoryId: category?.id || null,
          affinityScore: 1,
          order: idx
        };
      });
      const result = await db.insert(userInterests).values(insertItems).returning();
      await db.update(users).set({ onboardingStep: 2 }).where(eq6(users.id, userId));
      res.json({ success: true, interests: result });
    } catch (error) {
      console.error("Error selecting interests:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Invalid request", details: error.errors });
      }
      res.status(500).json({ error: "Failed to save interests" });
    }
  });
  app2.patch("/api/interests/:interestSlug/affinity", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    const { interestSlug } = req.params;
    const { delta } = req.body;
    try {
      const [interest] = await db.select().from(userInterests).where(and5(eq6(userInterests.userId, userId), eq6(userInterests.interest, interestSlug)));
      if (!interest) {
        return res.status(404).json({ error: "Interest not found" });
      }
      const newScore = Math.max(0.1, Math.min(10, (interest.affinityScore || 1) + delta));
      await db.update(userInterests).set({ affinityScore: newScore, updatedAt: /* @__PURE__ */ new Date() }).where(eq6(userInterests.id, interest.id));
      res.json({ success: true, newScore });
    } catch (error) {
      console.error("Error updating affinity:", error);
      res.status(500).json({ error: "Failed to update affinity" });
    }
  });
  app2.delete("/api/interests/:interestSlug", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    const { interestSlug } = req.params;
    try {
      await db.delete(userInterests).where(and5(eq6(userInterests.userId, userId), eq6(userInterests.interest, interestSlug)));
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing interest:", error);
      res.status(500).json({ error: "Failed to remove interest" });
    }
  });
  app2.post("/api/onboarding/industry", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      const { industry } = updateIndustrySchema.parse(req.body);
      await db.update(users).set({ industry, onboardingStep: 3 }).where(eq6(users.id, userId));
      res.json({ success: true });
    } catch (error) {
      console.error("Error updating industry:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Invalid industry" });
      }
      res.status(500).json({ error: "Failed to update industry" });
    }
  });
  app2.post("/api/onboarding/net-worth-tier", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      const { tier } = updateNetWorthTierSchema.parse(req.body);
      await db.update(users).set({ netWorthTier: tier, onboardingStep: 4 }).where(eq6(users.id, userId));
      res.json({ success: true });
    } catch (error) {
      console.error("Error updating net worth tier:", error);
      if (error instanceof z2.ZodError) {
        return res.status(400).json({ error: "Invalid tier" });
      }
      res.status(500).json({ error: "Failed to update tier" });
    }
  });
  app2.post("/api/onboarding/privacy", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      const data = updatePrivacySchema.parse(req.body);
      await db.update(users).set({ ...data, onboardingStep: 5 }).where(eq6(users.id, userId));
      res.json({ success: true });
    } catch (error) {
      console.error("Error updating privacy:", error);
      res.status(500).json({ error: "Failed to update privacy" });
    }
  });
  app2.post("/api/onboarding/step", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      const { step } = updateOnboardingStepSchema.parse(req.body);
      await db.update(users).set({ onboardingStep: step }).where(eq6(users.id, userId));
      res.json({ success: true });
    } catch (error) {
      console.error("Error updating step:", error);
      res.status(500).json({ error: "Failed to update step" });
    }
  });
  app2.post("/api/onboarding/complete", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      await db.update(users).set({ onboardingCompleted: true, onboardingStep: 7 }).where(eq6(users.id, userId));
      res.json({ success: true });
    } catch (error) {
      console.error("Error completing onboarding:", error);
      res.status(500).json({ error: "Failed to complete onboarding" });
    }
  });
  app2.get("/api/onboarding/status", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      const [user] = await db.select({
        onboardingCompleted: users.onboardingCompleted,
        onboardingStep: users.onboardingStep,
        industry: users.industry,
        netWorthTier: users.netWorthTier,
        netWorthVisibility: users.netWorthVisibility,
        profileVisibility: users.profileVisibility,
        firstSessionCompleted: users.firstSessionCompleted,
        avatarUrl: users.avatarUrl,
        phoneVerified: users.phoneVerified
      }).from(users).where(eq6(users.id, userId));
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const interests = await db.select({ interest: userInterests.interest }).from(userInterests).where(eq6(userInterests.userId, userId));
      res.json({
        ...user,
        interests: interests.map((i) => i.interest),
        hasInterests: interests.length > 0,
        hasAvatar: !!user.avatarUrl,
        hasIndustry: !!user.industry
      });
    } catch (error) {
      console.error("Error fetching onboarding status:", error);
      res.status(500).json({ error: "Failed to fetch status" });
    }
  });
  app2.get("/api/users/suggestions", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      const limit = parseInt(req.query.limit) || 20;
      const [currentUser] = await db.select().from(users).where(eq6(users.id, userId));
      if (!currentUser) {
        return res.status(404).json({ error: "User not found" });
      }
      const myInterests = await db.select({ interest: userInterests.interest }).from(userInterests).where(eq6(userInterests.userId, userId));
      const interestSlugs = myInterests.map((i) => i.interest);
      const following = await db.select({ followingId: follows.followingId }).from(follows).where(eq6(follows.followerId, userId));
      const followingIds = following.map((f) => f.followingId);
      const excludeIds = [userId, ...followingIds];
      let suggestions;
      if (interestSlugs.length > 0 || currentUser.industry) {
        const matchingInterestUsers = interestSlugs.length > 0 ? await db.select({
          userId: userInterests.userId,
          matchCount: count()
        }).from(userInterests).where(inArray5(userInterests.interest, interestSlugs)).groupBy(userInterests.userId).orderBy(desc4(count())) : [];
        const matchingUserIds = matchingInterestUsers.map((u) => u.userId);
        suggestions = await db.select({
          id: users.id,
          username: users.username,
          displayName: users.displayName,
          avatarUrl: users.avatarUrl,
          bio: users.bio,
          isVerified: users.isVerified,
          netWorth: users.netWorth,
          influenceScore: users.influenceScore,
          industry: users.industry
        }).from(users).where(
          and5(
            sql6`${users.id} NOT IN (${sql6.join(excludeIds.map((id) => sql6`${id}`), sql6`, `)})`,
            isNull3(users.suspendedAt),
            isNull3(users.deactivatedAt),
            or3(
              currentUser.industry ? eq6(users.industry, currentUser.industry) : sql6`1=0`,
              matchingUserIds.length > 0 ? inArray5(users.id, matchingUserIds) : sql6`1=0`,
              users.isVerified
            )
          )
        ).orderBy(desc4(users.influenceScore), desc4(users.netWorth)).limit(limit);
      } else {
        suggestions = await db.select({
          id: users.id,
          username: users.username,
          displayName: users.displayName,
          avatarUrl: users.avatarUrl,
          bio: users.bio,
          isVerified: users.isVerified,
          netWorth: users.netWorth,
          influenceScore: users.influenceScore,
          industry: users.industry
        }).from(users).where(
          and5(
            sql6`${users.id} NOT IN (${sql6.join(excludeIds.map((id) => sql6`${id}`), sql6`, `)})`,
            isNull3(users.suspendedAt),
            isNull3(users.deactivatedAt)
          )
        ).orderBy(desc4(users.isVerified), desc4(users.influenceScore), desc4(users.netWorth)).limit(limit);
      }
      const enrichedSuggestions = suggestions.map((user) => {
        const reasons = [];
        if (user.isVerified) reasons.push("verified");
        if (user.industry === currentUser.industry) reasons.push("same_industry");
        if ((user.netWorth || 0) > 1e6) reasons.push("high_net_worth");
        return { ...user, matchReasons: reasons };
      });
      res.json(enrichedSuggestions);
    } catch (error) {
      console.error("Error fetching suggestions:", error);
      res.status(500).json({ error: "Failed to fetch suggestions" });
    }
  });
  app2.get("/api/posts/preview", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 5;
      const previewPosts = await db.select({
        id: posts.id,
        type: posts.type,
        content: posts.content,
        caption: posts.caption,
        mediaUrl: posts.mediaUrl,
        thumbnailUrl: posts.thumbnailUrl,
        likesCount: posts.likesCount,
        commentsCount: posts.commentsCount,
        viewsCount: posts.viewsCount,
        createdAt: posts.createdAt,
        author: {
          id: users.id,
          username: users.username,
          displayName: users.displayName,
          avatarUrl: users.avatarUrl,
          isVerified: users.isVerified,
          netWorth: users.netWorth
        }
      }).from(posts).innerJoin(users, eq6(posts.authorId, users.id)).where(
        and5(
          eq6(posts.visibility, "PUBLIC"),
          isNull3(posts.deletedAt),
          eq6(posts.isHidden, false),
          or3(eq6(posts.type, "VIDEO"), eq6(posts.type, "PHOTO"))
        )
      ).orderBy(desc4(posts.likesCount), desc4(posts.viewsCount)).limit(limit);
      res.json(previewPosts);
    } catch (error) {
      console.error("Error fetching preview posts:", error);
      res.status(500).json({ error: "Failed to fetch preview" });
    }
  });
  app2.post("/api/content/analyze", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    const { postId } = req.body;
    if (!postId) {
      return res.status(400).json({ error: "Post ID required" });
    }
    try {
      const [post] = await db.select().from(posts).where(eq6(posts.id, postId));
      if (!post) {
        return res.status(404).json({ error: "Post not found" });
      }
      const categories = await db.select().from(interestCategories).where(eq6(interestCategories.isActive, true));
      const categoryNames = categories.map((c) => c.name).join(", ");
      let detectedCategories = [];
      if (post.content || post.caption) {
        const textContent = `${post.content || ""} ${post.caption || ""}`.trim();
        const textAnalysis = await moderateText(textContent);
        const lowerText = textContent.toLowerCase();
        for (const cat of categories) {
          const keywords = cat.name.toLowerCase().split(/[&\s]+/);
          const matchScore = keywords.filter((k) => lowerText.includes(k)).length / keywords.length;
          if (matchScore > 0.3) {
            detectedCategories.push({ slug: cat.slug, confidence: matchScore });
          }
        }
      }
      if (post.mediaUrl && (post.type === "PHOTO" || post.type === "VIDEO")) {
        try {
          const imageAnalysis = await analyzeImage(post.mediaUrl);
          const allLabels = [...imageAnalysis.tags || [], ...imageAnalysis.detectedObjects || []];
          if (allLabels.length > 0) {
            const labels = allLabels.map((l) => l.toLowerCase());
            for (const cat of categories) {
              const catWords = cat.name.toLowerCase().split(/[&\s]+/);
              const matchScore = catWords.filter(
                (w) => labels.some((l) => l.includes(w) || w.includes(l))
              ).length / catWords.length;
              if (matchScore > 0.2) {
                const existing = detectedCategories.find((d) => d.slug === cat.slug);
                if (existing) {
                  existing.confidence = Math.min(1, existing.confidence + matchScore);
                } else {
                  detectedCategories.push({ slug: cat.slug, confidence: matchScore });
                }
              }
            }
          }
        } catch (imgError) {
          console.error("Image analysis error:", imgError);
        }
      }
      detectedCategories.sort((a, b) => b.confidence - a.confidence);
      detectedCategories = detectedCategories.slice(0, 3);
      if (detectedCategories.length > 0) {
        const categoryMap = new Map(categories.map((c) => [c.slug, c.id]));
        await db.delete(contentCategories).where(eq6(contentCategories.postId, postId));
        const inserts = detectedCategories.map((dc) => ({
          postId,
          categoryId: categoryMap.get(dc.slug) || null,
          categorySlug: dc.slug,
          confidence: dc.confidence,
          analyzedBy: "gemini"
        }));
        await db.insert(contentCategories).values(inserts);
      }
      res.json({
        success: true,
        categories: detectedCategories,
        analyzed: true
      });
    } catch (error) {
      console.error("Error analyzing content:", error);
      res.status(500).json({ error: "Failed to analyze content" });
    }
  });
  app2.post("/api/onboarding/first-session-complete", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      await db.update(users).set({ firstSessionCompleted: true }).where(eq6(users.id, userId));
      res.json({ success: true });
    } catch (error) {
      console.error("Error marking first session complete:", error);
      res.status(500).json({ error: "Failed to update" });
    }
  });
  app2.get("/api/algorithm/preferences", async (req, res) => {
    const userId = req.session?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    try {
      const interests = await db.select({
        interest: userInterests.interest,
        affinityScore: userInterests.affinityScore,
        category: interestCategories
      }).from(userInterests).leftJoin(interestCategories, eq6(userInterests.categoryId, interestCategories.id)).where(eq6(userInterests.userId, userId)).orderBy(desc4(userInterests.affinityScore));
      const recentCategories = await db.select({
        slug: contentCategories.categorySlug,
        category: interestCategories
      }).from(contentCategories).innerJoin(posts, eq6(contentCategories.postId, posts.id)).leftJoin(interestCategories, eq6(contentCategories.categoryId, interestCategories.id)).where(eq6(posts.authorId, userId)).limit(10);
      res.json({
        interests: interests.map((i) => ({
          slug: i.interest,
          name: i.category?.name || i.interest,
          icon: i.category?.icon,
          color: i.category?.color,
          affinity: i.affinityScore
        })),
        detectedPatterns: recentCategories.map((c) => ({
          slug: c.slug,
          name: c.category?.name || c.slug
        }))
      });
    } catch (error) {
      console.error("Error fetching algorithm preferences:", error);
      res.status(500).json({ error: "Failed to fetch preferences" });
    }
  });
  app2.get("/api/onboarding/elite-circle", async (req, res) => {
    try {
      const eliteUsers = await db.select({
        id: users.id,
        username: users.username,
        displayName: users.displayName,
        avatarUrl: users.avatarUrl,
        netWorth: users.netWorth,
        netWorthTier: users.netWorthTier,
        influenceScore: users.influenceScore,
        isVerified: users.isVerified,
        bio: users.bio,
        industry: users.industry
      }).from(users).where(
        and5(
          sql6`${users.netWorth} > 0`,
          sql6`${users.profileVisibility} != 'NOBODY'`,
          sql6`${users.netWorthVisibility} != 'NOBODY'`
        )
      ).orderBy(desc4(users.netWorth)).limit(5);
      const formattedUsers = eliteUsers.map((user, index3) => ({
        ...user,
        rank: index3 + 1,
        formattedNetWorth: formatNetWorth(user.netWorth || 0),
        tierBadge: getTierBadge(user.netWorthTier || "BUILDING")
      }));
      res.json({
        eliteCircle: formattedUsers,
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
        totalEliteMembers: formattedUsers.length
      });
    } catch (error) {
      console.error("Error fetching elite circle:", error);
      res.status(500).json({ error: "Failed to fetch elite circle" });
    }
  });
  console.log("Onboarding routes registered successfully");
}
function formatNetWorth(netWorth) {
  if (netWorth >= 1e9) {
    return `$${(netWorth / 1e9).toFixed(1)}B`;
  } else if (netWorth >= 1e6) {
    return `$${(netWorth / 1e6).toFixed(1)}M`;
  } else if (netWorth >= 1e3) {
    return `$${(netWorth / 1e3).toFixed(0)}K`;
  }
  return `$${netWorth.toLocaleString()}`;
}
function getTierBadge(tier) {
  const tiers = {
    BUILDING: { name: "Building", color: "#6B7280", icon: "trending-up" },
    SILVER: { name: "Silver", color: "#9CA3AF", icon: "award" },
    GOLD: { name: "Gold", color: "#F59E0B", icon: "star" },
    PLATINUM: { name: "Platinum", color: "#8B5CF6", icon: "zap" },
    DIAMOND: { name: "Diamond", color: "#06B6D4", icon: "diamond" }
  };
  return tiers[tier] || tiers.BUILDING;
}

// server/routes-ads.ts
init_storage();
init_ads_storage();
init_db();
init_schema();
import { z as z3 } from "zod";
import { sql as sql9, eq as eq9, desc as desc7, and as and8, gte as gte5 } from "drizzle-orm";
async function sendAdNotification(advertiserId, type, entityId) {
  try {
    const [advertiser] = await db.select().from(advertisers).where(eq9(advertisers.id, advertiserId));
    if (advertiser?.userId) {
      await storage.createNotification(advertiser.userId, "system", type, entityId);
    }
  } catch (error) {
    console.error("Failed to send ad notification:", error);
  }
}
var createAdvertiserSchema = z3.object({
  businessName: z3.string().min(1).max(200),
  businessType: z3.enum(["INDIVIDUAL", "SMALL_BUSINESS", "ENTERPRISE", "AGENCY", "NON_PROFIT"]).optional(),
  website: z3.string().url().optional(),
  industry: z3.string().optional(),
  country: z3.string().optional(),
  registrationNumber: z3.string().optional(),
  taxId: z3.string().optional(),
  billingEmail: z3.string().email().optional()
});
var createCampaignSchema = z3.object({
  name: z3.string().min(1).max(200),
  objective: z3.enum(["AWARENESS", "TRAFFIC", "ENGAGEMENT", "LEADS", "SALES", "APP_PROMOTION", "VIDEO_VIEWS", "COMMUNITY_GROWTH"]),
  budgetType: z3.enum(["DAILY", "LIFETIME"]).optional(),
  budgetAmount: z3.number().positive().optional(),
  bidStrategy: z3.enum(["LOWEST_COST", "TARGET_COST", "MANUAL"]).optional(),
  startDate: z3.string().datetime().optional(),
  endDate: z3.string().datetime().optional()
});
var createAdGroupSchema = z3.object({
  campaignId: z3.string().uuid(),
  name: z3.string().min(1).max(200),
  budgetAmount: z3.number().positive().optional(),
  bidAmount: z3.number().positive().optional(),
  billingModel: z3.enum(["CPM", "CPC", "CPV", "CPA"]).optional(),
  placements: z3.array(z3.enum(["FEED", "STORIES", "REELS", "DISCOVER", "MESSAGES", "MALL", "GOSSIP", "PROFILE"])).optional(),
  netWorthTiers: z3.array(z3.enum(["BUILDING", "SILVER", "GOLD", "PLATINUM", "DIAMOND"])).optional(),
  minInfluenceScore: z3.number().min(0).max(1e3).optional(),
  maxInfluenceScore: z3.number().min(0).max(1e3).optional(),
  ageMin: z3.number().min(18).max(65).optional(),
  ageMax: z3.number().min(18).max(65).optional(),
  genders: z3.array(z3.string()).optional(),
  countries: z3.array(z3.string()).optional(),
  interests: z3.array(z3.string()).optional(),
  frequencyCapImpressions: z3.number().min(1).max(100).optional(),
  frequencyCapPeriodHours: z3.number().min(1).max(168).optional()
});
var createAdSchema = z3.object({
  adGroupId: z3.string().uuid(),
  name: z3.string().min(1).max(200),
  format: z3.enum(["IMAGE", "VIDEO", "CAROUSEL", "STORIES", "COLLECTION", "VOICE", "POLL", "CONVERSATION", "DARK_POST"]),
  headline: z3.string().max(125).optional(),
  description: z3.string().max(1e3).optional(),
  callToAction: z3.string().max(50).optional(),
  destinationUrl: z3.string().url().optional(),
  primaryMediaUrl: z3.string().url().optional(),
  primaryMediaType: z3.string().optional(),
  carouselItems: z3.array(z3.object({
    mediaUrl: z3.string().url(),
    headline: z3.string().optional(),
    description: z3.string().optional(),
    destinationUrl: z3.string().url().optional()
  })).optional(),
  voiceUrl: z3.string().url().optional(),
  voiceDuration: z3.number().optional(),
  pollQuestion: z3.string().optional(),
  pollOptions: z3.array(z3.string()).optional()
});
var walletTopupSchema = z3.object({
  amount: z3.number().positive().min(5e3),
  paymentMethod: z3.enum(["PAYFAST", "BANK_TRANSFER", "PROMO_CODE"]),
  promoCode: z3.string().optional()
});
function registerAdsRoutes(app2, requireAuth5) {
  const requireAdmin = async (req, res, next) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Authentication required" });
    }
    const user = await storage.getUser(req.session.userId);
    if (!user?.isAdmin) {
      return res.status(403).json({ message: "Admin access required" });
    }
    next();
  };
  const getAdvertiserOrFail = async (userId) => {
    const advertiser = await getAdvertiserByUserId(userId);
    if (!advertiser) {
      throw new Error("Advertiser account not found");
    }
    return advertiser;
  };
  const logAuditAction = async (action, entityType, entityId, actorId, actorType, previousState = null, newState = null, req) => {
    await createAdAuditLog({
      advertiserId: actorType === "ADVERTISER" ? actorId : void 0,
      actorId,
      actorType,
      action,
      entityType,
      entityId,
      previousState,
      newState,
      changesSummary: `${action} on ${entityType}`,
      ipAddress: req.ip || "unknown",
      userAgent: req.headers["user-agent"] || "unknown"
    });
  };
  app2.post("/api/ads/advertisers", requireAuth5, async (req, res) => {
    try {
      const data = createAdvertiserSchema.parse(req.body);
      const userId = req.session.userId;
      const existing = await getAdvertiserByUserId(userId);
      if (existing) {
        return res.status(400).json({ message: "Advertiser account already exists" });
      }
      const advertiser = await createAdvertiser({
        userId,
        ...data
      });
      await createWalletAccount(advertiser.id);
      await logAuditAction("ADVERTISER_CREATED", "advertiser", advertiser.id, userId, "ADVERTISER", null, advertiser, req);
      res.status(201).json(advertiser);
    } catch (error) {
      console.error("Failed to create advertiser:", error);
      res.status(400).json({ message: error.message || "Failed to create advertiser" });
    }
  });
  app2.get("/api/ads/advertisers/me", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserByUserId(req.session.userId);
      if (!advertiser) {
        return res.status(404).json({ message: "Advertiser account not found" });
      }
      const wallet = await getWalletByAdvertiserId(advertiser.id);
      const achievements2 = await getAdvertiserAchievements(advertiser.id);
      res.json({ ...advertiser, wallet, achievements: achievements2 });
    } catch (error) {
      console.error("Failed to get advertiser:", error);
      res.status(500).json({ message: "Failed to get advertiser" });
    }
  });
  app2.patch("/api/ads/advertisers/me", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const data = createAdvertiserSchema.partial().parse(req.body);
      const previousState = { ...advertiser };
      const updated = await updateAdvertiser(advertiser.id, data);
      await logAuditAction("ADVERTISER_UPDATED", "advertiser", advertiser.id, req.session.userId, "ADVERTISER", previousState, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update advertiser:", error);
      res.status(400).json({ message: error.message || "Failed to update advertiser" });
    }
  });
  app2.get("/api/ads/wallet", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const wallet = await getWalletByAdvertiserId(advertiser.id);
      if (!wallet) {
        return res.status(404).json({ message: "Wallet not found" });
      }
      res.json(wallet);
    } catch (error) {
      console.error("Failed to get wallet:", error);
      res.status(500).json({ message: error.message || "Failed to get wallet" });
    }
  });
  app2.get("/api/ads/wallet/transactions", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const wallet = await getWalletByAdvertiserId(advertiser.id);
      if (!wallet) {
        return res.status(404).json({ message: "Wallet not found" });
      }
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const transactions = await getWalletTransactions(wallet.id, { limit, offset });
      res.json(transactions);
    } catch (error) {
      console.error("Failed to get transactions:", error);
      res.status(500).json({ message: "Failed to get transactions" });
    }
  });
  app2.post("/api/ads/wallet/topup", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const wallet = await getWalletByAdvertiserId(advertiser.id);
      if (!wallet) {
        return res.status(404).json({ message: "Wallet not found" });
      }
      if (wallet.isFrozen) {
        return res.status(403).json({ message: "Wallet is frozen. Contact support." });
      }
      const data = walletTopupSchema.parse(req.body);
      if (data.paymentMethod === "PROMO_CODE" && data.promoCode) {
        const promo = await getPromoCodeByCode(data.promoCode);
        if (!promo) {
          return res.status(400).json({ message: "Invalid promo code" });
        }
        if (promo.validUntil && new Date(promo.validUntil) < /* @__PURE__ */ new Date()) {
          return res.status(400).json({ message: "Promo code expired" });
        }
        const redeemResult = await atomicRedeemPromoCode(
          promo.id,
          advertiser.id,
          wallet.id,
          promo.amount,
          promo.usageLimit
        );
        if (!redeemResult.success) {
          return res.status(400).json({ message: redeemResult.error });
        }
        const balanceBefore = wallet.balance || 0;
        const updatedWallet = await updateWalletBalance(wallet.id, promo.amount, "credit");
        if (!updatedWallet) {
          return res.status(500).json({ message: "Failed to credit wallet" });
        }
        await createWalletTransaction({
          walletId: wallet.id,
          type: "PROMO_CREDIT",
          amount: promo.amount,
          balanceBefore,
          balanceAfter: updatedWallet.balance || 0,
          status: "COMPLETED",
          description: `Promo code: ${promo.code}`,
          promoCodeId: promo.id,
          completedAt: /* @__PURE__ */ new Date()
        });
        await logAuditAction("WALLET_TOPUP", "wallet", wallet.id, req.session.userId, "ADVERTISER", { balance: balanceBefore }, { balance: updatedWallet.balance }, req);
        return res.json({ success: true, wallet: updatedWallet });
      }
      if (data.paymentMethod === "PAYFAST") {
        const tx = await createWalletTransaction({
          walletId: wallet.id,
          type: "TOP_UP",
          amount: data.amount,
          balanceBefore: wallet.balance || 0,
          balanceAfter: (wallet.balance || 0) + data.amount,
          status: "PENDING",
          description: `PayFast top-up`,
          reference: `PAYFAST-${Date.now()}`
        });
        const payfastUrl = `/payfast/checkout?type=ad_wallet_topup&amount=${data.amount}&txId=${tx.id}`;
        return res.json({
          success: true,
          paymentUrl: payfastUrl,
          transactionId: tx.id
        });
      }
      if (data.paymentMethod === "BANK_TRANSFER") {
        const tx = await createWalletTransaction({
          walletId: wallet.id,
          type: "TOP_UP",
          amount: data.amount,
          balanceBefore: wallet.balance || 0,
          balanceAfter: (wallet.balance || 0) + data.amount,
          status: "PENDING",
          description: `Bank transfer - awaiting confirmation`,
          reference: `BANK-${Date.now()}`
        });
        return res.json({
          success: true,
          transactionId: tx.id,
          bankDetails: {
            bankName: "First National Bank",
            accountName: "RabitChat Advertising",
            accountNumber: "62XXXXXXXX",
            branchCode: "250655",
            reference: `ADV-${tx.id.slice(0, 8).toUpperCase()}`
          }
        });
      }
      res.status(400).json({ message: "Invalid payment method" });
    } catch (error) {
      console.error("Failed to top up wallet:", error);
      res.status(400).json({ message: error.message || "Failed to top up wallet" });
    }
  });
  app2.post("/api/ads/wallet/payfast/create", requireAuth5, async (req, res) => {
    try {
      const {
        isPayFastConfigured: isPayFastConfigured2,
        getPayFastUrl: getPayFastUrl2,
        createPaymentData: createPaymentData2,
        formatAmountCents: formatAmountCents2
      } = await Promise.resolve().then(() => (init_payfast(), payfast_exports));
      if (!isPayFastConfigured2()) {
        return res.status(500).json({ message: "PayFast is not configured" });
      }
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const wallet = await getWalletByAdvertiserId(advertiser.id);
      if (!wallet) {
        return res.status(404).json({ message: "Wallet not found" });
      }
      if (wallet.isFrozen) {
        return res.status(403).json({ message: "Wallet is frozen" });
      }
      const { amount } = req.body;
      if (!amount || amount < 5e3) {
        return res.status(400).json({ message: "Minimum top-up is R50.00 (5000 cents)" });
      }
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      const tx = await createWalletTransaction({
        walletId: wallet.id,
        type: "TOP_UP",
        amount,
        balanceBefore: wallet.balance || 0,
        balanceAfter: (wallet.balance || 0) + amount,
        status: "PENDING",
        description: `PayFast wallet top-up`,
        reference: `PAYFAST-${Date.now()}`
      });
      const host = req.get("host") || process.env.REPLIT_DEV_DOMAIN || "localhost:5000";
      const protocol = req.get("x-forwarded-proto") || req.protocol || "https";
      const baseUrl = `${protocol}://${host}`;
      const amountInRands = formatAmountCents2(amount);
      const paymentData = createPaymentData2({
        orderId: `ADWALLET-${tx.id}`,
        amount: amountInRands,
        itemName: "RabitChat Ads Wallet Top-Up",
        itemDescription: `Add R${amountInRands.toFixed(2)} to your advertising wallet`,
        email: user.email || void 0,
        firstName: user.displayName?.split(" ")[0] || user.username,
        lastName: user.displayName?.split(" ").slice(1).join(" ") || void 0,
        returnUrl: `${baseUrl}/api/ads/wallet/payfast/return?tx_id=${tx.id}`,
        cancelUrl: `${baseUrl}/api/ads/wallet/payfast/cancel?tx_id=${tx.id}`,
        notifyUrl: `${baseUrl}/api/ads/wallet/payfast/notify`,
        userId: req.session.userId
      });
      res.json({
        transactionId: tx.id,
        paymentUrl: getPayFastUrl2(),
        paymentData,
        topup: {
          amount,
          amountRands: amountInRands
        }
      });
    } catch (error) {
      console.error("[PayFast Ads] Failed to create payment:", error);
      res.status(400).json({ message: error.message || "Failed to create payment" });
    }
  });
  app2.post("/api/ads/wallet/payfast/complete-topup", requireAuth5, async (req, res) => {
    try {
      const { transactionId } = req.body;
      console.log("[PayFast Ads Complete] Starting top-up completion for transaction:", transactionId);
      console.log("[PayFast Ads Complete] User ID from session:", req.session.userId);
      if (!transactionId) {
        console.log("[PayFast Ads Complete] No transaction ID provided");
        return res.status(400).json({ success: false, message: "Transaction ID is required" });
      }
      const transaction = await getTransactionById(transactionId);
      console.log("[PayFast Ads Complete] Transaction found:", transaction ? "yes" : "no");
      if (!transaction) {
        console.log("[PayFast Ads Complete] Transaction not found:", transactionId);
        return res.status(404).json({ success: false, message: "Transaction not found" });
      }
      console.log("[PayFast Ads Complete] Transaction details:", {
        id: transaction.id,
        walletId: transaction.walletId,
        amount: transaction.amount,
        status: transaction.status,
        type: transaction.type
      });
      if (transaction.status === "COMPLETED") {
        console.log("[PayFast Ads Complete] Transaction already completed");
        const wallet2 = await getWalletById(transaction.walletId);
        return res.json({
          success: true,
          message: "Top-up already completed",
          newBalance: wallet2?.balance || 0,
          alreadyCompleted: true
        });
      }
      if (transaction.status === "FAILED" || transaction.status === "CANCELLED") {
        console.log("[PayFast Ads Complete] Transaction already failed/cancelled");
        const wallet2 = await getWalletById(transaction.walletId);
        return res.json({
          success: false,
          message: `Transaction was ${transaction.status.toLowerCase()}`,
          newBalance: wallet2?.balance || 0
        });
      }
      const wallet = await getWalletById(transaction.walletId);
      if (!wallet) {
        console.log("[PayFast Ads Complete] Wallet not found:", transaction.walletId);
        return res.status(404).json({ success: false, message: "Wallet not found" });
      }
      const advertiser = await getAdvertiserById(wallet.advertiserId);
      if (!advertiser || advertiser.userId !== req.session.userId) {
        console.log("[PayFast Ads Complete] User mismatch");
        return res.json({ success: false, message: "Transaction does not belong to this user" });
      }
      console.log("[PayFast Ads Complete] Crediting wallet with amount:", transaction.amount);
      const balanceBefore = wallet.balance || 0;
      const updatedWallet = await updateWalletBalance(wallet.id, transaction.amount, "credit");
      if (!updatedWallet) {
        throw new Error("Failed to update wallet balance");
      }
      console.log("[PayFast Ads Complete] Wallet updated. Before:", balanceBefore, "After:", updatedWallet.balance);
      await updateTransaction(transactionId, {
        status: "COMPLETED",
        balanceBefore,
        balanceAfter: updatedWallet.balance || 0,
        completedAt: /* @__PURE__ */ new Date()
      });
      console.log("[PayFast Ads Complete] Transaction marked as COMPLETED");
      await logAuditAction(
        "WALLET_TOPUP",
        "wallet",
        wallet.id,
        req.session.userId,
        "ADVERTISER",
        { balance: balanceBefore },
        { balance: updatedWallet.balance, amount: transaction.amount },
        req
      );
      res.json({
        success: true,
        message: "Top-up completed successfully",
        newBalance: updatedWallet.balance || 0,
        amountAdded: transaction.amount
      });
    } catch (error) {
      console.error("[PayFast Ads Complete] Error:", error);
      res.status(500).json({ success: false, message: error.message || "Failed to complete top-up" });
    }
  });
  app2.get("/api/ads/wallet/payfast/checkout/:transactionId", async (req, res) => {
    try {
      const {
        isPayFastConfigured: isPayFastConfigured2,
        getPayFastUrl: getPayFastUrl2,
        createPaymentData: createPaymentData2,
        formatAmountCents: formatAmountCents2
      } = await Promise.resolve().then(() => (init_payfast(), payfast_exports));
      if (!isPayFastConfigured2()) {
        return res.status(500).send("PayFast is not configured");
      }
      const { transactionId } = req.params;
      const tx = await getTransactionById(transactionId);
      if (!tx) {
        return res.status(404).send("Transaction not found");
      }
      if (tx.status !== "PENDING") {
        return res.status(400).send("Transaction is no longer pending");
      }
      const wallet = await getWalletById(tx.walletId);
      if (!wallet) {
        return res.status(404).send("Wallet not found");
      }
      const advertiser = await getAdvertiserById(wallet.advertiserId);
      if (!advertiser) {
        return res.status(404).send("Advertiser not found");
      }
      const user = await storage.getUser(advertiser.userId);
      if (!user) {
        return res.status(404).send("User not found");
      }
      const host = req.get("host") || process.env.REPLIT_DEV_DOMAIN || "localhost:5000";
      const protocol = req.get("x-forwarded-proto") || req.protocol || "https";
      const baseUrl = `${protocol}://${host}`;
      const amountInRands = formatAmountCents2(tx.amount);
      const paymentData = createPaymentData2({
        orderId: `ADWALLET-${tx.id}`,
        amount: amountInRands,
        itemName: "RabitChat Ads Wallet Top-Up",
        itemDescription: `Add R${amountInRands.toFixed(2)} to your advertising wallet`,
        email: user.email || void 0,
        firstName: user.displayName?.split(" ")[0] || user.username,
        lastName: user.displayName?.split(" ").slice(1).join(" ") || void 0,
        returnUrl: `${baseUrl}/api/ads/wallet/payfast/return?tx_id=${tx.id}`,
        cancelUrl: `${baseUrl}/api/ads/wallet/payfast/cancel?tx_id=${tx.id}`,
        notifyUrl: `${baseUrl}/api/ads/wallet/payfast/notify`,
        userId: advertiser.userId
      });
      const payFastUrl = getPayFastUrl2();
      const formFields = Object.entries(paymentData).filter(([_, value]) => value !== void 0 && value !== "").map(([key, value]) => `<input type="hidden" name="${key}" value="${String(value).replace(/"/g, "&quot;")}" />`).join("\n");
      const html = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>Complete Your Payment</title>
          <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
          <meta name="format-detection" content="telephone=no">
          <style>
            * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
              display: flex;
              justify-content: center;
              align-items: center;
              min-height: 100vh;
              margin: 0;
              padding: 20px;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
            }
            .container {
              text-align: center;
              padding: 40px 30px;
              background: rgba(255,255,255,0.15);
              border-radius: 24px;
              backdrop-filter: blur(10px);
              -webkit-backdrop-filter: blur(10px);
              max-width: 400px;
              width: 100%;
            }
            .logo {
              font-size: 48px;
              margin-bottom: 16px;
            }
            h2 {
              margin: 0 0 8px 0;
              font-size: 24px;
            }
            .amount {
              font-size: 36px;
              font-weight: bold;
              margin: 20px 0;
              color: #FFD700;
            }
            p {
              margin: 0 0 24px 0;
              opacity: 0.9;
              font-size: 15px;
              line-height: 1.5;
            }
            .btn {
              display: block;
              width: 100%;
              margin-top: 10px;
              padding: 20px 30px;
              background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
              color: #1a1a2e;
              border: none;
              border-radius: 50px;
              font-size: 18px;
              font-weight: bold;
              cursor: pointer;
              text-decoration: none;
              box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
              -webkit-appearance: none;
              appearance: none;
              touch-action: manipulation;
            }
            .btn:active, .btn.pressed { 
              transform: scale(0.98);
              opacity: 0.9;
            }
            .btn.loading {
              opacity: 0.7;
              pointer-events: none;
            }
            .secure {
              margin-top: 24px;
              font-size: 13px;
              opacity: 0.7;
            }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="logo">\u{1F4B3}</div>
            <h2>Complete Your Payment</h2>
            <div class="amount">R${amountInRands}</div>
            <p>Tap the button below to pay securely with PayFast.</p>
            <form id="payfast-form" action="${payFastUrl}" method="POST">
              ${formFields}
              <input type="submit" class="btn" value="Pay Now with PayFast">
            </form>
            <p class="secure">\u{1F512} Secured by PayFast</p>
          </div>
        </body>
        </html>
      `;
      res.type("html").send(html);
    } catch (error) {
      console.error("[PayFast Ads Checkout] Error:", error);
      res.status(500).send("Failed to load checkout page");
    }
  });
  app2.post("/api/ads/wallet/payfast/notify", async (req, res) => {
    try {
      const { validateITNSignature: validateITNSignature2 } = await Promise.resolve().then(() => (init_payfast(), payfast_exports));
      console.log("[PayFast Ads ITN] Received:", JSON.stringify(req.body));
      const data = req.body;
      if (!validateITNSignature2(data)) {
        console.error("[PayFast Ads ITN] Invalid signature");
        return res.status(400).send("Invalid signature");
      }
      const paymentId = data.m_payment_id;
      if (!paymentId?.startsWith("ADWALLET-")) {
        console.log("[PayFast Ads ITN] Not an ad wallet payment, ignoring");
        return res.status(200).send("OK");
      }
      const txId = paymentId.replace("ADWALLET-", "");
      const transaction = await getTransactionById(txId);
      if (!transaction) {
        console.error("[PayFast Ads ITN] Transaction not found:", txId);
        return res.status(404).send("Transaction not found");
      }
      if (transaction.status === "COMPLETED") {
        console.log("[PayFast Ads ITN] Transaction already processed, ignoring duplicate ITN:", txId);
        return res.status(200).send("OK");
      }
      if (transaction.status === "FAILED" || transaction.status === "CANCELLED") {
        console.log("[PayFast Ads ITN] Transaction already marked as failed/cancelled:", txId);
        return res.status(200).send("OK");
      }
      if (data.payment_status === "COMPLETE") {
        const wallet = await getWalletById(transaction.walletId);
        if (wallet) {
          try {
            const updatedWallet = await updateWalletBalance(wallet.id, transaction.amount, "credit");
            if (!updatedWallet) {
              throw new Error("Wallet update returned null");
            }
            await updateTransaction(txId, {
              status: "COMPLETED",
              reference: data.pf_payment_id,
              balanceBefore: wallet.balance || 0,
              balanceAfter: updatedWallet.balance || 0,
              completedAt: /* @__PURE__ */ new Date()
            });
            console.log("[PayFast Ads ITN] Wallet credited:", transaction.amount, "to wallet:", wallet.id);
          } catch (error) {
            console.error("[PayFast Ads ITN] Failed to credit wallet:", error.message);
            await updateTransaction(txId, {
              status: "FAILED",
              reference: data.pf_payment_id
            });
          }
        }
      } else {
        await updateTransaction(txId, {
          status: "FAILED",
          reference: data.pf_payment_id
        });
      }
      res.status(200).send("OK");
    } catch (error) {
      console.error("[PayFast Ads ITN] Error:", error);
      res.status(500).send("Error processing notification");
    }
  });
  app2.get("/api/ads/wallet/payfast/return", async (req, res) => {
    const txId = req.query.tx_id;
    console.log("[PayFast Ads] User returned from payment, tx:", txId);
    res.send(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>Payment Processing</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style>
            body { 
              font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
              display: flex; 
              align-items: center; 
              justify-content: center; 
              min-height: 100vh; 
              margin: 0;
              background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
              color: white;
            }
            .container { 
              text-align: center; 
              padding: 40px;
              background: rgba(255,255,255,0.1);
              border-radius: 16px;
              backdrop-filter: blur(10px);
            }
            h1 { color: #9333EA; margin-bottom: 16px; }
            p { color: rgba(255,255,255,0.7); margin-bottom: 24px; }
            .loader {
              width: 48px;
              height: 48px;
              border: 4px solid rgba(147, 51, 234, 0.2);
              border-top-color: #9333EA;
              border-radius: 50%;
              animation: spin 1s linear infinite;
              margin: 0 auto 24px;
            }
            @keyframes spin { to { transform: rotate(360deg); } }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="success-icon">\u2713</div>
            <h1>Payment Complete!</h1>
            <p>Your wallet top-up is being processed. Your balance will update shortly.</p>
            <a href="rabitchat://wallet" class="btn">Return to App</a>
            <p class="hint">Or close this window to return to the app</p>
          </div>
          <style>
            .success-icon { font-size: 48px; color: #22C55E; margin-bottom: 16px; }
            .btn { 
              display: inline-block; 
              background: #9333EA; 
              color: white; 
              padding: 16px 32px; 
              border-radius: 12px; 
              text-decoration: none; 
              font-weight: 600;
              margin-top: 16px;
            }
            .hint { font-size: 12px; opacity: 0.5; margin-top: 16px; }
          </style>
        </body>
      </html>
    `);
  });
  app2.get("/api/ads/wallet/payfast/cancel", async (req, res) => {
    const txId = req.query.tx_id;
    console.log("[PayFast Ads] User cancelled payment, tx:", txId);
    if (txId) {
      await updateTransaction(txId, { status: "CANCELLED" });
    }
    res.send(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>Payment Cancelled</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style>
            body { 
              font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
              display: flex; 
              align-items: center; 
              justify-content: center; 
              min-height: 100vh; 
              margin: 0;
              background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
              color: white;
            }
            .container { 
              text-align: center; 
              padding: 40px;
              background: rgba(255,255,255,0.1);
              border-radius: 16px;
              backdrop-filter: blur(10px);
            }
            h1 { color: #EF4444; margin-bottom: 16px; }
            p { color: rgba(255,255,255,0.7); }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="cancel-icon">\u2715</div>
            <h1>Payment Cancelled</h1>
            <p>Your wallet top-up was cancelled. No charges were made.</p>
            <a href="rabitchat://wallet" class="btn">Return to App</a>
          </div>
          <style>
            .cancel-icon { font-size: 48px; color: #EF4444; margin-bottom: 16px; }
            .btn { 
              display: inline-block; 
              background: #9333EA; 
              color: white; 
              padding: 16px 32px; 
              border-radius: 12px; 
              text-decoration: none; 
              font-weight: 600;
              margin-top: 16px;
            }
          </style>
        </body>
      </html>
    `);
  });
  app2.get("/api/ads/wallet/payfast/status/:txId", requireAuth5, async (req, res) => {
    try {
      const transaction = await getTransactionById(req.params.txId);
      if (!transaction) {
        return res.status(404).json({ message: "Transaction not found" });
      }
      res.json({ status: transaction.status });
    } catch (error) {
      console.error("[PayFast Ads] Status check error:", error);
      res.status(500).json({ message: "Failed to check status" });
    }
  });
  app2.post("/api/ads/advertiser/register", requireAuth5, async (req, res) => {
    try {
      const userId = req.session.userId;
      const existing = await getAdvertiserByUserId(userId);
      if (existing) {
        return res.json(existing);
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      const { companyName, businessType } = req.body;
      const advertiser = await createAdvertiser({
        userId,
        businessName: companyName || user.displayName || user.username,
        businessType: businessType || "INDIVIDUAL",
        status: "ACTIVE"
      });
      await createWalletAccount(advertiser.id);
      await logAuditAction("ADVERTISER_CREATED", "advertiser", advertiser.id, userId, "ADVERTISER", null, advertiser, req);
      res.status(201).json(advertiser);
    } catch (error) {
      console.error("Failed to register advertiser:", error);
      res.status(400).json({ message: error.message || "Failed to register advertiser" });
    }
  });
  app2.get("/api/ads/advertiser/me", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserByUserId(req.session.userId);
      if (!advertiser) {
        return res.status(404).json({ message: "Advertiser account not found" });
      }
      const wallet = await getWalletByAdvertiserId(advertiser.id);
      res.json({ ...advertiser, wallet });
    } catch (error) {
      console.error("Failed to get advertiser:", error);
      res.status(500).json({ message: "Failed to get advertiser" });
    }
  });
  app2.post("/api/ads/boost-post", requireAuth5, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { postId, budget, durationDays, targeting, callToAction, destinationUrl: customDestinationUrl } = req.body;
      if (!postId) {
        return res.status(400).json({ message: "Post ID is required" });
      }
      if (!budget || budget < 5e3) {
        return res.status(400).json({ message: "Minimum budget is R50 (5000 cents)" });
      }
      if (!durationDays || durationDays < 1) {
        return res.status(400).json({ message: "Duration must be at least 1 day" });
      }
      if (durationDays > 90) {
        return res.status(400).json({ message: "Maximum campaign duration is 90 days" });
      }
      if (budget > 1e8) {
        return res.status(400).json({ message: "Maximum budget is R1,000,000 (100000000 cents)" });
      }
      const autoCTAs = ["VISIT_PROFILE", "VIEW_POST"];
      const customCTAs = ["LEARN_MORE", "SHOP_NOW", "SIGN_UP", "CONTACT", "WATCH_MORE", "BOOK_NOW", "GET_OFFER", "DOWNLOAD", "APPLY_NOW"];
      const validCTAs = [...autoCTAs, ...customCTAs];
      const selectedCTA = callToAction && validCTAs.includes(callToAction) ? callToAction : "VISIT_PROFILE";
      let validatedDestinationUrl;
      if (customCTAs.includes(selectedCTA)) {
        if (!customDestinationUrl) {
          return res.status(400).json({
            message: `A destination URL is required for "${selectedCTA}" call-to-action`
          });
        }
        try {
          const url = new URL(customDestinationUrl);
          if (url.protocol !== "https:" && url.protocol !== "http:") {
            return res.status(400).json({ message: "Destination URL must be a valid web address" });
          }
          if (url.protocol === "http:") {
            console.log(`[Boost] Warning: Non-HTTPS URL used: ${customDestinationUrl}`);
          }
          validatedDestinationUrl = customDestinationUrl;
        } catch (e) {
          return res.status(400).json({ message: "Invalid destination URL format. Please enter a valid website address (e.g., https://yoursite.com)" });
        }
      }
      const post = await storage.getPost(postId);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (post.authorId !== userId) {
        return res.status(403).json({ message: "You can only boost your own posts" });
      }
      let advertiser = await getAdvertiserByUserId(userId);
      if (!advertiser) {
        const user2 = await storage.getUser(userId);
        advertiser = await createAdvertiser({
          userId,
          businessName: user2?.displayName || user2?.username || "Personal",
          businessType: "INDIVIDUAL",
          status: "ACTIVE"
        });
        await createWalletAccount(advertiser.id);
      }
      const wallet = await getWalletByAdvertiserId(advertiser.id);
      if (!wallet) {
        return res.status(500).json({ message: "Wallet not found" });
      }
      const totalCost = budget * durationDays;
      if ((wallet.balance || 0) < totalCost) {
        return res.status(400).json({
          message: `Insufficient balance. Need R${(totalCost / 100).toFixed(2)}, have R${((wallet.balance || 0) / 100).toFixed(2)}`
        });
      }
      const startDate = /* @__PURE__ */ new Date();
      const endDate = /* @__PURE__ */ new Date();
      endDate.setDate(endDate.getDate() + durationDays);
      const campaign = await createCampaign({
        advertiserId: advertiser.id,
        name: `Boost: ${post.content?.substring(0, 50) || "Post"}...`,
        objective: "BOOST_POST",
        budgetType: "LIFETIME",
        budgetAmount: totalCost,
        bidStrategy: "LOWEST_COST",
        startDate,
        endDate,
        status: "PENDING_REVIEW"
      });
      const adGroup = await createAdGroup({
        campaignId: campaign.id,
        name: "Boosted Post Targeting",
        budgetAmount: totalCost,
        billingModel: "CPM",
        placements: ["FEED", "STORIES", "DISCOVER"],
        netWorthTiers: targeting?.netWorthTiers || ["BUILDING", "SILVER", "GOLD", "PLATINUM", "DIAMOND"],
        interests: targeting?.interests || [],
        status: "ACTIVE"
      });
      const adFormat = post.type === "VIDEO" ? "VIDEO" : post.type === "VOICE" ? "VOICE" : "IMAGE";
      const user = await storage.getUser(userId);
      const postDeepLink = `rabitchat://post/${postId}`;
      const profileUrl = `rabitchat://profile/${user?.username || userId}`;
      let finalDestinationUrl;
      if (selectedCTA === "VISIT_PROFILE") {
        finalDestinationUrl = profileUrl;
      } else if (selectedCTA === "VIEW_POST") {
        finalDestinationUrl = postDeepLink;
      } else if (validatedDestinationUrl) {
        finalDestinationUrl = validatedDestinationUrl;
      } else {
        finalDestinationUrl = postDeepLink;
      }
      const ad = await createAd({
        campaignId: campaign.id,
        adGroupId: adGroup.id,
        advertiserId: advertiser.id,
        name: "Boosted Post",
        format: adFormat,
        headline: post.content?.substring(0, 125) || "",
        description: `Boosted from post: ${postId}
${post.content || ""}`,
        primaryMediaUrl: post.mediaUrl || void 0,
        primaryMediaType: post.type || "TEXT",
        status: "PENDING_REVIEW",
        callToAction: selectedCTA,
        destinationUrl: finalDestinationUrl
      });
      console.log(`[Boost] Created ad with CTA: ${selectedCTA}, destination: ${finalDestinationUrl}`);
      await createWalletTransaction({
        walletId: wallet.id,
        type: "ADJUSTMENT",
        amount: 0,
        // No actual deduction - budget is reserved but not spent
        balanceBefore: wallet.balance || 0,
        balanceAfter: wallet.balance || 0,
        status: "COMPLETED",
        description: `Budget reserved for boost - R${(totalCost / 100).toFixed(2)} for ${durationDays} day(s)`,
        campaignId: campaign.id,
        completedAt: /* @__PURE__ */ new Date()
      });
      await logAuditAction("POST_BOOSTED", "campaign", campaign.id, userId, "ADVERTISER", null, { campaign, ad, postId }, req);
      res.status(201).json({
        success: true,
        campaign,
        ad,
        message: "Post boost submitted for review"
      });
    } catch (error) {
      console.error("Failed to boost post:", error);
      res.status(400).json({ message: error.message || "Failed to boost post" });
    }
  });
  app2.get("/api/ads/campaigns", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const status = req.query.status;
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const campaigns = await getCampaignsByAdvertiser(advertiser.id, { status, limit, offset });
      const terminalStatuses = ["ACTIVE", "PAUSED", "COMPLETED", "DISABLED", "ARCHIVED", "REJECTED"];
      const enrichedCampaigns = await Promise.all(
        campaigns.map(async (campaign) => {
          const ads2 = await getAdsByCampaign(campaign.id);
          const ad = ads2.length > 0 ? ads2[0] : null;
          const adStatus = ad?.status || void 0;
          const adNumber = ad?.adNumber || void 0;
          const adId = ad?.id || void 0;
          let campaignStatus = campaign.status;
          if (ad && (ad.status === "APPROVED" || ad.status === "ACTIVE") && !terminalStatuses.includes(campaign.status)) {
            await updateCampaign(campaign.id, { status: "ACTIVE" });
            campaignStatus = "ACTIVE";
            console.log(`[Auto-Fix] Campaign ${campaign.id} auto-activated on fetch - ad ${adNumber || adId} is ${ad.status}`);
          }
          return {
            ...campaign,
            status: campaignStatus,
            // Use possibly-fixed status
            adStatus,
            adNumber,
            adId
          };
        })
      );
      res.json(enrichedCampaigns);
    } catch (error) {
      console.error("Failed to get campaigns:", error);
      res.status(500).json({ message: error.message || "Failed to get campaigns" });
    }
  });
  app2.post("/api/ads/campaigns/sync", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const campaigns = await getCampaignsByAdvertiser(advertiser.id, { limit: 100 });
      const terminalStatuses = ["ACTIVE", "PAUSED", "COMPLETED", "DISABLED", "ARCHIVED", "REJECTED"];
      const fixed = [];
      for (const campaign of campaigns) {
        const ads2 = await getAdsByCampaign(campaign.id);
        const ad = ads2.length > 0 ? ads2[0] : null;
        if (ad && (ad.status === "APPROVED" || ad.status === "ACTIVE") && !terminalStatuses.includes(campaign.status)) {
          const previousStatus = campaign.status;
          await updateCampaign(campaign.id, { status: "ACTIVE" });
          fixed.push({
            campaignId: campaign.id,
            adNumber: ad.adNumber || "N/A",
            previousStatus
          });
          console.log(`[User Sync] Campaign ${campaign.id} activated - ad ${ad.adNumber || ad.id} is ${ad.status}`);
        }
      }
      res.json({
        message: `Synced ${fixed.length} campaigns`,
        fixed,
        totalCampaigns: campaigns.length
      });
    } catch (error) {
      console.error("Failed to sync campaigns:", error);
      res.status(500).json({ message: error.message || "Failed to sync campaigns" });
    }
  });
  app2.get("/api/ads/campaigns/:id/debug", requireAuth5, async (req, res) => {
    try {
      const campaign = await getCampaignById(req.params.id);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const ads2 = await getAdsByCampaign(campaign.id);
      res.json({
        campaign: {
          id: campaign.id,
          status: campaign.status,
          objective: campaign.objective,
          createdAt: campaign.createdAt
        },
        ads: ads2.map((ad) => ({
          id: ad.id,
          adNumber: ad.adNumber,
          status: ad.status,
          createdAt: ad.createdAt,
          reviewedAt: ad.reviewedAt
        })),
        diagnosis: {
          hasAds: ads2.length > 0,
          firstAdStatus: ads2[0]?.status || "NO_ADS",
          campaignStatus: campaign.status,
          isOrphaned: ads2.some((a) => a.status === "APPROVED" || a.status === "ACTIVE") && campaign.status !== "ACTIVE",
          recommendation: ads2.some((a) => a.status === "APPROVED" || a.status === "ACTIVE") && campaign.status !== "ACTIVE" ? "Campaign should be ACTIVE but is not. Call POST /api/ads/campaigns/sync to fix." : "Status looks correct"
        }
      });
    } catch (error) {
      console.error("Failed to debug campaign:", error);
      res.status(500).json({ message: error.message || "Failed to debug campaign" });
    }
  });
  app2.post("/api/ads/campaigns", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      if (advertiser.status !== "ACTIVE") {
        return res.status(403).json({ message: "Your advertiser account must be active to create campaigns" });
      }
      const data = createCampaignSchema.parse(req.body);
      const campaign = await createCampaign({
        advertiserId: advertiser.id,
        name: data.name,
        objective: data.objective,
        budgetType: data.budgetType,
        budgetAmount: data.budgetAmount ? Math.round(data.budgetAmount * 100) : 0,
        bidStrategy: data.bidStrategy,
        startDate: data.startDate ? new Date(data.startDate) : void 0,
        endDate: data.endDate ? new Date(data.endDate) : void 0
      });
      await logAuditAction("CAMPAIGN_CREATED", "campaign", campaign.id, req.session.userId, "ADVERTISER", null, campaign, req);
      res.status(201).json(campaign);
    } catch (error) {
      console.error("Failed to create campaign:", error);
      res.status(400).json({ message: error.message || "Failed to create campaign" });
    }
  });
  app2.get("/api/ads/campaigns/:id", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const campaign = await getCampaignById(req.params.id);
      if (!campaign || campaign.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const adGroups2 = await getAdGroupsByCampaign(campaign.id);
      const diagnostics = await getCampaignDiagnostics(campaign.id);
      const campaignAds = await getAdsByCampaign(campaign.id);
      const adStatus = campaignAds.length > 0 ? campaignAds[0].status : void 0;
      let postPreview = null;
      if (campaignAds.length > 0) {
        const ad = campaignAds[0];
        const descMatch = ad.description?.match(/Boosted from post: ([a-f0-9-]+)/);
        const postId = descMatch ? descMatch[1] : null;
        if (postId) {
          const { storage: storage2 } = await Promise.resolve().then(() => (init_storage(), storage_exports));
          const post = await storage2.getPost(postId);
          if (post) {
            postPreview = {
              id: post.id,
              content: post.content || "",
              mediaUrl: post.mediaUrl,
              mediaType: post.type,
              // Post uses 'type' field for TEXT/PHOTO/VIDEO
              user: post.author ? {
                displayName: post.author.displayName,
                username: post.author.username,
                profilePicUrl: post.author.avatarUrl
              } : void 0
            };
          }
        }
      }
      const adNumber = campaignAds.length > 0 ? campaignAds[0].adNumber : void 0;
      const adId = campaignAds.length > 0 ? campaignAds[0].id : void 0;
      const callToAction = campaignAds.length > 0 ? campaignAds[0].callToAction : void 0;
      const destinationUrl = campaignAds.length > 0 ? campaignAds[0].destinationUrl : void 0;
      res.json({ ...campaign, adGroups: adGroups2, diagnostics, adStatus, adNumber, adId, postPreview, callToAction, destinationUrl });
    } catch (error) {
      console.error("Failed to get campaign:", error);
      res.status(500).json({ message: error.message || "Failed to get campaign" });
    }
  });
  app2.patch("/api/ads/campaigns/:id", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const campaign = await getCampaignById(req.params.id);
      if (!campaign || campaign.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const data = createCampaignSchema.partial().parse(req.body);
      const previousState = { ...campaign };
      const updated = await updateCampaign(campaign.id, {
        ...data,
        budgetAmount: data.budgetAmount ? Math.round(data.budgetAmount * 100) : void 0,
        startDate: data.startDate ? new Date(data.startDate) : void 0,
        endDate: data.endDate ? new Date(data.endDate) : void 0
      });
      await logAuditAction("CAMPAIGN_UPDATED", "campaign", campaign.id, req.session.userId, "ADVERTISER", previousState, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update campaign:", error);
      res.status(400).json({ message: error.message || "Failed to update campaign" });
    }
  });
  app2.post("/api/ads/campaigns/:id/submit", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const campaign = await getCampaignById(req.params.id);
      if (!campaign || campaign.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      if (campaign.status !== "DRAFT") {
        return res.status(400).json({ message: "Only draft campaigns can be submitted" });
      }
      const adGroups2 = await getAdGroupsByCampaign(campaign.id);
      if (adGroups2.length === 0) {
        return res.status(400).json({ message: "Campaign must have at least one ad group" });
      }
      let hasAds = false;
      for (const group of adGroups2) {
        const adsInGroup = await getAdsByAdGroup(group.id);
        if (adsInGroup.length > 0) {
          hasAds = true;
          break;
        }
      }
      if (!hasAds) {
        return res.status(400).json({ message: "Campaign must have at least one ad" });
      }
      const updated = await updateCampaign(campaign.id, {
        status: "PENDING_REVIEW",
        submittedAt: /* @__PURE__ */ new Date()
      });
      await logAuditAction("CAMPAIGN_SUBMITTED", "campaign", campaign.id, req.session.userId, "ADVERTISER", campaign, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to submit campaign:", error);
      res.status(400).json({ message: error.message || "Failed to submit campaign" });
    }
  });
  app2.post("/api/ads/campaigns/:id/pause", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const campaign = await getCampaignById(req.params.id);
      if (!campaign || campaign.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const updated = await updateCampaignStatus(campaign.id, "PAUSED", req.session.userId);
      await logAuditAction("CAMPAIGN_PAUSED", "campaign", campaign.id, req.session.userId, "ADVERTISER", campaign, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to pause campaign:", error);
      res.status(400).json({ message: error.message || "Failed to pause campaign" });
    }
  });
  app2.post("/api/ads/campaigns/:id/resume", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const campaign = await getCampaignById(req.params.id);
      if (!campaign || campaign.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      if (campaign.status !== "PAUSED") {
        return res.status(400).json({ message: "Only paused campaigns can be resumed" });
      }
      const campaignAds = await getAdsByCampaign(campaign.id);
      const hasApprovedAd = campaignAds.some((ad) => ad.status === "APPROVED" || ad.status === "ACTIVE");
      const hasPendingAd = campaignAds.some((ad) => ad.status === "PENDING_REVIEW" || ad.status === "IN_REVIEW");
      if (!hasApprovedAd && hasPendingAd) {
        return res.status(400).json({ message: "Cannot resume campaign while ads are pending review" });
      }
      const updated = await updateCampaignStatus(campaign.id, "ACTIVE");
      await logAuditAction("CAMPAIGN_RESUMED", "campaign", campaign.id, req.session.userId, "ADVERTISER", campaign, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to resume campaign:", error);
      res.status(400).json({ message: error.message || "Failed to resume campaign" });
    }
  });
  app2.get("/api/ads/ad-groups", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const campaignId = req.query.campaignId;
      if (!campaignId) {
        return res.status(400).json({ message: "Campaign ID required" });
      }
      const campaign = await getCampaignById(campaignId);
      if (!campaign || campaign.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const adGroups2 = await getAdGroupsByCampaign(campaignId);
      res.json(adGroups2);
    } catch (error) {
      console.error("Failed to get ad groups:", error);
      res.status(500).json({ message: error.message || "Failed to get ad groups" });
    }
  });
  app2.post("/api/ads/ad-groups", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const data = createAdGroupSchema.parse(req.body);
      const campaign = await getCampaignById(data.campaignId);
      if (!campaign || campaign.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const adGroup = await createAdGroup({
        campaignId: data.campaignId,
        name: data.name,
        budgetAmount: data.budgetAmount ? Math.round(data.budgetAmount * 100) : void 0,
        bidAmount: data.bidAmount ? Math.round(data.bidAmount * 100) : void 0,
        billingModel: data.billingModel,
        placements: data.placements || [],
        netWorthTiers: data.netWorthTiers || [],
        minInfluenceScore: data.minInfluenceScore,
        maxInfluenceScore: data.maxInfluenceScore,
        ageMin: data.ageMin,
        ageMax: data.ageMax,
        genders: data.genders || [],
        countries: data.countries || [],
        interests: data.interests || [],
        frequencyCapImpressions: data.frequencyCapImpressions,
        frequencyCapPeriodHours: data.frequencyCapPeriodHours
      });
      await logAuditAction("AD_GROUP_CREATED", "ad_group", adGroup.id, req.session.userId, "ADVERTISER", null, adGroup, req);
      res.status(201).json(adGroup);
    } catch (error) {
      console.error("Failed to create ad group:", error);
      res.status(400).json({ message: error.message || "Failed to create ad group" });
    }
  });
  app2.patch("/api/ads/ad-groups/:id", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const adGroup = await getAdGroupById(req.params.id);
      if (!adGroup) {
        return res.status(404).json({ message: "Ad group not found" });
      }
      const campaign = await getCampaignById(adGroup.campaignId);
      if (!campaign || campaign.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const data = createAdGroupSchema.partial().parse(req.body);
      const previousState = { ...adGroup };
      const updated = await updateAdGroup(adGroup.id, {
        ...data,
        budgetAmount: data.budgetAmount ? Math.round(data.budgetAmount * 100) : void 0,
        bidAmount: data.bidAmount ? Math.round(data.bidAmount * 100) : void 0
      });
      await logAuditAction("AD_GROUP_UPDATED", "ad_group", adGroup.id, req.session.userId, "ADVERTISER", previousState, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update ad group:", error);
      res.status(400).json({ message: error.message || "Failed to update ad group" });
    }
  });
  app2.get("/api/ads/ads", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const adGroupId = req.query.adGroupId;
      const campaignId = req.query.campaignId;
      if (adGroupId) {
        const adGroup = await getAdGroupById(adGroupId);
        if (!adGroup) {
          return res.status(404).json({ message: "Ad group not found" });
        }
        const campaign = await getCampaignById(adGroup.campaignId);
        if (!campaign || campaign.advertiserId !== advertiser.id) {
          return res.status(404).json({ message: "Campaign not found" });
        }
        const ads2 = await getAdsByAdGroup(adGroupId);
        return res.json(ads2);
      }
      if (campaignId) {
        const campaign = await getCampaignById(campaignId);
        if (!campaign || campaign.advertiserId !== advertiser.id) {
          return res.status(404).json({ message: "Campaign not found" });
        }
        const ads2 = await getAdsByCampaign(campaignId);
        return res.json(ads2);
      }
      return res.status(400).json({ message: "Campaign ID or Ad Group ID required" });
    } catch (error) {
      console.error("Failed to get ads:", error);
      res.status(500).json({ message: error.message || "Failed to get ads" });
    }
  });
  app2.post("/api/ads/ads", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const data = createAdSchema.parse(req.body);
      const adGroup = await getAdGroupById(data.adGroupId);
      if (!adGroup) {
        return res.status(404).json({ message: "Ad group not found" });
      }
      const campaign = await getCampaignById(adGroup.campaignId);
      if (!campaign || campaign.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const ad = await createAd({
        adGroupId: data.adGroupId,
        campaignId: adGroup.campaignId,
        advertiserId: advertiser.id,
        name: data.name,
        format: data.format,
        headline: data.headline,
        description: data.description,
        callToAction: data.callToAction,
        destinationUrl: data.destinationUrl,
        primaryMediaUrl: data.primaryMediaUrl,
        primaryMediaType: data.primaryMediaType,
        carouselItems: data.carouselItems || [],
        voiceUrl: data.voiceUrl,
        voiceDuration: data.voiceDuration,
        pollQuestion: data.pollQuestion,
        pollOptions: data.pollOptions || []
      });
      await logAuditAction("AD_CREATED", "ad", ad.id, req.session.userId, "ADVERTISER", null, ad, req);
      res.status(201).json(ad);
    } catch (error) {
      console.error("Failed to create ad:", error);
      res.status(400).json({ message: error.message || "Failed to create ad" });
    }
  });
  app2.get("/api/ads/ads/:id", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const ad = await getAdById(req.params.id);
      if (!ad || ad.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Ad not found" });
      }
      const reviewHistory = await getReviewHistoryByAd(ad.id);
      res.json({ ...ad, reviewHistory });
    } catch (error) {
      console.error("Failed to get ad:", error);
      res.status(500).json({ message: error.message || "Failed to get ad" });
    }
  });
  app2.patch("/api/ads/ads/:id", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const ad = await getAdById(req.params.id);
      if (!ad || ad.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Ad not found" });
      }
      if (ad.status !== "DRAFT" && ad.status !== "REJECTED") {
        return res.status(400).json({ message: "Only draft or rejected ads can be edited" });
      }
      const data = createAdSchema.partial().parse(req.body);
      const previousState = { ...ad };
      const updated = await updateAd(ad.id, data);
      await logAuditAction("AD_UPDATED", "ad", ad.id, req.session.userId, "ADVERTISER", previousState, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update ad:", error);
      res.status(400).json({ message: error.message || "Failed to update ad" });
    }
  });
  app2.post("/api/ads/track/click", requireAuth5, async (req, res) => {
    try {
      const { adId, placement } = req.body;
      if (!adId) {
        return res.status(400).json({ message: "Ad ID is required" });
      }
      const { adsEngine: adsEngine2 } = await Promise.resolve().then(() => (init_ads_engine(), ads_engine_exports));
      await adsEngine2.recordClick(adId, req.session.userId, placement || "feed");
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to track ad click:", error);
      res.status(500).json({ message: "Failed to track click" });
    }
  });
  app2.post("/api/ads/track/cta-click", requireAuth5, async (req, res) => {
    try {
      const { adId, ctaType, destinationUrl, placement } = req.body;
      if (!adId) {
        return res.status(400).json({ message: "Ad ID is required" });
      }
      const { adsEngine: adsEngine2 } = await Promise.resolve().then(() => (init_ads_engine(), ads_engine_exports));
      await adsEngine2.recordClick(adId, req.session.userId, placement || "feed");
      console.log(`[CTA Click] Ad: ${adId}, CTA: ${ctaType || "unknown"}, Destination: ${destinationUrl || "none"}, User: ${req.session.userId}`);
      if (destinationUrl && destinationUrl.startsWith("http")) {
        await adsEngine2.recordConversion(adId, req.session.userId, "CTA_CLICK", 0);
      }
      res.json({ success: true, destinationUrl });
    } catch (error) {
      console.error("Failed to track CTA click:", error);
      res.status(500).json({ message: "Failed to track CTA click" });
    }
  });
  app2.post("/api/ads/track/engagement", requireAuth5, async (req, res) => {
    try {
      const { adId, engagementType } = req.body;
      if (!adId || !engagementType) {
        return res.status(400).json({ message: "Ad ID and engagement type are required" });
      }
      if (!["like", "comment", "share", "save"].includes(engagementType)) {
        return res.status(400).json({ message: "Invalid engagement type" });
      }
      const { adsEngine: adsEngine2 } = await Promise.resolve().then(() => (init_ads_engine(), ads_engine_exports));
      await adsEngine2.recordEngagement(adId, req.session.userId, engagementType);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to track ad engagement:", error);
      res.status(500).json({ message: "Failed to track engagement" });
    }
  });
  app2.post("/api/ads/track/conversion", requireAuth5, async (req, res) => {
    try {
      const { adId, conversionType, value } = req.body;
      if (!adId || !conversionType) {
        return res.status(400).json({ message: "Ad ID and conversion type are required" });
      }
      const { adsEngine: adsEngine2 } = await Promise.resolve().then(() => (init_ads_engine(), ads_engine_exports));
      await adsEngine2.recordConversion(adId, req.session.userId, conversionType, value);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to track conversion:", error);
      res.status(500).json({ message: "Failed to track conversion" });
    }
  });
  app2.get("/api/ads/stats/overview", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const campaigns = await getCampaignsByAdvertiser(advertiser.id);
      let totalSpend = 0;
      let totalImpressions = 0;
      let totalClicks = 0;
      let totalConversions = 0;
      for (const campaign of campaigns) {
        totalSpend += campaign.budgetSpent || 0;
        totalImpressions += campaign.impressions || 0;
        totalClicks += campaign.clicks || 0;
        totalConversions += campaign.conversions || 0;
      }
      res.json({
        totalCampaigns: campaigns.length,
        activeCampaigns: campaigns.filter((c) => c.status === "ACTIVE").length,
        totalSpend: totalSpend / 100,
        totalImpressions,
        totalClicks,
        totalConversions,
        ctr: totalImpressions > 0 ? (totalClicks / totalImpressions * 100).toFixed(2) : 0
      });
    } catch (error) {
      console.error("Failed to get stats overview:", error);
      res.status(500).json({ message: error.message || "Failed to get stats" });
    }
  });
  app2.get("/api/ads/stats/campaign/:id", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const campaign = await getCampaignById(req.params.id);
      if (!campaign || campaign.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const startDate = new Date(req.query.startDate || Date.now() - 30 * 24 * 60 * 60 * 1e3);
      const endDate = new Date(req.query.endDate || Date.now());
      const stats = await getCampaignStats(campaign.id, startDate, endDate);
      res.json({
        campaign: {
          impressions: campaign.impressions,
          clicks: campaign.clicks,
          conversions: campaign.conversions,
          spend: (campaign.budgetSpent || 0) / 100,
          ctr: campaign.impressions && campaign.impressions > 0 ? (campaign.clicks / campaign.impressions * 100).toFixed(2) : 0
        },
        daily: stats
      });
    } catch (error) {
      console.error("Failed to get campaign stats:", error);
      res.status(500).json({ message: error.message || "Failed to get stats" });
    }
  });
  app2.get("/api/ads/audiences", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const audiences = await getCustomAudiencesByAdvertiser(advertiser.id);
      res.json(audiences);
    } catch (error) {
      console.error("Failed to get audiences:", error);
      res.status(500).json({ message: error.message || "Failed to get audiences" });
    }
  });
  app2.post("/api/ads/audiences", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const { name, description, type, rules } = req.body;
      const audience = await createCustomAudience({
        advertiserId: advertiser.id,
        name,
        description,
        type: type || "CUSTOM",
        rules: rules || {}
      });
      await logAuditAction("AUDIENCE_CREATED", "audience", audience.id, req.session.userId, "ADVERTISER", null, audience, req);
      res.status(201).json(audience);
    } catch (error) {
      console.error("Failed to create audience:", error);
      res.status(400).json({ message: error.message || "Failed to create audience" });
    }
  });
  app2.get("/api/ads/pixels", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const pixels = await getConversionPixelsByAdvertiser(advertiser.id);
      res.json(pixels);
    } catch (error) {
      console.error("Failed to get pixels:", error);
      res.status(500).json({ message: error.message || "Failed to get pixels" });
    }
  });
  app2.post("/api/ads/pixels", requireAuth5, async (req, res) => {
    try {
      const advertiser = await getAdvertiserOrFail(req.session.userId);
      const { name, conversionType, defaultValue } = req.body;
      const pixel = await createConversionPixel({
        advertiserId: advertiser.id,
        name,
        conversionType,
        defaultValue: defaultValue ? Math.round(defaultValue * 100) : void 0
      });
      res.status(201).json(pixel);
    } catch (error) {
      console.error("Failed to create pixel:", error);
      res.status(400).json({ message: error.message || "Failed to create pixel" });
    }
  });
  app2.post("/api/ads/pixels/:code/fire", async (req, res) => {
    try {
      const pixel = await getConversionPixelByCode(req.params.code);
      if (!pixel || !pixel.isActive) {
        return res.status(404).json({ message: "Pixel not found" });
      }
      await incrementPixelFires(pixel.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to fire pixel:", error);
      res.status(500).json({ message: "Failed to fire pixel" });
    }
  });
  app2.get("/api/ads/policies", async (req, res) => {
    try {
      const category = req.query.category;
      const policies = await getAdPolicies(category);
      res.json(policies);
    } catch (error) {
      console.error("Failed to get policies:", error);
      res.status(500).json({ message: "Failed to get policies" });
    }
  });
  app2.get("/api/ads/terms", async (req, res) => {
    try {
      const terms = await getActiveAdvertisingTerms();
      res.json(terms || null);
    } catch (error) {
      console.error("Failed to get terms:", error);
      res.status(500).json({ message: "Failed to get terms" });
    }
  });
  app2.get("/api/admin/ads/overview", requireAdmin, async (req, res) => {
    try {
      const overview = await getAdsOverview();
      res.json(overview);
    } catch (error) {
      console.error("Failed to get ads overview:", error);
      res.status(500).json({ message: "Failed to get overview" });
    }
  });
  app2.get("/api/admin/ads/cta-performance", requireAdmin, async (req, res) => {
    try {
      const ctaStats = await getCtaPerformanceStats();
      res.json({ ctaStats });
    } catch (error) {
      console.error("Failed to get CTA performance:", error);
      res.status(500).json({ message: "Failed to get CTA performance" });
    }
  });
  app2.get("/api/admin/ads/destination-performance", requireAdmin, async (req, res) => {
    try {
      const destinations = await getDestinationPerformanceStats();
      res.json({ destinations });
    } catch (error) {
      console.error("Failed to get destination performance:", error);
      res.status(500).json({ message: "Failed to get destination performance" });
    }
  });
  app2.get("/api/admin/ads/advertisers", requireAdmin, async (req, res) => {
    try {
      const status = req.query.status;
      const verificationStatus = req.query.verificationStatus;
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const result = await getAllAdvertisers({ status, verificationStatus, limit, offset });
      const enrichedAdvertisers = await Promise.all(result.advertisers.map(async (adv) => {
        const wallet = await getWalletByAdvertiserId(adv.id);
        const user = await storage.getUser(adv.userId);
        const campaigns = await getCampaignsByAdvertiser(adv.id);
        return {
          ...adv,
          walletId: wallet?.id,
          walletBalance: wallet?.balance || 0,
          totalSpend: wallet?.lifetimeSpend || 0,
          campaignCount: campaigns.length,
          user: user ? { id: user.id, username: user.username, email: user.email } : null
        };
      }));
      res.json({ advertisers: enrichedAdvertisers, total: result.total });
    } catch (error) {
      console.error("Failed to get advertisers:", error);
      res.status(500).json({ message: "Failed to get advertisers" });
    }
  });
  app2.get("/api/admin/ads/advertisers/:id", requireAdmin, async (req, res) => {
    try {
      const advertiser = await getAdvertiserById(req.params.id);
      if (!advertiser) {
        return res.status(404).json({ message: "Advertiser not found" });
      }
      const wallet = await getWalletByAdvertiserId(advertiser.id);
      const campaigns = await getCampaignsByAdvertiser(advertiser.id);
      const achievements2 = await getAdvertiserAchievements(advertiser.id);
      const user = await storage.getUser(advertiser.userId);
      res.json({ ...advertiser, wallet, campaigns, achievements: achievements2, user });
    } catch (error) {
      console.error("Failed to get advertiser:", error);
      res.status(500).json({ message: "Failed to get advertiser" });
    }
  });
  app2.patch("/api/admin/ads/advertisers/:id", requireAdmin, async (req, res) => {
    try {
      const advertiser = await getAdvertiserById(req.params.id);
      if (!advertiser) {
        return res.status(404).json({ message: "Advertiser not found" });
      }
      const previousState = { ...advertiser };
      const updated = await updateAdvertiser(advertiser.id, req.body);
      await logAuditAction("ADVERTISER_UPDATED", "advertiser", advertiser.id, req.session.userId, "ADMIN", previousState, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update advertiser:", error);
      res.status(400).json({ message: error.message || "Failed to update advertiser" });
    }
  });
  app2.post("/api/admin/ads/advertisers/:id/verify", requireAdmin, async (req, res) => {
    try {
      const advertiser = await getAdvertiserById(req.params.id);
      if (!advertiser) {
        return res.status(404).json({ message: "Advertiser not found" });
      }
      const { status, note } = req.body;
      const previousState = { ...advertiser };
      const updated = await updateAdvertiser(advertiser.id, {
        verificationStatus: status,
        verifiedAt: status === "VERIFIED" ? /* @__PURE__ */ new Date() : void 0,
        verifiedById: status === "VERIFIED" ? req.session.userId : void 0,
        status: status === "VERIFIED" ? "ACTIVE" : advertiser.status
      });
      await logAuditAction("ADVERTISER_VERIFIED", "advertiser", advertiser.id, req.session.userId, "ADMIN", previousState, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to verify advertiser:", error);
      res.status(400).json({ message: error.message || "Failed to verify advertiser" });
    }
  });
  app2.get("/api/admin/ads/campaigns", requireAdmin, async (req, res) => {
    try {
      const status = req.query.status;
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const result = await getAllCampaigns({ status, limit, offset });
      res.json(result);
    } catch (error) {
      console.error("Failed to get campaigns:", error);
      res.status(500).json({ message: "Failed to get campaigns" });
    }
  });
  app2.get("/api/admin/ads/campaigns/pending", requireAdmin, async (req, res) => {
    try {
      const campaigns = await getPendingReviewCampaigns();
      res.json(campaigns);
    } catch (error) {
      console.error("Failed to get pending campaigns:", error);
      res.status(500).json({ message: "Failed to get pending campaigns" });
    }
  });
  app2.post("/api/admin/ads/campaigns/:id/review", requireAdmin, async (req, res) => {
    try {
      const campaign = await getCampaignById(req.params.id);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const { action, reason } = req.body;
      const previousState = { ...campaign };
      let newStatus;
      if (action === "approve") {
        newStatus = "ACTIVE";
      } else if (action === "reject") {
        newStatus = "REJECTED";
      } else {
        return res.status(400).json({ message: "Invalid action" });
      }
      const updated = await updateCampaignStatus(campaign.id, newStatus, req.session.userId, reason);
      if (action === "reject" && campaign.budgetAmount && campaign.budgetAmount > 0) {
        const wallet = await getWalletByAdvertiserId(campaign.advertiserId);
        if (wallet) {
          try {
            const balanceBefore = wallet.balance || 0;
            const updatedWallet = await updateWalletBalance(wallet.id, campaign.budgetAmount, "credit");
            if (updatedWallet) {
              await createWalletTransaction({
                walletId: wallet.id,
                type: "REFUND",
                amount: campaign.budgetAmount,
                balanceBefore,
                balanceAfter: updatedWallet.balance || 0,
                status: "COMPLETED",
                description: `Refund for rejected campaign: ${campaign.name}`,
                campaignId: campaign.id,
                completedAt: /* @__PURE__ */ new Date()
              });
              console.log(`[Campaign Refund] Refunded ${campaign.budgetAmount} cents to wallet ${wallet.id} for rejected campaign ${campaign.id}`);
            } else {
              console.error("[Campaign Refund] Wallet update returned null for campaign:", campaign.id);
            }
          } catch (refundError) {
            console.error("[Campaign Refund] Failed to refund:", refundError.message);
          }
        }
      }
      await logAuditAction(action === "approve" ? "CAMPAIGN_APPROVED" : "CAMPAIGN_REJECTED", "campaign", campaign.id, req.session.userId, "ADMIN", previousState, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to review campaign:", error);
      res.status(400).json({ message: error.message || "Failed to review campaign" });
    }
  });
  app2.get("/api/admin/ads/ads", requireAdmin, async (req, res) => {
    try {
      const status = req.query.status;
      const format = req.query.format;
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const result = await getAllAds({ status, format, limit, offset });
      res.json(result);
    } catch (error) {
      console.error("Failed to get ads:", error);
      res.status(500).json({ message: "Failed to get ads" });
    }
  });
  app2.get("/api/admin/ads/ads/pending", requireAdmin, async (req, res) => {
    try {
      const ads2 = await getPendingReviewAds();
      res.json(ads2);
    } catch (error) {
      console.error("Failed to get pending ads:", error);
      res.status(500).json({ message: "Failed to get pending ads" });
    }
  });
  app2.post("/api/admin/ads/ads/:id/review", requireAdmin, async (req, res) => {
    try {
      const ad = await getAdById(req.params.id);
      if (!ad) {
        return res.status(404).json({ message: "Ad not found" });
      }
      const { action, reason, policyViolations } = req.body;
      const previousState = { ...ad };
      let newStatus;
      if (action === "approve") {
        newStatus = "APPROVED";
      } else if (action === "reject") {
        newStatus = "REJECTED";
      } else {
        return res.status(400).json({ message: "Invalid action" });
      }
      const updated = await updateAdStatus(ad.id, newStatus, req.session.userId, reason);
      if (policyViolations) {
        await updateAd(ad.id, { policyViolations });
      }
      await createReviewHistory({
        adId: ad.id,
        campaignId: ad.campaignId,
        reviewerId: req.session.userId,
        action: action.toUpperCase(),
        previousStatus: previousState.status,
        newStatus,
        reason,
        policyViolations: policyViolations || []
      });
      if (action === "approve") {
        const campaign = await getCampaignById(ad.campaignId);
        const terminalStatuses = ["ACTIVE", "PAUSED", "COMPLETED", "DISABLED", "ARCHIVED"];
        if (campaign && !terminalStatuses.includes(campaign.status)) {
          const previousStatus = campaign.status;
          await updateCampaign(campaign.id, { status: "ACTIVE" });
          console.log(`[Ad Approval] Campaign ${campaign.id} activated (was ${previousStatus}) after ad approval`);
          await logAuditAction(
            "CAMPAIGN_ACTIVATED",
            "campaign",
            campaign.id,
            req.session.userId,
            "ADMIN",
            { status: previousStatus },
            { status: "ACTIVE" },
            req
          );
        } else if (campaign) {
          console.log(`[Ad Approval] Campaign ${campaign.id} already in terminal status ${campaign.status}, not activating`);
        }
      }
      if (action === "reject") {
        const campaign = await getCampaignById(ad.campaignId);
        if (campaign && campaign.objective === "BOOST_POST" && campaign.status === "PENDING_REVIEW") {
          const wallet = await getWalletByAdvertiserId(campaign.advertiserId);
          if (wallet && campaign.budgetAmount && campaign.budgetAmount > 0) {
            const balanceBefore = wallet.balance || 0;
            const updatedWallet = await updateWalletBalance(wallet.id, campaign.budgetAmount, "credit");
            if (updatedWallet) {
              await createWalletTransaction({
                walletId: wallet.id,
                type: "REFUND",
                amount: campaign.budgetAmount,
                balanceBefore,
                balanceAfter: updatedWallet.balance || 0,
                status: "COMPLETED",
                description: `Refund for rejected boost ad #${ad.id}`,
                campaignId: campaign.id,
                completedAt: /* @__PURE__ */ new Date()
              });
              await updateCampaign(campaign.id, { status: "REJECTED" });
              await logAuditAction(
                "BOOST_AD_REFUNDED",
                "campaign",
                campaign.id,
                req.session.userId,
                "ADMIN",
                { balance: balanceBefore },
                { balance: updatedWallet.balance, refundAmount: campaign.budgetAmount },
                req
              );
            }
          }
        }
      }
      await logAuditAction(action === "approve" ? "AD_APPROVED" : "AD_REJECTED", "ad", ad.id, req.session.userId, "ADMIN", previousState, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to review ad:", error);
      res.status(400).json({ message: error.message || "Failed to review ad" });
    }
  });
  app2.get("/api/admin/ads/wallets", requireAdmin, async (req, res) => {
    try {
      const wallets2 = await db.select({
        wallet: adWalletAccounts,
        advertiser: advertisers
      }).from(adWalletAccounts).leftJoin(advertisers, eq9(adWalletAccounts.advertiserId, advertisers.id)).orderBy(desc7(adWalletAccounts.updatedAt)).limit(100);
      res.json(wallets2);
    } catch (error) {
      console.error("Failed to get wallets:", error);
      res.status(500).json({ message: "Failed to get wallets" });
    }
  });
  app2.post("/api/admin/ads/wallets/:id/adjust", requireAdmin, async (req, res) => {
    try {
      const { amount, type, reason } = req.body;
      const [wallet] = await db.select().from(adWalletAccounts).where(eq9(adWalletAccounts.id, req.params.id));
      if (!wallet) {
        return res.status(404).json({ message: "Wallet not found" });
      }
      const previousBalance = wallet.balance;
      const amountCents = Math.round(amount * 100);
      await createWalletTransaction({
        walletId: wallet.id,
        type: type === "credit" ? "ADMIN_CREDIT" : "ADMIN_DEBIT",
        amount: amountCents,
        balanceBefore: wallet.balance || 0,
        balanceAfter: type === "credit" ? (wallet.balance || 0) + amountCents : (wallet.balance || 0) - amountCents,
        status: "COMPLETED",
        description: `Admin adjustment: ${reason}`,
        adminId: req.session.userId,
        adminNotes: reason,
        completedAt: /* @__PURE__ */ new Date()
      });
      const updated = await updateWalletBalance(wallet.id, amountCents, type);
      await logAuditAction("WALLET_ADJUSTED", "wallet", wallet.id, req.session.userId, "ADMIN", { balance: previousBalance }, { balance: updated?.balance }, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to adjust wallet:", error);
      res.status(400).json({ message: error.message || "Failed to adjust wallet" });
    }
  });
  app2.post("/api/admin/ads/wallets/:id/freeze", requireAdmin, async (req, res) => {
    try {
      const { reason } = req.body;
      const updated = await freezeWallet(req.params.id, reason, req.session.userId);
      if (!updated) {
        return res.status(404).json({ message: "Wallet not found" });
      }
      await logAuditAction("WALLET_FROZEN", "wallet", req.params.id, req.session.userId, "ADMIN", { isFrozen: false }, { isFrozen: true, reason }, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to freeze wallet:", error);
      res.status(400).json({ message: error.message || "Failed to freeze wallet" });
    }
  });
  app2.post("/api/admin/ads/wallets/:id/unfreeze", requireAdmin, async (req, res) => {
    try {
      const updated = await unfreezeWallet(req.params.id);
      if (!updated) {
        return res.status(404).json({ message: "Wallet not found" });
      }
      await logAuditAction("WALLET_UNFROZEN", "wallet", req.params.id, req.session.userId, "ADMIN", { isFrozen: true }, { isFrozen: false }, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to unfreeze wallet:", error);
      res.status(400).json({ message: error.message || "Failed to unfreeze wallet" });
    }
  });
  app2.get("/api/admin/ads/promo-codes", requireAdmin, async (req, res) => {
    try {
      const promoCodes = await getAllPromoCodes();
      res.json(promoCodes);
    } catch (error) {
      console.error("Failed to get promo codes:", error);
      res.status(500).json({ message: "Failed to get promo codes" });
    }
  });
  app2.post("/api/admin/ads/promo-codes", requireAdmin, async (req, res) => {
    try {
      const { code, amount, usageLimit, validUntil, description } = req.body;
      const promo = await createPromoCode({
        code: code.toUpperCase(),
        amount: Math.round(amount * 100),
        usageLimit,
        validUntil: validUntil ? new Date(validUntil) : void 0,
        description,
        createdById: req.session.userId
      });
      await logAuditAction("PROMO_CODE_CREATED", "promo_code", promo.id, req.session.userId, "ADMIN", null, promo, req);
      res.status(201).json(promo);
    } catch (error) {
      console.error("Failed to create promo code:", error);
      res.status(400).json({ message: error.message || "Failed to create promo code" });
    }
  });
  app2.get("/api/admin/ads/policies", requireAdmin, async (req, res) => {
    try {
      const policies = await db.select().from(adPolicies).orderBy(adPolicies.sortOrder);
      res.json(policies);
    } catch (error) {
      console.error("Failed to get policies:", error);
      res.status(500).json({ message: "Failed to get policies" });
    }
  });
  app2.post("/api/admin/ads/policies", requireAdmin, async (req, res) => {
    try {
      const policy = await createAdPolicy(req.body);
      await logAuditAction("POLICY_CREATED", "policy", policy.id, req.session.userId, "ADMIN", null, policy, req);
      res.status(201).json(policy);
    } catch (error) {
      console.error("Failed to create policy:", error);
      res.status(400).json({ message: error.message || "Failed to create policy" });
    }
  });
  app2.patch("/api/admin/ads/policies/:id", requireAdmin, async (req, res) => {
    try {
      const [existing] = await db.select().from(adPolicies).where(eq9(adPolicies.id, req.params.id));
      if (!existing) {
        return res.status(404).json({ message: "Policy not found" });
      }
      const previousState = { ...existing };
      const updated = await updateAdPolicy(req.params.id, req.body);
      await logAuditAction("POLICY_UPDATED", "policy", req.params.id, req.session.userId, "ADMIN", previousState, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update policy:", error);
      res.status(400).json({ message: error.message || "Failed to update policy" });
    }
  });
  app2.get("/api/admin/ads/terms", requireAdmin, async (req, res) => {
    try {
      const terms = await getAllAdvertisingTerms();
      res.json(terms);
    } catch (error) {
      console.error("Failed to get terms:", error);
      res.status(500).json({ message: "Failed to get terms" });
    }
  });
  app2.post("/api/admin/ads/terms", requireAdmin, async (req, res) => {
    try {
      const terms = await createAdvertisingTerms({
        ...req.body,
        createdById: req.session.userId
      });
      await logAuditAction("TERMS_CREATED", "terms", terms.id, req.session.userId, "ADMIN", null, terms, req);
      res.status(201).json(terms);
    } catch (error) {
      console.error("Failed to create terms:", error);
      res.status(400).json({ message: error.message || "Failed to create terms" });
    }
  });
  app2.post("/api/admin/ads/terms/:id/activate", requireAdmin, async (req, res) => {
    try {
      await setActiveTerms(req.params.id);
      await logAuditAction("TERMS_ACTIVATED", "terms", req.params.id, req.session.userId, "ADMIN", null, null, req);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to activate terms:", error);
      res.status(400).json({ message: error.message || "Failed to activate terms" });
    }
  });
  app2.get("/api/admin/ads/audit-logs", requireAdmin, async (req, res) => {
    try {
      const advertiserId = req.query.advertiserId;
      const action = req.query.action;
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const result = await getAdAuditLogs({ advertiserId, action, limit, offset });
      res.json(result);
    } catch (error) {
      console.error("Failed to get audit logs:", error);
      res.status(500).json({ message: "Failed to get audit logs" });
    }
  });
  app2.get("/api/admin/ads/settings", requireAdmin, async (req, res) => {
    try {
      const category = req.query.category;
      const settings = await getAllSystemSettings(category);
      res.json(settings);
    } catch (error) {
      console.error("Failed to get settings:", error);
      res.status(500).json({ message: "Failed to get settings" });
    }
  });
  app2.put("/api/admin/ads/settings/:key", requireAdmin, async (req, res) => {
    try {
      const { value, description } = req.body;
      const previous = await getSystemSetting(req.params.key);
      const updated = await updateSystemSetting(req.params.key, value, req.session.userId, description);
      await logAuditAction("SETTING_UPDATED", "setting", req.params.key, req.session.userId, "ADMIN", previous, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update setting:", error);
      res.status(400).json({ message: error.message || "Failed to update setting" });
    }
  });
  app2.get("/api/admin/ads/all", requireAdmin, async (req, res) => {
    try {
      const { ads: ads2 } = await getAllAds({ limit: 1e3 });
      res.json(ads2);
    } catch (error) {
      console.error("Failed to get all ads:", error);
      res.status(500).json({ message: "Failed to get ads" });
    }
  });
  app2.post("/api/admin/ads/:id/approve", requireAdmin, async (req, res) => {
    try {
      console.log(`[Ad Approval] Starting approval for ad ${req.params.id}`);
      const ad = await getAdById(req.params.id);
      if (!ad) {
        console.log(`[Ad Approval] Ad ${req.params.id} not found`);
        return res.status(404).json({ message: "Ad not found" });
      }
      console.log(`[Ad Approval] Found ad ${ad.adNumber || ad.id}, current status: ${ad.status}, campaignId: ${ad.campaignId}`);
      const updated = await updateAd(ad.id, {
        status: "APPROVED",
        reviewedById: req.session.userId,
        reviewedAt: /* @__PURE__ */ new Date()
      });
      console.log(`[Ad Approval] Ad ${ad.adNumber || ad.id} status updated to APPROVED`);
      await logAuditAction("AD_APPROVED", "ad", ad.id, req.session.userId, "ADMIN", { status: ad.status }, updated, req);
      const campaign = await getCampaignById(ad.campaignId);
      console.log(`[Ad Approval] Campaign ${ad.campaignId} current status: ${campaign?.status || "NOT_FOUND"}`);
      const terminalStatuses = ["ACTIVE", "PAUSED", "COMPLETED", "DISABLED", "ARCHIVED"];
      if (campaign && !terminalStatuses.includes(campaign.status)) {
        const previousStatus = campaign.status;
        await updateCampaign(campaign.id, { status: "ACTIVE" });
        console.log(`[Ad Approval] SUCCESS: Campaign ${campaign.id} activated (was ${previousStatus}) after ad ${ad.adNumber || ad.id} approval`);
        await logAuditAction(
          "CAMPAIGN_ACTIVATED",
          "campaign",
          campaign.id,
          req.session.userId,
          "ADMIN",
          { status: previousStatus },
          { status: "ACTIVE" },
          req
        );
      } else if (campaign) {
        console.log(`[Ad Approval] Campaign ${campaign.id} in terminal status ${campaign.status}, not activating`);
      } else {
        console.log(`[Ad Approval] WARNING: Campaign ${ad.campaignId} not found for ad ${ad.adNumber || ad.id}`);
      }
      const updatedCampaign = await getCampaignById(ad.campaignId);
      res.json({
        ...updated,
        campaignStatus: updatedCampaign?.status,
        debug: {
          adApproved: true,
          campaignActivated: updatedCampaign?.status === "ACTIVE",
          previousCampaignStatus: campaign?.status
        }
      });
    } catch (error) {
      console.error("Failed to approve ad:", error);
      res.status(500).json({ message: "Failed to approve ad" });
    }
  });
  app2.post("/api/admin/ads/:id/reject", requireAdmin, async (req, res) => {
    try {
      const ad = await getAdById(req.params.id);
      if (!ad) {
        return res.status(404).json({ message: "Ad not found" });
      }
      const { reason } = req.body;
      const updated = await updateAd(ad.id, {
        status: "REJECTED",
        rejectionReason: reason,
        reviewedById: req.session.userId,
        reviewedAt: /* @__PURE__ */ new Date()
      });
      await logAuditAction("AD_REJECTED", "ad", ad.id, req.session.userId, "ADMIN", { status: ad.status }, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to reject ad:", error);
      res.status(500).json({ message: "Failed to reject ad" });
    }
  });
  app2.post("/api/admin/ads/fix-orphaned", requireAdmin, async (req, res) => {
    try {
      const { ads: allAds } = await getAllAds({ status: "APPROVED", limit: 1e3 });
      const fixedCampaigns = [];
      const issues = [];
      const terminalStatuses = ["ACTIVE", "PAUSED", "COMPLETED", "DISABLED", "ARCHIVED"];
      for (const ad of allAds) {
        const campaign = await getCampaignById(ad.campaignId);
        if (campaign && !terminalStatuses.includes(campaign.status)) {
          const previousStatus = campaign.status;
          issues.push({
            adNumber: ad.adNumber || "N/A",
            adId: ad.id,
            campaignId: campaign.id,
            campaignStatus: previousStatus,
            fixed: true
          });
          await updateCampaign(campaign.id, { status: "ACTIVE" });
          fixedCampaigns.push(campaign.id);
          console.log(`[Fix Orphaned] Activated campaign ${campaign.id} (was ${previousStatus}) for approved ad ${ad.adNumber || ad.id}`);
          await logAuditAction(
            "CAMPAIGN_ACTIVATED",
            "campaign",
            campaign.id,
            req.session.userId,
            "ADMIN",
            { status: previousStatus },
            { status: "ACTIVE" },
            req
          );
        } else if (campaign && campaign.status !== "ACTIVE") {
          issues.push({
            adNumber: ad.adNumber || "N/A",
            adId: ad.id,
            campaignId: campaign.id,
            campaignStatus: campaign.status,
            fixed: false
          });
        }
      }
      res.json({
        message: `Fixed ${fixedCampaigns.length} orphaned campaigns`,
        fixed: fixedCampaigns,
        issues,
        totalApprovedAds: allAds.length
      });
    } catch (error) {
      console.error("Failed to fix orphaned ads:", error);
      res.status(500).json({ message: "Failed to fix orphaned ads" });
    }
  });
  app2.post("/api/admin/ads/fix-wallet-deductions", requireAdmin, async (req, res) => {
    try {
      const campaigns = await db.select().from(adCampaigns).orderBy(desc7(adCampaigns.createdAt));
      const fixes = [];
      for (const campaign of campaigns) {
        const budgetAmount = campaign.budgetAmount || 0;
        const budgetSpent = campaign.budgetSpent || 0;
        if (budgetAmount > 0 && budgetSpent === 0) {
          const wallet = await db.select().from(adWalletAccounts).where(eq9(adWalletAccounts.advertiserId, campaign.advertiserId)).limit(1);
          if (wallet.length > 0) {
            await db.update(adWalletAccounts).set({
              balance: sql9`COALESCE(${adWalletAccounts.balance}, 0) + ${budgetAmount}`,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq9(adWalletAccounts.id, wallet[0].id));
            await createWalletTransaction({
              walletId: wallet[0].id,
              type: "REFUND",
              amount: budgetAmount,
              balanceBefore: wallet[0].balance || 0,
              balanceAfter: (wallet[0].balance || 0) + budgetAmount,
              status: "COMPLETED",
              description: `Refund for upfront deduction - Campaign ${campaign.name?.substring(0, 30)}`,
              campaignId: campaign.id,
              completedAt: /* @__PURE__ */ new Date()
            });
            fixes.push({
              campaignId: campaign.id,
              advertiserId: campaign.advertiserId,
              amount: budgetAmount,
              reason: "Refunded upfront deduction"
            });
          }
        }
      }
      const draftAdGroups = await db.select().from(adGroups).where(eq9(adGroups.status, "DRAFT"));
      const activatedAdGroups = [];
      for (const group of draftAdGroups) {
        const campaign = campaigns.find((c) => c.id === group.campaignId);
        if (campaign && campaign.status === "ACTIVE") {
          await db.update(adGroups).set({ status: "ACTIVE", updatedAt: /* @__PURE__ */ new Date() }).where(eq9(adGroups.id, group.id));
          activatedAdGroups.push(group.id);
        }
      }
      res.json({
        message: `Fixed ${fixes.length} wallet deductions, activated ${activatedAdGroups.length} ad groups`,
        walletFixes: fixes,
        activatedAdGroups
      });
    } catch (error) {
      console.error("Failed to fix wallet deductions:", error);
      res.status(500).json({ message: "Failed to fix wallet deductions" });
    }
  });
  app2.post("/api/admin/ads/advertisers/:id/suspend", requireAdmin, async (req, res) => {
    try {
      const advertiser = await getAdvertiserById(req.params.id);
      if (!advertiser) {
        return res.status(404).json({ message: "Advertiser not found" });
      }
      const updated = await updateAdvertiser(advertiser.id, {
        status: "SUSPENDED"
      });
      await logAuditAction("ADVERTISER_SUSPENDED", "advertiser", advertiser.id, req.session.userId, "ADMIN", { status: advertiser.status }, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to suspend advertiser:", error);
      res.status(500).json({ message: "Failed to suspend advertiser" });
    }
  });
  app2.post("/api/admin/ads/advertisers/:id/activate", requireAdmin, async (req, res) => {
    try {
      const advertiser = await getAdvertiserById(req.params.id);
      if (!advertiser) {
        return res.status(404).json({ message: "Advertiser not found" });
      }
      const updated = await updateAdvertiser(advertiser.id, {
        status: "ACTIVE"
      });
      await logAuditAction("ADVERTISER_ACTIVATED", "advertiser", advertiser.id, req.session.userId, "ADMIN", { status: advertiser.status }, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to activate advertiser:", error);
      res.status(500).json({ message: "Failed to activate advertiser" });
    }
  });
  app2.post("/api/admin/ads/campaigns/:id/pause", requireAdmin, async (req, res) => {
    try {
      const campaign = await getCampaignById(req.params.id);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const updated = await updateCampaign(campaign.id, {
        status: "PAUSED"
      });
      await logAuditAction("CAMPAIGN_PAUSED", "campaign", campaign.id, req.session.userId, "ADMIN", { status: campaign.status }, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to pause campaign:", error);
      res.status(500).json({ message: "Failed to pause campaign" });
    }
  });
  app2.post("/api/admin/ads/campaigns/:id/resume", requireAdmin, async (req, res) => {
    try {
      const campaign = await getCampaignById(req.params.id);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const updated = await updateCampaign(campaign.id, {
        status: "ACTIVE"
      });
      await logAuditAction("CAMPAIGN_RESUMED", "campaign", campaign.id, req.session.userId, "ADMIN", { status: campaign.status }, updated, req);
      res.json(updated);
    } catch (error) {
      console.error("Failed to resume campaign:", error);
      res.status(500).json({ message: "Failed to resume campaign" });
    }
  });
  app2.get("/api/admin/ads/events", requireAdmin, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 100;
      const offset = parseInt(req.query.offset) || 0;
      const eventType = req.query.eventType;
      const campaignId = req.query.campaignId;
      let whereClause = void 0;
      if (eventType && campaignId) {
        whereClause = and8(eq9(adEvents.eventType, eventType), eq9(adEvents.campaignId, campaignId));
      } else if (eventType) {
        whereClause = eq9(adEvents.eventType, eventType);
      } else if (campaignId) {
        whereClause = eq9(adEvents.campaignId, campaignId);
      }
      const events2 = await db.select().from(adEvents).where(whereClause).orderBy(desc7(adEvents.createdAt)).limit(limit).offset(offset);
      const stats = await db.select({
        eventType: adEvents.eventType,
        count: sql9`count(*)::int`,
        totalCost: sql9`COALESCE(sum(${adEvents.costAmount}), 0)::int`
      }).from(adEvents).where(sql9`${adEvents.createdAt} > NOW() - INTERVAL '24 hours'`).groupBy(adEvents.eventType);
      res.json({ events: events2, stats, totalCount: events2.length });
    } catch (error) {
      console.error("Failed to get ad events:", error);
      res.status(500).json({ message: "Failed to get ad events" });
    }
  });
  app2.get("/api/admin/ads/transactions", requireAdmin, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 100;
      const offset = parseInt(req.query.offset) || 0;
      const type = req.query.type;
      const walletId = req.query.walletId;
      let whereClause = void 0;
      if (type) {
        whereClause = eq9(adWalletTransactions.type, type);
      }
      if (walletId) {
        whereClause = whereClause ? and8(whereClause, eq9(adWalletTransactions.walletId, walletId)) : eq9(adWalletTransactions.walletId, walletId);
      }
      const transactions = await db.select({
        transaction: adWalletTransactions,
        wallet: adWalletAccounts,
        advertiser: advertisers
      }).from(adWalletTransactions).leftJoin(adWalletAccounts, eq9(adWalletTransactions.walletId, adWalletAccounts.id)).leftJoin(advertisers, eq9(adWalletAccounts.advertiserId, advertisers.id)).where(whereClause).orderBy(desc7(adWalletTransactions.createdAt)).limit(limit).offset(offset);
      const summary = await db.select({
        type: adWalletTransactions.type,
        count: sql9`count(*)::int`,
        totalAmount: sql9`COALESCE(sum(${adWalletTransactions.amount}), 0)::int`
      }).from(adWalletTransactions).where(sql9`${adWalletTransactions.createdAt} > NOW() - INTERVAL '24 hours'`).groupBy(adWalletTransactions.type);
      res.json({ transactions, summary, totalCount: transactions.length });
    } catch (error) {
      console.error("Failed to get wallet transactions:", error);
      res.status(500).json({ message: "Failed to get wallet transactions" });
    }
  });
  app2.get("/api/admin/ads/boost-campaigns", requireAdmin, async (req, res) => {
    try {
      const status = req.query.status;
      const limit = parseInt(req.query.limit) || 50;
      let whereClause = eq9(adCampaigns.objective, "BOOST_POST");
      if (status) {
        whereClause = and8(whereClause, eq9(adCampaigns.status, status));
      }
      const campaigns = await db.select({
        campaign: adCampaigns,
        advertiser: advertisers
      }).from(adCampaigns).leftJoin(advertisers, eq9(adCampaigns.advertiserId, advertisers.id)).where(whereClause).orderBy(desc7(adCampaigns.createdAt)).limit(limit);
      const stats = await db.select({
        status: adCampaigns.status,
        count: sql9`count(*)::int`,
        totalBudget: sql9`COALESCE(sum(${adCampaigns.budgetAmount}), 0)::int`
      }).from(adCampaigns).where(eq9(adCampaigns.objective, "BOOST_POST")).groupBy(adCampaigns.status);
      res.json({ campaigns, stats, totalCount: campaigns.length });
    } catch (error) {
      console.error("Failed to get boost campaigns:", error);
      res.status(500).json({ message: "Failed to get boost campaigns" });
    }
  });
  app2.get("/api/admin/ads/feature-controls", requireAdmin, async (req, res) => {
    try {
      const controls = [
        {
          key: "ads_self_engagement_prevention",
          name: "Self-Engagement Prevention",
          description: "Prevents advertisers from counting their own impressions, clicks, and engagements",
          defaultValue: true
        },
        {
          key: "ads_boost_post_enabled",
          name: "Boost Post Feature",
          description: "Allows users to boost their posts as ads",
          defaultValue: true
        },
        {
          key: "ads_auto_pause_low_balance",
          name: "Auto-Pause on Low Balance",
          description: "Automatically pauses campaigns when wallet balance is insufficient",
          defaultValue: true
        },
        {
          key: "ads_refund_on_rejection",
          name: "Refund on Ad Rejection",
          description: "Automatically refunds budget when ads are rejected",
          defaultValue: true
        }
      ];
      const settings = await Promise.all(
        controls.map(async (control) => {
          const setting = await getSystemSetting(control.key);
          return {
            ...control,
            enabled: setting ? setting.value === true || setting.value === "true" : control.defaultValue,
            updatedAt: setting?.updatedAt
          };
        })
      );
      res.json(settings);
    } catch (error) {
      console.error("Failed to get feature controls:", error);
      res.status(500).json({ message: "Failed to get feature controls" });
    }
  });
  app2.put("/api/admin/ads/feature-controls/:key", requireAdmin, async (req, res) => {
    try {
      const { enabled } = req.body;
      const key = req.params.key;
      const validKeys = [
        "ads_self_engagement_prevention",
        "ads_boost_post_enabled",
        "ads_auto_pause_low_balance",
        "ads_refund_on_rejection"
      ];
      if (!validKeys.includes(key)) {
        return res.status(400).json({ message: "Invalid feature control key" });
      }
      const previous = await getSystemSetting(key);
      const updated = await updateSystemSetting(key, enabled, req.session.userId, `Feature control: ${key}`);
      await logAuditAction(
        "FEATURE_CONTROL_UPDATED",
        "setting",
        key,
        req.session.userId,
        "ADMIN",
        { enabled: previous?.value },
        { enabled: updated.value },
        req
      );
      res.json({ key, enabled: updated.value, updatedAt: updated.updatedAt });
    } catch (error) {
      console.error("Failed to update feature control:", error);
      res.status(400).json({ message: error.message || "Failed to update feature control" });
    }
  });
  app2.get("/api/admin/ads/refunds", requireAdmin, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const refunds = await db.select({
        transaction: adWalletTransactions,
        wallet: adWalletAccounts,
        advertiser: advertisers
      }).from(adWalletTransactions).leftJoin(adWalletAccounts, eq9(adWalletTransactions.walletId, adWalletAccounts.id)).leftJoin(advertisers, eq9(adWalletAccounts.advertiserId, advertisers.id)).where(eq9(adWalletTransactions.type, "REFUND")).orderBy(desc7(adWalletTransactions.createdAt)).limit(limit);
      const totalRefunded = await db.select({
        count: sql9`count(*)::int`,
        totalAmount: sql9`COALESCE(sum(${adWalletTransactions.amount}), 0)::int`
      }).from(adWalletTransactions).where(eq9(adWalletTransactions.type, "REFUND"));
      res.json({
        refunds,
        summary: totalRefunded[0] || { count: 0, totalAmount: 0 }
      });
    } catch (error) {
      console.error("Failed to get refunds:", error);
      res.status(500).json({ message: "Failed to get refunds" });
    }
  });
  app2.post("/api/admin/ads/campaigns/:id/end", requireAdmin, async (req, res) => {
    try {
      const campaign = await getCampaignById(req.params.id);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const updated = await updateCampaign(campaign.id, {
        status: "COMPLETED",
        endDate: /* @__PURE__ */ new Date()
      });
      if (!updated) {
        return res.status(500).json({ message: "Failed to update campaign" });
      }
      await logAuditAction(
        "CAMPAIGN_ENDED",
        "campaign",
        campaign.id,
        req.session.userId,
        "ADMIN",
        { status: campaign.status, endDate: campaign.endDate },
        { status: "COMPLETED", endDate: updated.endDate },
        req
      );
      res.json({ message: "Campaign ended successfully", campaign: updated });
    } catch (error) {
      console.error("Failed to end campaign:", error);
      res.status(500).json({ message: "Failed to end campaign" });
    }
  });
  app2.delete("/api/admin/ads/campaigns/:id", requireAdmin, async (req, res) => {
    try {
      const campaign = await getCampaignById(req.params.id);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const updated = await updateCampaign(campaign.id, {
        status: "ARCHIVED"
      });
      await logAuditAction(
        "CAMPAIGN_DELETED",
        "campaign",
        campaign.id,
        req.session.userId,
        "ADMIN",
        campaign,
        { status: "ARCHIVED" },
        req
      );
      res.json({ message: "Campaign archived successfully" });
    } catch (error) {
      console.error("Failed to delete campaign:", error);
      res.status(500).json({ message: "Failed to delete campaign" });
    }
  });
  app2.post("/api/admin/ads/wallets/:id/refund", requireAdmin, async (req, res) => {
    try {
      const { amount, reason } = req.body;
      const [wallet] = await db.select().from(adWalletAccounts).where(eq9(adWalletAccounts.id, req.params.id));
      if (!wallet) {
        return res.status(404).json({ message: "Wallet not found" });
      }
      const refundAmount = amount || wallet.lifetimeSpend || 0;
      if (refundAmount <= 0) {
        return res.status(400).json({ message: "No amount to refund" });
      }
      const balanceBefore = wallet.balance || 0;
      const newBalance = balanceBefore + refundAmount;
      await db.update(adWalletAccounts).set({
        balance: newBalance,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq9(adWalletAccounts.id, wallet.id));
      await db.insert(adWalletTransactions).values({
        walletId: wallet.id,
        type: "REFUND",
        amount: refundAmount,
        balanceBefore,
        balanceAfter: newBalance,
        status: "COMPLETED",
        description: reason || "Admin refund",
        metadata: { adminUserId: req.session.userId, reason }
      });
      await logAuditAction(
        "WALLET_REFUND",
        "wallet",
        wallet.id,
        req.session.userId,
        "ADMIN",
        { balance: balanceBefore },
        { balance: newBalance, refundAmount },
        req
      );
      await sendAdNotification(wallet.advertiserId, "AD_REFUND_PROCESSED", wallet.id);
      res.json({ message: "Refund processed successfully", refundAmount, newBalance });
    } catch (error) {
      console.error("Failed to process refund:", error);
      res.status(500).json({ message: "Failed to process refund" });
    }
  });
  app2.post("/api/admin/ads/wallets/:id/convert-to-coins", requireAdmin, async (req, res) => {
    try {
      const [wallet] = await db.select().from(adWalletAccounts).where(eq9(adWalletAccounts.id, req.params.id));
      if (!wallet) {
        return res.status(404).json({ message: "Wallet not found" });
      }
      const balanceToConvert = wallet.balance || 0;
      if (balanceToConvert <= 0) {
        return res.status(400).json({ message: "No balance to convert" });
      }
      const [advertiser] = await db.select().from(advertisers).where(eq9(advertisers.id, wallet.advertiserId));
      if (!advertiser) {
        return res.status(404).json({ message: "Advertiser not found" });
      }
      const { wallets: wallets2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      let [userWallet] = await db.select().from(wallets2).where(eq9(wallets2.userId, advertiser.userId));
      if (!userWallet) {
        [userWallet] = await db.insert(wallets2).values({
          userId: advertiser.userId,
          coinBalance: 0,
          lifetimeEarned: 0,
          lifetimeSpent: 0
        }).returning();
      }
      await db.update(wallets2).set({
        coinBalance: (userWallet.coinBalance || 0) + balanceToConvert,
        lifetimeEarned: (userWallet.lifetimeEarned || 0) + balanceToConvert,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq9(wallets2.id, userWallet.id));
      await db.update(adWalletAccounts).set({
        balance: 0,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq9(adWalletAccounts.id, wallet.id));
      await db.insert(adWalletTransactions).values({
        walletId: wallet.id,
        type: "ADJUSTMENT",
        amount: -balanceToConvert,
        balanceBefore: balanceToConvert,
        balanceAfter: 0,
        status: "COMPLETED",
        description: "Converted to Rabit Coins",
        metadata: { adminUserId: req.session.userId, coinsReceived: balanceToConvert }
      });
      await logAuditAction(
        "WALLET_CONVERTED_TO_COINS",
        "wallet",
        wallet.id,
        req.session.userId,
        "ADMIN",
        { adWalletBalance: balanceToConvert },
        { coinsReceived: balanceToConvert },
        req
      );
      res.json({
        message: "Balance converted to Rabit Coins successfully",
        convertedAmount: balanceToConvert,
        newCoinBalance: (userWallet.coinBalance || 0) + balanceToConvert
      });
    } catch (error) {
      console.error("Failed to convert to coins:", error);
      res.status(500).json({ message: "Failed to convert to coins" });
    }
  });
  app2.get("/api/admin/ads/revenue", requireAdmin, async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      const { adsEngine: adsEngine2 } = await Promise.resolve().then(() => (init_ads_engine(), ads_engine_exports));
      const start = startDate ? new Date(startDate) : void 0;
      const end = endDate ? new Date(endDate) : void 0;
      const revenue = await adsEngine2.getPlatformRevenue(start, end);
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
      const dailyStats = await db.select({
        date: sql9`DATE(${adWalletTransactions.createdAt})`,
        spend: sql9`COALESCE(SUM(ABS(${adWalletTransactions.amount})), 0)::int`,
        transactions: sql9`COUNT(*)::int`
      }).from(adWalletTransactions).where(and8(
        eq9(adWalletTransactions.type, "AD_SPEND"),
        gte5(adWalletTransactions.createdAt, thirtyDaysAgo)
      )).groupBy(sql9`DATE(${adWalletTransactions.createdAt})`).orderBy(sql9`DATE(${adWalletTransactions.createdAt})`);
      res.json({ revenue, dailyStats });
    } catch (error) {
      console.error("Failed to get revenue stats:", error);
      res.status(500).json({ message: "Failed to get revenue stats" });
    }
  });
  app2.get("/api/admin/ads/delivery-health", requireAdmin, async (req, res) => {
    try {
      const hoursThreshold = parseInt(req.query.hours) || 24;
      const { adsEngine: adsEngine2 } = await Promise.resolve().then(() => (init_ads_engine(), ads_engine_exports));
      const zeroDeliveryCampaigns = await adsEngine2.getZeroDeliveryCampaigns(hoursThreshold);
      const lowDeliveryCampaigns = await db.select().from(adCampaigns).where(
        and8(
          eq9(adCampaigns.status, "ACTIVE"),
          sql9`${adCampaigns.budgetSpent} < (${adCampaigns.budgetAmount} * 0.1)`,
          sql9`${adCampaigns.createdAt} < NOW() - INTERVAL '48 hours'`
        )
      );
      res.json({
        zeroDelivery: zeroDeliveryCampaigns,
        lowDelivery: lowDeliveryCampaigns,
        threshold: hoursThreshold
      });
    } catch (error) {
      console.error("Failed to get delivery health:", error);
      res.status(500).json({ message: "Failed to get delivery health" });
    }
  });
  app2.post("/api/admin/ads/expire-campaigns", requireAdmin, async (req, res) => {
    try {
      const { adsEngine: adsEngine2 } = await Promise.resolve().then(() => (init_ads_engine(), ads_engine_exports));
      const result = await adsEngine2.expireEndedCampaigns();
      await logAuditAction(
        "CAMPAIGNS_AUTO_EXPIRED",
        "system",
        "batch",
        req.session.userId,
        "ADMIN",
        null,
        { expired: result.expired, campaigns: result.details },
        req
      );
      res.json({
        message: `Expired ${result.expired} campaigns`,
        expired: result.expired,
        details: result.details
      });
    } catch (error) {
      console.error("Failed to expire campaigns:", error);
      res.status(500).json({ message: "Failed to expire campaigns" });
    }
  });
  app2.post("/api/admin/ads/emergency-pause", requireAdmin, async (req, res) => {
    try {
      const { pause, reason } = req.body;
      if (pause) {
        const pausedCampaigns = await db.update(adCampaigns).set({
          status: "PAUSED",
          updatedAt: /* @__PURE__ */ new Date(),
          metadata: sql9`COALESCE(${adCampaigns.metadata}, '{}')::jsonb || '{"emergencyPaused": true}'::jsonb`
        }).where(eq9(adCampaigns.status, "ACTIVE")).returning();
        await logAuditAction(
          "EMERGENCY_PAUSE_ALL",
          "system",
          "all_ads",
          req.session.userId,
          "ADMIN",
          null,
          { paused: pausedCampaigns.length, reason },
          req
        );
        res.json({ message: `Emergency paused ${pausedCampaigns.length} campaigns`, count: pausedCampaigns.length });
      } else {
        const resumedCampaigns = await db.update(adCampaigns).set({
          status: "ACTIVE",
          updatedAt: /* @__PURE__ */ new Date(),
          metadata: sql9`COALESCE(${adCampaigns.metadata}, '{}')::jsonb - 'emergencyPaused'`
        }).where(
          and8(
            eq9(adCampaigns.status, "PAUSED"),
            sql9`COALESCE(${adCampaigns.metadata}, '{}')::jsonb->>'emergencyPaused' = 'true'`
          )
        ).returning();
        await logAuditAction(
          "EMERGENCY_RESUME_ALL",
          "system",
          "all_ads",
          req.session.userId,
          "ADMIN",
          null,
          { resumed: resumedCampaigns.length, reason },
          req
        );
        res.json({ message: `Resumed ${resumedCampaigns.length} emergency-paused campaigns`, count: resumedCampaigns.length });
      }
    } catch (error) {
      console.error("Failed emergency pause/resume:", error);
      res.status(500).json({ message: "Failed to execute emergency action" });
    }
  });
  app2.get("/api/admin/ads/campaigns/:id/details", requireAdmin, async (req, res) => {
    try {
      const campaign = await getCampaignById(req.params.id);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const [advertiser] = await db.select().from(advertisers).where(eq9(advertisers.id, campaign.advertiserId));
      let wallet = null;
      if (advertiser) {
        const [w] = await db.select().from(adWalletAccounts).where(eq9(adWalletAccounts.advertiserId, advertiser.id));
        wallet = w;
      }
      const campaignAds = await db.select().from(ads).leftJoin(adGroups, eq9(ads.adGroupId, adGroups.id)).where(eq9(adGroups.campaignId, campaign.id));
      const recentEvents = await db.select().from(adEvents).where(eq9(adEvents.campaignId, campaign.id)).orderBy(desc7(adEvents.createdAt)).limit(50);
      const spendStats = await db.select({
        totalSpend: sql9`COALESCE(SUM(ABS(${adWalletTransactions.amount})), 0)::int`,
        transactionCount: sql9`COUNT(*)::int`
      }).from(adWalletTransactions).where(eq9(adWalletTransactions.campaignId, campaign.id));
      res.json({
        campaign,
        advertiser,
        wallet,
        ads: campaignAds,
        recentEvents,
        spendStats: spendStats[0] || { totalSpend: 0, transactionCount: 0 }
      });
    } catch (error) {
      console.error("Failed to get campaign details:", error);
      res.status(500).json({ message: "Failed to get campaign details" });
    }
  });
  app2.patch("/api/admin/ads/campaigns/:id", requireAdmin, async (req, res) => {
    try {
      const campaign = await getCampaignById(req.params.id);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      const { name, budgetAmount, budgetType, startDate, endDate, status } = req.body;
      const updates = {};
      if (name !== void 0) updates.name = name;
      if (budgetAmount !== void 0) updates.budgetAmount = budgetAmount;
      if (budgetType !== void 0) updates.budgetType = budgetType;
      if (startDate !== void 0) updates.startDate = new Date(startDate);
      if (endDate !== void 0) updates.endDate = new Date(endDate);
      if (status !== void 0) updates.status = status;
      const updated = await updateCampaign(campaign.id, updates);
      await logAuditAction(
        "CAMPAIGN_EDITED",
        "campaign",
        campaign.id,
        req.session.userId,
        "ADMIN",
        campaign,
        updated,
        req
      );
      res.json({ message: "Campaign updated successfully", campaign: updated });
    } catch (error) {
      console.error("Failed to update campaign:", error);
      res.status(500).json({ message: "Failed to update campaign" });
    }
  });
  app2.post("/api/advertising/disputes", requireAuth5, async (req, res) => {
    try {
      const { campaignId, disputeType, subject, description, requestedRefundAmount } = req.body;
      const [advertiser] = await db.select().from(advertisers).where(eq9(advertisers.userId, req.session.userId));
      if (!advertiser) {
        return res.status(403).json({ message: "No advertiser account found" });
      }
      if (campaignId) {
        const campaign = await getCampaignById(campaignId);
        if (!campaign || campaign.advertiserId !== advertiser.id) {
          return res.status(400).json({ message: "Invalid campaign" });
        }
      }
      const [dispute] = await db.insert(adDisputes).values({
        advertiserId: advertiser.id,
        campaignId,
        disputeType: disputeType || "OTHER",
        subject: subject || "Dispute",
        description: description || "",
        requestedRefundAmount: requestedRefundAmount ? Math.round(requestedRefundAmount) : null
      }).returning();
      res.json({ message: "Dispute submitted successfully", dispute });
    } catch (error) {
      console.error("Failed to create dispute:", error);
      res.status(500).json({ message: "Failed to submit dispute" });
    }
  });
  app2.get("/api/advertising/disputes", requireAuth5, async (req, res) => {
    try {
      const [advertiser] = await db.select().from(advertisers).where(eq9(advertisers.userId, req.session.userId));
      if (!advertiser) {
        return res.status(403).json({ message: "No advertiser account found" });
      }
      const disputes = await db.select().from(adDisputes).where(eq9(adDisputes.advertiserId, advertiser.id)).orderBy(desc7(adDisputes.createdAt));
      res.json({ disputes });
    } catch (error) {
      console.error("Failed to get disputes:", error);
      res.status(500).json({ message: "Failed to get disputes" });
    }
  });
  app2.post("/api/advertising/disputes/:id/cancel", requireAuth5, async (req, res) => {
    try {
      const [advertiser] = await db.select().from(advertisers).where(eq9(advertisers.userId, req.session.userId));
      if (!advertiser) {
        return res.status(403).json({ message: "No advertiser account found" });
      }
      const [dispute] = await db.select().from(adDisputes).where(eq9(adDisputes.id, req.params.id));
      if (!dispute || dispute.advertiserId !== advertiser.id) {
        return res.status(404).json({ message: "Dispute not found" });
      }
      if (dispute.status !== "PENDING" && dispute.status !== "UNDER_REVIEW") {
        return res.status(400).json({ message: "Cannot cancel resolved dispute" });
      }
      await db.update(adDisputes).set({ status: "CANCELLED", updatedAt: /* @__PURE__ */ new Date() }).where(eq9(adDisputes.id, req.params.id));
      res.json({ message: "Dispute cancelled" });
    } catch (error) {
      console.error("Failed to cancel dispute:", error);
      res.status(500).json({ message: "Failed to cancel dispute" });
    }
  });
  app2.get("/api/admin/ads/disputes", requireAdmin, async (req, res) => {
    try {
      const { status } = req.query;
      let query = db.select({
        dispute: adDisputes,
        advertiser: advertisers,
        campaign: adCampaigns
      }).from(adDisputes).leftJoin(advertisers, eq9(adDisputes.advertiserId, advertisers.id)).leftJoin(adCampaigns, eq9(adDisputes.campaignId, adCampaigns.id)).orderBy(desc7(adDisputes.createdAt));
      const allDisputes = await query;
      const disputes = status ? allDisputes.filter((d) => d.dispute.status === status) : allDisputes;
      const pendingCount = allDisputes.filter((d) => d.dispute.status === "PENDING").length;
      const underReviewCount = allDisputes.filter((d) => d.dispute.status === "UNDER_REVIEW").length;
      const resolvedCount = allDisputes.filter((d) => d.dispute.status === "RESOLVED_APPROVED" || d.dispute.status === "RESOLVED_DENIED").length;
      res.json({
        disputes,
        stats: { pendingCount, underReviewCount, resolvedCount, totalCount: allDisputes.length }
      });
    } catch (error) {
      console.error("Failed to get disputes:", error);
      res.status(500).json({ message: "Failed to get disputes" });
    }
  });
  app2.post("/api/admin/ads/disputes/:id/review", requireAdmin, async (req, res) => {
    try {
      const [dispute] = await db.select().from(adDisputes).where(eq9(adDisputes.id, req.params.id));
      if (!dispute) {
        return res.status(404).json({ message: "Dispute not found" });
      }
      await db.update(adDisputes).set({
        status: "UNDER_REVIEW",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq9(adDisputes.id, req.params.id));
      res.json({ message: "Dispute marked as under review" });
    } catch (error) {
      console.error("Failed to update dispute:", error);
      res.status(500).json({ message: "Failed to update dispute" });
    }
  });
  app2.post("/api/admin/ads/disputes/:id/resolve", requireAdmin, async (req, res) => {
    try {
      const { approved, adminResponse, refundAmount } = req.body;
      const [dispute] = await db.select().from(adDisputes).where(eq9(adDisputes.id, req.params.id));
      if (!dispute) {
        return res.status(404).json({ message: "Dispute not found" });
      }
      if (approved && refundAmount && refundAmount > 0) {
        const [wallet] = await db.select().from(adWalletAccounts).where(eq9(adWalletAccounts.advertiserId, dispute.advertiserId));
        if (wallet) {
          const balanceBefore = wallet.balance || 0;
          const newBalance = balanceBefore + refundAmount;
          await db.update(adWalletAccounts).set({
            balance: newBalance,
            lifetimeRefunds: (wallet.lifetimeRefunds || 0) + refundAmount,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq9(adWalletAccounts.id, wallet.id));
          await db.insert(adWalletTransactions).values({
            walletId: wallet.id,
            type: "REFUND",
            amount: refundAmount,
            balanceBefore,
            balanceAfter: newBalance,
            status: "COMPLETED",
            description: `Dispute refund: ${dispute.subject}`,
            campaignId: dispute.campaignId
          });
        }
      }
      await db.update(adDisputes).set({
        status: approved ? "RESOLVED_APPROVED" : "RESOLVED_DENIED",
        adminResponse: adminResponse || null,
        approvedRefundAmount: approved && refundAmount ? refundAmount : null,
        resolvedBy: req.session.userId,
        resolvedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq9(adDisputes.id, req.params.id));
      await logAuditAction(
        "DISPUTE_RESOLVED",
        "dispute",
        dispute.id,
        req.session.userId,
        "ADMIN",
        dispute,
        { approved, refundAmount, adminResponse },
        req
      );
      await sendAdNotification(dispute.advertiserId, "AD_DISPUTE_RESOLVED", dispute.id);
      res.json({ message: `Dispute ${approved ? "approved" : "denied"}` });
    } catch (error) {
      console.error("Failed to resolve dispute:", error);
      res.status(500).json({ message: "Failed to resolve dispute" });
    }
  });
}

// server/routes-link-preview.ts
import rateLimit from "express-rate-limit";

// server/validation.ts
import { z as z4 } from "zod";
var loginSchema = z4.object({
  username: z4.string().min(1, "Username is required").max(50, "Username too long"),
  password: z4.string().min(1, "Password is required")
});
var accountTypeEnum = z4.enum(["PERSONAL", "CREATOR", "BUSINESS"]);
var genderEnum2 = z4.enum(["MALE", "FEMALE", "NON_BINARY", "OTHER", "PREFER_NOT_TO_SAY"]);
var creatorCategoryEnum2 = z4.enum([
  "INFLUENCER",
  "ARTIST_MUSICIAN",
  "PHOTOGRAPHER",
  "VIDEOGRAPHER",
  "BLOGGER",
  "DJ_PRODUCER",
  "COMEDIAN",
  "PUBLIC_FIGURE",
  "GAMER_STREAMER",
  "EDUCATOR",
  "FASHION_MODEL",
  "FITNESS_COACH",
  "BEAUTY_MAKEUP",
  "BUSINESS_CREATOR",
  "OTHER"
]);
var businessCategoryEnum2 = z4.enum([
  "LUXURY_BRAND",
  "RESTAURANT_FOOD",
  "REAL_ESTATE",
  "FASHION_CLOTHING",
  "AUTOMOTIVE",
  "BEAUTY_SALON_SPA",
  "FINANCE_TRADING",
  "MEDIA_ENTERTAINMENT",
  "NIGHTLIFE_CLUB_EVENTS",
  "TECH_SOFTWARE",
  "EDUCATION",
  "HEALTH_MEDICAL",
  "ECOMMERCE_STORE",
  "SERVICES",
  "AGENCY_MARKETING",
  "OTHER"
]);
var signupSchema = z4.object({
  username: z4.string().min(3, "Username must be at least 3 characters").max(30, "Username must be at most 30 characters").regex(/^[a-zA-Z0-9_]+$/, "Username can only contain letters, numbers, and underscores"),
  email: z4.string().email("Invalid email address").optional(),
  phoneNumber: z4.string().min(10, "Invalid phone number").optional(),
  password: z4.string().min(8, "Password must be at least 8 characters").max(100, "Password too long"),
  displayName: z4.string().min(1, "Display name is required").max(50, "Display name too long"),
  birthday: z4.string().optional(),
  country: z4.string().min(1, "Country is required"),
  province: z4.string().min(1, "Province is required"),
  city: z4.string().min(1, "City is required"),
  category: accountTypeEnum.default("PERSONAL"),
  gender: genderEnum2.optional(),
  avatarUrl: z4.string().url().optional().nullable(),
  creatorCategory: creatorCategoryEnum2.optional(),
  bio: z4.string().max(500).optional(),
  portfolioUrl: z4.string().url().optional().nullable(),
  primaryPlatforms: z4.array(z4.string()).optional(),
  contentLanguage: z4.string().optional(),
  contentTags: z4.array(z4.string()).optional(),
  hasManagement: z4.boolean().optional(),
  managementName: z4.string().optional(),
  showLocationPublicly: z4.boolean().optional(),
  businessCategory: businessCategoryEnum2.optional(),
  dateEstablished: z4.string().optional(),
  contactEmail: z4.string().email().optional(),
  contactPhone: z4.string().optional(),
  contactAddress: z4.string().optional(),
  websiteUrl: z4.string().url().optional().nullable(),
  whatsappNumber: z4.string().optional(),
  businessHours: z4.record(z4.string(), z4.any()).optional()
}).refine((data) => data.email || data.phoneNumber, {
  message: "Either email or phone number is required",
  path: ["email"]
}).refine((data) => {
  if (data.category === "CREATOR" && !data.creatorCategory) {
    return false;
  }
  return true;
}, {
  message: "Creator category is required for creator accounts",
  path: ["creatorCategory"]
}).refine((data) => {
  if (data.category === "BUSINESS" && !data.businessCategory) {
    return false;
  }
  return true;
}, {
  message: "Business category is required for business accounts",
  path: ["businessCategory"]
});
var postTypeEnum2 = z4.enum(["TEXT", "PHOTO", "VIDEO", "VOICE"]);
var visibilityEnum2 = z4.enum(["PUBLIC", "FOLLOWERS", "PRIVATE"]);
var createPostSchema2 = z4.object({
  type: postTypeEnum2.default("TEXT"),
  content: z4.string().max(5e3, "Post content too long").optional().nullable(),
  caption: z4.string().max(500, "Caption too long").optional().nullable(),
  mediaUrl: z4.string().url().optional().nullable(),
  thumbnailUrl: z4.string().url().optional().nullable(),
  durationMs: z4.number().int().positive().optional().nullable(),
  aspectRatio: z4.number().positive().optional().nullable(),
  visibility: visibilityEnum2.default("PUBLIC"),
  commentsEnabled: z4.boolean().default(true)
}).superRefine((data, ctx) => {
  switch (data.type) {
    case "TEXT":
      if (!data.content || data.content.trim().length === 0) {
        ctx.addIssue({
          code: z4.ZodIssueCode.custom,
          message: "Content is required for text posts",
          path: ["content"]
        });
      }
      if (data.mediaUrl) {
        ctx.addIssue({
          code: z4.ZodIssueCode.custom,
          message: "Text posts cannot have media",
          path: ["mediaUrl"]
        });
      }
      break;
    case "PHOTO":
      if (!data.mediaUrl) {
        ctx.addIssue({
          code: z4.ZodIssueCode.custom,
          message: "Media URL is required for photo posts",
          path: ["mediaUrl"]
        });
      }
      break;
    case "VIDEO":
      if (!data.mediaUrl) {
        ctx.addIssue({
          code: z4.ZodIssueCode.custom,
          message: "Media URL is required for video posts",
          path: ["mediaUrl"]
        });
      }
      if (!data.thumbnailUrl) {
        ctx.addIssue({
          code: z4.ZodIssueCode.custom,
          message: "Thumbnail URL is required for video posts",
          path: ["thumbnailUrl"]
        });
      }
      if (!data.durationMs) {
        ctx.addIssue({
          code: z4.ZodIssueCode.custom,
          message: "Duration is required for video posts",
          path: ["durationMs"]
        });
      }
      break;
    case "VOICE":
      if (!data.mediaUrl) {
        ctx.addIssue({
          code: z4.ZodIssueCode.custom,
          message: "Media URL is required for voice posts",
          path: ["mediaUrl"]
        });
      }
      if (!data.thumbnailUrl) {
        ctx.addIssue({
          code: z4.ZodIssueCode.custom,
          message: "Thumbnail URL is required for voice posts",
          path: ["thumbnailUrl"]
        });
      }
      if (!data.durationMs) {
        ctx.addIssue({
          code: z4.ZodIssueCode.custom,
          message: "Duration is required for voice posts",
          path: ["durationMs"]
        });
      }
      break;
  }
});
var createCommentSchema = z4.object({
  content: z4.string().min(1, "Comment is required").max(2e3, "Comment too long")
});
var sendMessageSchema = z4.object({
  content: z4.string().min(1, "Message content is required").max(5e3, "Message too long"),
  receiverId: z4.string().uuid().optional()
});
var createConversationSchema = z4.object({
  participantId: z4.string().uuid("Invalid participant ID")
});
var updateProfileSchema = z4.object({
  displayName: z4.string().max(50, "Display name too long").optional(),
  bio: z4.string().max(500, "Bio too long").optional(),
  avatarUrl: z4.string().url().optional().nullable(),
  netWorth: z4.number().min(0).optional()
});
var reportSchema2 = z4.object({
  reason: z4.string().min(10, "Please provide more details (at least 10 characters)").max(1e3, "Reason too long"),
  reportedUserId: z4.string().uuid().optional(),
  reportedPostId: z4.string().uuid().optional()
});
var updateReportSchema = z4.object({
  status: z4.enum(["PENDING", "REVIEWED", "RESOLVED", "DISMISSED"]),
  adminNotes: z4.string().max(2e3, "Admin notes too long").optional()
});
function formatZodError(error) {
  return error.errors.map((err) => ({
    field: err.path.join("."),
    message: err.message
  }));
}
function validateBody(schema) {
  return (req, res, next) => {
    const result = schema.safeParse(req.body);
    if (!result.success) {
      const apiError2 = {
        success: false,
        error: {
          code: "VALIDATION_ERROR",
          message: "Request validation failed",
          details: formatZodError(result.error)
        }
      };
      return res.status(400).json(apiError2);
    }
    req.body = result.data;
    next();
  };
}
function apiError(code, message, details) {
  return {
    success: false,
    error: {
      code,
      message,
      details
    }
  };
}
var ErrorCodes = {
  VALIDATION_ERROR: "VALIDATION_ERROR",
  UNAUTHORIZED: "UNAUTHORIZED",
  FORBIDDEN: "FORBIDDEN",
  NOT_FOUND: "NOT_FOUND",
  CONFLICT: "CONFLICT",
  RATE_LIMITED: "RATE_LIMITED",
  INTERNAL_ERROR: "INTERNAL_ERROR"
};
var policyOptionEnum = z4.enum(["EVERYONE", "FOLLOWERS", "NOBODY"]);
var userCategoryEnum2 = z4.enum(["PERSONAL", "CREATOR", "BUSINESS"]);
var updateSettingsSchema = z4.object({
  privateAccount: z4.boolean().optional(),
  commentPolicy: policyOptionEnum.optional(),
  messagePolicy: policyOptionEnum.optional(),
  mentionPolicy: policyOptionEnum.optional(),
  storyViewPolicy: policyOptionEnum.optional(),
  followersListVisibility: policyOptionEnum.optional(),
  followingListVisibility: policyOptionEnum.optional(),
  // Legacy notifications (keeping for compatibility)
  notifications: z4.object({
    likes: z4.boolean().optional(),
    comments: z4.boolean().optional(),
    follows: z4.boolean().optional(),
    messages: z4.boolean().optional(),
    mentions: z4.boolean().optional()
  }).optional(),
  // Push Notifications (granular)
  pushNotifications: z4.object({
    likes: z4.boolean().optional(),
    comments: z4.boolean().optional(),
    follows: z4.boolean().optional(),
    messages: z4.boolean().optional(),
    mentions: z4.boolean().optional(),
    storyViews: z4.boolean().optional(),
    profileViews: z4.boolean().optional(),
    newFollowers: z4.boolean().optional(),
    liveVideos: z4.boolean().optional(),
    promotions: z4.boolean().optional()
  }).optional(),
  // Email Notifications
  emailNotifications: z4.object({
    weeklyDigest: z4.boolean().optional(),
    newFollowers: z4.boolean().optional(),
    messages: z4.boolean().optional(),
    mentions: z4.boolean().optional(),
    productUpdates: z4.boolean().optional(),
    securityAlerts: z4.boolean().optional()
  }).optional(),
  // Quiet Hours / Do Not Disturb
  quietHoursEnabled: z4.boolean().optional(),
  quietHoursStart: z4.string().regex(/^\d{2}:\d{2}$/, "Format: HH:MM").optional().nullable(),
  quietHoursEnd: z4.string().regex(/^\d{2}:\d{2}$/, "Format: HH:MM").optional().nullable(),
  quietHoursTimezone: z4.string().optional().nullable(),
  // Content Preferences
  contentPreferences: z4.object({
    showSensitiveContent: z4.boolean().optional(),
    autoTranslate: z4.boolean().optional(),
    prioritizeFollowing: z4.boolean().optional()
  }).optional(),
  sensitiveContentFilter: z4.boolean().optional(),
  // Security
  loginAlertsEnabled: z4.boolean().optional(),
  twoFactorEnabled: z4.boolean().optional(),
  // Accessibility
  fontSizePreference: z4.enum(["SMALL", "MEDIUM", "LARGE"]).optional(),
  // Media prefs
  mediaPrefs: z4.object({
    autoplay: z4.boolean().optional(),
    dataSaver: z4.boolean().optional(),
    uploadQuality: z4.enum(["low", "medium", "high"]).optional()
  }).optional()
});
var updateFullProfileSchema = z4.object({
  displayName: z4.string().max(50, "Display name too long").optional(),
  bio: z4.string().max(500, "Bio too long").optional().nullable(),
  avatarUrl: z4.string().url().optional().nullable(),
  coverUrl: z4.string().url().optional().nullable(),
  linkUrl: z4.string().url().max(200, "Link URL too long").optional().nullable(),
  location: z4.string().max(100, "Location too long").optional().nullable(),
  pronouns: z4.string().max(30, "Pronouns too long").optional().nullable(),
  category: userCategoryEnum2.optional()
});
var changePasswordSchema = z4.object({
  currentPassword: z4.string().min(1, "Current password is required"),
  newPassword: z4.string().min(8, "New password must be at least 8 characters").max(100, "Password too long")
});
var deleteAccountSchema = z4.object({
  password: z4.string().min(1, "Password is required for account deletion")
});
var verificationCategoryEnum2 = z4.enum(["CELEBRITY", "INFLUENCER", "BUSINESS", "ORGANIZATION", "GOVERNMENT", "OTHER"]);
var submitVerificationSchema = z4.object({
  fullName: z4.string().min(2, "Full name must be at least 2 characters").max(100, "Full name too long"),
  category: verificationCategoryEnum2,
  documentUrls: z4.array(z4.string()).max(5, "Maximum 5 documents allowed").default([]),
  links: z4.array(z4.string()).max(5, "Maximum 5 links allowed").default([]),
  reason: z4.string().min(50, "Reason must be at least 50 characters").max(2e3, "Reason too long")
});
var updateVerificationSchema = z4.object({
  status: z4.enum(["UNDER_REVIEW", "APPROVED", "DENIED", "MORE_INFO_NEEDED"]).optional(),
  adminNotes: z4.string().max(2e3).optional().nullable(),
  denialReason: z4.string().max(500).optional().nullable()
});
var verificationActionSchema = z4.object({
  action: z4.enum(["approve", "deny", "request_info"]),
  reason: z4.string().max(500).optional(),
  notes: z4.string().max(2e3).optional()
});

// server/routes-link-preview.ts
var MAX_RESPONSE_SIZE = 1024 * 1024;
var FETCH_TIMEOUT = 5e3;
var CACHE_TTL = 60 * 60 * 1e3;
var CACHE_MAX_SIZE = 1e3;
var cache = /* @__PURE__ */ new Map();
var cacheOrder = [];
function getCached(url) {
  const entry = cache.get(url);
  if (!entry) return null;
  if (Date.now() - entry.timestamp > CACHE_TTL) {
    cache.delete(url);
    const idx = cacheOrder.indexOf(url);
    if (idx !== -1) cacheOrder.splice(idx, 1);
    return null;
  }
  return entry.data;
}
function setCache(url, data) {
  if (cache.size >= CACHE_MAX_SIZE) {
    const oldest = cacheOrder.shift();
    if (oldest) cache.delete(oldest);
  }
  cache.set(url, { data, timestamp: Date.now() });
  cacheOrder.push(url);
}
var rateLimitHandler = (req, res) => {
  res.status(429).json(
    apiError(
      ErrorCodes.RATE_LIMITED,
      "Too many link preview requests. Please try again later."
    )
  );
};
var linkPreviewLimiter = rateLimit({
  windowMs: 60 * 1e3,
  max: 30,
  message: "Too many link preview requests. Please slow down.",
  standardHeaders: true,
  legacyHeaders: false,
  handler: rateLimitHandler,
  skip: (req) => !req.session?.userId
});
function isValidUrl(urlString) {
  try {
    const url = new URL(urlString);
    return url.protocol === "http:" || url.protocol === "https:";
  } catch {
    return false;
  }
}
function isPrivateOrLocalhost(urlString) {
  try {
    const url = new URL(urlString);
    const hostname = url.hostname.toLowerCase();
    if (hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1") {
      return true;
    }
    if (hostname === "0.0.0.0") {
      return true;
    }
    const ipv4Match = hostname.match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/);
    if (ipv4Match) {
      const [, a, b, c, d] = ipv4Match.map(Number);
      if (a === 10) return true;
      if (a === 172 && b >= 16 && b <= 31) return true;
      if (a === 192 && b === 168) return true;
      if (a === 127) return true;
      if (a === 169 && b === 254) return true;
      if (a === 0) return true;
    }
    if (hostname.endsWith(".local") || hostname.endsWith(".internal")) {
      return true;
    }
    return false;
  } catch {
    return true;
  }
}
function sanitizeText(text3) {
  if (!text3) return "";
  return text3.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "").replace(/<[^>]+>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&#x2F;/g, "/").replace(/javascript:/gi, "").replace(/on\w+=/gi, "").trim().slice(0, 500);
}
function sanitizeUrl(url) {
  if (!url) return null;
  try {
    const parsed = new URL(url.trim());
    if (parsed.protocol === "http:" || parsed.protocol === "https:") {
      return parsed.href;
    }
    return null;
  } catch {
    return null;
  }
}
function extractDomain(urlString) {
  try {
    const url = new URL(urlString);
    return url.hostname.replace(/^www\./, "");
  } catch {
    return "";
  }
}
function extractMetaContent(html, property) {
  const patterns = [
    new RegExp(`<meta[^>]+(?:property|name)=["']${property}["'][^>]+content=["']([^"']+)["']`, "i"),
    new RegExp(`<meta[^>]+content=["']([^"']+)["'][^>]+(?:property|name)=["']${property}["']`, "i")
  ];
  for (const pattern of patterns) {
    const match = html.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
  return null;
}
function extractTitle(html) {
  const ogTitle = extractMetaContent(html, "og:title");
  if (ogTitle) return sanitizeText(ogTitle);
  const twitterTitle = extractMetaContent(html, "twitter:title");
  if (twitterTitle) return sanitizeText(twitterTitle);
  const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
  if (titleMatch && titleMatch[1]) {
    return sanitizeText(titleMatch[1]);
  }
  return "";
}
function extractDescription(html) {
  const ogDesc = extractMetaContent(html, "og:description");
  if (ogDesc) return sanitizeText(ogDesc);
  const twitterDesc = extractMetaContent(html, "twitter:description");
  if (twitterDesc) return sanitizeText(twitterDesc);
  const metaDesc = extractMetaContent(html, "description");
  if (metaDesc) return sanitizeText(metaDesc);
  return "";
}
function extractImage(html, baseUrl) {
  const ogImage = extractMetaContent(html, "og:image");
  if (ogImage) {
    const sanitized = sanitizeUrl(ogImage);
    if (sanitized) return sanitized;
    try {
      return new URL(ogImage, baseUrl).href;
    } catch {
    }
  }
  const twitterImage = extractMetaContent(html, "twitter:image");
  if (twitterImage) {
    const sanitized = sanitizeUrl(twitterImage);
    if (sanitized) return sanitized;
    try {
      return new URL(twitterImage, baseUrl).href;
    } catch {
    }
  }
  return null;
}
async function fetchWithTimeout(url, timeout) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(url, {
      signal: controller.signal,
      headers: {
        "User-Agent": "Mozilla/5.0 (compatible; RabitChatBot/1.0; +https://rabitchat.com)",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5"
      },
      redirect: "follow"
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}
function registerLinkPreviewRoutes(app2) {
  app2.get("/api/link-preview", linkPreviewLimiter, async (req, res) => {
    const url = req.query.url;
    if (!url) {
      return res.status(400).json({
        success: false,
        error: "URL parameter is required"
      });
    }
    if (!isValidUrl(url)) {
      return res.status(400).json({
        success: false,
        error: "Invalid URL format. Must be http or https."
      });
    }
    if (isPrivateOrLocalhost(url)) {
      return res.status(400).json({
        success: false,
        error: "Cannot fetch private or local URLs"
      });
    }
    const cached = getCached(url);
    if (cached) {
      return res.json({
        success: true,
        data: cached
      });
    }
    try {
      const response = await fetchWithTimeout(url, FETCH_TIMEOUT);
      if (!response.ok) {
        return res.status(502).json({
          success: false,
          error: `Failed to fetch URL: ${response.status} ${response.statusText}`
        });
      }
      const contentType = response.headers.get("content-type") || "";
      if (!contentType.includes("text/html") && !contentType.includes("application/xhtml")) {
        const domain2 = extractDomain(url);
        const data2 = {
          url,
          title: domain2,
          description: "",
          image: null,
          domain: domain2
        };
        setCache(url, data2);
        return res.json({ success: true, data: data2 });
      }
      const contentLength = response.headers.get("content-length");
      if (contentLength && parseInt(contentLength, 10) > MAX_RESPONSE_SIZE) {
        return res.status(413).json({
          success: false,
          error: "Response too large"
        });
      }
      let html = "";
      let bytesRead = 0;
      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      if (reader) {
        while (bytesRead < MAX_RESPONSE_SIZE) {
          const { done, value } = await reader.read();
          if (done) break;
          bytesRead += value.length;
          if (bytesRead > MAX_RESPONSE_SIZE) {
            reader.cancel();
            break;
          }
          html += decoder.decode(value, { stream: true });
          if (html.includes("</head>")) {
            reader.cancel();
            break;
          }
        }
      } else {
        html = await response.text();
        if (html.length > MAX_RESPONSE_SIZE) {
          html = html.slice(0, MAX_RESPONSE_SIZE);
        }
      }
      const title = extractTitle(html);
      const description = extractDescription(html);
      const image = extractImage(html, url);
      const domain = extractDomain(url);
      const data = {
        url,
        title: title || domain,
        description,
        image,
        domain
      };
      setCache(url, data);
      return res.json({
        success: true,
        data
      });
    } catch (error) {
      if (error.name === "AbortError") {
        return res.status(504).json({
          success: false,
          error: "Request timed out"
        });
      }
      console.error("[LinkPreview] Error fetching URL:", error.message);
      return res.status(502).json({
        success: false,
        error: "Failed to fetch URL"
      });
    }
  });
}

// server/routes-messages.ts
init_db();
init_schema();
import { eq as eq11, and as and10, desc as desc8, ilike as ilike3, or as or7 } from "drizzle-orm";

// server/rate-limit.ts
import rateLimit2 from "express-rate-limit";
var rateLimitHandler2 = (req, res) => {
  res.status(429).json(
    apiError(
      ErrorCodes.RATE_LIMITED,
      "Too many requests. Please try again later."
    )
  );
};
var authLimiter = rateLimit2({
  windowMs: 15 * 60 * 1e3,
  max: 10,
  message: "Too many authentication attempts. Please try again in 15 minutes.",
  standardHeaders: true,
  legacyHeaders: false,
  handler: rateLimitHandler2
});
var signupLimiter = rateLimit2({
  windowMs: 60 * 60 * 1e3,
  max: process.env.NODE_ENV === "development" ? 100 : 5,
  message: "Too many account creation attempts. Please try again in an hour.",
  standardHeaders: true,
  legacyHeaders: false,
  handler: rateLimitHandler2
});
var postLimiter = rateLimit2({
  windowMs: 60 * 1e3,
  max: 10,
  message: "Too many posts. Please slow down.",
  standardHeaders: true,
  legacyHeaders: false,
  handler: rateLimitHandler2,
  skip: (req) => !req.session?.userId
});
var commentLimiter = rateLimit2({
  windowMs: 60 * 1e3,
  max: 20,
  message: "Too many comments. Please slow down.",
  standardHeaders: true,
  legacyHeaders: false,
  handler: rateLimitHandler2,
  skip: (req) => !req.session?.userId
});
var messageLimiter = rateLimit2({
  windowMs: 60 * 1e3,
  max: 30,
  message: "Too many messages. Please slow down.",
  standardHeaders: true,
  legacyHeaders: false,
  handler: rateLimitHandler2,
  skip: (req) => !req.session?.userId
});
var apiLimiter = rateLimit2({
  windowMs: 60 * 1e3,
  max: 100,
  message: "Too many API requests. Please slow down.",
  standardHeaders: true,
  legacyHeaders: false,
  handler: rateLimitHandler2
});
var uploadLimiter = rateLimit2({
  windowMs: 15 * 60 * 1e3,
  max: 30,
  message: "Too many upload attempts. Please try again in 15 minutes.",
  standardHeaders: true,
  legacyHeaders: false,
  handler: rateLimitHandler2,
  skip: (req) => !req.session?.userId
});

// server/notifications.ts
init_db();
init_schema();
import ExpoModule from "expo-server-sdk";
import { eq as eq10, and as and9, isNull as isNull6 } from "drizzle-orm";
var Expo = ExpoModule.default || ExpoModule;
var expo = new Expo();
function getNotificationBody(messageType, senderName, messageContent, fileName) {
  switch (messageType) {
    case "PHOTO":
      return `New photo from ${senderName}`;
    case "VIDEO":
      return `New video from ${senderName}`;
    case "VOICE":
      return `Voice message from ${senderName}`;
    case "FILE":
      return fileName ? `New file from ${senderName}: ${fileName}` : `New file from ${senderName}`;
    case "GIF":
      return `${senderName} sent a GIF`;
    case "STICKER":
      return `${senderName} sent a sticker`;
    case "LINK":
      return messageContent ? `New message from ${senderName}: ${truncatePreview(messageContent)}` : `${senderName} shared a link`;
    case "TEXT":
    default:
      return messageContent ? `New message from ${senderName}: ${truncatePreview(messageContent)}` : `New message from ${senderName}`;
  }
}
function truncatePreview(content, maxLength = 50) {
  if (content.length <= maxLength) return content;
  return content.slice(0, maxLength - 3) + "...";
}
async function getRecipientPushTokens(recipientId) {
  const tokens = await db.select({ token: pushTokens.token }).from(pushTokens).where(
    and9(
      eq10(pushTokens.userId, recipientId),
      eq10(pushTokens.isActive, true)
    )
  );
  return tokens.map((t) => t.token).filter((token) => Expo.isExpoPushToken(token));
}
async function isConversationMuted(conversationId, userId) {
  const [settings] = await db.select({
    isMuted: conversationSettings.isMuted,
    mutedUntil: conversationSettings.mutedUntil
  }).from(conversationSettings).where(
    and9(
      eq10(conversationSettings.conversationId, conversationId),
      eq10(conversationSettings.userId, userId)
    )
  ).limit(1);
  if (!settings) return false;
  if (!settings.isMuted) return false;
  if (settings.mutedUntil) {
    const now = /* @__PURE__ */ new Date();
    if (now > settings.mutedUntil) {
      await db.update(conversationSettings).set({ isMuted: false, mutedUntil: null }).where(
        and9(
          eq10(conversationSettings.conversationId, conversationId),
          eq10(conversationSettings.userId, userId)
        )
      );
      return false;
    }
  }
  return true;
}
async function getUnreadMessageCount(userId) {
  const result = await db.select({ id: messages.id }).from(messages).where(
    and9(
      eq10(messages.receiverId, userId),
      eq10(messages.read, false),
      isNull6(messages.deletedAt),
      eq10(messages.deletedForReceiver, false)
    )
  );
  return result.length;
}
async function handlePushReceipts2(tickets, tokens) {
  for (let i = 0; i < tickets.length; i++) {
    const ticket = tickets[i];
    const token = tokens[i];
    if (ticket.status === "error") {
      console.error(`[Push] Error for token ${token}:`, ticket.message);
      if (ticket.details?.error === "DeviceNotRegistered" || ticket.details?.error === "InvalidCredentials") {
        await db.update(pushTokens).set({ isActive: false }).where(eq10(pushTokens.token, token));
        console.log(`[Push] Deactivated invalid token: ${token}`);
      }
    }
  }
}
async function sendMessageNotification(recipientId, senderId, senderName, messageType, messageContent, conversationId, messageId, fileName) {
  try {
    if (recipientId === senderId) {
      return;
    }
    const isMuted = await isConversationMuted(conversationId, recipientId);
    if (isMuted) {
      console.log(`[Push] Conversation ${conversationId} is muted for user ${recipientId}`);
      return;
    }
    const tokens = await getRecipientPushTokens(recipientId);
    if (tokens.length === 0) {
      console.log(`[Push] No valid push tokens for user ${recipientId}`);
      return;
    }
    const badgeCount = await getUnreadMessageCount(recipientId);
    const body = getNotificationBody(
      messageType,
      senderName,
      messageContent,
      fileName
    );
    const pushMessages = tokens.map((token) => ({
      to: token,
      title: senderName,
      body,
      sound: "default",
      priority: "high",
      badge: badgeCount + 1,
      data: {
        type: "MESSAGE",
        conversationId,
        messageId,
        senderId,
        messageType,
        screen: "Chat",
        params: { conversationId }
      },
      channelId: "messages",
      categoryId: "message"
    }));
    const chunks = expo.chunkPushNotifications(pushMessages);
    const tickets = [];
    for (const chunk of chunks) {
      try {
        const ticketChunk = await expo.sendPushNotificationsAsync(chunk);
        tickets.push(...ticketChunk);
      } catch (error) {
        console.error("[Push] Error sending chunk:", error);
      }
    }
    await handlePushReceipts2(tickets, tokens);
    console.log(
      `[Push] Sent message notification to user ${recipientId} for message ${messageId}`
    );
  } catch (error) {
    console.error("[Push] Error sending message notification:", error);
  }
}

// server/routes-messages.ts
function requireAuth2(req, res, next) {
  if (!req.session.userId) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  next();
}
async function getMessageReactions(messageId) {
  const reactions = await db.select({
    id: messageReactions.id,
    messageId: messageReactions.messageId,
    userId: messageReactions.userId,
    reaction: messageReactions.reaction,
    createdAt: messageReactions.createdAt
  }).from(messageReactions).where(eq11(messageReactions.messageId, messageId));
  const groupedReactions = {};
  for (const r of reactions) {
    if (!groupedReactions[r.reaction]) {
      groupedReactions[r.reaction] = { emoji: r.reaction, count: 0, userIds: [] };
    }
    groupedReactions[r.reaction].count++;
    groupedReactions[r.reaction].userIds.push(r.userId);
  }
  return Object.values(groupedReactions);
}
async function isMessageParticipant(userId, messageId) {
  const [message] = await db.select({ senderId: messages.senderId, receiverId: messages.receiverId }).from(messages).where(eq11(messages.id, messageId)).limit(1);
  if (!message) return false;
  return message.senderId === userId || message.receiverId === userId;
}
async function isConversationParticipant(userId, conversationId) {
  const [conversation] = await db.select({ participant1Id: conversations.participant1Id, participant2Id: conversations.participant2Id }).from(conversations).where(eq11(conversations.id, conversationId)).limit(1);
  if (!conversation) return false;
  return conversation.participant1Id === userId || conversation.participant2Id === userId;
}
function registerMessageRoutes(app2) {
  app2.post("/api/messages/:messageId/react", requireAuth2, async (req, res) => {
    try {
      const { messageId } = req.params;
      const { emoji } = req.body;
      const userId = req.session.userId;
      if (!emoji || typeof emoji !== "string" || emoji.length > 10) {
        return res.status(400).json({ message: "Invalid emoji" });
      }
      const isParticipant = await isMessageParticipant(userId, messageId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to react to this message" });
      }
      const [existingReaction] = await db.select().from(messageReactions).where(and10(
        eq11(messageReactions.messageId, messageId),
        eq11(messageReactions.userId, userId)
      )).limit(1);
      if (existingReaction) {
        if (existingReaction.reaction === emoji) {
          await db.delete(messageReactions).where(eq11(messageReactions.id, existingReaction.id));
        } else {
          await db.update(messageReactions).set({ reaction: emoji, createdAt: /* @__PURE__ */ new Date() }).where(eq11(messageReactions.id, existingReaction.id));
        }
      } else {
        await db.insert(messageReactions).values({
          messageId,
          userId,
          reaction: emoji
        });
      }
      const updatedReactions = await getMessageReactions(messageId);
      res.json({ reactions: updatedReactions });
    } catch (error) {
      console.error("[Messages] Add reaction error:", error);
      res.status(500).json({ message: "Failed to add reaction" });
    }
  });
  app2.delete("/api/messages/:messageId/react", requireAuth2, async (req, res) => {
    try {
      const { messageId } = req.params;
      const { emoji } = req.body;
      const userId = req.session.userId;
      const isParticipant = await isMessageParticipant(userId, messageId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to remove reaction from this message" });
      }
      if (emoji) {
        await db.delete(messageReactions).where(and10(
          eq11(messageReactions.messageId, messageId),
          eq11(messageReactions.userId, userId),
          eq11(messageReactions.reaction, emoji)
        ));
      } else {
        await db.delete(messageReactions).where(and10(
          eq11(messageReactions.messageId, messageId),
          eq11(messageReactions.userId, userId)
        ));
      }
      const updatedReactions = await getMessageReactions(messageId);
      res.json({ reactions: updatedReactions });
    } catch (error) {
      console.error("[Messages] Remove reaction error:", error);
      res.status(500).json({ message: "Failed to remove reaction" });
    }
  });
  app2.post("/api/messages/:messageId/read", requireAuth2, async (req, res) => {
    try {
      const { messageId } = req.params;
      const userId = req.session.userId;
      const [message] = await db.select().from(messages).where(eq11(messages.id, messageId)).limit(1);
      if (!message) {
        return res.status(404).json({ message: "Message not found" });
      }
      if (message.receiverId !== userId) {
        return res.status(403).json({ message: "Not authorized to mark this message as read" });
      }
      if (message.read) {
        return res.json({ message: "Message already read", readAt: message.readAt });
      }
      const now = /* @__PURE__ */ new Date();
      await db.update(messages).set({
        read: true,
        readAt: now,
        status: "READ"
      }).where(eq11(messages.id, messageId));
      res.json({ message: "Message marked as read", readAt: now });
    } catch (error) {
      console.error("[Messages] Mark read error:", error);
      res.status(500).json({ message: "Failed to mark message as read" });
    }
  });
  app2.delete("/api/messages/:messageId", requireAuth2, async (req, res) => {
    try {
      const { messageId } = req.params;
      const deleteForEveryone = req.query.deleteForEveryone === "true";
      const userId = req.session.userId;
      const [message] = await db.select().from(messages).where(eq11(messages.id, messageId)).limit(1);
      if (!message) {
        return res.status(404).json({ message: "Message not found" });
      }
      const isSender = message.senderId === userId;
      const isReceiver = message.receiverId === userId;
      if (!isSender && !isReceiver) {
        return res.status(403).json({ message: "Not authorized to delete this message" });
      }
      if (deleteForEveryone) {
        if (!isSender) {
          return res.status(403).json({ message: "Only the sender can delete for everyone" });
        }
        const messageAge = Date.now() - new Date(message.createdAt).getTime();
        const oneHourMs = 60 * 60 * 1e3;
        if (messageAge > oneHourMs) {
          return res.status(400).json({ message: "Messages can only be deleted for everyone within 1 hour of sending" });
        }
        await db.update(messages).set({
          deletedAt: /* @__PURE__ */ new Date(),
          content: "[Message deleted]",
          mediaUrl: null,
          mediaThumbnail: null,
          fileName: null,
          encryptedContent: null,
          encryptedKey: null,
          iv: null
        }).where(eq11(messages.id, messageId));
        res.json({ message: "Message deleted for everyone" });
      } else {
        if (isSender) {
          await db.update(messages).set({ deletedForSender: true }).where(eq11(messages.id, messageId));
        } else {
          await db.update(messages).set({ deletedForReceiver: true }).where(eq11(messages.id, messageId));
        }
        res.json({ message: "Message deleted" });
      }
    } catch (error) {
      console.error("[Messages] Delete message error:", error);
      res.status(500).json({ message: "Failed to delete message" });
    }
  });
  app2.post("/api/messages/:messageId/forward", requireAuth2, messageLimiter, async (req, res) => {
    try {
      const { messageId } = req.params;
      const { conversationId } = req.body;
      const userId = req.session.userId;
      if (!conversationId) {
        return res.status(400).json({ message: "conversationId is required" });
      }
      const isOriginalParticipant = await isMessageParticipant(userId, messageId);
      if (!isOriginalParticipant) {
        return res.status(403).json({ message: "Not authorized to forward this message" });
      }
      const isTargetParticipant = await isConversationParticipant(userId, conversationId);
      if (!isTargetParticipant) {
        return res.status(403).json({ message: "Not authorized to send to this conversation" });
      }
      const [originalMessage] = await db.select().from(messages).where(eq11(messages.id, messageId)).limit(1);
      if (!originalMessage) {
        return res.status(404).json({ message: "Original message not found" });
      }
      if (originalMessage.deletedAt) {
        return res.status(400).json({ message: "Cannot forward a deleted message" });
      }
      const [targetConversation] = await db.select().from(conversations).where(eq11(conversations.id, conversationId)).limit(1);
      if (!targetConversation) {
        return res.status(404).json({ message: "Target conversation not found" });
      }
      const receiverId = targetConversation.participant1Id === userId ? targetConversation.participant2Id : targetConversation.participant1Id;
      const forwardedContent = originalMessage.content ? `\u21AA Forwarded:
${originalMessage.content}` : "\u21AA Forwarded message";
      const [forwardedMessage] = await db.insert(messages).values({
        conversationId,
        senderId: userId,
        receiverId,
        content: forwardedContent,
        messageType: originalMessage.messageType,
        mediaUrl: originalMessage.mediaUrl,
        mediaThumbnail: originalMessage.mediaThumbnail,
        mediaDuration: originalMessage.mediaDuration,
        fileName: originalMessage.fileName,
        fileSize: originalMessage.fileSize,
        fileMimeType: originalMessage.fileMimeType,
        voiceWaveform: originalMessage.voiceWaveform,
        linkUrl: originalMessage.linkUrl,
        linkTitle: originalMessage.linkTitle,
        linkDescription: originalMessage.linkDescription,
        linkImage: originalMessage.linkImage,
        linkDomain: originalMessage.linkDomain,
        replyToId: messageId,
        status: "SENT"
      }).returning();
      await db.update(conversations).set({ lastMessageAt: /* @__PURE__ */ new Date() }).where(eq11(conversations.id, conversationId));
      res.json(forwardedMessage);
    } catch (error) {
      console.error("[Messages] Forward message error:", error);
      res.status(500).json({ message: "Failed to forward message" });
    }
  });
  app2.get("/api/conversations/:conversationId/search", requireAuth2, async (req, res) => {
    try {
      const { conversationId } = req.params;
      const { q, limit: limitStr } = req.query;
      const userId = req.session.userId;
      const limit = Math.min(parseInt(limitStr) || 50, 100);
      if (!q || typeof q !== "string" || q.trim().length === 0) {
        return res.status(400).json({ message: "Search query is required" });
      }
      const isParticipant = await isConversationParticipant(userId, conversationId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to search this conversation" });
      }
      const searchQuery = q.trim();
      const results = await db.select({
        id: messages.id,
        conversationId: messages.conversationId,
        senderId: messages.senderId,
        receiverId: messages.receiverId,
        content: messages.content,
        messageType: messages.messageType,
        mediaUrl: messages.mediaUrl,
        fileName: messages.fileName,
        createdAt: messages.createdAt
      }).from(messages).where(and10(
        eq11(messages.conversationId, conversationId),
        ilike3(messages.content, `%${searchQuery}%`),
        or7(
          and10(eq11(messages.senderId, userId), eq11(messages.deletedForSender, false)),
          and10(eq11(messages.receiverId, userId), eq11(messages.deletedForReceiver, false))
        )
      )).orderBy(desc8(messages.createdAt)).limit(limit);
      res.json({ messages: results, query: searchQuery, count: results.length });
    } catch (error) {
      console.error("[Messages] Search messages error:", error);
      res.status(500).json({ message: "Failed to search messages" });
    }
  });
  app2.post("/api/conversations/:conversationId/messages", requireAuth2, messageLimiter, async (req, res) => {
    try {
      const { conversationId } = req.params;
      const userId = req.session.userId;
      const {
        content,
        messageType = "TEXT",
        mediaUrl,
        mediaThumbnail,
        mediaDuration,
        fileName,
        fileSize,
        fileMimeType,
        voiceWaveform,
        linkUrl,
        linkTitle,
        linkDescription,
        linkImage,
        linkDomain,
        replyToMessageId,
        encryptedContent,
        encryptedKey,
        iv
      } = req.body;
      const [conversation] = await db.select().from(conversations).where(eq11(conversations.id, conversationId)).limit(1);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      const { participant1Id, participant2Id } = conversation;
      if (participant1Id !== userId && participant2Id !== userId) {
        return res.status(403).json({ message: "Not authorized to send messages in this conversation" });
      }
      const receiverId = participant1Id === userId ? participant2Id : participant1Id;
      const validMessageTypes = ["TEXT", "PHOTO", "VIDEO", "FILE", "VOICE", "GIF", "STICKER", "LINK"];
      if (!validMessageTypes.includes(messageType)) {
        return res.status(400).json({ message: "Invalid message type" });
      }
      if (messageType === "TEXT" && !content && !encryptedContent) {
        return res.status(400).json({ message: "Content is required for text messages" });
      }
      if (["PHOTO", "VIDEO", "FILE", "VOICE", "GIF", "STICKER"].includes(messageType) && !mediaUrl) {
        return res.status(400).json({ message: "Media URL is required for media messages" });
      }
      if (messageType === "LINK" && !linkUrl) {
        return res.status(400).json({ message: "Link URL is required for link messages" });
      }
      if (replyToMessageId) {
        const [replyMessage] = await db.select({ id: messages.id, conversationId: messages.conversationId }).from(messages).where(eq11(messages.id, replyToMessageId)).limit(1);
        if (!replyMessage || replyMessage.conversationId !== conversationId) {
          return res.status(400).json({ message: "Invalid reply message" });
        }
      }
      const [newMessage] = await db.insert(messages).values({
        conversationId,
        senderId: userId,
        receiverId,
        content: content || "",
        messageType,
        mediaUrl: mediaUrl || null,
        mediaThumbnail: mediaThumbnail || null,
        mediaDuration: mediaDuration || null,
        fileName: fileName || null,
        fileSize: fileSize || null,
        fileMimeType: fileMimeType || null,
        voiceWaveform: voiceWaveform || null,
        linkUrl: linkUrl || null,
        linkTitle: linkTitle || null,
        linkDescription: linkDescription || null,
        linkImage: linkImage || null,
        linkDomain: linkDomain || null,
        replyToId: replyToMessageId || null,
        encryptedContent: encryptedContent || null,
        encryptedKey: encryptedKey || null,
        iv: iv || null,
        status: "SENT"
      }).returning();
      await db.update(conversations).set({ lastMessageAt: /* @__PURE__ */ new Date() }).where(eq11(conversations.id, conversationId));
      const [sender] = await db.select({
        id: users.id,
        username: users.username,
        displayName: users.displayName,
        avatarUrl: users.avatarUrl
      }).from(users).where(eq11(users.id, userId)).limit(1);
      if (sender && userId !== receiverId) {
        sendMessageNotification(
          receiverId,
          userId,
          sender.displayName || sender.username,
          messageType,
          content || void 0,
          conversationId,
          newMessage.id,
          fileName || void 0
        ).catch((err) => console.error("[Push] Message notification error:", err));
      }
      let replyToMessage = null;
      if (replyToMessageId) {
        const [reply] = await db.select({
          id: messages.id,
          content: messages.content,
          senderId: messages.senderId,
          messageType: messages.messageType
        }).from(messages).where(eq11(messages.id, replyToMessageId)).limit(1);
        replyToMessage = reply || null;
      }
      res.status(201).json({
        ...newMessage,
        sender,
        replyToMessage
      });
    } catch (error) {
      console.error("[Messages] Create message error:", error);
      res.status(500).json({ message: "Failed to create message" });
    }
  });
  app2.get("/api/messages/:messageId/reactions", requireAuth2, async (req, res) => {
    try {
      const { messageId } = req.params;
      const userId = req.session.userId;
      const isParticipant = await isMessageParticipant(userId, messageId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to view reactions for this message" });
      }
      const reactions = await getMessageReactions(messageId);
      res.json({ reactions });
    } catch (error) {
      console.error("[Messages] Get reactions error:", error);
      res.status(500).json({ message: "Failed to get reactions" });
    }
  });
}

// server/routes-conversation-settings.ts
init_db();
init_schema();
import { eq as eq12, and as and11 } from "drizzle-orm";
function requireAuth3(req, res, next) {
  if (!req.session.userId) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  next();
}
async function isConversationParticipant2(userId, conversationId) {
  const [conversation] = await db.select({ participant1Id: conversations.participant1Id, participant2Id: conversations.participant2Id }).from(conversations).where(eq12(conversations.id, conversationId)).limit(1);
  if (!conversation) return false;
  return conversation.participant1Id === userId || conversation.participant2Id === userId;
}
function calculateMutedUntil(duration) {
  const now = /* @__PURE__ */ new Date();
  switch (duration) {
    case "1hour":
      return new Date(now.getTime() + 60 * 60 * 1e3);
    case "8hours":
      return new Date(now.getTime() + 8 * 60 * 60 * 1e3);
    case "1day":
      return new Date(now.getTime() + 24 * 60 * 60 * 1e3);
    case "1week":
      return new Date(now.getTime() + 7 * 24 * 60 * 60 * 1e3);
    case "forever":
    default:
      return null;
  }
}
function registerConversationSettingsRoutes(app2) {
  app2.get("/api/conversations/:conversationId/settings", requireAuth3, async (req, res) => {
    try {
      const { conversationId } = req.params;
      const userId = req.session.userId;
      const isParticipant = await isConversationParticipant2(userId, conversationId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to access this conversation" });
      }
      const [settings] = await db.select({
        isMuted: conversationSettings.isMuted,
        mutedUntil: conversationSettings.mutedUntil,
        isPinned: conversationSettings.isPinned,
        isArchived: conversationSettings.isArchived,
        notificationSound: conversationSettings.notificationSound,
        customName: conversationSettings.customName
      }).from(conversationSettings).where(and11(
        eq12(conversationSettings.conversationId, conversationId),
        eq12(conversationSettings.userId, userId)
      )).limit(1);
      if (!settings) {
        return res.json({
          isMuted: false,
          mutedUntil: null,
          isPinned: false,
          isArchived: false,
          notificationSound: "default",
          customName: null
        });
      }
      res.json(settings);
    } catch (error) {
      console.error("[ConversationSettings] Get settings error:", error);
      res.status(500).json({ message: "Failed to get conversation settings" });
    }
  });
  app2.patch("/api/conversations/:conversationId/settings", requireAuth3, async (req, res) => {
    try {
      const { conversationId } = req.params;
      const userId = req.session.userId;
      const { isMuted, mutedUntil, isPinned, isArchived, notificationSound, customName } = req.body;
      const isParticipant = await isConversationParticipant2(userId, conversationId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to access this conversation" });
      }
      const updateData = { updatedAt: /* @__PURE__ */ new Date() };
      if (isMuted !== void 0) updateData.isMuted = isMuted;
      if (mutedUntil !== void 0) updateData.mutedUntil = mutedUntil ? new Date(mutedUntil) : null;
      if (isPinned !== void 0) updateData.isPinned = isPinned;
      if (isArchived !== void 0) updateData.isArchived = isArchived;
      if (notificationSound !== void 0) updateData.notificationSound = notificationSound;
      if (customName !== void 0) updateData.customName = customName;
      const [existing] = await db.select({ id: conversationSettings.id }).from(conversationSettings).where(and11(
        eq12(conversationSettings.conversationId, conversationId),
        eq12(conversationSettings.userId, userId)
      )).limit(1);
      let result;
      if (existing) {
        [result] = await db.update(conversationSettings).set(updateData).where(eq12(conversationSettings.id, existing.id)).returning({
          isMuted: conversationSettings.isMuted,
          mutedUntil: conversationSettings.mutedUntil,
          isPinned: conversationSettings.isPinned,
          isArchived: conversationSettings.isArchived,
          notificationSound: conversationSettings.notificationSound,
          customName: conversationSettings.customName
        });
      } else {
        [result] = await db.insert(conversationSettings).values({
          conversationId,
          userId,
          ...updateData
        }).returning({
          isMuted: conversationSettings.isMuted,
          mutedUntil: conversationSettings.mutedUntil,
          isPinned: conversationSettings.isPinned,
          isArchived: conversationSettings.isArchived,
          notificationSound: conversationSettings.notificationSound,
          customName: conversationSettings.customName
        });
      }
      res.json(result);
    } catch (error) {
      console.error("[ConversationSettings] Update settings error:", error);
      res.status(500).json({ message: "Failed to update conversation settings" });
    }
  });
  app2.post("/api/conversations/:conversationId/mute", requireAuth3, async (req, res) => {
    try {
      const { conversationId } = req.params;
      const userId = req.session.userId;
      const { duration = "forever" } = req.body;
      const isParticipant = await isConversationParticipant2(userId, conversationId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to access this conversation" });
      }
      const validDurations = ["forever", "1hour", "8hours", "1day", "1week"];
      if (!validDurations.includes(duration)) {
        return res.status(400).json({ message: "Invalid duration. Use: forever, 1hour, 8hours, 1day, 1week" });
      }
      const mutedUntil = calculateMutedUntil(duration);
      const updateData = {
        isMuted: true,
        mutedUntil,
        updatedAt: /* @__PURE__ */ new Date()
      };
      const [existing] = await db.select({ id: conversationSettings.id }).from(conversationSettings).where(and11(
        eq12(conversationSettings.conversationId, conversationId),
        eq12(conversationSettings.userId, userId)
      )).limit(1);
      let result;
      if (existing) {
        [result] = await db.update(conversationSettings).set(updateData).where(eq12(conversationSettings.id, existing.id)).returning({
          isMuted: conversationSettings.isMuted,
          mutedUntil: conversationSettings.mutedUntil
        });
      } else {
        [result] = await db.insert(conversationSettings).values({
          conversationId,
          userId,
          isMuted: true,
          mutedUntil
        }).returning({
          isMuted: conversationSettings.isMuted,
          mutedUntil: conversationSettings.mutedUntil
        });
      }
      res.json({ message: "Conversation muted", ...result });
    } catch (error) {
      console.error("[ConversationSettings] Mute error:", error);
      res.status(500).json({ message: "Failed to mute conversation" });
    }
  });
  app2.post("/api/conversations/:conversationId/unmute", requireAuth3, async (req, res) => {
    try {
      const { conversationId } = req.params;
      const userId = req.session.userId;
      const isParticipant = await isConversationParticipant2(userId, conversationId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to access this conversation" });
      }
      const [existing] = await db.select({ id: conversationSettings.id }).from(conversationSettings).where(and11(
        eq12(conversationSettings.conversationId, conversationId),
        eq12(conversationSettings.userId, userId)
      )).limit(1);
      if (existing) {
        await db.update(conversationSettings).set({ isMuted: false, mutedUntil: null, updatedAt: /* @__PURE__ */ new Date() }).where(eq12(conversationSettings.id, existing.id));
      }
      res.json({ message: "Conversation unmuted", isMuted: false, mutedUntil: null });
    } catch (error) {
      console.error("[ConversationSettings] Unmute error:", error);
      res.status(500).json({ message: "Failed to unmute conversation" });
    }
  });
  app2.post("/api/conversations/:conversationId/pin", requireAuth3, async (req, res) => {
    try {
      const { conversationId } = req.params;
      const userId = req.session.userId;
      const isParticipant = await isConversationParticipant2(userId, conversationId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to access this conversation" });
      }
      const [existing] = await db.select({ id: conversationSettings.id }).from(conversationSettings).where(and11(
        eq12(conversationSettings.conversationId, conversationId),
        eq12(conversationSettings.userId, userId)
      )).limit(1);
      if (existing) {
        await db.update(conversationSettings).set({ isPinned: true, updatedAt: /* @__PURE__ */ new Date() }).where(eq12(conversationSettings.id, existing.id));
      } else {
        await db.insert(conversationSettings).values({
          conversationId,
          userId,
          isPinned: true
        });
      }
      res.json({ message: "Conversation pinned", isPinned: true });
    } catch (error) {
      console.error("[ConversationSettings] Pin error:", error);
      res.status(500).json({ message: "Failed to pin conversation" });
    }
  });
  app2.post("/api/conversations/:conversationId/unpin", requireAuth3, async (req, res) => {
    try {
      const { conversationId } = req.params;
      const userId = req.session.userId;
      const isParticipant = await isConversationParticipant2(userId, conversationId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to access this conversation" });
      }
      const [existing] = await db.select({ id: conversationSettings.id }).from(conversationSettings).where(and11(
        eq12(conversationSettings.conversationId, conversationId),
        eq12(conversationSettings.userId, userId)
      )).limit(1);
      if (existing) {
        await db.update(conversationSettings).set({ isPinned: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq12(conversationSettings.id, existing.id));
      }
      res.json({ message: "Conversation unpinned", isPinned: false });
    } catch (error) {
      console.error("[ConversationSettings] Unpin error:", error);
      res.status(500).json({ message: "Failed to unpin conversation" });
    }
  });
  app2.post("/api/conversations/:conversationId/archive", requireAuth3, async (req, res) => {
    try {
      const { conversationId } = req.params;
      const userId = req.session.userId;
      const isParticipant = await isConversationParticipant2(userId, conversationId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to access this conversation" });
      }
      const [existing] = await db.select({ id: conversationSettings.id }).from(conversationSettings).where(and11(
        eq12(conversationSettings.conversationId, conversationId),
        eq12(conversationSettings.userId, userId)
      )).limit(1);
      if (existing) {
        await db.update(conversationSettings).set({ isArchived: true, updatedAt: /* @__PURE__ */ new Date() }).where(eq12(conversationSettings.id, existing.id));
      } else {
        await db.insert(conversationSettings).values({
          conversationId,
          userId,
          isArchived: true
        });
      }
      res.json({ message: "Conversation archived", isArchived: true });
    } catch (error) {
      console.error("[ConversationSettings] Archive error:", error);
      res.status(500).json({ message: "Failed to archive conversation" });
    }
  });
  app2.post("/api/conversations/:conversationId/unarchive", requireAuth3, async (req, res) => {
    try {
      const { conversationId } = req.params;
      const userId = req.session.userId;
      const isParticipant = await isConversationParticipant2(userId, conversationId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to access this conversation" });
      }
      const [existing] = await db.select({ id: conversationSettings.id }).from(conversationSettings).where(and11(
        eq12(conversationSettings.conversationId, conversationId),
        eq12(conversationSettings.userId, userId)
      )).limit(1);
      if (existing) {
        await db.update(conversationSettings).set({ isArchived: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq12(conversationSettings.id, existing.id));
      }
      res.json({ message: "Conversation unarchived", isArchived: false });
    } catch (error) {
      console.error("[ConversationSettings] Unarchive error:", error);
      res.status(500).json({ message: "Failed to unarchive conversation" });
    }
  });
}

// server/routes.ts
init_ads_engine();
init_db();
import { sql as sql11, and as and16, eq as eq17, gt as gt6, gte as gte8, isNull as isNull8, inArray as inArray10, desc as desc11, or as or10, like as like2, asc as asc4, ilike as ilike4 } from "drizzle-orm";

// server/policy.ts
init_storage();
var DEFAULT_SETTINGS = {
  privateAccount: false,
  commentPolicy: "EVERYONE",
  messagePolicy: "EVERYONE",
  mentionPolicy: "EVERYONE"
};
async function getViewerContext(userId) {
  if (!userId) {
    return {
      user: null,
      userId: null,
      roles: [],
      permissions: [],
      settings: null,
      isAdmin: false,
      isSuperAdmin: false
    };
  }
  const [user, roles2, settingsResult] = await Promise.all([
    storage.getUser(userId),
    storage.getUserRoles(userId),
    storage.getUserSettings(userId)
  ]);
  const settings = settingsResult ?? null;
  if (!user) {
    return {
      user: null,
      userId: null,
      roles: [],
      permissions: [],
      settings: null,
      isAdmin: false,
      isSuperAdmin: false
    };
  }
  const permissions2 = [];
  for (const role of roles2) {
    const rolePerms = await storage.getRolePermissions(role.id);
    permissions2.push(...rolePerms.map((p) => p.key));
  }
  const isSuperAdmin = roles2.some((r) => r.name === "SUPER_ADMIN") || user.isAdmin === true;
  const isAdmin = isSuperAdmin || roles2.some((r) => ["ADMIN", "MODERATOR", "SUPPORT"].includes(r.name));
  return {
    user,
    userId: user.id,
    roles: roles2,
    permissions: [...new Set(permissions2)],
    settings,
    isAdmin,
    isSuperAdmin
  };
}
function hasPermission(viewer, permission) {
  if (viewer.isSuperAdmin) return true;
  return viewer.permissions.includes(permission);
}
async function canViewProfile(viewer, targetUser) {
  if (!targetUser) {
    return { allowed: false, reason: "User not found" };
  }
  if (viewer.userId === targetUser.id) {
    return { allowed: true };
  }
  if (targetUser.suspendedAt) {
    if (viewer.isAdmin && hasPermission(viewer, "users.read")) {
      return { allowed: true };
    }
    return { allowed: false, reason: "This account has been suspended" };
  }
  if (viewer.userId) {
    const isBlocked = await storage.isBlockedEither(viewer.userId, targetUser.id);
    if (isBlocked) {
      if (viewer.isAdmin && hasPermission(viewer, "users.read")) {
        return { allowed: true };
      }
      return { allowed: false, reason: "Unable to view this profile" };
    }
  }
  const targetSettings = await storage.getUserSettings(targetUser.id);
  const isPrivate = targetSettings?.privateAccount ?? DEFAULT_SETTINGS.privateAccount;
  if (isPrivate) {
    if (viewer.isAdmin && hasPermission(viewer, "users.read")) {
      return { allowed: true };
    }
    if (!viewer.userId) {
      return { allowed: false, reason: "This account is private", restricted: true };
    }
    const isFollowing = await storage.isFollowing(viewer.userId, targetUser.id);
    if (isFollowing) {
      return { allowed: true };
    }
    return { allowed: false, reason: "This account is private", restricted: true };
  }
  return { allowed: true };
}
async function canViewPost(viewer, post, postAuthor) {
  if (!post) {
    return { allowed: false, reason: "Post not found" };
  }
  const authorId = post.authorId;
  const author = postAuthor || await storage.getUser(authorId);
  if (!author) {
    return { allowed: false, reason: "Post author not found" };
  }
  if (viewer.userId === authorId) {
    return { allowed: true };
  }
  if (post.isHidden) {
    if (viewer.isAdmin && hasPermission(viewer, "posts.read")) {
      return { allowed: true };
    }
    return { allowed: false, reason: "This post is not available" };
  }
  if (viewer.userId) {
    const isBlocked = await storage.isBlockedEither(viewer.userId, authorId);
    if (isBlocked) {
      if (viewer.isAdmin && hasPermission(viewer, "posts.read")) {
        return { allowed: true };
      }
      return { allowed: false, reason: "Unable to view this post" };
    }
  }
  const visibility = post.visibility || "PUBLIC";
  switch (visibility) {
    case "PUBLIC":
      return { allowed: true };
    case "FOLLOWERS":
      if (viewer.isAdmin && hasPermission(viewer, "posts.read")) {
        return { allowed: true };
      }
      if (!viewer.userId) {
        return { allowed: false, reason: "This post is only visible to followers" };
      }
      const isFollowing = await storage.isFollowing(viewer.userId, authorId);
      if (isFollowing) {
        return { allowed: true };
      }
      return { allowed: false, reason: "This post is only visible to followers" };
    case "PRIVATE":
      if (viewer.isAdmin && hasPermission(viewer, "posts.read")) {
        return { allowed: true };
      }
      return { allowed: false, reason: "This post is private" };
    default:
      return { allowed: true };
  }
}
async function canComment(viewer, post, authorSettings) {
  if (!viewer.userId) {
    return { allowed: false, reason: "You must be logged in to comment" };
  }
  if (!post) {
    return { allowed: false, reason: "Post not found" };
  }
  if (viewer.userId === post.authorId) {
    return { allowed: true };
  }
  if (post.isHidden) {
    return { allowed: false, reason: "Cannot comment on hidden posts" };
  }
  if (post.commentsEnabled === false) {
    return { allowed: false, reason: "Comments are disabled on this post" };
  }
  if (viewer.userId) {
    const isBlocked = await storage.isBlockedEither(viewer.userId, post.authorId);
    if (isBlocked) {
      return { allowed: false, reason: "Unable to comment on this post" };
    }
  }
  const settings = authorSettings || await storage.getUserSettings(post.authorId);
  const commentPolicy = settings?.commentPolicy ?? DEFAULT_SETTINGS.commentPolicy;
  switch (commentPolicy) {
    case "EVERYONE":
      return { allowed: true };
    case "FOLLOWERS":
      const isFollowing = await storage.isFollowing(viewer.userId, post.authorId);
      if (isFollowing) {
        return { allowed: true };
      }
      return { allowed: false, reason: "Only followers can comment on this post" };
    case "NOBODY":
      return { allowed: false, reason: "The author has disabled comments" };
    default:
      return { allowed: true };
  }
}
async function canMessage(viewer, targetUser, targetSettings) {
  if (!viewer.userId) {
    return { allowed: false, reason: "You must be logged in to send messages" };
  }
  if (!targetUser) {
    return { allowed: false, reason: "User not found" };
  }
  if (viewer.userId === targetUser.id) {
    return { allowed: true };
  }
  if (targetUser.suspendedAt) {
    return { allowed: false, reason: "Cannot message suspended users" };
  }
  const isBlocked = await storage.isBlockedEither(viewer.userId, targetUser.id);
  if (isBlocked) {
    if (viewer.isAdmin && hasPermission(viewer, "users.support.contact")) {
      return { allowed: true };
    }
    return { allowed: false, reason: "Unable to send message to this user" };
  }
  const settings = targetSettings || await storage.getUserSettings(targetUser.id);
  const messagePolicy = settings?.messagePolicy ?? DEFAULT_SETTINGS.messagePolicy;
  switch (messagePolicy) {
    case "EVERYONE":
      return { allowed: true };
    case "FOLLOWERS":
      const isFollowing = await storage.isFollowing(targetUser.id, viewer.userId);
      if (isFollowing) {
        return { allowed: true };
      }
      if (viewer.isAdmin && hasPermission(viewer, "users.support.contact")) {
        return { allowed: true };
      }
      return { allowed: false, reason: "This user only accepts messages from people they follow" };
    case "NOBODY":
      if (viewer.isAdmin && hasPermission(viewer, "users.support.contact")) {
        return { allowed: true };
      }
      return { allowed: false, reason: "This user has disabled messages" };
    default:
      return { allowed: true };
  }
}
async function canFollow(viewer, targetUser) {
  if (!viewer.userId) {
    return { allowed: false, reason: "You must be logged in to follow users" };
  }
  if (viewer.userId === targetUser.id) {
    return { allowed: false, reason: "You cannot follow yourself" };
  }
  if (targetUser.suspendedAt) {
    return { allowed: false, reason: "Cannot follow suspended users" };
  }
  const isBlocked = await storage.isBlockedEither(viewer.userId, targetUser.id);
  if (isBlocked) {
    return { allowed: false, reason: "Unable to follow this user" };
  }
  return { allowed: true };
}
async function canLike(viewer, post) {
  if (!viewer.userId) {
    return { allowed: false, reason: "You must be logged in to like posts" };
  }
  if (post.isHidden) {
    return { allowed: false, reason: "Cannot like hidden posts" };
  }
  if (viewer.userId) {
    const isBlocked = await storage.isBlockedEither(viewer.userId, post.authorId);
    if (isBlocked) {
      return { allowed: false, reason: "Unable to like this post" };
    }
  }
  const viewResult = await canViewPost(viewer, post);
  if (!viewResult.allowed) {
    return { allowed: false, reason: "Cannot like posts you cannot view" };
  }
  return { allowed: true };
}
async function filterPostsForViewer(viewer, posts3, options = {}) {
  const results = [];
  let mutedAccountIds = /* @__PURE__ */ new Set();
  let hiddenPostIds = /* @__PURE__ */ new Set();
  let notInterestedPostIds = /* @__PURE__ */ new Set();
  let keywordFilters2 = [];
  if (options.forFeed && viewer.userId) {
    const [mutedAccounts2, hiddenPosts2, notInterested2, filters] = await Promise.all([
      storage.getMutedAccounts(viewer.userId),
      storage.getHiddenPostIds(viewer.userId),
      storage.getNotInterestedPostIds(viewer.userId),
      storage.getKeywordFilters(viewer.userId)
    ]);
    mutedAccountIds = new Set(mutedAccounts2.filter((m) => m.mutePosts !== false).map((m) => m.mutedUserId));
    hiddenPostIds = new Set(hiddenPosts2);
    notInterestedPostIds = new Set(notInterested2);
    keywordFilters2 = filters.filter((f) => f.filterPosts !== false).map((f) => ({
      keyword: f.keyword.toLowerCase(),
      filterPosts: f.filterPosts !== false
    }));
  }
  for (const post of posts3) {
    const canView = await canViewPost(viewer, post, post.author);
    if (!canView.allowed) {
      continue;
    }
    if (options.forFeed && mutedAccountIds.has(post.authorId)) {
      continue;
    }
    if (options.forFeed && hiddenPostIds.has(post.id)) {
      continue;
    }
    if (options.forFeed && notInterestedPostIds.has(post.id)) {
      continue;
    }
    if (post.isArchived && post.authorId !== viewer.userId) {
      continue;
    }
    if (options.forFeed && keywordFilters2.length > 0) {
      const postContent = (post.content || "").toLowerCase() + " " + (post.caption || "").toLowerCase();
      const hasBlockedKeyword = keywordFilters2.some((f) => postContent.includes(f.keyword));
      if (hasBlockedKeyword) {
        continue;
      }
    }
    results.push(post);
  }
  return results;
}

// server/routes.ts
init_schema();

// server/cloudinary.ts
import { v2 as cloudinary } from "cloudinary";
import * as fs from "fs";
import * as path from "path";
var UPLOAD_TEMP_DIR = path.join(process.cwd(), "tmp", "uploads");
if (!fs.existsSync(UPLOAD_TEMP_DIR)) {
  fs.mkdirSync(UPLOAD_TEMP_DIR, { recursive: true });
}
if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
  console.warn(`
\u26A0\uFE0F  Cloudinary is not configured!

To enable media uploads, add these secrets:
1. CLOUDINARY_CLOUD_NAME - Your Cloudinary cloud name
2. CLOUDINARY_API_KEY - Your Cloudinary API key
3. CLOUDINARY_API_SECRET - Your Cloudinary API secret

Get these from https://cloudinary.com/console
`);
}
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});
var ALLOWED_IMAGE_TYPES = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "image/heic",
  // iOS HEIC format
  "image/heif",
  // HEIF format
  "image/bmp",
  // BMP images
  "image/tiff",
  // TIFF images
  "image/svg+xml",
  // SVG images
  "application/octet-stream"
  // Fallback for unknown types
];
var ALLOWED_VIDEO_TYPES = [
  "video/mp4",
  "video/webm",
  "video/quicktime",
  "video/x-m4v",
  // M4V video
  "video/3gpp",
  // 3GP mobile video
  "video/3gpp2",
  // 3G2 mobile video
  "video/x-msvideo",
  // AVI
  "video/mpeg",
  // MPEG
  "video/ogg",
  // OGG video
  "video/x-matroska",
  // MKV video
  "video/x-flv",
  // FLV video
  "video/x-ms-wmv",
  // WMV video
  "application/octet-stream"
  // Fallback for unknown types
];
var ALLOWED_AUDIO_TYPES = [
  "audio/mpeg",
  // mp3
  "audio/mp4",
  // m4a
  "audio/x-m4a",
  // m4a alternative
  "audio/m4a",
  // m4a variant
  "audio/wav",
  "audio/x-wav",
  // wav alternative
  "audio/webm",
  "audio/ogg",
  "audio/aac",
  "audio/x-aac",
  // aac alternative
  "audio/3gpp",
  // Android recordings
  "audio/3gpp2",
  // Android recordings
  "audio/amr",
  // Android older format
  "audio/amr-wb",
  // Android wideband
  "audio/x-caf",
  // iOS Core Audio Format
  "audio/caf",
  // iOS caf variant
  "audio/flac",
  // FLAC audio
  "audio/x-flac"
  // FLAC alternative
];
var MAX_FILE_SIZE = 500 * 1024 * 1024;
var MAX_VIDEO_SIZE = 2048 * 1024 * 1024;
var MAX_AUDIO_SIZE = 1024 * 1024 * 1024;
async function uploadToCloudinaryFromFile(filePath, folder, resourceType = "image") {
  return new Promise((resolve2, reject) => {
    const fileSize = fs.statSync(filePath).size;
    const isLargeFile = fileSize > 100 * 1024 * 1024;
    console.log(`[Cloudinary] Uploading file: ${filePath}, size: ${(fileSize / 1024 / 1024).toFixed(2)}MB, large: ${isLargeFile}`);
    const uploadOptions = {
      folder: `rabitchat/${folder}`,
      resource_type: resourceType,
      timeout: 6e5,
      transformation: resourceType === "image" ? [
        { quality: "auto:good" },
        { fetch_format: "auto" }
      ] : void 0
    };
    if (isLargeFile) {
      uploadOptions.chunk_size = 20 * 1024 * 1024;
    }
    const uploadStream = cloudinary.uploader.upload_stream(
      uploadOptions,
      (error, result) => {
        if (error) {
          console.error("[Cloudinary] Upload error:", error.message);
          reject(error);
        } else if (result) {
          let thumbnailUrl;
          if (result.resource_type === "video") {
            thumbnailUrl = result.secure_url.replace(/\.[^.]+$/, ".jpg").replace("/video/upload/", "/video/upload/so_0,w_400,h_400,c_fill/");
          }
          console.log(`[Cloudinary] Upload successful: ${result.public_id}`);
          resolve2({
            url: result.secure_url,
            publicId: result.public_id,
            width: result.width,
            height: result.height,
            format: result.format,
            resourceType: result.resource_type,
            duration: result.duration,
            thumbnailUrl
          });
        } else {
          reject(new Error("Upload failed with no result"));
        }
      }
    );
    const readStream = fs.createReadStream(filePath, { highWaterMark: 2 * 1024 * 1024 });
    readStream.on("error", (err) => {
      console.error("[Cloudinary] Read stream error:", err.message);
      reject(new Error(`Failed to read file: ${err.message}`));
    });
    readStream.pipe(uploadStream);
  });
}
function cleanupTempFile(filePath) {
  try {
    if (filePath && fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      console.log(`[Cleanup] Removed temp file: ${filePath}`);
    }
  } catch (error) {
    console.error(`[Cleanup] Failed to remove temp file: ${filePath}`, error);
  }
}
function cleanupOldTempFiles(maxAgeMinutes = 60) {
  try {
    if (!fs.existsSync(UPLOAD_TEMP_DIR)) return;
    const files = fs.readdirSync(UPLOAD_TEMP_DIR);
    const now = Date.now();
    const maxAge = maxAgeMinutes * 60 * 1e3;
    for (const file of files) {
      const filePath = path.join(UPLOAD_TEMP_DIR, file);
      try {
        const stat = fs.statSync(filePath);
        if (now - stat.mtimeMs > maxAge) {
          fs.unlinkSync(filePath);
          console.log(`[Cleanup] Removed old temp file: ${file}`);
        }
      } catch (e) {
      }
    }
  } catch (error) {
    console.error("[Cleanup] Error cleaning temp files:", error);
  }
}
function generateAudioThumbnailUrl() {
  return "https://res.cloudinary.com/demo/image/upload/v1/samples/audio-placeholder.png";
}
function isCloudinaryConfigured() {
  return !!(process.env.CLOUDINARY_CLOUD_NAME && process.env.CLOUDINARY_API_KEY && process.env.CLOUDINARY_API_SECRET);
}
function generateSignedUploadParams(folder, resourceType = "video") {
  const timestamp3 = Math.round(Date.now() / 1e3);
  const paramsToSign = {
    folder: `rabitchat/${folder}`,
    timestamp: timestamp3
  };
  const signature = cloudinary.utils.api_sign_request(
    paramsToSign,
    process.env.CLOUDINARY_API_SECRET
  );
  return {
    signature,
    timestamp: timestamp3,
    apiKey: process.env.CLOUDINARY_API_KEY,
    cloudName: process.env.CLOUDINARY_CLOUD_NAME,
    folder: `rabitchat/${folder}`
  };
}
function getCloudinaryUploadUrl(resourceType = "video") {
  const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
  return `https://api.cloudinary.com/v1_1/${cloudName}/${resourceType}/upload`;
}
var cloudinary_default = cloudinary;

// server/services/deezer.ts
var DEEZER_API_BASE = "https://api.deezer.com";
async function fetchDeezer(endpoint) {
  const url = `${DEEZER_API_BASE}${endpoint}`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Deezer API error: ${response.status} ${response.statusText}`);
  }
  const data = await response.json();
  if (data.error) {
    throw new Error(`Deezer API error: ${data.error.message || data.error.type}`);
  }
  return data;
}
function transformTrack(track, genre) {
  return {
    id: `deezer_${track.id}`,
    title: track.title_short || track.title,
    artist: track.artist.name,
    album: track.album.title,
    duration: track.duration,
    previewUrl: track.preview,
    coverUrl: track.album.cover_big || track.album.cover_medium || track.album.cover,
    coverUrlSmall: track.album.cover_small || track.album.cover,
    genre,
    isExplicit: track.explicit_lyrics || false,
    popularity: track.rank || 0,
    source: "deezer",
    sourceId: track.id
  };
}
async function searchTracks(query, limit = 25) {
  const encodedQuery = encodeURIComponent(query);
  const response = await fetchDeezer(`/search?q=${encodedQuery}&limit=${limit}`);
  return response.data.filter((track) => track.preview).map((track) => transformTrack(track));
}
async function getChartTracks(limit = 50) {
  const response = await fetchDeezer(`/chart/0/tracks?limit=${limit}`);
  return response.data.filter((track) => track.preview).map((track) => transformTrack(track, "Pop"));
}
async function getGenres() {
  const response = await fetchDeezer("/genre");
  return response.data.filter((genre) => genre.id !== 0);
}
async function getTracksByGenre(genreId, limit = 25) {
  const response = await fetchDeezer(`/genre/${genreId}/artists?limit=10`);
  const tracks = [];
  let genreName = "";
  try {
    const genreInfo = await fetchDeezer(`/genre/${genreId}`);
    genreName = genreInfo.name;
  } catch (error) {
    console.error(`Error fetching genre info for ${genreId}:`, error);
  }
  for (const artist of response.data.slice(0, 5)) {
    try {
      const artistTracks = await fetchDeezer(`/artist/${artist.id}/top?limit=5`);
      for (const track of artistTracks.data) {
        if (track.preview && tracks.length < limit) {
          tracks.push(transformTrack(track, genreName));
        }
      }
    } catch (error) {
      console.error(`Error fetching tracks for artist ${artist.id}:`, error);
    }
    if (tracks.length >= limit) break;
  }
  return tracks;
}
var GENRE_IDS = {
  pop: 132,
  hiphop: 116,
  rnb: 165,
  rock: 152,
  electronic: 106,
  jazz: 129,
  classical: 98,
  latin: 197,
  reggae: 144,
  country: 84,
  metal: 464,
  soul: 169,
  folk: 466,
  blues: 153,
  african: 2,
  asian: 16
};

// server/services/email.ts
import { Resend } from "resend";
var connectionSettings;
async function getCredentials() {
  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME;
  const xReplitToken = process.env.REPL_IDENTITY ? "repl " + process.env.REPL_IDENTITY : process.env.WEB_REPL_RENEWAL ? "depl " + process.env.WEB_REPL_RENEWAL : null;
  if (!xReplitToken) {
    throw new Error("X_REPLIT_TOKEN not found for repl/depl");
  }
  connectionSettings = await fetch(
    "https://" + hostname + "/api/v2/connection?include_secrets=true&connector_names=resend",
    {
      headers: {
        Accept: "application/json",
        X_REPLIT_TOKEN: xReplitToken
      }
    }
  ).then((res) => res.json()).then((data) => data.items?.[0]);
  if (!connectionSettings || !connectionSettings.settings.api_key) {
    throw new Error("Resend not connected");
  }
  return {
    apiKey: connectionSettings.settings.api_key,
    fromEmail: connectionSettings.settings.from_email
  };
}
async function getResendClient() {
  const { apiKey, fromEmail } = await getCredentials();
  return {
    client: new Resend(apiKey),
    fromEmail
  };
}
var emailStyles = `
  body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background-color: #0a0a0f; }
  .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; }
  .header { text-align: center; margin-bottom: 40px; }
  .logo { font-size: 32px; font-weight: 700; color: #8B5CF6; letter-spacing: -1px; }
  .card { background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 16px; padding: 32px; margin-bottom: 24px; }
  .title { color: #ffffff; font-size: 24px; font-weight: 600; margin: 0 0 16px 0; }
  .text { color: #a1a1aa; font-size: 16px; line-height: 1.6; margin: 0 0 16px 0; }
  .button { display: inline-block; background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%); color: #ffffff !important; text-decoration: none; padding: 14px 32px; border-radius: 12px; font-weight: 600; font-size: 16px; margin: 16px 0; }
  .button:hover { background: linear-gradient(135deg, #7C3AED 0%, #6D28D9 100%); }
  .code { background: rgba(139, 92, 246, 0.2); border: 1px solid rgba(139, 92, 246, 0.4); border-radius: 8px; padding: 16px 24px; font-size: 32px; font-weight: 700; color: #8B5CF6; letter-spacing: 4px; text-align: center; margin: 24px 0; }
  .footer { text-align: center; color: #71717a; font-size: 14px; margin-top: 40px; }
  .divider { height: 1px; background: rgba(139, 92, 246, 0.2); margin: 24px 0; }
  .highlight { color: #8B5CF6; font-weight: 600; }
  .stats { display: flex; justify-content: space-around; margin: 24px 0; }
  .stat { text-align: center; }
  .stat-value { color: #8B5CF6; font-size: 24px; font-weight: 700; }
  .stat-label { color: #71717a; font-size: 12px; text-transform: uppercase; }
`;
function getPasswordResetEmailHtml(username, resetCode) {
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reset Your Password - RabitChat</title>
  <style>${emailStyles}</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">RabitChat</div>
    </div>
    <div class="card">
      <h1 class="title">Password Reset Request</h1>
      <p class="text">
        Hi ${username}, we received a request to reset your RabitChat password. 
        Use the code below to complete the reset:
      </p>
      <div class="code">${resetCode}</div>
      <p class="text">
        This code expires in <span class="highlight">15 minutes</span>. 
        If you didn't request this, please ignore this email or contact support if you're concerned.
      </p>
    </div>
    <div class="footer">
      <p>The RabitChat Team</p>
      <p>This is an automated message. Please do not reply.</p>
    </div>
  </div>
</body>
</html>
  `;
}
function getVerificationCodeEmailHtml(username, code) {
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Verify Your Email - RabitChat</title>
  <style>${emailStyles}</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">RabitChat</div>
    </div>
    <div class="card">
      <h1 class="title">Verify Your Email</h1>
      <p class="text">
        Hi ${username}, please use the verification code below to confirm your email address:
      </p>
      <div class="code">${code}</div>
      <p class="text">
        This code expires in <span class="highlight">10 minutes</span>.
      </p>
    </div>
    <div class="footer">
      <p>The RabitChat Team</p>
      <p>This is an automated message. Please do not reply.</p>
    </div>
  </div>
</body>
</html>
  `;
}
async function sendEmail(to, subject, html) {
  try {
    console.log("[Email] Attempting to send email to:", to);
    const { client: client2, fromEmail } = await getResendClient();
    const from = process.env.NODE_ENV === "production" && fromEmail ? fromEmail : "RabitChat <onboarding@resend.dev>";
    console.log("[Email] Using from address:", from);
    const result = await client2.emails.send({
      from,
      to: [to],
      subject,
      html
    });
    if (result.error) {
      console.error("[Email] Resend API error:", JSON.stringify(result.error));
      return { success: false, error: result.error.message };
    }
    console.log("[Email] Sent successfully to:", to, "ID:", result.data?.id);
    return { success: true };
  } catch (error) {
    console.error("[Email] Exception sending email:", error.message);
    console.error("[Email] Full error:", error);
    return { success: false, error: error.message };
  }
}
async function sendPasswordResetEmail(to, username, resetCode) {
  return sendEmail(to, "Reset Your RabitChat Password", getPasswordResetEmailHtml(username, resetCode));
}
async function sendVerificationEmail(to, username, code) {
  return sendEmail(to, "Verify Your RabitChat Email", getVerificationCodeEmailHtml(username, code));
}

// server/services/openai-features.ts
import OpenAI from "openai";
var openai = new OpenAI({
  apiKey: process.env.AI_INTEGRATIONS_OPENAI_API_KEY,
  baseURL: process.env.AI_INTEGRATIONS_OPENAI_BASE_URL
});
async function generateSmartCaption(imageDescription, context) {
  try {
    const styleGuide = context?.style || "luxury, sophisticated";
    const moodGuide = context?.mood || "aspirational";
    const audienceGuide = context?.audience || "high-net-worth individuals and influencers";
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: `You are a social media expert for RabitChat, a Forbes-style luxury social network. Generate captivating captions that resonate with ${audienceGuide}. Style: ${styleGuide}. Mood: ${moodGuide}.`
        },
        {
          role: "user",
          content: `Generate an engaging caption for this image/content: "${imageDescription}"

Respond in JSON format only:
{
  "caption": "the engaging caption (2-3 sentences max)",
  "hashtags": ["hashtag1", "hashtag2", "hashtag3", "hashtag4", "hashtag5"],
  "tone": "detected tone of the caption"
}`
        }
      ],
      max_tokens: 300,
      temperature: 0.8
    });
    const text3 = response.choices[0]?.message?.content || "";
    const jsonMatch = text3.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      return {
        caption: result.caption || "",
        hashtags: result.hashtags || [],
        tone: result.tone || "luxury"
      };
    }
    return {
      caption: "Living the extraordinary life.",
      hashtags: ["#luxury", "#lifestyle", "#elite"],
      tone: "aspirational"
    };
  } catch (error) {
    console.error("[OpenAI] Caption generation error:", error);
    return {
      caption: "",
      hashtags: [],
      tone: "neutral"
    };
  }
}
async function transcribeVoiceMessage(audioUrl) {
  try {
    const response = await fetch(audioUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch audio: ${response.status}`);
    }
    const audioBuffer = await response.arrayBuffer();
    const audioFile = new File([audioBuffer], "audio.mp3", { type: "audio/mpeg" });
    const transcription = await openai.audio.transcriptions.create({
      file: audioFile,
      model: "whisper-1",
      response_format: "verbose_json"
    });
    return {
      text: transcription.text,
      duration: transcription.duration,
      language: transcription.language
    };
  } catch (error) {
    console.error("[OpenAI] Transcription error:", error);
    return {
      text: "Transcription unavailable"
    };
  }
}
async function enhancePost(content, options) {
  try {
    const targetTone = options?.targetTone || "sophisticated and engaging";
    const maxLength = options?.maxLength || 500;
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: `You are a premium content editor for RabitChat, a Forbes-style luxury social network. Enhance posts to be more ${targetTone} while maintaining authenticity. Max length: ${maxLength} characters.`
        },
        {
          role: "user",
          content: `Enhance this post while keeping the core message:

"${content}"

Respond in JSON format only:
{
  "enhanced": "the improved version",
  "suggestions": ["improvement 1", "improvement 2", "improvement 3"],
  "readabilityScore": 0-100
}`
        }
      ],
      max_tokens: 500,
      temperature: 0.7
    });
    const text3 = response.choices[0]?.message?.content || "";
    const jsonMatch = text3.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      return {
        original: content,
        enhanced: result.enhanced || content,
        suggestions: result.suggestions || [],
        readabilityScore: result.readabilityScore ?? 75
      };
    }
    return {
      original: content,
      enhanced: content,
      suggestions: [],
      readabilityScore: 70
    };
  } catch (error) {
    console.error("[OpenAI] Post enhancement error:", error);
    return {
      original: content,
      enhanced: content,
      suggestions: [],
      readabilityScore: 50
    };
  }
}
async function getAIAssistance(query, context) {
  try {
    const messages4 = [
      {
        role: "system",
        content: `You are RabitChat's AI assistant, helping users create compelling content for a Forbes-style luxury social network. Be helpful, concise, and maintain a sophisticated tone. Focus on: content creation, caption ideas, engagement strategies, and personal branding tips.${context?.topic ? ` Current topic: ${context.topic}` : ""}`
      }
    ];
    if (context?.previousMessages) {
      for (const msg of context.previousMessages.slice(-6)) {
        messages4.push({ role: "user", content: msg });
      }
    }
    messages4.push({ role: "user", content: query });
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: messages4,
      max_tokens: 500,
      temperature: 0.7
    });
    const responseText = response.choices[0]?.message?.content || "";
    return {
      response: responseText,
      suggestions: extractSuggestions(responseText)
    };
  } catch (error) {
    console.error("[OpenAI] AI assistance error:", error);
    return {
      response: "I'm having trouble processing your request right now. Please try again."
    };
  }
}
function extractSuggestions(text3) {
  const lines = text3.split("\n").filter((line) => line.trim().startsWith("-") || line.trim().match(/^\d+\./));
  return lines.slice(0, 5).map((line) => line.replace(/^[-\d.]+\s*/, "").trim());
}
async function generateImageCaption(imageUrl) {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "You are a luxury social media content expert. Analyze images and generate captivating captions for a high-end social network."
        },
        {
          role: "user",
          content: [
            {
              type: "text",
              text: `Analyze this image and generate an engaging caption for RabitChat, a Forbes-style luxury social network.

Respond in JSON format only:
{
  "caption": "the engaging caption (2-3 sentences max)",
  "hashtags": ["hashtag1", "hashtag2", "hashtag3", "hashtag4", "hashtag5"],
  "tone": "detected tone"
}`
            },
            {
              type: "image_url",
              image_url: { url: imageUrl }
            }
          ]
        }
      ],
      max_tokens: 300
    });
    const text3 = response.choices[0]?.message?.content || "";
    const jsonMatch = text3.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      return {
        caption: result.caption || "",
        hashtags: result.hashtags || [],
        tone: result.tone || "luxury"
      };
    }
    return {
      caption: "Capturing life's finest moments.",
      hashtags: ["#luxury", "#lifestyle"],
      tone: "aspirational"
    };
  } catch (error) {
    console.error("[OpenAI] Image caption error:", error);
    return {
      caption: "",
      hashtags: [],
      tone: "neutral"
    };
  }
}
async function generateVoicePostSummary(transcription) {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "Create a brief, engaging text summary of voice content for a luxury social network. Keep it under 100 words."
        },
        {
          role: "user",
          content: `Summarize this voice message transcription for display: "${transcription}"`
        }
      ],
      max_tokens: 150
    });
    return response.choices[0]?.message?.content || transcription.slice(0, 200);
  } catch (error) {
    console.error("[OpenAI] Voice summary error:", error);
    return transcription.slice(0, 200);
  }
}

// server/services/sms.ts
import twilio from "twilio";
var accountSid = process.env.TWILIO_ACCOUNT_SID;
var authToken = process.env.TWILIO_AUTH_TOKEN;
var twilioPhone = process.env.TWILIO_PHONE_NUMBER;
var client = null;
function getClient() {
  if (!accountSid || !authToken) {
    console.warn("[SMS] Twilio credentials not configured");
    return null;
  }
  if (!client) {
    client = twilio(accountSid, authToken);
  }
  return client;
}
async function sendSMS(to, body) {
  const twilioClient = getClient();
  if (!twilioClient || !twilioPhone) {
    return { success: false, error: "SMS service not configured" };
  }
  try {
    const message = await twilioClient.messages.create({
      body,
      from: twilioPhone,
      to
    });
    console.log(`[SMS] Sent message ${message.sid} to ${to}`);
    return { success: true, messageId: message.sid };
  } catch (error) {
    console.error("[SMS] Failed to send message:", error.message);
    return { success: false, error: error.message };
  }
}
function generateVerificationCode() {
  return Math.floor(1e5 + Math.random() * 9e5).toString();
}
async function sendVerificationCode(phoneNumber, code) {
  const message = `Your RabitChat verification code is: ${code}. This code expires in 10 minutes. Do not share this code with anyone.`;
  return sendSMS(phoneNumber, message);
}
function isSMSConfigured() {
  const configured = !!(accountSid && authToken && twilioPhone);
  console.log(`[SMS] Configuration check: accountSid=${!!accountSid}, authToken=${!!authToken}, phone=${!!twilioPhone}, configured=${configured}`);
  return configured;
}

// server/algorithm/feed.ts
init_db();
init_schema();
import { eq as eq15, and as and14, or as or9, not as not2, desc as desc10, inArray as inArray8, isNull as isNull7 } from "drizzle-orm";

// server/algorithm/types.ts
var DEFAULT_WEIGHTS = {
  authorNetWorth: 2.5,
  authorInfluence: 2,
  authorVerified: 5,
  engagementVelocity: 3,
  engagementQuality: 2.5,
  contentRecency: 1.5,
  relationshipDepth: 2,
  contentQuality: 1,
  mediaRichness: 1.2,
  completionRate: 2,
  saves: 3,
  shares: 4,
  comments: 2,
  likes: 0.5,
  dwellTime: 2.5
};
var NET_WORTH_TIERS = {
  ULTRA_HIGH: { min: 1e7, multiplier: 10 },
  HIGH: { min: 1e6, multiplier: 7 },
  AFFLUENT: { min: 1e5, multiplier: 4 },
  EMERGING: { min: 1e4, multiplier: 2 },
  STANDARD: { min: 0, multiplier: 1 }
};
var INFLUENCE_TIERS = {
  ELITE: { min: 1e5, multiplier: 2.5 },
  INFLUENCER: { min: 1e4, multiplier: 2 },
  CREATOR: { min: 1e3, multiplier: 1.5 },
  ACTIVE: { min: 100, multiplier: 1.2 },
  STANDARD: { min: 0, multiplier: 1 }
};

// server/algorithm/scoring.ts
var ScoringEngine = class {
  weights;
  constructor(weights = DEFAULT_WEIGHTS) {
    this.weights = weights;
  }
  calculateUserAuthority(user) {
    const netWorthScore = this.calculateNetWorthScore(user.netWorth || 0);
    const influenceScore = this.calculateInfluenceScore(user.influenceScore || 0);
    const verifiedBonus = user.isVerified ? 5 : 1;
    const engagementRate = this.estimateEngagementRate(user);
    const totalAuthority = netWorthScore * this.weights.authorNetWorth + influenceScore * this.weights.authorInfluence + verifiedBonus * this.weights.authorVerified + engagementRate;
    return {
      userId: user.id,
      netWorthScore,
      influenceScore,
      verifiedBonus,
      engagementRate,
      totalAuthority
    };
  }
  calculateNetWorthScore(netWorth) {
    const baselineScore = 0.1;
    for (const [tier, config] of Object.entries(NET_WORTH_TIERS).sort((a, b) => b[1].min - a[1].min)) {
      if (netWorth >= config.min) {
        const normalized = Math.min(Math.log10(Math.max(netWorth, 1) + 1) / 10, 1);
        return Math.max(normalized * config.multiplier, baselineScore);
      }
    }
    return baselineScore;
  }
  calculateInfluenceScore(influence) {
    const baselineScore = 0.1;
    for (const [tier, config] of Object.entries(INFLUENCE_TIERS).sort((a, b) => b[1].min - a[1].min)) {
      if (influence >= config.min) {
        const normalized = Math.min(Math.log10(Math.max(influence, 1) + 1) / 6, 1);
        return Math.max(normalized * config.multiplier, baselineScore);
      }
    }
    return baselineScore;
  }
  estimateEngagementRate(user) {
    const totalLikes = user.totalLikesReceived || 0;
    const totalViews = user.totalViewsReceived || 1;
    const rate = totalLikes / totalViews;
    return Math.min(rate * 10, 1);
  }
  calculateEngagementScore(post, velocity) {
    const likes2 = post.likesCount || 0;
    const comments3 = post.commentsCount || 0;
    const saves = post.savesCount || 0;
    const shares2 = post.sharesCount || 0;
    const views = post.viewsCount || 1;
    const likeScore = likes2 / views * 100 * this.weights.likes;
    const commentScore = comments3 / views * 100 * this.weights.comments;
    const saveScore = saves / views * 100 * this.weights.saves;
    const shareScore = shares2 / views * 100 * this.weights.shares;
    let velocityBonus = 1;
    if (velocity) {
      velocityBonus = 1 + velocity.velocityScore * this.weights.engagementVelocity / 10;
    }
    return (likeScore + commentScore + saveScore + shareScore) * velocityBonus;
  }
  calculateRecencyScore(post) {
    const now = Date.now();
    const postTime = new Date(post.createdAt).getTime();
    const hoursAgo = (now - postTime) / (1e3 * 60 * 60);
    if (hoursAgo < 1) return 1;
    if (hoursAgo < 6) return 0.9;
    if (hoursAgo < 24) return 0.7;
    if (hoursAgo < 48) return 0.5;
    if (hoursAgo < 168) return 0.3;
    return 0.1;
  }
  calculateRelationshipScore(depth) {
    if (!depth) return 0.1;
    return Math.min(depth.score * this.weights.relationshipDepth, 1);
  }
  calculateContentQualityScore(post, quality) {
    let score = 0.5;
    if (post.type === "VIDEO") score += 0.2;
    else if (post.type === "PHOTO") score += 0.15;
    else if (post.type === "VOICE") score += 0.1;
    if (post.caption && post.caption.length > 50) score += 0.1;
    if (post.thumbnailUrl) score += 0.05;
    if (quality) {
      score = quality.estimatedQuality;
    }
    return Math.min(score * this.weights.contentQuality, 1);
  }
  calculateMediaRichnessScore(post) {
    if (post.type === "VIDEO" && post.durationMs && post.durationMs > 3e4) {
      return 1 * this.weights.mediaRichness;
    }
    if (post.type === "VIDEO") return 0.8 * this.weights.mediaRichness;
    if (post.type === "PHOTO") return 0.6 * this.weights.mediaRichness;
    if (post.type === "VOICE") return 0.5 * this.weights.mediaRichness;
    return 0.3 * this.weights.mediaRichness;
  }
  getNetWorthMultiplier(netWorth) {
    if (netWorth >= 1e7) return 10;
    if (netWorth >= 1e6) return 7;
    if (netWorth >= 1e5) return 4;
    if (netWorth >= 1e4) return 2;
    return 1;
  }
  calculatePostScore(post, author, velocity, relationship, quality) {
    const authority = this.calculateUserAuthority(author);
    const engagement = this.calculateEngagementScore(post, velocity);
    const recency = this.calculateRecencyScore(post);
    const relationshipScore = this.calculateRelationshipScore(relationship);
    const qualityScore = this.calculateContentQualityScore(post, quality);
    const mediaScore = this.calculateMediaRichnessScore(post);
    const pinnedBonus = post.isPinned ? 1.5 : 1;
    const featuredBonus = post.isFeatured ? 1.3 : 1;
    const verifiedBonus = author.isVerified ? 2 : 1;
    const netWorthBonus = this.getNetWorthMultiplier(author.netWorth || 0);
    const totalScore = (authority.totalAuthority * 2.5 + engagement * 2 + recency * this.weights.contentRecency + relationshipScore * 2 + qualityScore * 1.5 + mediaScore * 1.2) * pinnedBonus * featuredBonus * verifiedBonus * netWorthBonus;
    return {
      postId: post.id,
      authorId: author.id,
      totalScore,
      breakdown: {
        authorityScore: authority.totalAuthority,
        engagementScore: engagement,
        recencyScore: recency,
        relationshipScore,
        qualityScore,
        mediaScore
      }
    };
  }
  rankPosts(posts3) {
    return [...posts3].sort((a, b) => b.totalScore - a.totalScore);
  }
  applyDiversification(posts3, maxPerAuthor = 3) {
    const authorCounts = /* @__PURE__ */ new Map();
    const diversified = [];
    for (const post of posts3) {
      const count5 = authorCounts.get(post.authorId) || 0;
      if (count5 < maxPerAuthor) {
        diversified.push(post);
        authorCounts.set(post.authorId, count5 + 1);
      }
    }
    return diversified;
  }
};

// server/algorithm/velocity.ts
init_db();
init_schema();
import { eq as eq13, and as and12, gte as gte6, lte as lte7, count as count3 } from "drizzle-orm";
var VelocityTracker = class {
  async calculateVelocity(postId, createdAt) {
    const now = /* @__PURE__ */ new Date();
    const oneHourAfterPost = new Date(createdAt.getTime() + 60 * 60 * 1e3);
    const isWithinFirstHour = now <= oneHourAfterPost;
    const cutoffTime = isWithinFirstHour ? now : oneHourAfterPost;
    const [likeCount] = await db.select({ count: count3() }).from(likes).where(
      and12(
        eq13(likes.postId, postId),
        gte6(likes.createdAt, createdAt),
        lte7(likes.createdAt, cutoffTime)
      )
    );
    const [commentCount] = await db.select({ count: count3() }).from(comments).where(
      and12(
        eq13(comments.postId, postId),
        gte6(comments.createdAt, createdAt),
        lte7(comments.createdAt, cutoffTime)
      )
    );
    const [saveCount] = await db.select({ count: count3() }).from(bookmarks).where(
      and12(
        eq13(bookmarks.postId, postId),
        gte6(bookmarks.createdAt, createdAt),
        lte7(bookmarks.createdAt, cutoffTime)
      )
    );
    const [shareCount] = await db.select({ count: count3() }).from(shares).where(
      and12(
        eq13(shares.postId, postId),
        gte6(shares.createdAt, createdAt),
        lte7(shares.createdAt, cutoffTime)
      )
    );
    const totalEngagement = (likeCount?.count || 0) * 0.5 + (commentCount?.count || 0) * 2 + (saveCount?.count || 0) * 3 + (shareCount?.count || 0) * 4;
    const minutesElapsed = Math.max(1, (cutoffTime.getTime() - createdAt.getTime()) / (1e3 * 60));
    const velocityPerMinute = totalEngagement / minutesElapsed;
    const velocityScore = Math.min(velocityPerMinute * 10, 10);
    return {
      postId,
      firstHourEngagement: totalEngagement,
      velocityScore,
      peakTime: null
    };
  }
  async batchCalculateVelocities(postIds, createdAts) {
    const results = /* @__PURE__ */ new Map();
    await Promise.all(
      postIds.map(async (postId) => {
        const createdAt = createdAts.get(postId);
        if (createdAt) {
          const velocity = await this.calculateVelocity(postId, createdAt);
          results.set(postId, velocity);
        }
      })
    );
    return results;
  }
  isInGoldenHour(createdAt) {
    const now = /* @__PURE__ */ new Date();
    const hoursSincePost = (now.getTime() - createdAt.getTime()) / (1e3 * 60 * 60);
    return hoursSincePost <= 1;
  }
  isInBoostWindow(createdAt) {
    const now = /* @__PURE__ */ new Date();
    const hoursSincePost = (now.getTime() - createdAt.getTime()) / (1e3 * 60 * 60);
    return hoursSincePost <= 6;
  }
};

// server/algorithm/relationships.ts
init_db();
init_schema();
import { eq as eq14, and as and13, or as or8, count as count4, desc as desc9, gte as gte7 } from "drizzle-orm";
var RelationshipCalculator = class {
  async calculateDepth(userId, targetUserId) {
    const [mutualCheck] = await db.select({ count: count4() }).from(follows).where(
      or8(
        and13(eq14(follows.followerId, userId), eq14(follows.followingId, targetUserId)),
        and13(eq14(follows.followerId, targetUserId), eq14(follows.followingId, userId))
      )
    );
    const mutualFollows = (mutualCheck?.count || 0) >= 2;
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3);
    const [likeInteractions] = await db.select({ count: count4() }).from(likes).innerJoin(posts, eq14(likes.postId, posts.id)).where(
      and13(
        eq14(likes.userId, userId),
        eq14(posts.authorId, targetUserId),
        gte7(likes.createdAt, sevenDaysAgo)
      )
    );
    const [commentInteractions] = await db.select({ count: count4() }).from(comments).innerJoin(posts, eq14(comments.postId, posts.id)).where(
      and13(
        eq14(comments.authorId, userId),
        eq14(posts.authorId, targetUserId),
        gte7(comments.createdAt, sevenDaysAgo)
      )
    );
    const [dmHistory] = await db.select({ count: count4() }).from(conversations).where(
      or8(
        and13(eq14(conversations.participant1Id, userId), eq14(conversations.participant2Id, targetUserId)),
        and13(eq14(conversations.participant1Id, targetUserId), eq14(conversations.participant2Id, userId))
      )
    );
    const hasDmHistory = (dmHistory?.count || 0) > 0;
    const recentInteractions = (likeInteractions?.count || 0) + (commentInteractions?.count || 0) * 2;
    const interactionCount = recentInteractions;
    let score = 0.1;
    if (mutualFollows) score += 0.3;
    if (hasDmHistory) score += 0.2;
    score += Math.min(recentInteractions / 50, 0.4);
    return {
      userId,
      targetUserId,
      interactionCount,
      recentInteractions,
      mutualFollows,
      dmHistory: hasDmHistory,
      score: Math.min(score, 1)
    };
  }
  async batchCalculateDepths(userId, targetUserIds) {
    const results = /* @__PURE__ */ new Map();
    await Promise.all(
      targetUserIds.map(async (targetId) => {
        const depth = await this.calculateDepth(userId, targetId);
        results.set(targetId, depth);
      })
    );
    return results;
  }
  async getClosestConnections(userId, limit = 50) {
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
    const recentConvos = await db.select({
      partnerId: conversations.participant2Id
    }).from(conversations).where(
      and13(
        eq14(conversations.participant1Id, userId),
        gte7(conversations.lastMessageAt, thirtyDaysAgo)
      )
    ).orderBy(desc9(conversations.lastMessageAt)).limit(limit);
    const recentConvos2 = await db.select({
      partnerId: conversations.participant1Id
    }).from(conversations).where(
      and13(
        eq14(conversations.participant2Id, userId),
        gte7(conversations.lastMessageAt, thirtyDaysAgo)
      )
    ).orderBy(desc9(conversations.lastMessageAt)).limit(limit);
    const partnerIds = /* @__PURE__ */ new Set();
    recentConvos.forEach((c) => partnerIds.add(c.partnerId));
    recentConvos2.forEach((c) => partnerIds.add(c.partnerId));
    return Array.from(partnerIds).slice(0, limit);
  }
};

// server/algorithm/config.ts
var currentWeights = { ...DEFAULT_WEIGHTS };
function getAlgorithmWeights() {
  return { ...currentWeights };
}
function updateAlgorithmWeights(updates) {
  currentWeights = {
    ...currentWeights,
    ...updates
  };
  return { ...currentWeights };
}
function resetAlgorithmWeights() {
  currentWeights = { ...DEFAULT_WEIGHTS };
  return { ...currentWeights };
}
function getAlgorithmDescription() {
  return {
    weights: getAlgorithmWeights(),
    description: {
      authorNetWorth: "Priority boost for high net worth authors (Ultra High: 3x, High: 2x, Affluent: 1.5x)",
      authorInfluence: "Priority boost based on influence score (Elite: 2.5x, Influencer: 2x, Creator: 1.5x)",
      authorVerified: "Verified badge bonus multiplier (5x boost for verified users)",
      engagementVelocity: "First-hour engagement velocity boost (TikTok-style golden hour)",
      engagementQuality: "Quality of engagement (saves/shares weighted higher than likes)",
      contentRecency: "Time decay factor for post age",
      relationshipDepth: "Connection strength between viewer and author (DMs, mutual follows, interactions)",
      contentQuality: "Content quality signals (caption length, media presence)",
      mediaRichness: "Media type bonus (Video > Photo > Voice > Text)",
      completionRate: "Video/audio completion rate factor",
      saves: "Weight for saves (Instagram: high-value signal)",
      shares: "Weight for shares (X/Twitter: 75x more valuable than likes)",
      comments: "Weight for comments (Facebook: meaningful interactions)",
      likes: "Weight for likes (lower value passive engagement)",
      dwellTime: "Time spent viewing content (YouTube: primary signal)"
    }
  };
}

// server/algorithm/feed.ts
init_diversity();
var EliteFeedAlgorithm = class {
  velocityTracker;
  relationshipCalculator;
  constructor() {
    this.velocityTracker = new VelocityTracker();
    this.relationshipCalculator = new RelationshipCalculator();
  }
  getScoringEngine() {
    return new ScoringEngine(getAlgorithmWeights());
  }
  async generateFeed(viewerId, options = {}) {
    const {
      limit = 20,
      offset = 0,
      includeFollowingOnly = false,
      prioritizeNetWorth = true,
      prioritizeVerified = true,
      diversify = true,
      maxPerAuthor = 3
    } = options;
    const scoringEngine = this.getScoringEngine();
    const candidatePosts = await this.getCandidatePosts(viewerId, includeFollowingOnly, limit * 5);
    if (candidatePosts.length === 0) {
      return { posts: [], hasMore: false };
    }
    const authorIds = [...new Set(candidatePosts.map((p) => p.authorId))];
    const authorMap = await this.getAuthors(authorIds);
    const relationships = await this.relationshipCalculator.batchCalculateDepths(viewerId, authorIds);
    const postCreatedAts = /* @__PURE__ */ new Map();
    candidatePosts.forEach((p) => postCreatedAts.set(p.id, new Date(p.createdAt)));
    const velocities = await this.velocityTracker.batchCalculateVelocities(
      candidatePosts.map((p) => p.id),
      postCreatedAts
    );
    const viewerInterests = await this.getUserInterests(viewerId);
    const interestSlugs = new Set(viewerInterests.map((i) => i.interest));
    const postIds = candidatePosts.map((p) => p.id);
    const postCategories = await this.getPostCategories(postIds);
    const scores = [];
    for (const post of candidatePosts) {
      const author = authorMap.get(post.authorId);
      if (!author) continue;
      const velocity = velocities.get(post.id);
      const relationship = relationships.get(post.authorId);
      const score = scoringEngine.calculatePostScore(
        post,
        author,
        velocity,
        relationship
      );
      if (prioritizeNetWorth && author.netWorth > 1e6) {
        score.totalScore *= 1.5;
      }
      const postCats = postCategories.get(post.id) || [];
      const interestBoost = this.calculateInterestBoost(postCats, viewerInterests, interestSlugs);
      if (interestBoost > 0) {
        score.totalScore *= 1 + interestBoost;
      }
      scores.push(score);
    }
    let rankedScores = scoringEngine.rankPosts(scores);
    if (diversify) {
      const diversifiableScores = rankedScores.map((s) => ({
        ...s,
        id: s.postId,
        score: s.totalScore
      }));
      const diversified = diversifyFeed(diversifiableScores, {
        minSpacing: 4,
        // At least 4 posts between same creator
        maxPerCreator: maxPerAuthor,
        useScoreWeighting: true,
        shuffleTiers: false
      });
      rankedScores = diversified;
    }
    const paginatedScores = rankedScores.slice(offset, offset + limit);
    const scoreMap = new Map(paginatedScores.map((s) => [s.postId, s.totalScore]));
    const result = [];
    for (const score of paginatedScores) {
      const post = candidatePosts.find((p) => p.id === score.postId);
      const author = authorMap.get(score.authorId);
      if (post && author) {
        result.push({
          ...post,
          author,
          score: scoreMap.get(post.id) || 0
        });
      }
    }
    return {
      posts: result,
      hasMore: rankedScores.length > offset + limit,
      scoringBreakdown: paginatedScores
    };
  }
  async getCandidatePosts(viewerId, followingOnly, limit) {
    const blockedUsers = await db.select({ blockedId: blocks.blockedId }).from(blocks).where(eq15(blocks.blockerId, viewerId));
    const blockedByUsers = await db.select({ blockerId: blocks.blockerId }).from(blocks).where(eq15(blocks.blockedId, viewerId));
    const muted = await db.select({ mutedUserId: mutedAccounts.mutedUserId }).from(mutedAccounts).where(eq15(mutedAccounts.userId, viewerId));
    const hidden = await db.select({ postId: hiddenPosts.postId }).from(hiddenPosts).where(eq15(hiddenPosts.userId, viewerId));
    const notInterested2 = await db.select({ postId: notInterestedPosts.postId }).from(notInterestedPosts).where(eq15(notInterestedPosts.userId, viewerId));
    const restricted = await db.select({ restrictedUserId: restrictedAccounts.restrictedUserId }).from(restrictedAccounts).where(eq15(restrictedAccounts.userId, viewerId));
    const excludedUserIds = /* @__PURE__ */ new Set([
      ...blockedUsers.map((b) => b.blockedId),
      ...blockedByUsers.map((b) => b.blockerId),
      ...muted.map((m) => m.mutedUserId),
      ...restricted.map((r) => r.restrictedUserId)
    ]);
    const excludedPostIds = /* @__PURE__ */ new Set([
      ...hidden.map((h) => h.postId),
      ...notInterested2.map((n) => n.postId)
    ]);
    let followingIds = [];
    if (followingOnly) {
      const following = await db.select({ followingId: follows.followingId }).from(follows).where(eq15(follows.followerId, viewerId));
      followingIds = following.map((f) => f.followingId);
    }
    const conditions = [
      eq15(posts.isHidden, false),
      isNull7(posts.deletedAt),
      or9(
        eq15(posts.visibility, "PUBLIC"),
        eq15(posts.authorId, viewerId)
      )
    ];
    if (excludedUserIds.size > 0) {
      conditions.push(not2(inArray8(posts.authorId, Array.from(excludedUserIds))));
    }
    if (excludedPostIds.size > 0) {
      conditions.push(not2(inArray8(posts.id, Array.from(excludedPostIds))));
    }
    if (followingOnly) {
      if (followingIds.length > 0) {
        conditions.push(
          or9(
            inArray8(posts.authorId, followingIds),
            eq15(posts.authorId, viewerId)
          )
        );
      } else {
        conditions.push(eq15(posts.authorId, viewerId));
      }
    }
    const candidatePosts = await db.select().from(posts).where(and14(...conditions)).orderBy(desc10(posts.createdAt)).limit(limit);
    return candidatePosts.filter((p) => !p.isArchived || p.authorId === viewerId);
  }
  async getAuthors(authorIds) {
    if (authorIds.length === 0) return /* @__PURE__ */ new Map();
    const authors = await db.select().from(users).where(inArray8(users.id, authorIds));
    return new Map(authors.map((a) => [a.id, a]));
  }
  async getDiscoverFeed(viewerId, options = {}) {
    return this.generateFeed(viewerId, {
      ...options,
      includeFollowingOnly: false,
      prioritizeNetWorth: true,
      prioritizeVerified: true
    });
  }
  async getFollowingFeed(viewerId, options = {}) {
    return this.generateFeed(viewerId, {
      ...options,
      includeFollowingOnly: true
    });
  }
  async getEliteFeed(viewerId, options = {}) {
    return this.generateFeed(viewerId, {
      ...options,
      prioritizeNetWorth: true,
      prioritizeVerified: true
    });
  }
  async getUserInterests(userId) {
    const interests = await db.select({
      interest: userInterests.interest,
      affinityScore: userInterests.affinityScore
    }).from(userInterests).where(eq15(userInterests.userId, userId));
    return interests;
  }
  async getPostCategories(postIds) {
    if (postIds.length === 0) return /* @__PURE__ */ new Map();
    const categories = await db.select({
      postId: contentCategories.postId,
      categorySlug: contentCategories.categorySlug
    }).from(contentCategories).where(inArray8(contentCategories.postId, postIds));
    const map = /* @__PURE__ */ new Map();
    for (const cat of categories) {
      if (!cat.categorySlug) continue;
      const existing = map.get(cat.postId) || [];
      existing.push(cat.categorySlug);
      map.set(cat.postId, existing);
    }
    return map;
  }
  calculateInterestBoost(postCategories, viewerInterests, interestSlugs) {
    if (postCategories.length === 0 || viewerInterests.length === 0) {
      return 0;
    }
    let totalBoost = 0;
    let matchCount = 0;
    for (const category of postCategories) {
      if (interestSlugs.has(category)) {
        const interest = viewerInterests.find((i) => i.interest === category);
        const affinity = interest?.affinityScore || 1;
        totalBoost += affinity * 0.1;
        matchCount++;
      }
    }
    return Math.min(totalBoost, 1);
  }
};
var feedAlgorithm = new EliteFeedAlgorithm();

// server/algorithm/index.ts
init_diversity();

// server/rbac.ts
init_db();
init_schema();
import { eq as eq16, inArray as inArray9, and as and15 } from "drizzle-orm";
var ROLE_NAMES = {
  SUPER_ADMIN: "SUPER_ADMIN",
  ADMIN: "ADMIN",
  MODERATOR: "MODERATOR",
  SUPPORT: "SUPPORT"
};
async function getUserRoles(userId) {
  const userRoleRecords = await db.select({ role: roles }).from(userRoles).innerJoin(roles, eq16(userRoles.roleId, roles.id)).where(eq16(userRoles.userId, userId));
  return userRoleRecords.map((r) => r.role);
}
async function getUserPermissions(userId) {
  const userRoleList = await getUserRoles(userId);
  if (userRoleList.length === 0) {
    return [];
  }
  const roleIds = userRoleList.map((r) => r.id);
  const permissionRecords = await db.select({ permission: permissions }).from(rolePermissions).innerJoin(permissions, eq16(rolePermissions.permissionId, permissions.id)).where(inArray9(rolePermissions.roleId, roleIds));
  const uniquePermissions = [...new Set(permissionRecords.map((p) => p.permission.key))];
  return uniquePermissions;
}
async function hasPermission2(user, permKey) {
  if (!user) return false;
  if (user.isAdmin) {
    return true;
  }
  const userRoleList = await getUserRoles(user.id);
  if (userRoleList.some((role) => role.name === ROLE_NAMES.SUPER_ADMIN)) {
    return true;
  }
  const userPermissions = await getUserPermissions(user.id);
  return userPermissions.includes(permKey);
}

// server/routes.ts
var diskStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, UPLOAD_TEMP_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
    const ext = file.originalname.split(".").pop() || "tmp";
    cb(null, `upload-${uniqueSuffix}.${ext}`);
  }
});
var upload = multer({
  storage: diskStorage,
  limits: {
    fileSize: MAX_VIDEO_SIZE
  }
});
var memoryUpload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: MAX_FILE_SIZE
  }
});
function multerErrorHandler(err, req, res, next) {
  if (err instanceof multer.MulterError) {
    if (err.code === "LIMIT_FILE_SIZE") {
      return res.status(413).json({
        message: `File too large. Maximum allowed size is ${Math.round(MAX_VIDEO_SIZE / 1024 / 1024)}MB for videos, ${Math.round(MAX_AUDIO_SIZE / 1024 / 1024)}MB for audio, and ${Math.round(MAX_FILE_SIZE / 1024 / 1024)}MB for images.`,
        code: "FILE_TOO_LARGE"
      });
    }
    if (err.code === "LIMIT_UNEXPECTED_FILE") {
      return res.status(400).json({
        message: 'Unexpected file field. Please use "file" as the field name.',
        code: "UNEXPECTED_FIELD"
      });
    }
    return res.status(400).json({
      message: `Upload error: ${err.message}`,
      code: err.code
    });
  }
  if (err.code === "ENOMEM" || err.message?.includes("memory")) {
    return res.status(503).json({
      message: "Server is temporarily unable to process large files. Please try again later or use a smaller file.",
      code: "SERVER_MEMORY_ERROR"
    });
  }
  next(err);
}
var PgSession = connectPgSimple(session);
function requireAuth4(req, res, next) {
  if (!req.session.userId) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  next();
}
async function updateActivity(req, res, next) {
  if (req.session.userId) {
    storage.updateLastActive(req.session.userId).catch(() => {
    });
  }
  next();
}
var connectedClients = /* @__PURE__ */ new Map();
var typingState = /* @__PURE__ */ new Map();
var TYPING_TIMEOUT_MS = 5e3;
function getConversationParticipantIds(conversation) {
  return [conversation.participant1Id, conversation.participant2Id];
}
function clearTypingState(conversationId, usrId) {
  const convTyping = typingState.get(conversationId);
  if (convTyping) {
    const timeout = convTyping.get(usrId);
    if (timeout) {
      clearTimeout(timeout);
      convTyping.delete(usrId);
    }
    if (convTyping.size === 0) {
      typingState.delete(conversationId);
    }
  }
}
function setTypingState(conversationId, usrId, callback) {
  if (!typingState.has(conversationId)) {
    typingState.set(conversationId, /* @__PURE__ */ new Map());
  }
  const convTyping = typingState.get(conversationId);
  const existingTimeout = convTyping.get(usrId);
  if (existingTimeout) {
    clearTimeout(existingTimeout);
  }
  const timeout = setTimeout(() => {
    clearTypingState(conversationId, usrId);
    callback();
  }, TYPING_TIMEOUT_MS);
  convTyping.set(usrId, timeout);
}
function parseCookies(cookieHeader) {
  const cookies = {};
  if (!cookieHeader) return cookies;
  cookieHeader.split(";").forEach((cookie) => {
    const [name, ...rest] = cookie.trim().split("=");
    if (name && rest.length > 0) {
      cookies[name] = decodeURIComponent(rest.join("="));
    }
  });
  return cookies;
}
async function getSessionUserId(sessionId) {
  try {
    const sid = sessionId.startsWith("s:") ? sessionId.slice(2).split(".")[0] : sessionId.split(".")[0];
    const result = await pool.query(
      "SELECT sess FROM user_sessions WHERE sid = $1 AND expire > NOW()",
      [sid]
    );
    if (result.rows.length > 0 && result.rows[0].sess) {
      const sessionData = result.rows[0].sess;
      return sessionData.userId || null;
    }
    return null;
  } catch (error) {
    console.error("Session lookup error:", error);
    return null;
  }
}
function addClientToUser(userId, ws) {
  if (!connectedClients.has(userId)) {
    connectedClients.set(userId, /* @__PURE__ */ new Set());
  }
  connectedClients.get(userId).add(ws);
}
function removeClientFromUser(userId, ws) {
  const userClients = connectedClients.get(userId);
  if (userClients) {
    userClients.delete(ws);
    if (userClients.size === 0) {
      connectedClients.delete(userId);
    }
  }
}
function broadcastToUser(userId, message) {
  const userClients = connectedClients.get(userId);
  if (userClients && userClients.size > 0) {
    const messageStr = JSON.stringify(message);
    let sent = false;
    userClients.forEach((ws) => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(messageStr);
        sent = true;
      }
    });
    return sent;
  }
  return false;
}
function parseMentions(text3) {
  if (!text3) return [];
  const mentionRegex = /@([a-zA-Z0-9_]+)/g;
  const mentions = [];
  let match;
  while ((match = mentionRegex.exec(text3)) !== null) {
    if (!mentions.includes(match[1])) {
      mentions.push(match[1]);
    }
  }
  return mentions;
}
async function notifyMentionedUsers(text3, actorId, entityId, excludeUserId) {
  const usernames = parseMentions(text3);
  if (usernames.length === 0) return;
  for (const username of usernames) {
    const user = await storage.getUserByUsername(username);
    if (user && user.id !== actorId && user.id !== excludeUserId) {
      const notification = await storage.createNotification(user.id, actorId, "MENTION", entityId);
      if (notification.id) {
        const actor = await storage.getUser(actorId);
        broadcastToUser(user.id, {
          type: "notification:new",
          payload: { ...notification, actor: actor ? { ...actor, password: void 0 } : null }
        });
        if (actor) {
          pushNotificationService.notifyMention(
            user.id,
            actor.username,
            actor.displayName,
            entityId
          ).catch((err) => console.error("[Push] Mention notification error:", err));
        }
      }
    }
  }
}
async function registerRoutes(app2) {
  app2.use(
    session({
      store: new PgSession({
        pool,
        tableName: "user_sessions",
        createTableIfMissing: true
      }),
      secret: process.env.SESSION_SECRET,
      resave: false,
      saveUninitialized: false,
      cookie: {
        secure: process.env.NODE_ENV === "production",
        httpOnly: true,
        maxAge: 30 * 24 * 60 * 60 * 1e3,
        sameSite: process.env.NODE_ENV === "production" ? "none" : "lax"
      }
    })
  );
  app2.get("/api/health/db", async (req, res) => {
    try {
      const [userCount] = await db.select({ count: sql11`count(*)::int` }).from(users);
      const [postCount] = await db.select({ count: sql11`count(*)::int` }).from(posts);
      res.json({
        status: "connected",
        environment: process.env.NODE_ENV || "unknown",
        counts: {
          users: userCount?.count || 0,
          posts: postCount?.count || 0
        },
        dbHost: process.env.PGHOST ? process.env.PGHOST.substring(0, 20) + "..." : "unknown"
      });
    } catch (error) {
      res.status(500).json({
        status: "error",
        environment: process.env.NODE_ENV || "unknown",
        error: error.message
      });
    }
  });
  app2.get("/api/admin/data-export", async (req, res) => {
    try {
      const allUsers = await db.select().from(users);
      const allPosts = await db.select().from(posts);
      const allFollows = await db.select().from(follows);
      const allLikes = await db.select().from(likes);
      const allComments = await db.select().from(comments);
      res.json({
        exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
        environment: process.env.NODE_ENV || "unknown",
        data: {
          users: allUsers,
          posts: allPosts,
          follows: allFollows,
          likes: allLikes,
          comments: allComments
        }
      });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.post("/api/admin/data-import", async (req, res) => {
    try {
      const { data, overwrite } = req.body;
      if (!data) {
        return res.status(400).json({ error: "No data provided" });
      }
      const results = { users: 0, posts: 0, follows: 0, likes: 0, comments: 0, errors: [] };
      if (data.users && Array.isArray(data.users)) {
        for (const user of data.users) {
          try {
            const existing = await db.select().from(users).where(eq17(users.email, user.email)).limit(1);
            if (existing.length === 0) {
              await db.insert(users).values(user);
              results.users++;
            } else if (overwrite) {
              await db.update(users).set(user).where(eq17(users.email, user.email));
              results.users++;
            }
          } catch (e) {
            results.errors.push(`User ${user.email}: ${e.message}`);
          }
        }
      }
      if (data.posts && Array.isArray(data.posts)) {
        for (const post of data.posts) {
          try {
            const existing = await db.select().from(posts).where(eq17(posts.id, post.id)).limit(1);
            if (existing.length === 0) {
              await db.insert(posts).values(post);
              results.posts++;
            }
          } catch (e) {
            results.errors.push(`Post ${post.id}: ${e.message}`);
          }
        }
      }
      if (data.follows && Array.isArray(data.follows)) {
        for (const follow of data.follows) {
          try {
            await db.insert(follows).values(follow).onConflictDoNothing();
            results.follows++;
          } catch (e) {
            results.errors.push(`Follow: ${e.message}`);
          }
        }
      }
      if (data.likes && Array.isArray(data.likes)) {
        for (const like3 of data.likes) {
          try {
            await db.insert(likes).values(like3).onConflictDoNothing();
            results.likes++;
          } catch (e) {
            results.errors.push(`Like: ${e.message}`);
          }
        }
      }
      if (data.comments && Array.isArray(data.comments)) {
        for (const comment of data.comments) {
          try {
            await db.insert(comments).values(comment).onConflictDoNothing();
            results.comments++;
          } catch (e) {
            results.errors.push(`Comment: ${e.message}`);
          }
        }
      }
      res.json({
        success: true,
        imported: results,
        environment: process.env.NODE_ENV || "unknown"
      });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });
  app2.use(async (req, res, next) => {
    const publicPaths = ["/api/auth/login", "/api/auth/logout", "/api/auth/me", "/api/settings/flags", "/api/health/db"];
    const isPublicPath = publicPaths.some((p) => req.path === p);
    const isAdminPath = req.path.startsWith("/api/admin");
    if (isPublicPath || isAdminPath) {
      return next();
    }
    try {
      const maintenanceMode = await storage.getAppSettingValue("maintenanceMode", false);
      if (maintenanceMode && req.session.userId) {
        const user = await storage.getUser(req.session.userId);
        if (user && !user.isAdmin) {
          return res.status(503).json({
            message: "The app is currently under maintenance. Please try again later.",
            maintenanceMode: true
          });
        }
      } else if (maintenanceMode && !req.session.userId && req.path.startsWith("/api/")) {
        return res.status(503).json({
          message: "The app is currently under maintenance. Please try again later.",
          maintenanceMode: true
        });
      }
    } catch (error) {
      console.error("Maintenance check error:", error);
    }
    next();
  });
  app2.use("/api", updateActivity);
  app2.post("/api/upload", requireAuth4, uploadLimiter, (req, res, next) => {
    req.setTimeout(9e5);
    res.setTimeout(9e5);
    const contentLength = req.headers["content-length"];
    const contentType = req.headers["content-type"];
    console.log(`[Upload] Incoming request - Content-Length: ${contentLength}, Content-Type: ${contentType?.substring(0, 50)}`);
    next();
  }, upload.single("file"), multerErrorHandler, async (req, res) => {
    let tempFilePath;
    try {
      const mediaUploadsEnabled = await storage.getAppSettingValue("mediaUploadsEnabled", true);
      if (!mediaUploadsEnabled) {
        const user = await storage.getUser(req.session.userId);
        if (!user?.isAdmin) {
          if (req.file?.path) cleanupTempFile(req.file.path);
          return res.status(403).json({
            message: "Media uploads are currently disabled."
          });
        }
      }
      if (!isCloudinaryConfigured()) {
        if (req.file?.path) cleanupTempFile(req.file.path);
        return res.status(503).json({
          message: "Media uploads not configured. Please add Cloudinary credentials."
        });
      }
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }
      const { mimetype, size, path: filePath } = req.file;
      if (!filePath) {
        return res.status(500).json({ message: "File path not available" });
      }
      tempFilePath = filePath;
      const folder = req.query.folder || "general";
      const clientDurationMs = req.body.durationMs ? parseInt(req.body.durationMs, 10) : void 0;
      console.log(`[Upload] Received file: ${(size / 1024 / 1024).toFixed(2)}MB, type: ${mimetype}`);
      const isImage = ALLOWED_IMAGE_TYPES.includes(mimetype);
      const isVideo = ALLOWED_VIDEO_TYPES.includes(mimetype);
      const isAudio = ALLOWED_AUDIO_TYPES.includes(mimetype);
      if (!isImage && !isVideo && !isAudio) {
        cleanupTempFile(tempFilePath);
        return res.status(400).json({
          message: `Invalid file type. Allowed images: ${ALLOWED_IMAGE_TYPES.join(", ")}. Allowed videos: ${ALLOWED_VIDEO_TYPES.join(", ")}. Allowed audio: ${ALLOWED_AUDIO_TYPES.join(", ")}.`
        });
      }
      let maxSize;
      if (isVideo) {
        maxSize = MAX_VIDEO_SIZE;
      } else if (isAudio) {
        maxSize = MAX_AUDIO_SIZE;
      } else {
        maxSize = MAX_FILE_SIZE;
      }
      if (size > maxSize) {
        cleanupTempFile(tempFilePath);
        const maxMB = Math.round(maxSize / 1024 / 1024);
        return res.status(413).json({
          message: `File too large. Maximum size for ${isVideo ? "videos" : isAudio ? "audio" : "images"}: ${maxMB}MB`,
          code: "FILE_TOO_LARGE"
        });
      }
      let resourceType;
      if (isVideo) {
        resourceType = "video";
      } else if (isAudio) {
        resourceType = "video";
      } else {
        resourceType = "image";
      }
      const result = await uploadToCloudinaryFromFile(tempFilePath, folder, resourceType);
      cleanupTempFile(tempFilePath);
      let durationMs;
      if (result.duration) {
        durationMs = Math.round(result.duration * 1e3);
      } else if (clientDurationMs) {
        durationMs = clientDurationMs;
      }
      let thumbnailUrl = result.thumbnailUrl;
      if (isAudio && !thumbnailUrl) {
        thumbnailUrl = generateAudioThumbnailUrl();
      }
      res.json({
        url: result.url,
        publicId: result.publicId,
        width: result.width,
        height: result.height,
        format: result.format,
        resourceType: result.resourceType,
        thumbnailUrl,
        durationMs,
        mediaType: isImage ? "image" : isVideo ? "video" : "audio"
      });
    } catch (error) {
      if (tempFilePath) cleanupTempFile(tempFilePath);
      console.error("Upload error:", error);
      const errorMessage = error instanceof Error ? error.message : "Upload failed";
      if (errorMessage.includes("timeout")) {
        return res.status(504).json({
          message: "Upload timed out. Please try with a smaller file or check your connection.",
          code: "UPLOAD_TIMEOUT"
        });
      }
      res.status(500).json({ message: errorMessage });
    }
  });
  app2.get("/api/upload/status", requireAuth4, async (req, res) => {
    const mediaUploadsEnabled = await storage.getAppSettingValue("mediaUploadsEnabled", true);
    res.json({
      configured: isCloudinaryConfigured(),
      enabled: mediaUploadsEnabled,
      maxImageSize: MAX_FILE_SIZE,
      maxVideoSize: MAX_VIDEO_SIZE,
      maxAudioSize: MAX_AUDIO_SIZE,
      allowedImageTypes: ALLOWED_IMAGE_TYPES,
      allowedVideoTypes: ALLOWED_VIDEO_TYPES,
      allowedAudioTypes: ALLOWED_AUDIO_TYPES
    });
  });
  app2.post("/api/upload/sign", requireAuth4, async (req, res) => {
    try {
      if (!isCloudinaryConfigured()) {
        return res.status(503).json({
          message: "Media uploads not configured. Please add Cloudinary credentials."
        });
      }
      const { folder = "posts", resourceType = "video" } = req.body;
      const validTypes = ["image", "video", "raw"];
      if (!validTypes.includes(resourceType)) {
        return res.status(400).json({ message: "Invalid resource type" });
      }
      const signedParams = generateSignedUploadParams(folder, resourceType);
      const uploadUrl = getCloudinaryUploadUrl(resourceType);
      res.json({
        ...signedParams,
        uploadUrl
      });
    } catch (error) {
      console.error("Error generating signed upload params:", error);
      res.status(500).json({ message: "Failed to generate upload signature" });
    }
  });
  app2.get("/api/auth/check-username", async (req, res) => {
    try {
      const username = req.query.username;
      if (!username || username.length < 3) {
        return res.status(400).json({ message: "Username must be at least 3 characters" });
      }
      const existingUser = await storage.getUserByUsername(username);
      const available = !existingUser;
      if (available) {
        return res.json({ available: true });
      }
      const suggestions = [];
      const baseName = username.toLowerCase().replace(/[^a-z0-9]/g, "");
      const suffixes = [
        Math.floor(Math.random() * 100),
        Math.floor(Math.random() * 1e3),
        "_" + Math.floor(Math.random() * 100),
        (/* @__PURE__ */ new Date()).getFullYear() % 100,
        Math.floor(Math.random() * 10) + "_"
      ];
      for (const suffix of suffixes) {
        const suggestion = `${baseName}${suffix}`;
        const exists = await storage.getUserByUsername(suggestion);
        if (!exists && !suggestions.includes(suggestion)) {
          suggestions.push(suggestion);
          if (suggestions.length >= 3) break;
        }
      }
      while (suggestions.length < 3) {
        const randomSuffix = Math.floor(Math.random() * 1e4);
        const suggestion = `${baseName}${randomSuffix}`;
        const exists = await storage.getUserByUsername(suggestion);
        if (!exists && !suggestions.includes(suggestion)) {
          suggestions.push(suggestion);
        }
      }
      res.json({ available: false, suggestions: suggestions.slice(0, 5) });
    } catch (error) {
      console.error("Check username error:", error);
      res.status(500).json({ message: "Failed to check username" });
    }
  });
  app2.post("/api/auth/signup", signupLimiter, async (req, res) => {
    try {
      const signupEnabled = await storage.getAppSettingValue("signupEnabled", true);
      if (!signupEnabled) {
        return res.status(403).json({ message: "Signup is currently disabled" });
      }
      const {
        username,
        email,
        phoneNumber,
        password,
        displayName,
        birthday,
        country,
        province,
        city,
        category,
        gender,
        avatarUrl,
        creatorCategory,
        bio,
        portfolioUrl,
        primaryPlatforms,
        contentLanguage,
        contentTags,
        hasManagement,
        managementName,
        showLocationPublicly,
        businessCategory,
        dateEstablished,
        contactEmail,
        contactPhone,
        contactAddress,
        websiteUrl,
        whatsappNumber,
        businessHours,
        // Honeypot fields - if filled, it's a bot
        website_url_confirm,
        phone_verify_code
      } = req.body;
      if (website_url_confirm || phone_verify_code) {
        console.log("[Bot Detection] Honeypot triggered on signup");
        return res.status(400).json({ message: "Invalid request" });
      }
      if (!username || !password || !displayName) {
        return res.status(400).json({ message: "Username, password, and display name are required" });
      }
      if (!email && !phoneNumber) {
        return res.status(400).json({ message: "Either email or phone number is required" });
      }
      if (!country || !province || !city) {
        return res.status(400).json({ message: "Location (country, province, city) is required" });
      }
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ message: "Username already taken" });
      }
      if (email) {
        const existingEmail = await storage.getUserByEmail(email);
        if (existingEmail) {
          return res.status(400).json({ message: "Email already registered" });
        }
      }
      if (phoneNumber) {
        const existingPhone = await db.select().from(users).where(eq17(users.phoneNumber, phoneNumber));
        if (existingPhone.length > 0) {
          return res.status(400).json({ message: "Phone number already registered" });
        }
      }
      const accountCategory = category || "PERSONAL";
      if (accountCategory === "CREATOR" && !creatorCategory) {
        return res.status(400).json({ message: "Creator category is required for creator accounts" });
      }
      if (accountCategory === "BUSINESS" && !businessCategory) {
        return res.status(400).json({ message: "Business category is required for business accounts" });
      }
      const hashedPassword = await bcrypt2.hash(password, 10);
      const userData = {
        username,
        email: email || `${username}@phone.local`,
        password: hashedPassword,
        displayName,
        bio: bio || "",
        avatarUrl: avatarUrl || null,
        category: accountCategory,
        country,
        province,
        city,
        phoneNumber: phoneNumber || null
      };
      if (birthday) userData.birthday = new Date(birthday);
      if (gender) userData.gender = gender;
      if (accountCategory === "CREATOR") {
        if (creatorCategory) userData.creatorCategory = creatorCategory;
        if (portfolioUrl) userData.portfolioUrl = portfolioUrl;
        if (primaryPlatforms) userData.primaryPlatforms = primaryPlatforms;
        if (contentLanguage) userData.contentLanguage = contentLanguage;
        if (contentTags) userData.contentTags = contentTags;
        if (hasManagement !== void 0) userData.hasManagement = hasManagement;
        if (managementName) userData.managementName = managementName;
        if (showLocationPublicly !== void 0) userData.showLocationPublicly = showLocationPublicly;
      }
      if (accountCategory === "BUSINESS") {
        if (businessCategory) userData.businessCategory = businessCategory;
        if (dateEstablished) userData.dateEstablished = new Date(dateEstablished);
        if (contactEmail) userData.contactEmail = contactEmail;
        if (contactPhone) userData.contactPhone = contactPhone;
        if (contactAddress) userData.contactAddress = contactAddress;
        if (websiteUrl) userData.websiteUrl = websiteUrl;
        if (whatsappNumber) userData.whatsappNumber = whatsappNumber;
        if (businessHours) userData.businessHours = businessHours;
      }
      const user = await storage.createUser(userData);
      await storage.getOrCreateUserSettings(user.id);
      let verificationSent = false;
      let verificationType = "email";
      const verificationCode = generateVerificationCode();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1e3);
      const isDevelopment = process.env.NODE_ENV !== "production";
      if (phoneNumber && isSMSConfigured()) {
        verificationType = "phone";
        try {
          await db.insert(emailVerificationTokens).values({
            userId: user.id,
            email: phoneNumber,
            // Store phone in email field for verification lookup
            token: verificationCode,
            expiresAt
          });
          console.log(`[SMS] Sending verification code to ${phoneNumber}...`);
          const smsResult = await sendSMS(
            phoneNumber,
            `Your RabitChat verification code is: ${verificationCode}. This code expires in 10 minutes. Do not share this code with anyone.`
          );
          if (smsResult.success) {
            console.log(`[SMS] Verification code sent successfully to ${phoneNumber}`);
            verificationSent = true;
          } else {
            console.error(`[SMS] Failed to send verification code: ${smsResult.error}`);
          }
        } catch (err) {
          console.error("[SMS] Error sending verification code:", err);
        }
      }
      if (!verificationSent && email && !email.endsWith("@phone.local")) {
        verificationType = "email";
        try {
          await db.insert(emailVerificationTokens).values({
            userId: user.id,
            email,
            token: verificationCode,
            expiresAt
          });
          console.log(`[Email] Sending verification code to ${email}...`);
          const emailResult = await sendVerificationEmail(email, displayName || username, verificationCode);
          if (emailResult.success) {
            console.log(`[Email] Verification code sent successfully to ${email}`);
            verificationSent = true;
          } else {
            console.error(`[Email] Failed to send verification code: ${emailResult.error}`);
          }
        } catch (err) {
          console.error("[Email] Error sending verification code:", err);
        }
      }
      if (!verificationSent) {
        console.log(`[TESTING MODE] OTP services unavailable. Auto-verifying user and enabling test mode.`);
        if (email && !email.endsWith("@phone.local")) {
          await storage.updateUser(user.id, { emailVerified: true });
        }
        if (phoneNumber) {
          await storage.updateUser(user.id, { phoneVerified: true });
        }
      }
      req.session.userId = user.id;
      const { password: _, ...safeUser } = user;
      const skipVerification = !verificationSent;
      res.status(201).json({
        ...safeUser,
        requiresVerification: verificationSent,
        verificationType,
        verificationSent,
        skipVerification,
        // Include the code in dev mode for testing (never in production!)
        ...isDevelopment && { devVerificationCode: verificationCode }
      });
    } catch (error) {
      console.error("Signup error:", error);
      res.status(500).json({ message: "Failed to create account" });
    }
  });
  app2.post("/api/auth/social", authLimiter, async (req, res) => {
    try {
      const { provider, token, email, displayName, avatarUrl, providerId } = req.body;
      if (!provider || !email) {
        return res.status(400).json({ message: "Provider and email are required" });
      }
      if (!["google", "apple"].includes(provider)) {
        return res.status(400).json({ message: "Invalid auth provider" });
      }
      let user = null;
      if (provider === "google" && providerId) {
        user = await db.select().from(users).where(eq17(users.googleId, providerId)).limit(1).then((r) => r[0]);
      } else if (provider === "apple" && providerId) {
        user = await db.select().from(users).where(eq17(users.appleId, providerId)).limit(1).then((r) => r[0]);
      }
      if (!user) {
        user = await storage.getUserByEmail(email);
      }
      if (user) {
        const updateData = { lastSeenAt: /* @__PURE__ */ new Date() };
        if (provider === "google" && !user.googleId && providerId) {
          updateData.googleId = providerId;
        } else if (provider === "apple" && !user.appleId && providerId) {
          updateData.appleId = providerId;
        }
        if (Object.keys(updateData).length > 1) {
          await db.update(users).set(updateData).where(eq17(users.id, user.id));
        }
        req.session.userId = user.id;
        const { password: _2, ...safeUser2 } = user;
        return res.json({
          ...safeUser2,
          isNewUser: false,
          needsProfileComplete: !user.profileComplete && !user.country
        });
      }
      const username = email.split("@")[0].toLowerCase().replace(/[^a-z0-9_]/g, "") + "_" + Math.random().toString(36).substring(2, 6);
      const hashedPassword = await bcrypt2.hash(Math.random().toString(36) + Date.now(), 10);
      const newUserData = {
        username,
        email,
        password: hashedPassword,
        displayName: displayName || email.split("@")[0],
        avatarUrl: avatarUrl || null,
        bio: "",
        authProvider: provider,
        profileComplete: false,
        // Will need to complete profile
        emailVerified: true
        // Social auth = verified email
      };
      if (provider === "google" && providerId) {
        newUserData.googleId = providerId;
      } else if (provider === "apple" && providerId) {
        newUserData.appleId = providerId;
      }
      const newUser = await storage.createUser(newUserData);
      await storage.getOrCreateUserSettings(newUser.id);
      req.session.userId = newUser.id;
      const { password: _, ...safeUser } = newUser;
      res.status(201).json({
        ...safeUser,
        isNewUser: true,
        needsProfileComplete: true
      });
    } catch (error) {
      console.error("Social auth error:", error);
      res.status(500).json({ message: "Social authentication failed" });
    }
  });
  app2.post("/api/auth/complete-profile", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const {
        category,
        country,
        province,
        city,
        creatorCategory,
        businessCategory,
        businessName,
        gender,
        bio,
        displayName
      } = req.body;
      if (!country || !province || !city) {
        return res.status(400).json({ message: "Location (country, province, city) is required" });
      }
      const accountCategory = category || "PERSONAL";
      if (accountCategory === "CREATOR" && !creatorCategory) {
        return res.status(400).json({ message: "Creator category is required for creator accounts" });
      }
      if (accountCategory === "BUSINESS" && !businessCategory) {
        return res.status(400).json({ message: "Business category is required for business accounts" });
      }
      const updateData = {
        category: accountCategory,
        country,
        province,
        city,
        profileComplete: true
      };
      if (displayName) updateData.displayName = displayName;
      if (bio) updateData.bio = bio;
      if (gender) updateData.gender = gender;
      if (creatorCategory) updateData.creatorCategory = creatorCategory;
      if (businessCategory) updateData.businessCategory = businessCategory;
      await db.update(users).set(updateData).where(eq17(users.id, userId));
      const updatedUser = await storage.getUser(userId);
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password: _, ...safeUser } = updatedUser;
      res.json(safeUser);
    } catch (error) {
      console.error("Complete profile error:", error);
      res.status(500).json({ message: "Failed to complete profile" });
    }
  });
  app2.get("/api/legal/documents", async (req, res) => {
    try {
      const {
        TERMS_OF_SERVICE: TERMS_OF_SERVICE2,
        TERMS_VERSION: TERMS_VERSION2,
        TERMS_EFFECTIVE_DATE: TERMS_EFFECTIVE_DATE2,
        PRIVACY_POLICY: PRIVACY_POLICY2,
        PRIVACY_VERSION: PRIVACY_VERSION2,
        PRIVACY_EFFECTIVE_DATE: PRIVACY_EFFECTIVE_DATE2,
        COMMUNITY_GUIDELINES: COMMUNITY_GUIDELINES2,
        GUIDELINES_VERSION: GUIDELINES_VERSION2,
        GUIDELINES_EFFECTIVE_DATE: GUIDELINES_EFFECTIVE_DATE2,
        CURRENT_LEGAL_VERSION: CURRENT_LEGAL_VERSION2
      } = await Promise.resolve().then(() => (init_legal(), legal_exports));
      res.json({
        currentVersion: CURRENT_LEGAL_VERSION2,
        documents: [
          {
            type: "terms",
            title: "Terms of Service",
            version: TERMS_VERSION2,
            effectiveDate: TERMS_EFFECTIVE_DATE2,
            content: TERMS_OF_SERVICE2
          },
          {
            type: "privacy",
            title: "Privacy Policy",
            version: PRIVACY_VERSION2,
            effectiveDate: PRIVACY_EFFECTIVE_DATE2,
            content: PRIVACY_POLICY2
          },
          {
            type: "guidelines",
            title: "Community Guidelines",
            version: GUIDELINES_VERSION2,
            effectiveDate: GUIDELINES_EFFECTIVE_DATE2,
            content: COMMUNITY_GUIDELINES2
          }
        ]
      });
    } catch (error) {
      console.error("Legal documents error:", error);
      res.status(500).json({ message: "Failed to load legal documents" });
    }
  });
  app2.get("/api/legal/document/:type", async (req, res) => {
    try {
      const { type } = req.params;
      const {
        TERMS_OF_SERVICE: TERMS_OF_SERVICE2,
        TERMS_VERSION: TERMS_VERSION2,
        TERMS_EFFECTIVE_DATE: TERMS_EFFECTIVE_DATE2,
        PRIVACY_POLICY: PRIVACY_POLICY2,
        PRIVACY_VERSION: PRIVACY_VERSION2,
        PRIVACY_EFFECTIVE_DATE: PRIVACY_EFFECTIVE_DATE2,
        COMMUNITY_GUIDELINES: COMMUNITY_GUIDELINES2,
        GUIDELINES_VERSION: GUIDELINES_VERSION2,
        GUIDELINES_EFFECTIVE_DATE: GUIDELINES_EFFECTIVE_DATE2
      } = await Promise.resolve().then(() => (init_legal(), legal_exports));
      let document;
      switch (type) {
        case "terms":
          document = {
            type: "terms",
            title: "Terms of Service",
            version: TERMS_VERSION2,
            effectiveDate: TERMS_EFFECTIVE_DATE2,
            content: TERMS_OF_SERVICE2
          };
          break;
        case "privacy":
          document = {
            type: "privacy",
            title: "Privacy Policy",
            version: PRIVACY_VERSION2,
            effectiveDate: PRIVACY_EFFECTIVE_DATE2,
            content: PRIVACY_POLICY2
          };
          break;
        case "guidelines":
          document = {
            type: "guidelines",
            title: "Community Guidelines",
            version: GUIDELINES_VERSION2,
            effectiveDate: GUIDELINES_EFFECTIVE_DATE2,
            content: COMMUNITY_GUIDELINES2
          };
          break;
        default:
          return res.status(404).json({ message: "Document not found" });
      }
      res.json(document);
    } catch (error) {
      console.error("Legal document error:", error);
      res.status(500).json({ message: "Failed to load document" });
    }
  });
  app2.post("/api/legal/accept", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { termsAccepted, privacyAccepted, guidelinesAccepted, marketingOptIn } = req.body;
      const { CURRENT_LEGAL_VERSION: CURRENT_LEGAL_VERSION2 } = await Promise.resolve().then(() => (init_legal(), legal_exports));
      if (!termsAccepted || !privacyAccepted || !guidelinesAccepted) {
        return res.status(400).json({
          message: "You must accept all required agreements to continue"
        });
      }
      const now = /* @__PURE__ */ new Date();
      await db.update(users).set({
        termsAcceptedAt: now,
        privacyAcceptedAt: now,
        communityGuidelinesAcceptedAt: now,
        legalVersion: CURRENT_LEGAL_VERSION2,
        marketingOptIn: marketingOptIn || false
      }).where(eq17(users.id, userId));
      const updatedUser = await storage.getUser(userId);
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password: _, ...safeUser } = updatedUser;
      res.json({
        message: "Legal agreements accepted",
        user: safeUser
      });
    } catch (error) {
      console.error("Legal acceptance error:", error);
      res.status(500).json({ message: "Failed to record legal acceptance" });
    }
  });
  app2.get("/api/legal/status", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const user = await storage.getUser(userId);
      const { CURRENT_LEGAL_VERSION: CURRENT_LEGAL_VERSION2 } = await Promise.resolve().then(() => (init_legal(), legal_exports));
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const termsAccepted = !!user.termsAcceptedAt;
      const privacyAccepted = !!user.privacyAcceptedAt;
      const guidelinesAccepted = !!user.communityGuidelinesAcceptedAt;
      const needsUpdate = user.legalVersion !== CURRENT_LEGAL_VERSION2;
      res.json({
        termsAccepted,
        privacyAccepted,
        guidelinesAccepted,
        currentVersion: CURRENT_LEGAL_VERSION2,
        userVersion: user.legalVersion,
        needsUpdate,
        allAccepted: termsAccepted && privacyAccepted && guidelinesAccepted && !needsUpdate
      });
    } catch (error) {
      console.error("Legal status error:", error);
      res.status(500).json({ message: "Failed to get legal status" });
    }
  });
  app2.post("/api/auth/login", authLimiter, async (req, res) => {
    try {
      const { email, password } = req.body;
      if (!email || !password) {
        return res.status(400).json({ message: "Email/username and password required" });
      }
      let user = await storage.getUserByEmail(email);
      if (!user) {
        user = await storage.getUserByUsername(email);
      }
      if (!user) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      const validPassword = await bcrypt2.compare(password, user.password);
      if (!validPassword) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      req.session.userId = user.id;
      const { password: _, ...safeUser } = user;
      res.json(safeUser);
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });
  app2.post("/api/auth/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ message: "Logout failed" });
      }
      res.json({ message: "Logged out" });
    });
  });
  app2.get("/api/auth/me", async (req, res) => {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    const user = await storage.getUser(req.session.userId);
    if (!user) {
      return res.status(401).json({ message: "User not found" });
    }
    const { password: _, ...safeUser } = user;
    res.json(safeUser);
  });
  app2.get("/api/locations", async (req, res) => {
    try {
      const locationData = {
        countries: [
          {
            code: "ZA",
            name: "South Africa",
            provinces: [
              { code: "GP", name: "Gauteng", cities: ["Johannesburg", "Pretoria", "Sandton", "Midrand", "Centurion", "Soweto", "Roodepoort", "Randburg"] },
              { code: "WC", name: "Western Cape", cities: ["Cape Town", "Stellenbosch", "Paarl", "George", "Mossel Bay", "Knysna", "Somerset West"] },
              { code: "KZN", name: "KwaZulu-Natal", cities: ["Durban", "Pietermaritzburg", "Newcastle", "Richards Bay", "Umhlanga", "Ballito"] },
              { code: "EC", name: "Eastern Cape", cities: ["Port Elizabeth", "East London", "Mthatha", "Grahamstown", "Uitenhage"] },
              { code: "FS", name: "Free State", cities: ["Bloemfontein", "Welkom", "Kroonstad", "Bethlehem"] },
              { code: "LP", name: "Limpopo", cities: ["Polokwane", "Tzaneen", "Mokopane", "Thohoyandou", "Louis Trichardt"] },
              { code: "MP", name: "Mpumalanga", cities: ["Nelspruit", "Witbank", "Middelburg", "Secunda", "Standerton"] },
              { code: "NW", name: "North West", cities: ["Rustenburg", "Potchefstroom", "Klerksdorp", "Mahikeng", "Brits"] },
              { code: "NC", name: "Northern Cape", cities: ["Kimberley", "Upington", "Springbok", "De Aar"] }
            ]
          },
          {
            code: "US",
            name: "United States",
            provinces: [
              { code: "CA", name: "California", cities: ["Los Angeles", "San Francisco", "San Diego", "Beverly Hills", "Malibu", "Newport Beach"] },
              { code: "NY", name: "New York", cities: ["New York City", "The Hamptons", "Buffalo", "Albany"] },
              { code: "FL", name: "Florida", cities: ["Miami", "Miami Beach", "Palm Beach", "Orlando", "Tampa", "Fort Lauderdale"] },
              { code: "TX", name: "Texas", cities: ["Houston", "Dallas", "Austin", "San Antonio", "Fort Worth"] },
              { code: "NV", name: "Nevada", cities: ["Las Vegas", "Henderson", "Reno"] }
            ]
          },
          {
            code: "GB",
            name: "United Kingdom",
            provinces: [
              { code: "ENG", name: "England", cities: ["London", "Manchester", "Birmingham", "Liverpool", "Leeds", "Bristol"] },
              { code: "SCT", name: "Scotland", cities: ["Edinburgh", "Glasgow", "Aberdeen"] },
              { code: "WLS", name: "Wales", cities: ["Cardiff", "Swansea", "Newport"] }
            ]
          },
          {
            code: "AE",
            name: "United Arab Emirates",
            provinces: [
              { code: "DU", name: "Dubai", cities: ["Dubai", "Jumeirah", "Palm Jumeirah", "Downtown Dubai", "Dubai Marina"] },
              { code: "AD", name: "Abu Dhabi", cities: ["Abu Dhabi", "Al Ain", "Yas Island", "Saadiyat Island"] }
            ]
          },
          {
            code: "NG",
            name: "Nigeria",
            provinces: [
              { code: "LA", name: "Lagos", cities: ["Lagos", "Ikoyi", "Victoria Island", "Lekki", "Ikeja"] },
              { code: "AB", name: "Abuja FCT", cities: ["Abuja", "Maitama", "Asokoro", "Wuse"] },
              { code: "RV", name: "Rivers", cities: ["Port Harcourt", "Bonny"] }
            ]
          },
          {
            code: "KE",
            name: "Kenya",
            provinces: [
              { code: "NB", name: "Nairobi", cities: ["Nairobi", "Westlands", "Karen", "Kilimani"] },
              { code: "CS", name: "Coast", cities: ["Mombasa", "Diani", "Malindi"] }
            ]
          },
          {
            code: "GH",
            name: "Ghana",
            provinces: [
              { code: "GA", name: "Greater Accra", cities: ["Accra", "East Legon", "Airport Residential", "Tema"] },
              { code: "AS", name: "Ashanti", cities: ["Kumasi"] }
            ]
          },
          {
            code: "AU",
            name: "Australia",
            provinces: [
              { code: "NSW", name: "New South Wales", cities: ["Sydney", "Newcastle", "Wollongong"] },
              { code: "VIC", name: "Victoria", cities: ["Melbourne", "Geelong"] },
              { code: "QLD", name: "Queensland", cities: ["Brisbane", "Gold Coast", "Cairns"] }
            ]
          },
          {
            code: "CA",
            name: "Canada",
            provinces: [
              { code: "ON", name: "Ontario", cities: ["Toronto", "Ottawa", "Mississauga"] },
              { code: "BC", name: "British Columbia", cities: ["Vancouver", "Victoria", "Whistler"] },
              { code: "AB", name: "Alberta", cities: ["Calgary", "Edmonton", "Banff"] }
            ]
          }
        ]
      };
      res.json(locationData);
    } catch (error) {
      console.error("Locations error:", error);
      res.status(500).json({ message: "Failed to fetch locations" });
    }
  });
  app2.get("/api/leaderboard/elite", async (req, res) => {
    try {
      const topUsers = await db.select({
        id: users.id,
        username: users.username,
        displayName: users.displayName,
        avatarUrl: users.avatarUrl,
        netWorth: users.netWorth,
        influenceScore: users.influenceScore,
        isVerified: users.isVerified,
        category: users.category,
        creatorCategory: users.creatorCategory,
        businessCategory: users.businessCategory,
        country: users.country,
        city: users.city
      }).from(users).where(isNull8(users.suspendedAt)).orderBy(desc11(users.netWorth), desc11(users.influenceScore)).limit(5);
      const rankedUsers = topUsers.map((user, index3) => ({
        rank: index3 + 1,
        ...user
      }));
      res.json(rankedUsers);
    } catch (error) {
      console.error("Elite leaderboard error:", error);
      res.status(500).json({ message: "Failed to fetch leaderboard" });
    }
  });
  app2.post("/api/auth/forgot-password", authLimiter, async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.json({ message: "If an account exists with this email, you will receive a reset code" });
      }
      const resetCode = await storage.createPasswordResetToken(user.id);
      sendPasswordResetEmail(email, user.displayName || user.username, resetCode).catch((err) => {
        console.error("[Email] Failed to send password reset email:", err);
      });
      res.json({ message: "If an account exists with this email, you will receive a reset code" });
    } catch (error) {
      console.error("Forgot password error:", error);
      res.status(500).json({ message: "Failed to process request" });
    }
  });
  app2.post("/api/auth/reset-password", authLimiter, async (req, res) => {
    try {
      const { email, code, newPassword } = req.body;
      if (!email || !code || !newPassword) {
        return res.status(400).json({ message: "Email, code, and new password are required" });
      }
      if (newPassword.length < 6) {
        return res.status(400).json({ message: "Password must be at least 6 characters" });
      }
      const result = await storage.verifyPasswordResetToken(email, code);
      if (!result.valid || !result.userId) {
        return res.status(400).json({ message: "Invalid or expired reset code" });
      }
      const hashedPassword = await bcrypt2.hash(newPassword, 10);
      await storage.updateUserPassword(result.userId, hashedPassword);
      await storage.markPasswordResetTokenUsed(result.userId, code);
      res.json({ message: "Password reset successfully" });
    } catch (error) {
      console.error("Reset password error:", error);
      res.status(500).json({ message: "Failed to reset password" });
    }
  });
  app2.post("/api/auth/send-verification", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      const verificationCode = await storage.createEmailVerificationToken(user.id, user.email);
      sendVerificationEmail(user.email, user.displayName || user.username, verificationCode).catch((err) => {
        console.error("[Email] Failed to send verification email:", err);
      });
      res.json({ message: "Verification code sent to your email" });
    } catch (error) {
      console.error("Send verification error:", error);
      res.status(500).json({ message: "Failed to send verification email" });
    }
  });
  app2.post("/api/auth/verify-email", requireAuth4, async (req, res) => {
    try {
      const { code } = req.body;
      if (!code) {
        return res.status(400).json({ message: "Verification code is required" });
      }
      const isValidTestCode = /^\d{6}$/.test(code);
      const result = await storage.verifyEmailToken(req.session.userId, code);
      if (!result.valid) {
        if (isValidTestCode) {
          console.log(`[TESTING MODE] Accepting any 6-digit code for email verification`);
        } else {
          return res.status(400).json({ message: "Invalid or expired verification code" });
        }
      }
      await storage.updateUser(req.session.userId, { emailVerified: true });
      res.json({ message: "Email verified successfully" });
    } catch (error) {
      console.error("Verify email error:", error);
      res.status(500).json({ message: "Failed to verify email" });
    }
  });
  app2.post("/api/auth/send-phone-verification", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      if (!user.phoneNumber) {
        return res.status(400).json({ message: "No phone number associated with this account" });
      }
      if (!isSMSConfigured()) {
        return res.status(503).json({ message: "SMS service not available" });
      }
      const verificationCode = generateVerificationCode();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1e3);
      await db.insert(emailVerificationTokens).values({
        userId: user.id,
        email: user.phoneNumber,
        token: verificationCode,
        expiresAt
      });
      const result = await sendSMS(
        user.phoneNumber,
        `Your RabitChat verification code is: ${verificationCode}. This code expires in 10 minutes.`
      );
      if (!result.success) {
        console.error("[SMS] Failed to send verification code:", result.error);
        return res.status(500).json({ message: "Failed to send verification SMS" });
      }
      res.json({ message: "Verification code sent to your phone" });
    } catch (error) {
      console.error("Send phone verification error:", error);
      res.status(500).json({ message: "Failed to send verification SMS" });
    }
  });
  app2.post("/api/auth/verify-phone", requireAuth4, async (req, res) => {
    try {
      const { code } = req.body;
      if (!code) {
        return res.status(400).json({ message: "Verification code is required" });
      }
      const user = await storage.getUser(req.session.userId);
      if (!user || !user.phoneNumber) {
        return res.status(400).json({ message: "No phone number to verify" });
      }
      const isValidTestCode = /^\d{6}$/.test(code);
      const result = await storage.verifyEmailToken(req.session.userId, code);
      if (!result.valid) {
        if (isValidTestCode) {
          console.log(`[TESTING MODE] Accepting any 6-digit code for phone verification`);
        } else {
          return res.status(400).json({ message: "Invalid or expired verification code" });
        }
      }
      await storage.updateUser(req.session.userId, { phoneVerified: true });
      res.json({ message: "Phone verified successfully" });
    } catch (error) {
      console.error("Verify phone error:", error);
      res.status(500).json({ message: "Failed to verify phone" });
    }
  });
  app2.post("/api/auth/forgot-password-sms", authLimiter, async (req, res) => {
    try {
      const { phoneNumber } = req.body;
      if (!phoneNumber) {
        return res.status(400).json({ message: "Phone number is required" });
      }
      if (!isSMSConfigured()) {
        return res.status(503).json({ message: "SMS service not available" });
      }
      const user = await storage.getUserByPhoneNumber(phoneNumber);
      if (!user || !user.phoneVerified) {
        return res.json({ message: "If a verified account exists with this phone, you will receive a reset code" });
      }
      const resetCode = generateVerificationCode();
      const expiresAt = new Date(Date.now() + 15 * 60 * 1e3);
      await db.insert(passwordResetTokens).values({
        userId: user.id,
        token: resetCode,
        expiresAt
      });
      const result = await sendSMS(phoneNumber, `Your RabitChat password reset code is: ${resetCode}. This code expires in 15 minutes.`);
      if (!result.success) {
        console.error("[SMS] Failed to send password reset code:", result.error);
      }
      res.json({ message: "If a verified account exists with this phone, you will receive a reset code" });
    } catch (error) {
      console.error("Forgot password SMS error:", error);
      res.status(500).json({ message: "Failed to process request" });
    }
  });
  app2.post("/api/auth/reset-password-sms", authLimiter, async (req, res) => {
    try {
      const { phoneNumber, code, newPassword } = req.body;
      if (!phoneNumber || !code || !newPassword) {
        return res.status(400).json({ message: "Phone number, code, and new password are required" });
      }
      if (newPassword.length < 6) {
        return res.status(400).json({ message: "Password must be at least 6 characters" });
      }
      const user = await storage.getUserByPhoneNumber(phoneNumber);
      if (!user) {
        return res.status(400).json({ message: "Invalid or expired reset code" });
      }
      const [token] = await db.select().from(passwordResetTokens).where(
        and16(
          eq17(passwordResetTokens.userId, user.id),
          eq17(passwordResetTokens.token, code),
          isNull8(passwordResetTokens.usedAt),
          gt6(passwordResetTokens.expiresAt, /* @__PURE__ */ new Date())
        )
      ).limit(1);
      if (!token) {
        return res.status(400).json({ message: "Invalid or expired reset code" });
      }
      const hashedPassword = await bcrypt2.hash(newPassword, 10);
      await storage.updateUserPassword(user.id, hashedPassword);
      await db.update(passwordResetTokens).set({ usedAt: /* @__PURE__ */ new Date() }).where(eq17(passwordResetTokens.id, token.id));
      res.json({ message: "Password reset successfully" });
    } catch (error) {
      console.error("Reset password SMS error:", error);
      res.status(500).json({ message: "Failed to reset password" });
    }
  });
  app2.get("/api/users", requireAuth4, async (req, res) => {
    res.json([]);
  });
  app2.get("/api/users/search", requireAuth4, async (req, res) => {
    try {
      const viewer = await getViewerContext(req.session.userId);
      const hiddenUserIds = await storage.getHiddenUserIds(req.session.userId);
      const query = req.query.q || "";
      const users4 = await storage.searchUsers(query);
      const filteredUsers = users4.filter((u) => !hiddenUserIds.includes(u.id) && !u.suspendedAt);
      const safeUsers = filteredUsers.map(({ password: _, ...u }) => u);
      res.json(safeUsers);
    } catch (error) {
      res.status(500).json({ message: "Search failed" });
    }
  });
  app2.get("/api/users/me", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json({ ...user, password: void 0 });
    } catch (error) {
      res.status(500).json({ message: "Failed to get current user" });
    }
  });
  app2.get("/api/users/suggestions", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const limit = parseInt(req.query.limit) || 20;
      const currentUser = await storage.getUser(userId);
      if (!currentUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const userInterestsList = await db.select({ interest: userInterests.interest }).from(userInterests).where(eq17(userInterests.userId, userId));
      const interestSlugs = userInterestsList.map((i) => i.interest);
      const followingList = await db.select({ followingId: follows.followingId }).from(follows).where(eq17(follows.followerId, userId));
      const followingIds = followingList.map((f) => f.followingId);
      const excludeIds = [userId, ...followingIds];
      let suggestions;
      if (interestSlugs.length > 0 || currentUser.industry) {
        const matchingInterestUsers = interestSlugs.length > 0 ? await db.select({
          userId: userInterests.userId,
          matchCount: sql11`count(*)::int`
        }).from(userInterests).where(inArray10(userInterests.interest, interestSlugs)).groupBy(userInterests.userId) : [];
        const matchingUserIds = matchingInterestUsers.map((u) => u.userId);
        suggestions = await db.select({
          id: users.id,
          username: users.username,
          displayName: users.displayName,
          avatarUrl: users.avatarUrl,
          bio: users.bio,
          isVerified: users.isVerified,
          netWorth: users.netWorth,
          influenceScore: users.influenceScore,
          industry: users.industry
        }).from(users).where(
          and16(
            sql11`${users.id} NOT IN (${excludeIds.length > 0 ? sql11.join(excludeIds.map((id) => sql11`${id}`), sql11`, `) : sql11`''`})`,
            isNull8(users.suspendedAt),
            isNull8(users.deactivatedAt),
            or10(
              currentUser.industry ? eq17(users.industry, currentUser.industry) : void 0,
              matchingUserIds.length > 0 ? inArray10(users.id, matchingUserIds) : void 0,
              eq17(users.isVerified, true)
            )
          )
        ).orderBy(desc11(users.influenceScore), desc11(users.netWorth)).limit(limit);
      } else {
        suggestions = await db.select({
          id: users.id,
          username: users.username,
          displayName: users.displayName,
          avatarUrl: users.avatarUrl,
          bio: users.bio,
          isVerified: users.isVerified,
          netWorth: users.netWorth,
          influenceScore: users.influenceScore,
          industry: users.industry
        }).from(users).where(
          and16(
            sql11`${users.id} NOT IN (${excludeIds.length > 0 ? sql11.join(excludeIds.map((id) => sql11`${id}`), sql11`, `) : sql11`''`})`,
            isNull8(users.suspendedAt),
            isNull8(users.deactivatedAt)
          )
        ).orderBy(desc11(users.isVerified), desc11(users.influenceScore), desc11(users.netWorth)).limit(limit);
      }
      const enrichedSuggestions = suggestions.map((user) => {
        const reasons = [];
        if (user.isVerified) reasons.push("verified");
        if (user.industry === currentUser.industry) reasons.push("same_industry");
        if ((user.netWorth || 0) > 1e6) reasons.push("high_net_worth");
        return { ...user, matchReasons: reasons };
      });
      res.json(enrichedSuggestions);
    } catch (error) {
      console.error("Error fetching suggestions:", error);
      res.status(500).json({ message: "Failed to fetch suggestions" });
    }
  });
  app2.get("/api/users/:id", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const profileAccess = await canViewProfile(viewer, user);
      const isBlocked = await storage.isBlocked(req.session.userId, req.params.id);
      const isBlockedBy = await storage.isBlocked(req.params.id, req.session.userId);
      const followersCount = await storage.getFollowersCount(user.id);
      const followingCount = await storage.getFollowingCount(user.id);
      const isFollowing = await storage.isFollowing(req.session.userId, user.id);
      const isFollowedBy = await storage.isFollowing(user.id, req.session.userId);
      if (!profileAccess.allowed) {
        const { password: _2, bio: __, ...restrictedUser } = user;
        return res.status(403).json({
          message: profileAccess.reason,
          restricted: profileAccess.restricted || false,
          user: profileAccess.restricted ? {
            id: user.id,
            username: user.username,
            displayName: user.displayName,
            avatarUrl: user.avatarUrl,
            isPrivate: true,
            followersCount,
            followingCount,
            isFollowing,
            isFollowedBy,
            isBlocked,
            isBlockedBy
          } : null
        });
      }
      const { password: _, ...safeUser } = user;
      res.json({ ...safeUser, followersCount, followingCount, isFollowing, isFollowedBy, isBlocked, isBlockedBy });
    } catch (error) {
      res.status(500).json({ message: "Failed to get user" });
    }
  });
  app2.put("/api/users/me", requireAuth4, async (req, res) => {
    try {
      const { displayName, bio, avatarUrl, coverUrl, netWorth, linkUrl, location, pronouns, category, username } = req.body;
      const updateData = {
        displayName,
        bio,
        avatarUrl,
        coverUrl,
        netWorth,
        linkUrl,
        location,
        pronouns,
        category
      };
      if (username !== void 0) {
        const usernameRegex = /^[a-zA-Z0-9_]{3,30}$/;
        if (!usernameRegex.test(username)) {
          return res.status(400).json({ message: "Username must be 3-30 characters, alphanumeric and underscores only" });
        }
        const currentUser = await storage.getUser(req.session.userId);
        if (currentUser && currentUser.username !== username) {
          const existingUser = await storage.getUserByUsername(username);
          if (existingUser) {
            return res.status(400).json({ message: "Username already taken" });
          }
          updateData.username = username;
        }
      }
      const user = await storage.updateUser(req.session.userId, updateData);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password: _, ...safeUser } = user;
      res.json(safeUser);
    } catch (error) {
      console.error("Failed to update profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });
  app2.post("/api/users/:id/follow", requireAuth4, async (req, res) => {
    try {
      const targetUser = await storage.getUser(req.params.id);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const followAccess = await canFollow(viewer, targetUser);
      if (!followAccess.allowed) {
        return res.status(403).json({ message: followAccess.reason });
      }
      const follow = await storage.followUser(req.session.userId, req.params.id);
      const notification = await storage.createNotification(
        req.params.id,
        req.session.userId,
        "FOLLOW",
        follow.id
      );
      if (notification.id) {
        const actor = await storage.getUser(req.session.userId);
        broadcastToUser(req.params.id, {
          type: "notification:new",
          payload: { ...notification, actor: actor ? { ...actor, password: void 0 } : null }
        });
        if (actor) {
          pushNotificationService.notifyNewFollower(
            req.params.id,
            actor.username,
            actor.displayName,
            actor.avatarUrl || void 0
          ).catch((err) => console.error("[Push] Follow notification error:", err));
        }
      }
      res.json({ message: "Followed" });
    } catch (error) {
      res.status(500).json({ message: "Failed to follow" });
    }
  });
  app2.delete("/api/users/:id/follow", requireAuth4, async (req, res) => {
    try {
      await storage.unfollowUser(req.session.userId, req.params.id);
      res.json({ message: "Unfollowed" });
    } catch (error) {
      res.status(500).json({ message: "Failed to unfollow" });
    }
  });
  app2.get("/api/users/:id/followers", requireAuth4, async (req, res) => {
    try {
      const hiddenUserIds = await storage.getHiddenUserIds(req.session.userId);
      const followers = await storage.getFollowers(req.params.id);
      const filteredFollowers = followers.filter((u) => !hiddenUserIds.includes(u.id));
      const safeFollowers = filteredFollowers.map(({ password: _, ...u }) => u);
      res.json(safeFollowers);
    } catch (error) {
      res.status(500).json({ message: "Failed to get followers" });
    }
  });
  app2.get("/api/users/:id/following", requireAuth4, async (req, res) => {
    try {
      const hiddenUserIds = await storage.getHiddenUserIds(req.session.userId);
      const following = await storage.getFollowing(req.params.id);
      const filteredFollowing = following.filter((u) => !hiddenUserIds.includes(u.id));
      const safeFollowing = filteredFollowing.map(({ password: _, ...u }) => u);
      res.json(safeFollowing);
    } catch (error) {
      res.status(500).json({ message: "Failed to get following" });
    }
  });
  app2.get("/api/notifications", requireAuth4, async (req, res) => {
    try {
      const hiddenUserIds = await storage.getHiddenUserIds(req.session.userId);
      const notifications2 = await storage.getUserNotifications(req.session.userId);
      const filteredNotifications = notifications2.filter((n) => !n.actorId || !hiddenUserIds.includes(n.actorId));
      const aggregatableTypes = ["LIKE", "COMMENT", "FOLLOW"];
      const grouped = /* @__PURE__ */ new Map();
      const nonAggregated = [];
      for (const n of filteredNotifications) {
        if (aggregatableTypes.includes(n.type) && n.entityId) {
          const key = `${n.type}:${n.entityId}`;
          const existing = grouped.get(key) || [];
          existing.push(n);
          grouped.set(key, existing);
        } else {
          nonAggregated.push(n);
        }
      }
      const aggregatedNotifications = [];
      for (const [, group] of grouped) {
        const latest = group[0];
        const otherActors = group.slice(1).map((n) => n.actor ? { ...n.actor, password: void 0 } : null).filter(Boolean);
        aggregatedNotifications.push({
          ...latest,
          actor: latest.actor ? { ...latest.actor, password: void 0 } : null,
          othersCount: group.length - 1,
          otherActors: otherActors.slice(0, 3),
          groupedIds: group.map((n) => n.id)
        });
      }
      const safeNonAggregated = nonAggregated.map((n) => ({
        ...n,
        actor: n.actor ? { ...n.actor, password: void 0 } : null,
        othersCount: 0,
        otherActors: [],
        groupedIds: [n.id]
      }));
      const allNotifications = [...aggregatedNotifications, ...safeNonAggregated].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
      res.json(allNotifications);
    } catch (error) {
      res.status(500).json({ message: "Failed to get notifications" });
    }
  });
  app2.get("/api/notifications/unread-count", requireAuth4, async (req, res) => {
    try {
      const hiddenUserIds = await storage.getHiddenUserIds(req.session.userId);
      const notifications2 = await storage.getUserNotifications(req.session.userId);
      const filteredNotifications = notifications2.filter((n) => !n.readAt && (!n.actorId || !hiddenUserIds.includes(n.actorId)));
      res.json({ count: filteredNotifications.length });
    } catch (error) {
      res.status(500).json({ message: "Failed to get unread count" });
    }
  });
  app2.post("/api/notifications/:id/read", requireAuth4, async (req, res) => {
    try {
      const notification = await storage.markNotificationRead(req.params.id, req.session.userId);
      if (!notification) {
        return res.status(404).json({ message: "Notification not found" });
      }
      res.json(notification);
    } catch (error) {
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });
  app2.post("/api/notifications/read-all", requireAuth4, async (req, res) => {
    try {
      await storage.markAllNotificationsRead(req.session.userId);
      res.json({ message: "All notifications marked as read" });
    } catch (error) {
      res.status(500).json({ message: "Failed to mark all notifications as read" });
    }
  });
  app2.post("/api/push-tokens", requireAuth4, async (req, res) => {
    try {
      const { token, platform, deviceId, deviceName } = req.body;
      if (!token || typeof token !== "string") {
        return res.status(400).json({ message: "Push token is required" });
      }
      if (!token.startsWith("ExponentPushToken[") && !token.startsWith("ExpoPushToken[")) {
        return res.status(400).json({ message: "Invalid push token format" });
      }
      const registered = await pushNotificationService.registerToken(
        req.session.userId,
        token,
        platform,
        deviceId,
        deviceName
      );
      res.status(201).json({ message: "Push token registered", token: registered });
    } catch (error) {
      console.error("[Push] Token registration error:", error);
      res.status(500).json({ message: "Failed to register push token" });
    }
  });
  app2.delete("/api/push-tokens", requireAuth4, async (req, res) => {
    try {
      const { token } = req.body;
      if (token) {
        await pushNotificationService.unregisterToken(token);
      } else {
        await pushNotificationService.unregisterAllUserTokens(req.session.userId);
      }
      res.json({ message: "Push token unregistered" });
    } catch (error) {
      res.status(500).json({ message: "Failed to unregister push token" });
    }
  });
  app2.get("/api/push-tokens", requireAuth4, async (req, res) => {
    try {
      const tokens = await pushNotificationService.getUserTokens(req.session.userId);
      res.json(tokens.map((t) => ({
        id: t.id,
        platform: t.platform,
        deviceName: t.deviceName,
        isActive: t.isActive,
        lastUsedAt: t.lastUsedAt,
        createdAt: t.createdAt
      })));
    } catch (error) {
      res.status(500).json({ message: "Failed to get push tokens" });
    }
  });
  app2.get("/api/posts/trending/preview", async (req, res) => {
    try {
      const trendingPosts = await storage.getTrendingPreviewPosts(5);
      const publicPosts = trendingPosts.map((post) => ({
        id: post.id,
        content: post.content?.substring(0, 200) || "",
        mediaUrl: post.mediaUrl || null,
        type: post.type || "TEXT",
        author: {
          displayName: post.author?.displayName || "Anonymous",
          username: post.author?.username || "user",
          avatarUrl: post.author?.avatarUrl || null,
          isVerified: post.author?.isVerified || false,
          netWorth: post.author?.netWorth || 0,
          netWorthTier: post.author?.netWorthTier || "BUILDING"
        },
        likesCount: post.likesCount || 0,
        commentsCount: post.commentsCount || 0
      }));
      res.json(publicPosts);
    } catch (error) {
      console.error("Error fetching trending preview:", error);
      res.json([]);
    }
  });
  app2.get("/api/posts", requireAuth4, async (req, res) => {
    try {
      const viewer = await getViewerContext(req.session.userId);
      const posts3 = await storage.getPosts();
      const visiblePosts = await filterPostsForViewer(viewer, posts3);
      const postsWithFlags = await Promise.all(
        visiblePosts.map(async (post) => ({
          ...post,
          author: { ...post.author, password: void 0 },
          hasLiked: await storage.hasUserLikedPost(post.id, req.session.userId),
          hasSaved: await storage.hasUserSavedPost(post.id, req.session.userId)
        }))
      );
      res.json(postsWithFlags);
    } catch (error) {
      res.status(500).json({ message: "Failed to get posts" });
    }
  });
  app2.get("/api/posts/feed", requireAuth4, async (req, res) => {
    try {
      const viewer = await getViewerContext(req.session.userId);
      const cursor = req.query.cursor;
      const limit = Math.min(parseInt(req.query.limit) || 20, 50);
      const includeAds = req.query.includeAds !== "false";
      const { posts: posts3, nextCursor } = await storage.getFeedPosts(req.session.userId, limit, cursor);
      const visiblePosts = await filterPostsForViewer(viewer, posts3, { forFeed: true });
      const postsWithFlags = await Promise.all(
        visiblePosts.map(async (post) => ({
          ...post,
          author: { ...post.author, password: void 0 },
          hasLiked: await storage.hasUserLikedPost(post.id, req.session.userId),
          hasSaved: await storage.hasUserSavedPost(post.id, req.session.userId),
          isAd: false
        }))
      );
      let feedWithAds = postsWithFlags;
      if (includeAds && !cursor) {
        try {
          const feedAds = await adsEngine.getAdsForFeed(req.session.userId, limit, 5);
          if (feedAds.length > 0) {
            feedWithAds = [...postsWithFlags];
            for (const adResult of feedAds) {
              const adPost = {
                id: `ad_${adResult.adId}`,
                isAd: true,
                adId: adResult.adId,
                adGroupId: adResult.adGroupId,
                campaignId: adResult.campaignId,
                advertiserId: adResult.advertiserId,
                format: adResult.format,
                headline: adResult.creative.headline,
                description: adResult.creative.description,
                mediaUrl: adResult.creative.mediaUrl,
                thumbnailUrl: adResult.creative.thumbnailUrl,
                callToAction: adResult.creative.callToAction,
                destinationUrl: adResult.creative.destinationUrl,
                type: adResult.format === "VIDEO" ? "VIDEO" : "PHOTO",
                position: adResult.position
              };
              const insertPosition = Math.min(adResult.position, feedWithAds.length);
              feedWithAds.splice(insertPosition, 0, adPost);
              await adsEngine.recordImpression(adResult, req.session.userId, "feed");
            }
          }
        } catch (adError) {
          console.error("Error fetching ads for feed:", adError);
        }
      }
      res.json({ posts: feedWithAds, nextCursor });
    } catch (error) {
      res.status(500).json({ message: "Failed to get feed" });
    }
  });
  app2.get("/api/posts/videos", requireAuth4, async (req, res) => {
    try {
      const viewer = await getViewerContext(req.session.userId);
      const { posts: allPosts } = await storage.getFeedPosts(req.session.userId, 100);
      const videoPosts = allPosts.filter((post) => post.type === "VIDEO");
      const visiblePosts = await filterPostsForViewer(viewer, videoPosts, { forFeed: true });
      const postsWithFlags = await Promise.all(
        visiblePosts.map(async (post) => ({
          ...post,
          user: {
            id: post.author.id,
            username: post.author.username,
            displayName: post.author.displayName,
            avatarUrl: post.author.avatarUrl,
            isVerified: post.author.isVerified
          },
          author: void 0,
          hasLiked: await storage.hasUserLikedPost(post.id, req.session.userId),
          hasBookmarked: await storage.hasUserSavedPost(post.id, req.session.userId)
        }))
      );
      res.json(postsWithFlags);
    } catch (error) {
      res.status(500).json({ message: "Failed to get video posts" });
    }
  });
  app2.get("/api/posts/elite-feed", requireAuth4, async (req, res) => {
    try {
      const limit = Math.min(parseInt(req.query.limit) || 20, 50);
      const offset = parseInt(req.query.offset) || 0;
      const mode = req.query.mode || "discover";
      let result;
      if (mode === "following") {
        result = await feedAlgorithm.getFollowingFeed(req.session.userId, { limit, offset });
      } else if (mode === "elite") {
        result = await feedAlgorithm.getEliteFeed(req.session.userId, { limit, offset });
      } else {
        result = await feedAlgorithm.getDiscoverFeed(req.session.userId, { limit, offset });
      }
      const postsWithFlags = await Promise.all(
        result.posts.map(async (post) => ({
          ...post,
          author: { ...post.author, password: void 0 },
          hasLiked: await storage.hasUserLikedPost(post.id, req.session.userId),
          hasSaved: await storage.hasUserSavedPost(post.id, req.session.userId),
          algorithmScore: post.score
        }))
      );
      res.json({
        posts: postsWithFlags,
        hasMore: result.hasMore,
        offset: offset + postsWithFlags.length
      });
    } catch (error) {
      console.error("Elite feed error:", error);
      res.status(500).json({ message: "Failed to get elite feed" });
    }
  });
  app2.get("/api/posts/search", requireAuth4, async (req, res) => {
    try {
      const viewer = await getViewerContext(req.session.userId);
      const query = req.query.q || "";
      const posts3 = await storage.searchPosts(query);
      const visiblePosts = await filterPostsForViewer(viewer, posts3);
      const postsWithFlags = await Promise.all(
        visiblePosts.map(async (post) => ({
          ...post,
          author: { ...post.author, password: void 0 },
          hasLiked: await storage.hasUserLikedPost(post.id, req.session.userId),
          hasSaved: await storage.hasUserSavedPost(post.id, req.session.userId)
        }))
      );
      res.json(postsWithFlags);
    } catch (error) {
      res.status(500).json({ message: "Search failed" });
    }
  });
  app2.post("/api/posts", requireAuth4, postLimiter, validateBody(createPostSchema2), async (req, res) => {
    try {
      const { type, content, caption, mediaUrl, thumbnailUrl, durationMs, aspectRatio, visibility, commentsEnabled } = req.body;
      if (content) {
        const maxPostLength = await storage.getAppSettingValue("maxPostLength", 500);
        if (content.length > maxPostLength) {
          return res.status(400).json({ message: `Post content exceeds maximum length of ${maxPostLength} characters` });
        }
      }
      const post = await storage.createPost({
        authorId: req.session.userId,
        type: type || "TEXT",
        content,
        caption,
        mediaUrl,
        thumbnailUrl,
        durationMs,
        aspectRatio,
        visibility: visibility || "PUBLIC",
        commentsEnabled: commentsEnabled ?? true
      });
      const textToCheck = [content, caption].filter(Boolean).join(" ");
      await notifyMentionedUsers(textToCheck, req.session.userId, post.id);
      const postWithAuthor = await storage.getPost(post.id);
      res.status(201).json({
        ...postWithAuthor,
        author: { ...postWithAuthor.author, password: void 0 },
        hasLiked: false,
        hasSaved: false
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to create post" });
    }
  });
  app2.get("/api/posts/:id", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const postAccess = await canViewPost(viewer, post, post.author);
      if (!postAccess.allowed) {
        return res.status(403).json({ message: postAccess.reason });
      }
      res.json({
        ...post,
        author: { ...post.author, password: void 0 },
        hasLiked: await storage.hasUserLikedPost(post.id, req.session.userId),
        hasSaved: await storage.hasUserSavedPost(post.id, req.session.userId)
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get post" });
    }
  });
  app2.delete("/api/posts/:id", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (post.authorId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.deletePost(req.params.id);
      res.json({ message: "Post deleted" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete post" });
    }
  });
  app2.post("/api/posts/:id/like", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const likeAccess = await canLike(viewer, post);
      if (!likeAccess.allowed) {
        return res.status(403).json({ message: likeAccess.reason });
      }
      await storage.likePost(req.params.id, req.session.userId);
      if (post && post.authorId !== req.session.userId) {
        const notification = await storage.createNotification(
          post.authorId,
          req.session.userId,
          "LIKE",
          req.params.id
        );
        if (notification.id) {
          const actor = await storage.getUser(req.session.userId);
          broadcastToUser(post.authorId, {
            type: "notification:new",
            payload: { ...notification, actor: actor ? { ...actor, password: void 0 } : null }
          });
          if (actor) {
            pushNotificationService.notifyLike(
              post.authorId,
              actor.username,
              actor.displayName,
              req.params.id
            ).catch((err) => console.error("[Push] Like notification error:", err));
          }
        }
      }
      res.json({ message: "Liked" });
    } catch (error) {
      res.status(500).json({ message: "Failed to like post" });
    }
  });
  app2.delete("/api/posts/:id/like", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const likeAccess = await canLike(viewer, post);
      if (!likeAccess.allowed) {
        return res.status(403).json({ message: likeAccess.reason });
      }
      await storage.unlikePost(req.params.id, req.session.userId);
      res.json({ message: "Unliked" });
    } catch (error) {
      res.status(500).json({ message: "Failed to unlike post" });
    }
  });
  app2.post("/api/posts/:id/save", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const postAccess = await canViewPost(viewer, post, post.author);
      if (!postAccess.allowed) {
        return res.status(403).json({ message: postAccess.reason });
      }
      const isSaved = await storage.hasUserSavedPost(req.params.id, req.session.userId);
      if (isSaved) {
        await storage.unsavePost(req.session.userId, req.params.id);
        res.json({ message: "Post unsaved", saved: false });
      } else {
        await storage.savePost(req.session.userId, req.params.id);
        res.json({ message: "Post saved", saved: true });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to toggle save" });
    }
  });
  app2.delete("/api/posts/:id/save", requireAuth4, async (req, res) => {
    try {
      await storage.unsavePost(req.session.userId, req.params.id);
      res.json({ message: "Post unsaved", saved: false });
    } catch (error) {
      res.status(500).json({ message: "Failed to unsave post" });
    }
  });
  app2.post("/api/posts/:id/share", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const postAccess = await canViewPost(viewer, post, post.author);
      if (!postAccess.allowed) {
        return res.status(403).json({ message: postAccess.reason });
      }
      const { platform } = req.body;
      const share = await storage.sharePost(req.session.userId, req.params.id, platform);
      res.json({ message: "Share recorded", shareId: share.id });
    } catch (error) {
      res.status(500).json({ message: "Failed to record share" });
    }
  });
  app2.post("/api/posts/:id/view", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const postAccess = await canViewPost(viewer, post, post.author);
      if (!postAccess.allowed) {
        return res.status(403).json({ message: postAccess.reason });
      }
      const result = await storage.viewPost(req.session.userId, req.params.id);
      res.json({ message: result.isNew ? "View recorded" : "Already viewed", isNew: result.isNew });
    } catch (error) {
      res.status(500).json({ message: "Failed to record view" });
    }
  });
  app2.get("/api/bookmarks", requireAuth4, async (req, res) => {
    try {
      const savedPosts2 = await storage.getUserBookmarks(req.session.userId);
      const hiddenUserIds = await storage.getHiddenUserIds(req.session.userId);
      const visiblePosts = savedPosts2.filter((p) => !hiddenUserIds.includes(p.authorId) && !p.isHidden);
      const postsWithFlags = await Promise.all(
        visiblePosts.map(async (post) => ({
          ...post,
          author: { ...post.author, password: void 0 },
          hasLiked: await storage.hasUserLikedPost(post.id, req.session.userId),
          hasSaved: true
        }))
      );
      res.json(postsWithFlags);
    } catch (error) {
      res.status(500).json({ message: "Failed to get bookmarks" });
    }
  });
  app2.get("/api/posts/saved", requireAuth4, async (req, res) => {
    try {
      const savedPostsList = await storage.getUserBookmarks(req.session.userId);
      const hiddenUserIds = await storage.getHiddenUserIds(req.session.userId);
      const visiblePosts = savedPostsList.filter((p) => !hiddenUserIds.includes(p.authorId) && !p.isHidden);
      const postsWithFlags = await Promise.all(
        visiblePosts.map(async (post) => ({
          ...post,
          author: { ...post.author, password: void 0 },
          hasLiked: await storage.hasUserLikedPost(post.id, req.session.userId),
          hasSaved: true
        }))
      );
      res.json(postsWithFlags);
    } catch (error) {
      res.status(500).json({ message: "Failed to get saved posts" });
    }
  });
  app2.post("/api/posts/:id/hide", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      const { reason } = req.body;
      await storage.hidePostFromFeed(req.session.userId, req.params.id, reason);
      res.json({ message: "Post hidden from feed", hidden: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to hide post" });
    }
  });
  app2.delete("/api/posts/:id/hide", requireAuth4, async (req, res) => {
    try {
      await storage.unhidePostFromFeed(req.session.userId, req.params.id);
      res.json({ message: "Post unhidden from feed", hidden: false });
    } catch (error) {
      res.status(500).json({ message: "Failed to unhide post" });
    }
  });
  app2.post("/api/posts/:id/not-interested", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      const { reason } = req.body;
      await storage.markNotInterested(req.session.userId, req.params.id, reason);
      res.json({ message: "Marked as not interested", notInterested: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to mark as not interested" });
    }
  });
  app2.post("/api/posts/:id/archive", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (post.authorId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      if (post.isArchived) {
        const updatedPost = await storage.unarchivePost(req.params.id, req.session.userId);
        res.json({ message: "Post unarchived", isArchived: false, post: updatedPost });
      } else {
        const updatedPost = await storage.archivePost(req.params.id, req.session.userId);
        res.json({ message: "Post archived", isArchived: true, post: updatedPost });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to toggle archive" });
    }
  });
  app2.post("/api/posts/:id/pin", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (post.authorId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      if (post.isPinned) {
        const updatedPost = await storage.unpinPost(req.params.id, req.session.userId);
        res.json({ message: "Post unpinned", isPinned: false, post: updatedPost });
      } else {
        const updatedPost = await storage.pinPost(req.params.id, req.session.userId);
        res.json({ message: "Post pinned", isPinned: true, post: updatedPost });
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to toggle pin" });
    }
  });
  app2.patch("/api/posts/:id", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (post.authorId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const { content, caption } = req.body;
      if (content === void 0 && caption === void 0) {
        return res.status(400).json({ message: "Nothing to update" });
      }
      const updates = {};
      if (content !== void 0) updates.content = content;
      if (caption !== void 0) updates.caption = caption;
      const updatedPost = await storage.editPost(req.params.id, req.session.userId, updates);
      if (!updatedPost) {
        return res.status(404).json({ message: "Failed to update post" });
      }
      const postWithAuthor = await storage.getPost(updatedPost.id);
      res.json({
        ...postWithAuthor,
        author: { ...postWithAuthor.author, password: void 0 }
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to edit post" });
    }
  });
  app2.patch("/api/posts/:id/comments", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (post.authorId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const { enabled } = req.body;
      if (typeof enabled !== "boolean") {
        return res.status(400).json({ message: "enabled must be a boolean" });
      }
      const updatedPost = await storage.toggleComments(req.params.id, req.session.userId, enabled);
      res.json({
        message: enabled ? "Comments enabled" : "Comments disabled",
        commentsEnabled: enabled,
        post: updatedPost
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to toggle comments" });
    }
  });
  app2.get("/api/posts/:id/comments", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const postAccess = await canViewPost(viewer, post, post.author);
      if (!postAccess.allowed) {
        return res.status(403).json({ message: postAccess.reason });
      }
      const hiddenUserIds = await storage.getHiddenUserIds(req.session.userId);
      const keywordFilters2 = await storage.getKeywordFilters(req.session.userId);
      const commentKeywords = keywordFilters2.filter((f) => f.filterComments !== false).map((f) => f.keyword.toLowerCase());
      const comments3 = await storage.getPostComments(req.params.id);
      const filteredComments = comments3.filter((c) => {
        if (hiddenUserIds.includes(c.authorId) || c.isHidden) return false;
        if (commentKeywords.length > 0) {
          const contentText = (c.content || "").toLowerCase();
          if (commentKeywords.some((kw) => contentText.includes(kw))) return false;
        }
        return true;
      });
      const safeComments = filteredComments.map((c) => ({
        ...c,
        author: { ...c.author, password: void 0 }
      }));
      res.json(safeComments);
    } catch (error) {
      res.status(500).json({ message: "Failed to get comments" });
    }
  });
  app2.post("/api/posts/:id/comments", requireAuth4, commentLimiter, validateBody(createCommentSchema), async (req, res) => {
    try {
      const { content } = req.body;
      const post = await storage.getPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const commentAccess = await canComment(viewer, post);
      if (!commentAccess.allowed) {
        return res.status(403).json({ message: commentAccess.reason });
      }
      const comment = await storage.createComment(req.params.id, req.session.userId, content);
      const user = await storage.getUser(req.session.userId);
      if (post && post.authorId !== req.session.userId) {
        const notification = await storage.createNotification(
          post.authorId,
          req.session.userId,
          "COMMENT",
          req.params.id
        );
        if (notification.id) {
          broadcastToUser(post.authorId, {
            type: "notification:new",
            payload: { ...notification, actor: user ? { ...user, password: void 0 } : null }
          });
          if (user) {
            pushNotificationService.notifyComment(
              post.authorId,
              user.username,
              user.displayName,
              req.params.id,
              content
            ).catch((err) => console.error("[Push] Comment notification error:", err));
          }
        }
      }
      await notifyMentionedUsers(content, req.session.userId, req.params.id, post?.authorId);
      res.status(201).json({
        ...comment,
        author: { ...user, password: void 0 }
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to create comment" });
    }
  });
  app2.get("/api/users/:id/posts", requireAuth4, async (req, res) => {
    try {
      const targetUser = await storage.getUser(req.params.id);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const profileAccess = await canViewProfile(viewer, targetUser);
      if (!profileAccess.allowed) {
        return res.json([]);
      }
      const posts3 = await storage.getUserPosts(req.params.id);
      const visiblePosts = await filterPostsForViewer(viewer, posts3);
      const postsWithLikes = await Promise.all(
        visiblePosts.map(async (post) => ({
          ...post,
          author: { ...post.author, password: void 0 },
          hasLiked: await storage.hasUserLikedPost(post.id, req.session.userId)
        }))
      );
      res.json(postsWithLikes);
    } catch (error) {
      res.status(500).json({ message: "Failed to get user posts" });
    }
  });
  app2.get("/api/users/:username/profile", async (req, res) => {
    try {
      const targetUser = await storage.getUserByUsername(req.params.username);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const viewer = await getViewerContext(req.session?.userId);
      const profileAccess = await canViewProfile(viewer, targetUser);
      const [followersCount, followingCount, postsCount, totalLikes, settings] = await Promise.all([
        storage.getFollowersCount(targetUser.id),
        storage.getFollowingCount(targetUser.id),
        storage.getUserPostsCount(targetUser.id),
        storage.getUserTotalLikes(targetUser.id),
        storage.getUserSettings(targetUser.id)
      ]);
      let relationship = {
        isFollowing: false,
        isBlocked: false,
        canMessage: false
      };
      if (viewer.userId && viewer.userId !== targetUser.id) {
        const [isFollowing, isBlocked, messageAccess] = await Promise.all([
          storage.isFollowing(viewer.userId, targetUser.id),
          storage.isBlocked(viewer.userId, targetUser.id),
          canMessage(viewer, targetUser, settings ?? void 0)
        ]);
        relationship = {
          isFollowing,
          isBlocked,
          canMessage: messageAccess.allowed
        };
      } else if (viewer.userId === targetUser.id) {
        relationship.canMessage = true;
      }
      const isPrivate = settings?.privateAccount ?? false;
      const viewerCanSeeContent = profileAccess.allowed;
      const profileData = {
        id: targetUser.id,
        username: targetUser.username,
        displayName: targetUser.displayName,
        bio: viewerCanSeeContent ? targetUser.bio : null,
        avatarUrl: targetUser.avatarUrl,
        coverUrl: targetUser.coverUrl,
        category: viewerCanSeeContent ? targetUser.category : null,
        location: viewerCanSeeContent ? targetUser.location : null,
        linkUrl: viewerCanSeeContent ? targetUser.linkUrl : null,
        netWorth: viewerCanSeeContent ? targetUser.netWorth : null,
        influenceScore: viewerCanSeeContent ? targetUser.influenceScore : null,
        verified: targetUser.isAdmin,
        createdAt: targetUser.createdAt,
        counts: {
          posts: viewerCanSeeContent ? postsCount : 0,
          followers: followersCount,
          following: followingCount,
          totalLikes: viewerCanSeeContent ? totalLikes : 0
        },
        relationship,
        privacy: {
          isPrivate,
          viewerCanSeeContent
        },
        contentRestricted: !viewerCanSeeContent
      };
      res.json(profileData);
    } catch (error) {
      console.error("Profile fetch error:", error);
      res.status(500).json({ message: "Failed to get profile" });
    }
  });
  app2.get("/api/users/:username/featured", async (req, res) => {
    try {
      const targetUser = await storage.getUserByUsername(req.params.username);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const viewer = await getViewerContext(req.session?.userId);
      const profileAccess = await canViewProfile(viewer, targetUser);
      if (!profileAccess.allowed) {
        return res.status(403).json({
          message: profileAccess.reason || "Cannot view this profile",
          restricted: profileAccess.restricted
        });
      }
      const [pinnedPosts, playlistsSummary, featuredIntro] = await Promise.all([
        storage.getUserPinnedPosts(targetUser.id),
        storage.getUserPlaylistsSummary(targetUser.id),
        storage.getUserFeaturedIntro(targetUser.id)
      ]);
      const visiblePinnedPosts = await filterPostsForViewer(viewer, pinnedPosts);
      const publicPlaylists = playlistsSummary.filter((p) => p.isPublic);
      const pinnedWithInteractions = await Promise.all(
        visiblePinnedPosts.slice(0, 3).map(async (post) => ({
          id: post.id,
          type: post.type,
          thumbnailUrl: post.thumbnailUrl || post.mediaUrl,
          mediaUrl: post.mediaUrl,
          durationMs: post.durationMs,
          caption: post.caption,
          content: post.content,
          likesCount: post.likesCount,
          viewsCount: post.viewsCount,
          commentsCount: post.commentsCount,
          hasLiked: viewer.userId ? await storage.hasUserLikedPost(post.id, viewer.userId) : false,
          hasSaved: viewer.userId ? await storage.hasUserSavedPost(post.id, viewer.userId) : false,
          author: { ...post.author, password: void 0 }
        }))
      );
      res.json({
        pinnedPosts: pinnedWithInteractions,
        playlists: publicPlaylists,
        featuredIntro: featuredIntro || null
      });
    } catch (error) {
      console.error("Featured fetch error:", error);
      res.status(500).json({ message: "Failed to get featured content" });
    }
  });
  app2.get("/api/users/:username/posts", async (req, res) => {
    try {
      const targetUser = await storage.getUserByUsername(req.params.username);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const viewer = await getViewerContext(req.session?.userId);
      const profileAccess = await canViewProfile(viewer, targetUser);
      if (!profileAccess.allowed) {
        return res.status(403).json({
          message: profileAccess.reason || "Cannot view this profile",
          restricted: profileAccess.restricted
        });
      }
      const tab = req.query.tab?.toUpperCase() || "ALL";
      const cursor = req.query.cursor;
      const limit = Math.min(parseInt(req.query.limit) || 24, 50);
      let typeFilter = null;
      if (["TEXT", "PHOTO", "VIDEO", "VOICE"].includes(tab)) {
        typeFilter = tab;
      }
      if (tab === "PINNED") {
        const pinnedPosts = await storage.getUserPinnedPosts(targetUser.id);
        const visiblePinned = await filterPostsForViewer(viewer, pinnedPosts);
        const tiles2 = await Promise.all(
          visiblePinned.map(async (post) => ({
            id: post.id,
            type: post.type,
            thumbnailUrl: post.thumbnailUrl || post.mediaUrl,
            durationMs: post.durationMs,
            likesCount: post.likesCount,
            viewsCount: post.viewsCount,
            commentsCount: post.commentsCount,
            isPinned: true
          }))
        );
        return res.json({ posts: tiles2, nextCursor: null });
      }
      const { posts: posts3, nextCursor } = await storage.getUserPostsByType(
        targetUser.id,
        typeFilter,
        limit,
        cursor
      );
      const visiblePosts = await filterPostsForViewer(viewer, posts3);
      const tiles = visiblePosts.map((post) => ({
        id: post.id,
        type: post.type,
        thumbnailUrl: post.thumbnailUrl || post.mediaUrl,
        durationMs: post.durationMs,
        likesCount: post.likesCount,
        viewsCount: post.viewsCount,
        commentsCount: post.commentsCount
      }));
      res.json({ posts: tiles, nextCursor });
    } catch (error) {
      console.error("User posts fetch error:", error);
      res.status(500).json({ message: "Failed to get posts" });
    }
  });
  app2.get("/api/users/:username/swipe", async (req, res) => {
    try {
      const targetUser = await storage.getUserByUsername(req.params.username);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const viewer = await getViewerContext(req.session?.userId);
      const profileAccess = await canViewProfile(viewer, targetUser);
      if (!profileAccess.allowed) {
        return res.status(403).json({
          message: profileAccess.reason || "Cannot view this profile",
          restricted: profileAccess.restricted
        });
      }
      const cursor = req.query.cursor;
      const limit = Math.min(parseInt(req.query.limit) || 10, 20);
      const { posts: posts3, nextCursor } = await storage.getUserPostsByType(
        targetUser.id,
        null,
        limit,
        cursor
      );
      const visiblePosts = await filterPostsForViewer(viewer, posts3);
      const swipePosts = await Promise.all(
        visiblePosts.map(async (post) => ({
          id: post.id,
          type: post.type,
          content: post.content,
          caption: post.caption,
          mediaUrl: post.mediaUrl,
          thumbnailUrl: post.thumbnailUrl,
          durationMs: post.durationMs,
          aspectRatio: post.aspectRatio,
          likesCount: post.likesCount,
          commentsCount: post.commentsCount,
          sharesCount: post.sharesCount,
          viewsCount: post.viewsCount,
          createdAt: post.createdAt,
          hasLiked: viewer.userId ? await storage.hasUserLikedPost(post.id, viewer.userId) : false,
          hasSaved: viewer.userId ? await storage.hasUserSavedPost(post.id, viewer.userId) : false,
          author: {
            id: post.author.id,
            username: post.author.username,
            displayName: post.author.displayName,
            avatarUrl: post.author.avatarUrl,
            verified: post.author.isAdmin
          }
        }))
      );
      res.json({ posts: swipePosts, nextCursor });
    } catch (error) {
      console.error("Swipe posts fetch error:", error);
      res.status(500).json({ message: "Failed to get swipe posts" });
    }
  });
  app2.post("/api/me/pins", requireAuth4, async (req, res) => {
    try {
      const { postIds } = req.body;
      if (!Array.isArray(postIds)) {
        return res.status(400).json({ message: "postIds must be an array" });
      }
      if (postIds.length > 3) {
        return res.status(400).json({ message: "Maximum 3 pinned posts allowed" });
      }
      for (const postId of postIds) {
        const post = await storage.getPost(postId);
        if (!post) {
          return res.status(404).json({ message: `Post not found: ${postId}` });
        }
        if (post.authorId !== req.session.userId) {
          return res.status(403).json({ message: "Can only pin your own posts" });
        }
      }
      const pins2 = await storage.setUserPins(req.session.userId, postIds);
      res.json({ pins: pins2, message: "Pins updated successfully" });
    } catch (error) {
      console.error("Set pins error:", error);
      res.status(500).json({ message: "Failed to update pins" });
    }
  });
  app2.get("/api/me/pins", requireAuth4, async (req, res) => {
    try {
      const pins2 = await storage.getUserPins(req.session.userId);
      const posts3 = pins2.map((p) => ({
        ...p.post,
        author: { ...p.post.author, password: void 0 }
      }));
      res.json(posts3);
    } catch (error) {
      res.status(500).json({ message: "Failed to get pins" });
    }
  });
  app2.get("/api/users/:id/pins", requireAuth4, async (req, res) => {
    try {
      const { id } = req.params;
      const pins2 = await storage.getUserPins(id);
      const posts3 = pins2.map((p) => ({
        ...p.post,
        author: { ...p.post.author, password: void 0 }
      }));
      res.json(posts3);
    } catch (error) {
      res.status(500).json({ message: "Failed to get user pins" });
    }
  });
  app2.post("/api/me/playlists", requireAuth4, async (req, res) => {
    try {
      const { title, type, description } = req.body;
      if (!title || typeof title !== "string" || title.length > 100) {
        return res.status(400).json({ message: "Title is required (max 100 characters)" });
      }
      if (!type || !["VIDEO", "VOICE"].includes(type)) {
        return res.status(400).json({ message: "Type must be VIDEO or VOICE" });
      }
      const playlist = await storage.createPlaylist(
        req.session.userId,
        title.trim(),
        type,
        description?.trim()
      );
      res.status(201).json(playlist);
    } catch (error) {
      console.error("Create playlist error:", error);
      res.status(500).json({ message: "Failed to create playlist" });
    }
  });
  app2.get("/api/me/playlists", requireAuth4, async (req, res) => {
    try {
      const playlistsSummary = await storage.getUserPlaylistsSummary(req.session.userId);
      res.json(playlistsSummary);
    } catch (error) {
      res.status(500).json({ message: "Failed to get playlists" });
    }
  });
  app2.get("/api/playlists/:id", async (req, res) => {
    try {
      const playlist = await storage.getPlaylistWithItems(req.params.id);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      const viewer = await getViewerContext(req.session?.userId);
      const owner = await storage.getUser(playlist.userId);
      if (!owner) {
        return res.status(404).json({ message: "Playlist owner not found" });
      }
      if (!playlist.isPublic && viewer.userId !== playlist.userId) {
        if (!viewer.isAdmin || !hasPermission(viewer, "users.read")) {
          return res.status(403).json({ message: "This playlist is private" });
        }
      }
      const visibleItems = [];
      for (const item of playlist.items) {
        const canView = await canViewPost(viewer, item.post, owner);
        if (canView.allowed) {
          visibleItems.push({
            ...item,
            post: { ...item.post, author: { ...item.post.author, password: void 0 } }
          });
        }
      }
      res.json({
        ...playlist,
        items: visibleItems
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get playlist" });
    }
  });
  app2.patch("/api/playlists/:id", requireAuth4, async (req, res) => {
    try {
      const playlist = await storage.getPlaylist(req.params.id);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      if (playlist.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized to edit this playlist" });
      }
      const { title, description, isPublic } = req.body;
      const updates = {};
      if (title !== void 0) {
        if (typeof title !== "string" || title.length > 100) {
          return res.status(400).json({ message: "Title must be a string (max 100 characters)" });
        }
        updates.title = title.trim();
      }
      if (description !== void 0) {
        updates.description = description?.trim() || null;
      }
      if (isPublic !== void 0) {
        updates.isPublic = Boolean(isPublic);
      }
      const updated = await storage.updatePlaylist(req.params.id, updates);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update playlist" });
    }
  });
  app2.delete("/api/playlists/:id", requireAuth4, async (req, res) => {
    try {
      const playlist = await storage.getPlaylist(req.params.id);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      if (playlist.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized to delete this playlist" });
      }
      await storage.deletePlaylist(req.params.id);
      res.json({ message: "Playlist deleted" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete playlist" });
    }
  });
  app2.post("/api/playlists/:id/items", requireAuth4, async (req, res) => {
    try {
      const playlist = await storage.getPlaylist(req.params.id);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      if (playlist.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized to modify this playlist" });
      }
      const { postId } = req.body;
      if (!postId) {
        return res.status(400).json({ message: "postId is required" });
      }
      const post = await storage.getPost(postId);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (post.authorId !== req.session.userId) {
        return res.status(403).json({ message: "Can only add your own posts to playlists" });
      }
      const postType = post.type;
      const playlistType = playlist.type;
      if (playlistType === "VIDEO" && postType !== "VIDEO" || playlistType === "VOICE" && postType !== "VOICE") {
        return res.status(400).json({
          message: `This playlist only accepts ${playlistType.toLowerCase()} posts`
        });
      }
      const item = await storage.addPlaylistItem(req.params.id, postId);
      res.status(201).json(item);
    } catch (error) {
      res.status(500).json({ message: "Failed to add item to playlist" });
    }
  });
  app2.delete("/api/playlists/:id/items/:postId", requireAuth4, async (req, res) => {
    try {
      const playlist = await storage.getPlaylist(req.params.id);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      if (playlist.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized to modify this playlist" });
      }
      await storage.removePlaylistItem(req.params.id, req.params.postId);
      res.json({ message: "Item removed from playlist" });
    } catch (error) {
      res.status(500).json({ message: "Failed to remove item from playlist" });
    }
  });
  app2.get("/api/me/featured-intro", requireAuth4, async (req, res) => {
    try {
      const intro = await storage.getUserFeaturedIntro(req.session.userId);
      res.json(intro || null);
    } catch (error) {
      res.status(500).json({ message: "Failed to get featured intro" });
    }
  });
  app2.patch("/api/me/featured-intro", requireAuth4, async (req, res) => {
    try {
      const { title, body, ctaText, ctaUrl } = req.body;
      if (!title || typeof title !== "string" || title.length > 100) {
        return res.status(400).json({ message: "Title is required (max 100 characters)" });
      }
      if (!body || typeof body !== "string") {
        return res.status(400).json({ message: "Body is required" });
      }
      if (ctaText && ctaText.length > 50) {
        return res.status(400).json({ message: "CTA text must be max 50 characters" });
      }
      if (ctaUrl && !/^https?:\/\/.+/.test(ctaUrl)) {
        return res.status(400).json({ message: "CTA URL must be a valid URL" });
      }
      const intro = await storage.updateFeaturedIntro(req.session.userId, {
        title: title.trim(),
        body: body.trim(),
        ctaText: ctaText?.trim(),
        ctaUrl: ctaUrl?.trim()
      });
      res.json(intro);
    } catch (error) {
      console.error("Update featured intro error:", error);
      res.status(500).json({ message: "Failed to update featured intro" });
    }
  });
  app2.delete("/api/me/featured-intro", requireAuth4, async (req, res) => {
    try {
      await storage.deleteFeaturedIntro(req.session.userId);
      res.json({ message: "Featured intro deleted" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete featured intro" });
    }
  });
  app2.post("/api/stories", requireAuth4, upload.single("file"), async (req, res) => {
    try {
      console.log("[Story Create] Request body:", JSON.stringify(req.body, null, 2));
      console.log("[Story Create] User ID:", req.session.userId);
      console.log("[Story Create] File:", req.file ? "Present" : "None");
      const {
        type,
        caption,
        mediaUrl: providedMediaUrl,
        thumbnailUrl: providedThumbnailUrl,
        durationMs: providedDurationMs,
        textContent,
        backgroundColor,
        isGradient,
        gradientColors,
        fontFamily,
        textAlignment,
        textAnimation,
        textBackgroundPill,
        fontSize,
        audioUrl: providedAudioUrl,
        audioDuration,
        audioTranscript,
        musicUrl,
        musicTitle,
        musicArtist,
        musicStartTime,
        musicDuration,
        filterName,
        textOverlays,
        drawings,
        isCloseFriends,
        replySetting,
        scheduledAt,
        locationName,
        locationLat,
        locationLng,
        stickers
        // Array of stickers to add after story creation
      } = req.body;
      console.log("[Story Create] Extracted type:", type);
      console.log("[Story Create] Extracted textContent:", textContent);
      console.log("[Story Create] Extracted fontFamily:", fontFamily);
      const fontFamilyMap = {
        "POPPINS": "MODERN",
        "PLAYFAIR": "SERIF",
        "SPACE_MONO": "MODERN",
        "DANCING_SCRIPT": "HANDWRITTEN",
        "BEBAS_NEUE": "BOLD",
        // Database enum values pass through
        "MODERN": "MODERN",
        "SERIF": "SERIF",
        "HANDWRITTEN": "HANDWRITTEN",
        "BOLD": "BOLD",
        "LUXURY": "LUXURY"
      };
      const mappedFontFamily = fontFamily ? fontFamilyMap[fontFamily] || "MODERN" : void 0;
      console.log("[Story Create] Mapped fontFamily:", mappedFontFamily);
      if (!type || !["PHOTO", "VIDEO", "TEXT", "VOICE"].includes(type)) {
        console.log("[Story Create] Invalid type, returning 400");
        return res.status(400).json({ message: "Invalid story type. Must be PHOTO, VIDEO, TEXT, or VOICE" });
      }
      let mediaUrl = providedMediaUrl;
      let thumbnailUrl = providedThumbnailUrl;
      let durationMs = providedDurationMs ? parseInt(providedDurationMs) : void 0;
      let audioUrl = providedAudioUrl;
      if (req.file && (type === "PHOTO" || type === "VIDEO")) {
        const resourceType = type === "VIDEO" ? "video" : "image";
        const result = await cloudinary_default.uploader.upload(
          `data:${req.file.mimetype};base64,${req.file.buffer.toString("base64")}`,
          {
            resource_type: resourceType,
            folder: "stories"
          }
        );
        mediaUrl = result.secure_url;
        if (type === "VIDEO" && result.duration) {
          durationMs = Math.round(result.duration * 1e3);
          thumbnailUrl = cloudinary_default.url(result.public_id, {
            resource_type: "video",
            format: "jpg",
            transformation: [{ width: 400, height: 700, crop: "fill" }]
          });
        }
      }
      if (req.file && type === "VOICE") {
        const result = await cloudinary_default.uploader.upload(
          `data:${req.file.mimetype};base64,${req.file.buffer.toString("base64")}`,
          {
            resource_type: "video",
            // Cloudinary uses "video" for audio
            folder: "story-audio"
          }
        );
        audioUrl = result.secure_url;
        if (result.duration) {
          durationMs = Math.round(result.duration * 1e3);
        }
      }
      if ((type === "PHOTO" || type === "VIDEO") && !mediaUrl) {
        return res.status(400).json({ message: "Media URL or file upload required for PHOTO/VIDEO stories" });
      }
      if (type === "TEXT" && !textContent?.trim()) {
        return res.status(400).json({ message: "Text content is required for TEXT stories" });
      }
      if (type === "VOICE" && !audioUrl) {
        return res.status(400).json({ message: "Audio URL or file upload required for VOICE stories" });
      }
      const story = await storage.createStory(req.session.userId, {
        type,
        mediaUrl,
        thumbnailUrl,
        durationMs,
        caption: caption?.trim(),
        textContent: textContent?.trim(),
        backgroundColor,
        isGradient: isGradient === true || isGradient === "true",
        gradientColors: gradientColors ? typeof gradientColors === "string" ? JSON.parse(gradientColors) : gradientColors : null,
        fontFamily: mappedFontFamily,
        textAlignment,
        textAnimation,
        textBackgroundPill: textBackgroundPill === true || textBackgroundPill === "true",
        fontSize: fontSize ? parseInt(fontSize) : void 0,
        audioUrl,
        audioDuration: audioDuration ? parseInt(audioDuration) : durationMs && type === "VOICE" ? Math.round(durationMs / 1e3) : void 0,
        audioTranscript,
        musicUrl,
        musicTitle,
        musicArtist,
        musicStartTime: musicStartTime ? parseInt(musicStartTime) : void 0,
        musicDuration: musicDuration ? parseInt(musicDuration) : void 0,
        filterName,
        textOverlays: textOverlays ? typeof textOverlays === "string" ? JSON.parse(textOverlays) : textOverlays : null,
        drawings: drawings ? typeof drawings === "string" ? JSON.parse(drawings) : drawings : null,
        isCloseFriends: isCloseFriends === true || isCloseFriends === "true",
        replySetting: replySetting || "ALL",
        scheduledAt: scheduledAt ? new Date(scheduledAt) : void 0,
        locationName,
        locationLat: locationLat ? parseFloat(locationLat) : void 0,
        locationLng: locationLng ? parseFloat(locationLng) : void 0
      });
      const mentionedUserIds = [];
      if (stickers && Array.isArray(stickers)) {
        for (const sticker of stickers) {
          await storage.createStorySticker({
            storyId: story.id,
            type: sticker.type,
            positionX: sticker.positionX,
            positionY: sticker.positionY,
            scale: sticker.scale,
            rotation: sticker.rotation,
            data: sticker.data
          });
          if (sticker.type === "MENTION" && sticker.data?.userId) {
            mentionedUserIds.push(sticker.data.userId);
          }
        }
        for (const mentionedUserId of mentionedUserIds) {
          if (mentionedUserId !== req.session.userId) {
            try {
              await storage.createNotification(mentionedUserId, req.session.userId, "STORY_MENTION", story.id);
            } catch (e) {
            }
          }
        }
      }
      const storyWithUser = await storage.getStory(story.id);
      res.status(201).json(storyWithUser);
    } catch (error) {
      console.error("Create story error:", error);
      console.error("Create story error stack:", error?.stack);
      console.error("Create story error message:", error?.message);
      const errorMessage = error?.message || "Failed to create story";
      res.status(500).json({ message: errorMessage, error: error?.message });
    }
  });
  app2.get("/api/stories/me", requireAuth4, async (req, res) => {
    try {
      const userStories = await storage.getActiveUserStories(req.session.userId);
      const safeStories = userStories.map((s) => ({
        ...s,
        user: { ...s.user, password: void 0 }
      }));
      res.json(safeStories);
    } catch (error) {
      res.status(500).json({ message: "Failed to get stories" });
    }
  });
  app2.get("/api/stories/feed", requireAuth4, async (req, res) => {
    try {
      const yourStories = await storage.getActiveUserStories(req.session.userId);
      const safeYourStories = yourStories.map((s) => ({
        ...s,
        user: { ...s.user, password: void 0 }
      }));
      const feedStories = await storage.getFeedStories(req.session.userId);
      const followingStories = feedStories.map((group) => ({
        user: { ...group.user, password: void 0 },
        stories: group.stories
      }));
      res.json({
        yourStories: safeYourStories,
        followingStories
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get feed stories" });
    }
  });
  app2.get("/api/users/:id/stories", requireAuth4, async (req, res) => {
    try {
      const userStories = await storage.getActiveUserStories(req.params.id);
      const safeStories = userStories.map((s) => ({
        ...s,
        user: { ...s.user, password: void 0 }
      }));
      res.json(safeStories);
    } catch (error) {
      res.status(500).json({ message: "Failed to get user stories" });
    }
  });
  app2.post("/api/stories/:id/view", requireAuth4, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story) {
        return res.status(404).json({ message: "Story not found" });
      }
      const isBlocked = await storage.isBlockedEither(req.session.userId, story.userId);
      if (isBlocked) {
        return res.status(403).json({ message: "Cannot view this story" });
      }
      const isRestricted = await storage.isStoryViewerRestricted(story.userId, req.session.userId);
      if (isRestricted) {
        return res.status(403).json({ message: "Cannot view this story" });
      }
      const view = await storage.viewStory(req.params.id, req.session.userId);
      res.json(view);
    } catch (error) {
      res.status(500).json({ message: "Failed to view story" });
    }
  });
  app2.get("/api/stories/:id/viewers", requireAuth4, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story) {
        return res.status(404).json({ message: "Story not found" });
      }
      if (story.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const viewers = await storage.getStoryViewers(req.params.id);
      const safeViewers = viewers.map((v) => ({ ...v, password: void 0 }));
      res.json(safeViewers);
    } catch (error) {
      res.status(500).json({ message: "Failed to get story viewers" });
    }
  });
  app2.delete("/api/stories/:id", requireAuth4, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story) {
        return res.status(404).json({ message: "Story not found" });
      }
      if (story.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.deleteStory(req.params.id);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete story" });
    }
  });
  app2.post("/api/stories/:id/reply", requireAuth4, async (req, res) => {
    try {
      const { recipientId, message } = req.body;
      if (!recipientId || !message) {
        return res.status(400).json({ message: "Recipient and message are required" });
      }
      const story = await storage.getStory(req.params.id);
      if (!story) {
        return res.status(404).json({ message: "Story not found" });
      }
      if (story.userId === req.session.userId) {
        return res.status(400).json({ message: "Cannot reply to your own story" });
      }
      const conversation = await storage.getOrCreateConversation(req.session.userId, recipientId, req.session.userId);
      const replyContent = `[Story Reply] ${message}`;
      const newMessage = await storage.createMessage(
        conversation.id,
        req.session.userId,
        recipientId,
        replyContent
      );
      try {
        await storage.createNotification(
          recipientId,
          req.session.userId,
          "MESSAGE",
          story.id
        );
      } catch (e) {
      }
      res.status(201).json({ success: true, message: newMessage, conversationId: conversation.id });
    } catch (error) {
      console.error("Error replying to story:", error);
      res.status(500).json({ message: "Failed to send story reply" });
    }
  });
  app2.get("/api/stories/:id/stickers", requireAuth4, async (req, res) => {
    try {
      const stickers = await storage.getStoryStickers(req.params.id);
      res.json(stickers);
    } catch (error) {
      res.status(500).json({ message: "Failed to get stickers" });
    }
  });
  app2.post("/api/stories/:id/stickers", requireAuth4, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story) {
        return res.status(404).json({ message: "Story not found" });
      }
      if (story.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const { type, positionX, positionY, scale, rotation, data } = req.body;
      if (!type || !data) {
        return res.status(400).json({ message: "Sticker type and data are required" });
      }
      const sticker = await storage.createStorySticker({
        storyId: req.params.id,
        type,
        positionX,
        positionY,
        scale,
        rotation,
        data
      });
      res.status(201).json(sticker);
    } catch (error) {
      res.status(500).json({ message: "Failed to add sticker" });
    }
  });
  app2.patch("/api/stories/:id/stickers/:stickerId", requireAuth4, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story || story.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const sticker = await storage.updateStorySticker(req.params.stickerId, req.body);
      if (!sticker) {
        return res.status(404).json({ message: "Sticker not found" });
      }
      res.json(sticker);
    } catch (error) {
      res.status(500).json({ message: "Failed to update sticker" });
    }
  });
  app2.delete("/api/stories/:id/stickers/:stickerId", requireAuth4, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story || story.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.deleteStorySticker(req.params.stickerId);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete sticker" });
    }
  });
  app2.post("/api/stickers/:stickerId/respond", requireAuth4, async (req, res) => {
    try {
      const { responseType, responseData } = req.body;
      if (!responseType || responseData === void 0) {
        return res.status(400).json({ message: "Response type and data required" });
      }
      const response = await storage.respondToSticker(
        req.params.stickerId,
        req.session.userId,
        responseType,
        responseData
      );
      const sticker = await storage.getSticker(req.params.stickerId);
      if (sticker?.storyId) {
        const story = await storage.getStory(sticker.storyId);
        if (story && story.userId !== req.session.userId) {
          try {
            await storage.createNotification(story.userId, req.session.userId, "STORY_STICKER_RESPONSE", story.id);
          } catch (e) {
          }
        }
      }
      res.status(201).json(response);
    } catch (error) {
      res.status(500).json({ message: "Failed to respond to sticker" });
    }
  });
  app2.get("/api/stickers/:stickerId/responses", requireAuth4, async (req, res) => {
    try {
      const responses = await storage.getStickerResponses(req.params.stickerId);
      res.json(responses);
    } catch (error) {
      res.status(500).json({ message: "Failed to get responses" });
    }
  });
  app2.post("/api/stories/:id/reactions", requireAuth4, async (req, res) => {
    try {
      const { reactionType } = req.body;
      if (!reactionType || !["FIRE", "HEART", "LAUGH", "WOW", "SAD", "CLAP"].includes(reactionType)) {
        return res.status(400).json({ message: "Valid reaction type required" });
      }
      const story = await storage.getStory(req.params.id);
      if (!story) {
        return res.status(404).json({ message: "Story not found" });
      }
      const reaction = await storage.addStoryReaction(req.params.id, req.session.userId, reactionType);
      if (story.userId !== req.session.userId) {
        try {
          await storage.createNotification(story.userId, req.session.userId, "STORY_REACTION", req.params.id);
        } catch (e) {
        }
      }
      res.status(201).json(reaction);
    } catch (error) {
      res.status(500).json({ message: "Failed to add reaction" });
    }
  });
  app2.delete("/api/stories/:id/reactions", requireAuth4, async (req, res) => {
    try {
      await storage.removeStoryReaction(req.params.id, req.session.userId);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to remove reaction" });
    }
  });
  app2.get("/api/stories/:id/reactions", requireAuth4, async (req, res) => {
    try {
      const reactions = await storage.getStoryReactions(req.params.id);
      res.json(reactions);
    } catch (error) {
      res.status(500).json({ message: "Failed to get reactions" });
    }
  });
  app2.post("/api/stories/:id/replies", requireAuth4, async (req, res) => {
    try {
      const { content, mediaUrl, mediaType } = req.body;
      if (!content && !mediaUrl) {
        return res.status(400).json({ message: "Content or media required" });
      }
      const story = await storage.getStory(req.params.id);
      if (!story) {
        return res.status(404).json({ message: "Story not found" });
      }
      if (story.replySetting === "OFF") {
        return res.status(403).json({ message: "Replies are disabled for this story" });
      }
      if (story.replySetting === "FOLLOWERS") {
        const isFollower = await storage.isFollowing(req.session.userId, story.userId);
        if (!isFollower) {
          return res.status(403).json({ message: "Only followers can reply" });
        }
      }
      if (story.replySetting === "CLOSE_FRIENDS") {
        const isCloseFriend = await storage.isCloseFriend(story.userId, req.session.userId);
        if (!isCloseFriend) {
          return res.status(403).json({ message: "Only close friends can reply" });
        }
      }
      const reply = await storage.createStoryReply(req.params.id, req.session.userId, content, mediaUrl, mediaType);
      if (story.userId !== req.session.userId) {
        try {
          await storage.createNotification(story.userId, req.session.userId, "STORY_REPLY", req.params.id);
        } catch (e) {
        }
      }
      res.status(201).json(reply);
    } catch (error) {
      res.status(500).json({ message: "Failed to create reply" });
    }
  });
  app2.get("/api/stories/:id/replies", requireAuth4, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story || story.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const replies = await storage.getStoryReplies(req.params.id);
      res.json(replies.map((r) => ({ ...r, user: { ...r.user, password: void 0 } })));
    } catch (error) {
      res.status(500).json({ message: "Failed to get replies" });
    }
  });
  app2.post("/api/stories/:id/replies/read", requireAuth4, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story || story.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.markStoryRepliesRead(req.params.id);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to mark replies as read" });
    }
  });
  app2.get("/api/stories/drafts", requireAuth4, async (req, res) => {
    try {
      const drafts2 = await storage.getUserStoryDrafts(req.session.userId);
      res.json(drafts2);
    } catch (error) {
      res.status(500).json({ message: "Failed to get drafts" });
    }
  });
  app2.post("/api/stories/drafts", requireAuth4, async (req, res) => {
    try {
      const draft = await storage.createStoryDraft(req.session.userId, req.body);
      res.status(201).json(draft);
    } catch (error) {
      res.status(500).json({ message: "Failed to create draft" });
    }
  });
  app2.get("/api/stories/drafts/:id", requireAuth4, async (req, res) => {
    try {
      const draft = await storage.getStoryDraft(req.params.id);
      if (!draft || draft.userId !== req.session.userId) {
        return res.status(404).json({ message: "Draft not found" });
      }
      res.json(draft);
    } catch (error) {
      res.status(500).json({ message: "Failed to get draft" });
    }
  });
  app2.patch("/api/stories/drafts/:id", requireAuth4, async (req, res) => {
    try {
      const draft = await storage.getStoryDraft(req.params.id);
      if (!draft || draft.userId !== req.session.userId) {
        return res.status(404).json({ message: "Draft not found" });
      }
      const updated = await storage.updateStoryDraft(req.params.id, req.body);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update draft" });
    }
  });
  app2.delete("/api/stories/drafts/:id", requireAuth4, async (req, res) => {
    try {
      const draft = await storage.getStoryDraft(req.params.id);
      if (!draft || draft.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.deleteStoryDraft(req.params.id);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete draft" });
    }
  });
  app2.post("/api/stories/:id/insights", requireAuth4, async (req, res) => {
    try {
      const { viewDuration, tappedForward, tappedBack, exited, shared, profileVisited } = req.body;
      const insight = await storage.recordStoryInsight(req.params.id, req.session.userId, {
        viewDuration,
        tappedForward,
        tappedBack,
        exited,
        shared,
        profileVisited
      });
      res.json(insight);
    } catch (error) {
      res.status(500).json({ message: "Failed to record insight" });
    }
  });
  app2.get("/api/stories/:id/analytics", requireAuth4, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story || story.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const analytics = await storage.getStoryAnalytics(req.params.id);
      const insights = await storage.getStoryInsights(req.params.id);
      const reactions = await storage.getStoryReactions(req.params.id);
      res.json({
        ...analytics,
        insights,
        reactions,
        viewsCount: story.viewsCount,
        reactionsCount: story.reactionsCount,
        repliesCount: story.repliesCount,
        sharesCount: story.sharesCount,
        tapsForwardCount: story.tapsForwardCount,
        tapsBackCount: story.tapsBackCount,
        exitsCount: story.exitsCount
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get analytics" });
    }
  });
  app2.get("/api/stories/streak", requireAuth4, async (req, res) => {
    try {
      const streak = await storage.getOrCreateStreak(req.session.userId);
      res.json(streak);
    } catch (error) {
      res.status(500).json({ message: "Failed to get streak" });
    }
  });
  app2.post("/api/stories/streak/claim", requireAuth4, async (req, res) => {
    try {
      const { milestone } = req.body;
      if (![7, 30, 100, 365].includes(milestone)) {
        return res.status(400).json({ message: "Invalid milestone" });
      }
      const streak = await storage.getOrCreateStreak(req.session.userId);
      if (streak.currentStreak < milestone) {
        return res.status(400).json({ message: "Milestone not reached" });
      }
      const updated = await storage.claimStreakMilestone(req.session.userId, milestone);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to claim milestone" });
    }
  });
  app2.get("/api/stories/templates", requireAuth4, async (req, res) => {
    try {
      const { category } = req.query;
      const templates = await storage.getStoryTemplates(category);
      res.json(templates);
    } catch (error) {
      res.status(500).json({ message: "Failed to get templates" });
    }
  });
  app2.get("/api/stories/templates/:id", requireAuth4, async (req, res) => {
    try {
      const template = await storage.getStoryTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ message: "Template not found" });
      }
      await storage.incrementTemplateUsage(req.params.id);
      res.json(template);
    } catch (error) {
      res.status(500).json({ message: "Failed to get template" });
    }
  });
  app2.get("/api/stories/music", requireAuth4, async (req, res) => {
    try {
      const { genre, limit } = req.query;
      const limitNum = limit ? parseInt(limit) : 25;
      let tracks;
      if (genre) {
        const genreKey = genre.toString().toLowerCase();
        const genreId = GENRE_IDS[genreKey];
        if (genreId) {
          tracks = await getTracksByGenre(genreId, limitNum);
        } else {
          tracks = await searchTracks(genre.toString(), limitNum);
        }
      } else {
        tracks = await getChartTracks(limitNum);
      }
      res.json(tracks);
    } catch (error) {
      console.error("Failed to get music from Deezer:", error);
      res.status(500).json({ message: "Failed to get music" });
    }
  });
  app2.get("/api/stories/music/featured", requireAuth4, async (req, res) => {
    try {
      const tracks = await getChartTracks(30);
      res.json(tracks);
    } catch (error) {
      console.error("Failed to get featured music from Deezer:", error);
      res.status(500).json({ message: "Failed to get featured music" });
    }
  });
  app2.get("/api/stories/music/search", requireAuth4, async (req, res) => {
    try {
      const { q, limit } = req.query;
      if (!q) {
        return res.status(400).json({ message: "Search query required" });
      }
      const limitNum = limit ? parseInt(limit) : 25;
      const tracks = await searchTracks(q, limitNum);
      res.json(tracks);
    } catch (error) {
      console.error("Failed to search music on Deezer:", error);
      res.status(500).json({ message: "Failed to search music" });
    }
  });
  app2.get("/api/stories/music/genres", requireAuth4, async (req, res) => {
    try {
      const genres = await getGenres();
      res.json(genres);
    } catch (error) {
      console.error("Failed to get genres from Deezer:", error);
      res.status(500).json({ message: "Failed to get genres" });
    }
  });
  app2.get("/api/stories/music/genre/:genreId", requireAuth4, async (req, res) => {
    try {
      const genreId = parseInt(req.params.genreId);
      const { limit } = req.query;
      const limitNum = limit ? parseInt(limit) : 25;
      const tracks = await getTracksByGenre(genreId, limitNum);
      res.json(tracks);
    } catch (error) {
      console.error("Failed to get genre tracks from Deezer:", error);
      res.status(500).json({ message: "Failed to get genre tracks" });
    }
  });
  app2.post("/api/stories/music/:id/use", requireAuth4, async (req, res) => {
    try {
      console.log(`Music track used: ${req.params.id} by user ${req.session.userId}`);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to track music usage" });
    }
  });
  app2.post("/api/stories/:id/tip", requireAuth4, async (req, res) => {
    try {
      const { amount, message } = req.body;
      if (!amount || amount < 1) {
        return res.status(400).json({ message: "Valid amount required" });
      }
      const story = await storage.getStory(req.params.id);
      if (!story) {
        return res.status(404).json({ message: "Story not found" });
      }
      if (story.userId === req.session.userId) {
        return res.status(400).json({ message: "Cannot tip your own story" });
      }
      const tip = await storage.createStoryTip(
        req.params.id,
        req.session.userId,
        story.userId,
        amount,
        message
      );
      try {
        await storage.createNotification(story.userId, req.session.userId, "LIKE", req.params.id);
      } catch (e) {
      }
      res.status(201).json(tip);
    } catch (error) {
      res.status(500).json({ message: "Failed to send tip" });
    }
  });
  app2.get("/api/stories/:id/tips", requireAuth4, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story || story.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const tips = await storage.getStoryTips(req.params.id);
      res.json(tips.map((t) => ({ ...t, sender: { ...t.sender, password: void 0 } })));
    } catch (error) {
      res.status(500).json({ message: "Failed to get tips" });
    }
  });
  app2.get("/api/stories/tips/received", requireAuth4, async (req, res) => {
    try {
      const tips = await storage.getUserReceivedTips(req.session.userId);
      res.json(tips.map((t) => ({ ...t, sender: { ...t.sender, password: void 0 } })));
    } catch (error) {
      res.status(500).json({ message: "Failed to get received tips" });
    }
  });
  app2.post("/api/stickers/:stickerId/subscribe", requireAuth4, async (req, res) => {
    try {
      const subscription = await storage.subscribeToCountdown(req.params.stickerId, req.session.userId);
      res.status(201).json(subscription);
    } catch (error) {
      res.status(500).json({ message: "Failed to subscribe" });
    }
  });
  app2.delete("/api/stickers/:stickerId/subscribe", requireAuth4, async (req, res) => {
    try {
      await storage.unsubscribeFromCountdown(req.params.stickerId, req.session.userId);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to unsubscribe" });
    }
  });
  app2.post("/api/stories/:id/reshare", requireAuth4, async (req, res) => {
    try {
      const { comment } = req.body;
      const originalStory = await storage.getStory(req.params.id);
      if (!originalStory) {
        return res.status(404).json({ message: "Story not found" });
      }
      const resharedStory = await storage.createStory(req.session.userId, {
        type: originalStory.type,
        mediaUrl: originalStory.mediaUrl,
        thumbnailUrl: originalStory.thumbnailUrl,
        textContent: originalStory.textContent,
        backgroundColor: originalStory.backgroundColor,
        isGradient: originalStory.isGradient ?? false,
        fontFamily: originalStory.fontFamily,
        textAlignment: originalStory.textAlignment,
        textAnimation: originalStory.textAnimation,
        audioUrl: originalStory.audioUrl,
        audioDuration: originalStory.audioDuration
      });
      await storage.recordStoryInsight(req.params.id, req.session.userId, { shared: true });
      if (originalStory.userId !== req.session.userId) {
        try {
          await storage.createNotification(originalStory.userId, req.session.userId, "LIKE", req.params.id);
        } catch (e) {
        }
      }
      const storyWithUser = await storage.getStory(resharedStory.id);
      res.status(201).json(storyWithUser);
    } catch (error) {
      res.status(500).json({ message: "Failed to reshare story" });
    }
  });
  app2.get("/api/admin/stories", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.view")) {
        return res.status(403).json({ message: "Missing permission: content.view" });
      }
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const userId = req.query.userId;
      const stories2 = await storage.getAllStories(limit, offset, userId);
      res.json(stories2);
    } catch (error) {
      res.status(500).json({ message: "Failed to get stories" });
    }
  });
  app2.get("/api/admin/stories/:id", requireAdmin, async (req, res) => {
    try {
      const story = await storage.getStory(req.params.id);
      if (!story) {
        return res.status(404).json({ message: "Story not found" });
      }
      const viewers = await storage.getStoryViewers(req.params.id);
      res.json({ ...story, viewers: viewers.map((v) => ({ ...v, password: void 0 })) });
    } catch (error) {
      res.status(500).json({ message: "Failed to get story" });
    }
  });
  app2.delete("/api/admin/stories/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.soft_delete")) {
        return res.status(403).json({ message: "Missing permission: content.soft_delete" });
      }
      const story = await storage.getStory(req.params.id);
      if (!story) {
        return res.status(404).json({ message: "Story not found" });
      }
      await storage.deleteStory(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "CONTENT_SOFT_DELETED",
        "story",
        req.params.id,
        { userId: story.userId, type: story.type },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete story" });
    }
  });
  app2.get("/api/admin/stories/extended/stats", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.view")) {
        return res.status(403).json({ message: "Missing permission: content.view" });
      }
      const stats = await storage.getAdminStoryExtendedStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Failed to get extended story stats" });
    }
  });
  app2.get("/api/admin/stories/highlights", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.view")) {
        return res.status(403).json({ message: "Missing permission: content.view" });
      }
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search;
      const result = await storage.getAdminStoryHighlights({ page, limit, search });
      res.json(result);
    } catch (error) {
      res.status(500).json({ message: "Failed to get story highlights" });
    }
  });
  app2.delete("/api/admin/stories/highlights/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.soft_delete")) {
        return res.status(403).json({ message: "Missing permission: content.soft_delete" });
      }
      await storage.adminDeleteStoryHighlight(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "CONTENT_SOFT_DELETED",
        "story_highlight",
        req.params.id,
        {},
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete story highlight" });
    }
  });
  app2.get("/api/admin/stories/stickers", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.view")) {
        return res.status(403).json({ message: "Missing permission: content.view" });
      }
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const result = await storage.getAdminStoryStickers({ page, limit });
      res.json(result);
    } catch (error) {
      res.status(500).json({ message: "Failed to get story stickers" });
    }
  });
  app2.get("/api/admin/stories/tips", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.view")) {
        return res.status(403).json({ message: "Missing permission: content.view" });
      }
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const result = await storage.getAdminStoryTips({ page, limit });
      res.json(result);
    } catch (error) {
      res.status(500).json({ message: "Failed to get story tips" });
    }
  });
  app2.get("/api/admin/story-templates", requireAdmin, async (req, res) => {
    try {
      const templates = await storage.getStoryTemplates();
      res.json(templates);
    } catch (error) {
      res.status(500).json({ message: "Failed to get templates" });
    }
  });
  app2.post("/api/admin/story-templates", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.create")) {
        return res.status(403).json({ message: "Missing permission: content.create" });
      }
      const { name, category, thumbnailUrl, backgroundColor, fontFamily, textAlignment, textAnimation, fontSize, filterName, stickerPresets, isPremium } = req.body;
      if (!name || !category) {
        return res.status(400).json({ message: "Name and category are required" });
      }
      const template = await storage.createStoryTemplate({
        name,
        category,
        thumbnailUrl,
        backgroundColor,
        fontFamily,
        textAlignment,
        textAnimation,
        fontSize,
        filterName,
        stickerPresets: stickerPresets || [],
        isPremium: isPremium || false
      });
      await storage.createAuditLog(
        req.session.userId,
        "CREATE",
        "story_template",
        template.id,
        { name, category },
        req.ip,
        req.headers["user-agent"]
      );
      res.status(201).json(template);
    } catch (error) {
      res.status(500).json({ message: "Failed to create template" });
    }
  });
  app2.patch("/api/admin/story-templates/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.edit")) {
        return res.status(403).json({ message: "Missing permission: content.edit" });
      }
      const template = await storage.getStoryTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ message: "Template not found" });
      }
      const updated = await storage.updateStoryTemplate(req.params.id, req.body);
      await storage.createAuditLog(
        req.session.userId,
        "UPDATE",
        "story_template",
        req.params.id,
        { updates: Object.keys(req.body) },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update template" });
    }
  });
  app2.delete("/api/admin/story-templates/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.soft_delete")) {
        return res.status(403).json({ message: "Missing permission: content.soft_delete" });
      }
      const template = await storage.getStoryTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ message: "Template not found" });
      }
      await storage.deleteStoryTemplate(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "CONTENT_SOFT_DELETED",
        "story_template",
        req.params.id,
        { name: template.name },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete template" });
    }
  });
  app2.post("/api/admin/story-templates/reorder", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.edit")) {
        return res.status(403).json({ message: "Missing permission: content.edit" });
      }
      const { orderedIds } = req.body;
      if (!orderedIds || !Array.isArray(orderedIds)) {
        return res.status(400).json({ message: "orderedIds array required" });
      }
      for (let i = 0; i < orderedIds.length; i++) {
        await storage.updateStoryTemplate(orderedIds[i], {});
      }
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to reorder templates" });
    }
  });
  app2.get("/api/admin/story-music", requireAdmin, async (req, res) => {
    try {
      const music = await storage.getStoryMusic();
      res.json(music);
    } catch (error) {
      res.status(500).json({ message: "Failed to get music" });
    }
  });
  app2.post("/api/admin/story-music", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.create")) {
        return res.status(403).json({ message: "Missing permission: content.create" });
      }
      const { title, artist, albumArt, audioUrl, previewUrl, duration, genre, mood, isFeatured, startTime: startTime2, endTime } = req.body;
      if (!title || !artist || !audioUrl || !duration) {
        return res.status(400).json({ message: "Title, artist, audioUrl, and duration are required" });
      }
      const track = await storage.createStoryMusic({
        title,
        artist,
        coverUrl: albumArt,
        previewUrl: previewUrl || audioUrl,
        duration,
        genre: genre || "Pop",
        isFeatured: isFeatured || false
      });
      await storage.createAuditLog(
        req.session.userId,
        "CREATE",
        "story_music",
        track.id,
        { title, artist },
        req.ip,
        req.headers["user-agent"]
      );
      res.status(201).json(track);
    } catch (error) {
      res.status(500).json({ message: "Failed to add music" });
    }
  });
  app2.patch("/api/admin/story-music/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.edit")) {
        return res.status(403).json({ message: "Missing permission: content.edit" });
      }
      const track = await storage.getStoryMusicById(req.params.id);
      if (!track) {
        return res.status(404).json({ message: "Music track not found" });
      }
      const updated = await storage.updateStoryMusic(req.params.id, req.body);
      await storage.createAuditLog(
        req.session.userId,
        "UPDATE",
        "story_music",
        req.params.id,
        { updates: Object.keys(req.body) },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update music" });
    }
  });
  app2.delete("/api/admin/story-music/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.soft_delete")) {
        return res.status(403).json({ message: "Missing permission: content.soft_delete" });
      }
      const track = await storage.getStoryMusicById(req.params.id);
      if (!track) {
        return res.status(404).json({ message: "Music track not found" });
      }
      await storage.deleteStoryMusic(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "CONTENT_SOFT_DELETED",
        "story_music",
        req.params.id,
        { title: track.title },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete music" });
    }
  });
  app2.post("/api/admin/story-music/:id/feature", requireAdmin, async (req, res) => {
    try {
      const { featured } = req.body;
      const updated = await storage.updateStoryMusic(req.params.id, { isFeatured: featured !== false });
      if (!updated) {
        return res.status(404).json({ message: "Music track not found" });
      }
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update music" });
    }
  });
  app2.get("/api/admin/story-reports", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "reports.view")) {
        return res.status(403).json({ message: "Missing permission: reports.view" });
      }
      const { status } = req.query;
      const reports2 = await storage.getStoryReports(status);
      res.json(reports2);
    } catch (error) {
      res.status(500).json({ message: "Failed to get story reports" });
    }
  });
  app2.post("/api/admin/story-reports/:reportId/action", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "reports.action")) {
        return res.status(403).json({ message: "Missing permission: reports.action" });
      }
      const { action, reason } = req.body;
      if (!action || !["DISMISS", "WARN", "DELETE", "BAN"].includes(action)) {
        return res.status(400).json({ message: "Valid action required (DISMISS, WARN, DELETE, BAN)" });
      }
      await storage.updateReportStatus(req.params.reportId, action === "DISMISS" ? "DISMISSED" : "RESOLVED", req.session.userId, reason);
      if (action === "DELETE") {
        const report = await storage.getReportById(req.params.reportId);
        if (report && report.reportedPostId) {
          await storage.deleteStory(report.reportedPostId);
        }
      }
      await storage.createAuditLog(
        req.session.userId,
        "REPORT_RESOLVED",
        "story_report",
        req.params.reportId,
        { action, reason },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to take action" });
    }
  });
  app2.get("/api/admin/story-analytics", requireAdmin, async (req, res) => {
    try {
      const { days = 7 } = req.query;
      const daysNum = parseInt(days) || 7;
      const stats = await storage.getPlatformStoryStats(daysNum);
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Failed to get story analytics" });
    }
  });
  app2.get("/api/users/:id/mutuals", requireAuth4, async (req, res) => {
    try {
      const allMutuals = await storage.getMutualFollowers(req.params.id, req.session.userId, 100);
      const limitedMutuals = allMutuals.slice(0, 5);
      const safeMutuals = limitedMutuals.map((u) => ({ ...u, password: void 0 }));
      res.json({
        count: allMutuals.length,
        users: safeMutuals
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get mutual followers" });
    }
  });
  app2.get("/api/users/:id/share-link", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      res.json({
        url: `https://rabitchat.app/u/${user.username}`,
        username: user.username
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get share link" });
    }
  });
  app2.get("/api/users/:id/can-call", requireAuth4, async (req, res) => {
    try {
      const targetUserId = req.params.id;
      const viewerId = req.session.userId;
      if (targetUserId === viewerId) {
        return res.json({ canCall: false, reason: "Cannot call yourself" });
      }
      const targetUser = await storage.getUser(targetUserId);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const viewer = await getViewerContext(viewerId);
      const messageAccess = await canMessage(viewer, targetUser);
      if (messageAccess.allowed) {
        return res.json({
          canCall: true,
          user: {
            id: targetUser.id,
            username: targetUser.username,
            displayName: targetUser.displayName,
            avatarUrl: targetUser.avatarUrl
          }
        });
      }
      const userConversations = await storage.getUserConversations(viewerId);
      const existingConversation = userConversations.find(
        (c) => c.participant1Id === targetUserId || c.participant2Id === targetUserId
      );
      if (existingConversation && existingConversation.status === "ACCEPTED") {
        return res.json({
          canCall: true,
          user: {
            id: targetUser.id,
            username: targetUser.username,
            displayName: targetUser.displayName,
            avatarUrl: targetUser.avatarUrl
          }
        });
      }
      res.json({
        canCall: false,
        reason: messageAccess.reason || "You must follow each other or have a conversation to call"
      });
    } catch (error) {
      console.error("Can-call check error:", error);
      res.status(500).json({ message: "Failed to check call permission" });
    }
  });
  app2.get("/api/conversations", requireAuth4, async (req, res) => {
    try {
      const chatEnabled = await storage.getAppSettingValue("chatEnabled", true);
      const user = await storage.getUser(req.session.userId);
      if (!chatEnabled && user && !user.isAdmin) {
        return res.status(403).json({ message: "Chat is currently disabled", chatDisabled: true });
      }
      const conversations3 = await storage.getUserConversations(req.session.userId);
      const safeConversations = conversations3.map((c) => ({
        ...c,
        participant1: { ...c.participant1, password: void 0 },
        participant2: { ...c.participant2, password: void 0 }
      }));
      res.json(safeConversations);
    } catch (error) {
      res.status(500).json({ message: "Failed to get conversations" });
    }
  });
  app2.post("/api/conversations", requireAuth4, async (req, res) => {
    try {
      const chatEnabled = await storage.getAppSettingValue("chatEnabled", true);
      const currentUser = await storage.getUser(req.session.userId);
      if (!chatEnabled && currentUser && !currentUser.isAdmin) {
        return res.status(403).json({ message: "Chat is currently disabled", chatDisabled: true });
      }
      const { userId } = req.body;
      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }
      const targetUser = await storage.getUser(userId);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const messageAccess = await canMessage(viewer, targetUser);
      if (!messageAccess.allowed) {
        return res.status(403).json({ message: messageAccess.reason });
      }
      const conversation = await storage.getOrCreateConversation(req.session.userId, userId, req.session.userId);
      res.status(201).json(conversation);
    } catch (error) {
      res.status(500).json({ message: "Failed to create conversation" });
    }
  });
  app2.get("/api/conversations/:id", requireAuth4, async (req, res) => {
    try {
      const conversation = await storage.getConversation(req.params.id);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      const userId = req.session.userId;
      const isParticipant = conversation.participant1Id === userId || conversation.participant2Id === userId;
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to view this conversation" });
      }
      res.json(conversation);
    } catch (error) {
      res.status(500).json({ message: "Failed to get conversation" });
    }
  });
  app2.get("/api/conversations/:id/messages", requireAuth4, async (req, res) => {
    try {
      const conversation = await storage.getConversation(req.params.id);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      const userId = req.session.userId;
      const isParticipant = conversation.participant1Id === userId || conversation.participant2Id === userId;
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to view this conversation" });
      }
      const messages4 = await storage.getConversationMessages(req.params.id);
      if (conversation.status === "ACCEPTED") {
        await storage.markMessagesAsRead(req.params.id, userId);
      }
      const keywordFilters2 = await storage.getKeywordFilters(userId);
      const messageKeywords = keywordFilters2.filter((f) => f.filterMessages !== false).map((f) => f.keyword.toLowerCase());
      const filteredMessages = messageKeywords.length > 0 ? messages4.filter((m) => {
        const contentText = (m.content || "").toLowerCase();
        return !messageKeywords.some((kw) => contentText.includes(kw));
      }) : messages4;
      const safeMessages = filteredMessages.map((m) => ({
        ...m,
        sender: { ...m.sender, password: void 0 }
      }));
      res.json(safeMessages);
    } catch (error) {
      res.status(500).json({ message: "Failed to get messages" });
    }
  });
  app2.post("/api/conversations/:id/messages", requireAuth4, messageLimiter, validateBody(sendMessageSchema), async (req, res) => {
    try {
      const chatEnabled = await storage.getAppSettingValue("chatEnabled", true);
      const currentUser = await storage.getUser(req.session.userId);
      if (!chatEnabled && currentUser && !currentUser.isAdmin) {
        return res.status(403).json({ message: "Chat is currently disabled", chatDisabled: true });
      }
      const conversation = await storage.getConversation(req.params.id);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      const userId = req.session.userId;
      const isParticipant = conversation.participant1Id === userId || conversation.participant2Id === userId;
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized to send messages in this conversation" });
      }
      const validReceiverId = conversation.participant1Id === userId ? conversation.participant2Id : conversation.participant1Id;
      const targetUser = await storage.getUser(validReceiverId);
      if (!targetUser) {
        return res.status(404).json({ message: "Recipient not found" });
      }
      const viewer = await getViewerContext(userId);
      const messageAccess = await canMessage(viewer, targetUser);
      if (!messageAccess.allowed) {
        return res.status(403).json({ message: messageAccess.reason });
      }
      if (conversation.status === "REQUEST" && conversation.requestedByUserId !== userId) {
        return res.status(403).json({ message: "You must accept this message request before replying" });
      }
      const { content, receiverId } = req.body;
      if (!content) {
        return res.status(400).json({ message: "Content is required" });
      }
      if (typeof content !== "string" || content.trim().length === 0) {
        return res.status(400).json({ message: "Message content cannot be empty" });
      }
      if (receiverId && receiverId !== validReceiverId) {
        return res.status(400).json({ message: "Invalid receiver for this conversation" });
      }
      const message = await storage.createMessage(
        req.params.id,
        userId,
        validReceiverId,
        content.trim()
      );
      const sender = await storage.getUser(userId);
      const messageWithSender = {
        ...message,
        sender: { ...sender, password: void 0 }
      };
      broadcastToUser(validReceiverId, {
        type: "new_message",
        data: messageWithSender
      });
      broadcastToUser(userId, {
        type: "new_message",
        data: messageWithSender
      });
      const notification = await storage.createNotification(
        validReceiverId,
        userId,
        "MESSAGE",
        req.params.id
      );
      if (notification.id) {
        broadcastToUser(validReceiverId, {
          type: "notification:new",
          payload: { ...notification, actor: sender ? { ...sender, password: void 0 } : null }
        });
        if (sender) {
          pushNotificationService.notifyMessage(
            validReceiverId,
            sender.username,
            sender.displayName,
            req.params.id,
            content.trim()
          ).catch((err) => console.error("[Push] Message notification error:", err));
        }
      }
      res.status(201).json(messageWithSender);
    } catch (error) {
      res.status(500).json({ message: "Failed to send message" });
    }
  });
  app2.post("/api/conversations/:id/messages/media", requireAuth4, messageLimiter, async (req, res) => {
    try {
      const conversation = await storage.getConversation(req.params.id);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      const userId = req.session.userId;
      const isParticipant = conversation.participant1Id === userId || conversation.participant2Id === userId;
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const validReceiverId = conversation.participant1Id === userId ? conversation.participant2Id : conversation.participant1Id;
      const { content, messageType, mediaUrl, replyToId } = req.body;
      const message = await storage.createMessageWithMedia(
        req.params.id,
        userId,
        validReceiverId,
        content || "",
        messageType || "TEXT",
        mediaUrl || null,
        replyToId || null
      );
      const sender = await storage.getUser(userId);
      const messageWithSender = {
        ...message,
        sender: { ...sender, password: void 0 }
      };
      broadcastToUser(validReceiverId, {
        type: "new_message",
        data: messageWithSender
      });
      broadcastToUser(userId, {
        type: "new_message",
        data: messageWithSender
      });
      res.status(201).json(messageWithSender);
    } catch (error) {
      console.error("Failed to send media message:", error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });
  app2.delete("/api/messages/:messageId", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const messageId = req.params.messageId;
      const message = await storage.getMessage(messageId);
      if (!message) {
        return res.status(404).json({ message: "Message not found" });
      }
      if (message.senderId !== userId) {
        return res.status(403).json({ message: "Can only delete your own messages" });
      }
      await storage.deleteMessage(messageId);
      broadcastToUser(message.senderId, {
        type: "message_deleted",
        data: { messageId, conversationId: message.conversationId }
      });
      broadcastToUser(message.receiverId, {
        type: "message_deleted",
        data: { messageId, conversationId: message.conversationId }
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete message:", error);
      res.status(500).json({ message: "Failed to delete message" });
    }
  });
  app2.post("/api/messages/:messageId/reactions", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const messageId = req.params.messageId;
      const { emoji } = req.body;
      if (!emoji || typeof emoji !== "string") {
        return res.status(400).json({ message: "Emoji is required" });
      }
      const message = await storage.getMessage(messageId);
      if (!message) {
        return res.status(404).json({ message: "Message not found" });
      }
      const reaction = await storage.addMessageReaction(messageId, userId, emoji);
      broadcastToUser(message.senderId, {
        type: "message_reaction",
        data: { messageId, reaction, conversationId: message.conversationId }
      });
      broadcastToUser(message.receiverId, {
        type: "message_reaction",
        data: { messageId, reaction, conversationId: message.conversationId }
      });
      res.status(201).json(reaction);
    } catch (error) {
      console.error("Failed to add reaction:", error);
      res.status(500).json({ message: "Failed to add reaction" });
    }
  });
  app2.delete("/api/messages/:messageId/reactions", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const messageId = req.params.messageId;
      const { emoji } = req.body;
      const message = await storage.getMessage(messageId);
      if (!message) {
        return res.status(404).json({ message: "Message not found" });
      }
      await storage.removeMessageReaction(messageId, userId, emoji);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to remove reaction:", error);
      res.status(500).json({ message: "Failed to remove reaction" });
    }
  });
  app2.post("/api/conversations/:id/read", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const conversationId = req.params.id;
      const conversation = await storage.getConversation(conversationId);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      const isParticipant = conversation.participant1Id === userId || conversation.participant2Id === userId;
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.markMessagesAsRead(conversationId, userId);
      const otherUserId = conversation.participant1Id === userId ? conversation.participant2Id : conversation.participant1Id;
      broadcastToUser(otherUserId, {
        type: "messages_read",
        data: { conversationId, readBy: userId, readAt: (/* @__PURE__ */ new Date()).toISOString() }
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to mark messages as read:", error);
      res.status(500).json({ message: "Failed to mark as read" });
    }
  });
  app2.post("/api/conversations/:id/typing", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const conversationId = req.params.id;
      const { isTyping } = req.body;
      const conversation = await storage.getConversation(conversationId);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      const otherUserId = conversation.participant1Id === userId ? conversation.participant2Id : conversation.participant1Id;
      broadcastToUser(otherUserId, {
        type: "typing_indicator",
        data: { conversationId, userId, isTyping: !!isTyping }
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to send typing indicator:", error);
      res.status(500).json({ message: "Failed to send typing indicator" });
    }
  });
  app2.post("/api/users/online-status", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { isOnline } = req.body;
      await storage.updateUserOnlineStatus(userId, !!isOnline);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to update online status:", error);
      res.status(500).json({ message: "Failed to update online status" });
    }
  });
  app2.get("/api/users/:id/online-status", requireAuth4, async (req, res) => {
    try {
      const targetId = req.params.id;
      const status = await storage.getUserOnlineStatus(targetId);
      res.json(status || { userId: targetId, isOnline: false, lastSeenAt: null });
    } catch (error) {
      console.error("Failed to get online status:", error);
      res.status(500).json({ message: "Failed to get online status" });
    }
  });
  app2.post("/api/users/:id/block", requireAuth4, async (req, res) => {
    try {
      const blockerId = req.session.userId;
      const blockedId = req.params.id;
      if (blockerId === blockedId) {
        return res.status(400).json({ message: "Cannot block yourself" });
      }
      const blockedUser = await storage.getUser(blockedId);
      if (!blockedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.blockUser(blockerId, blockedId);
      res.json({ success: true, message: "User blocked" });
    } catch (error) {
      res.status(500).json({ message: "Failed to block user" });
    }
  });
  app2.delete("/api/users/:id/block", requireAuth4, async (req, res) => {
    try {
      const blockerId = req.session.userId;
      const blockedId = req.params.id;
      await storage.unblockUser(blockerId, blockedId);
      res.json({ success: true, message: "User unblocked" });
    } catch (error) {
      res.status(500).json({ message: "Failed to unblock user" });
    }
  });
  app2.get("/api/users/me/blocked", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const blockedUsers = await storage.getBlockedUsers(userId);
      const safeUsers = blockedUsers.map((u) => ({ ...u, password: void 0 }));
      res.json(safeUsers);
    } catch (error) {
      res.status(500).json({ message: "Failed to get blocked users" });
    }
  });
  app2.get("/api/users/:id/blocked", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const targetId = req.params.id;
      const isBlocked = await storage.isBlocked(userId, targetId);
      const isBlockedBy = await storage.isBlocked(targetId, userId);
      res.json({ isBlocked, isBlockedBy });
    } catch (error) {
      res.status(500).json({ message: "Failed to check block status" });
    }
  });
  app2.post("/api/reports", requireAuth4, async (req, res) => {
    try {
      const reporterId = req.session.userId;
      const { reason, reportedUserId, reportedPostId } = req.body;
      if (!reason || reason.trim().length === 0) {
        return res.status(400).json({ message: "Reason is required" });
      }
      if (!reportedUserId && !reportedPostId) {
        return res.status(400).json({ message: "Must report a user or a post" });
      }
      if (reportedUserId) {
        const user = await storage.getUser(reportedUserId);
        if (!user) {
          return res.status(404).json({ message: "User not found" });
        }
        if (reportedUserId === reporterId) {
          return res.status(400).json({ message: "Cannot report yourself" });
        }
      }
      if (reportedPostId) {
        const post = await storage.getPost(reportedPostId);
        if (!post) {
          return res.status(404).json({ message: "Post not found" });
        }
      }
      const report = await storage.createReport(
        reporterId,
        reason.trim(),
        reportedUserId,
        reportedPostId
      );
      res.status(201).json({ success: true, reportId: report.id });
    } catch (error) {
      res.status(500).json({ message: "Failed to create report" });
    }
  });
  async function requireAdmin(req, res, next) {
    if (!req.session.userId) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const user = await storage.getUser(req.session.userId);
    if (!user || !user.isAdmin) {
      return res.status(403).json({ message: "Admin access required" });
    }
    next();
  }
  registerGossipRoutes(app2, requireAdmin);
  registerAdvancedRoutes(app2);
  registerOnboardingRoutes(app2);
  registerAdsRoutes(app2, requireAuth4);
  registerLinkPreviewRoutes(app2);
  registerMessageRoutes(app2);
  registerConversationSettingsRoutes(app2);
  app2.get("/api/admin/reports", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "reports.view")) {
        return res.status(403).json({ message: "Missing permission: reports.view" });
      }
      const { status, type, reporterId, dateFrom, dateTo } = req.query;
      const validStatuses = ["PENDING", "REVIEWED", "RESOLVED", "DISMISSED"];
      const validTypes = ["user", "post"];
      const filters = {};
      if (status && validStatuses.includes(status)) {
        filters.status = status;
      }
      if (type && validTypes.includes(type)) {
        filters.type = type;
      }
      if (reporterId && typeof reporterId === "string") {
        filters.reporterId = reporterId;
      }
      if (dateFrom && typeof dateFrom === "string") {
        filters.dateFrom = new Date(dateFrom);
      }
      if (dateTo && typeof dateTo === "string") {
        filters.dateTo = new Date(dateTo);
      }
      const reports2 = await storage.getReportsWithFilters(filters);
      res.json(reports2);
    } catch (error) {
      res.status(500).json({ message: "Failed to get reports" });
    }
  });
  app2.get("/api/admin/reports/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "reports.view")) {
        return res.status(403).json({ message: "Missing permission: reports.view" });
      }
      const report = await storage.getReportWithDetails(req.params.id);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      res.json(report);
    } catch (error) {
      res.status(500).json({ message: "Failed to get report" });
    }
  });
  app2.patch("/api/admin/reports/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "reports.manage")) {
        return res.status(403).json({ message: "Missing permission: reports.manage" });
      }
      const { status, notes } = req.body;
      const validStatuses = ["PENDING", "REVIEWED", "RESOLVED", "DISMISSED"];
      if (!status || !validStatuses.includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }
      const adminId = req.session.userId;
      const report = await storage.updateReportStatus(
        req.params.id,
        status,
        adminId,
        notes
      );
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      await storage.createAuditLog(
        adminId,
        "UPDATE",
        "report",
        req.params.id,
        { status, notes },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(report);
    } catch (error) {
      res.status(500).json({ message: "Failed to update report" });
    }
  });
  app2.post("/api/admin/reports/:id/action", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "reports.manage")) {
        return res.status(403).json({ message: "Missing permission: reports.manage" });
      }
      const { action, reason } = req.body;
      const reportId = req.params.id;
      const adminId = req.session.userId;
      const report = await storage.getReportWithDetails(reportId);
      if (!report) {
        return res.status(404).json({ message: "Report not found" });
      }
      let actionResult = null;
      switch (action) {
        case "suspend_user":
          if (!report.reportedUserId) {
            return res.status(400).json({ message: "No user to suspend in this report" });
          }
          if (!reason) {
            return res.status(400).json({ message: "Reason is required for suspension" });
          }
          actionResult = await storage.suspendUser(report.reportedUserId, adminId, reason);
          await storage.createAuditLog(
            adminId,
            "UPDATE",
            "user",
            report.reportedUserId,
            { action: "suspend", reason, fromReport: reportId },
            req.ip,
            req.headers["user-agent"]
          );
          break;
        case "hide_post":
          if (!report.reportedPostId) {
            return res.status(400).json({ message: "No post to hide in this report" });
          }
          actionResult = await storage.hidePost(report.reportedPostId, adminId, reason || "Reported content");
          await storage.createAuditLog(
            adminId,
            "UPDATE",
            "post",
            report.reportedPostId,
            { action: "hide", reason, fromReport: reportId },
            req.ip,
            req.headers["user-agent"]
          );
          break;
        case "delete_post":
          if (!report.reportedPostId) {
            return res.status(400).json({ message: "No post to delete in this report" });
          }
          await storage.hardDeletePost(report.reportedPostId);
          actionResult = { deleted: true };
          await storage.createAuditLog(
            adminId,
            "DELETE",
            "post",
            report.reportedPostId,
            { action: "hard_delete", reason, fromReport: reportId },
            req.ip,
            req.headers["user-agent"]
          );
          break;
        default:
          return res.status(400).json({ message: "Invalid action" });
      }
      await storage.updateReportStatus(reportId, "RESOLVED", adminId, `Action taken: ${action}`);
      await storage.createAuditLog(
        adminId,
        "UPDATE",
        "report",
        reportId,
        { status: "RESOLVED", action },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ success: true, action, result: actionResult });
    } catch (error) {
      res.status(500).json({ message: "Failed to take action on report" });
    }
  });
  app2.get("/api/users/me/admin", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId);
      res.json({ isAdmin: user?.isAdmin || false });
    } catch (error) {
      res.status(500).json({ message: "Failed to check admin status" });
    }
  });
  app2.get("/api/admin/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminStats();
      res.json(stats);
    } catch (error) {
      res.status(500).json({ message: "Failed to get stats" });
    }
  });
  app2.get("/api/admin/dashboard/overview", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdvancedDashboardStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get dashboard overview:", error?.message || error, error?.stack);
      res.status(500).json({
        message: "Failed to get dashboard overview",
        error: error?.message || String(error),
        stack: process.env.NODE_ENV === "development" ? error?.stack : void 0
      });
    }
  });
  app2.get("/api/admin/dashboard/user-growth", requireAdmin, async (req, res) => {
    try {
      const days = parseInt(req.query.days) || 30;
      const data = await storage.getDashboardUserGrowth(days);
      res.json(data);
    } catch (error) {
      console.error("Failed to get user growth data:", error);
      res.status(500).json({ message: "Failed to get user growth data" });
    }
  });
  app2.get("/api/admin/dashboard/engagement-trends", requireAdmin, async (req, res) => {
    try {
      const days = parseInt(req.query.days) || 30;
      const data = await storage.getDashboardEngagementTrends(days);
      res.json(data);
    } catch (error) {
      console.error("Failed to get engagement trends:", error);
      res.status(500).json({ message: "Failed to get engagement trends" });
    }
  });
  app2.get("/api/admin/dashboard/activity-feed", requireAdmin, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const feed = await storage.getDashboardActivityFeed(limit);
      res.json(feed);
    } catch (error) {
      console.error("Failed to get activity feed:", error);
      res.status(500).json({ message: "Failed to get activity feed" });
    }
  });
  app2.get("/api/admin/dashboard/top-performers", requireAdmin, async (req, res) => {
    try {
      const data = await storage.getDashboardTopPerformers();
      res.json(data);
    } catch (error) {
      console.error("Failed to get top performers:", error);
      res.status(500).json({ message: "Failed to get top performers" });
    }
  });
  app2.get("/api/admin/dashboard/content-distribution", requireAdmin, async (req, res) => {
    try {
      const data = await storage.getDashboardContentDistribution();
      res.json(data);
    } catch (error) {
      console.error("Failed to get content distribution:", error);
      res.status(500).json({ message: "Failed to get content distribution" });
    }
  });
  app2.get("/api/admin/dashboard/peak-hours", requireAdmin, async (req, res) => {
    try {
      const data = await storage.getDashboardPeakHours();
      res.json(data);
    } catch (error) {
      console.error("Failed to get peak hours data:", error);
      res.status(500).json({ message: "Failed to get peak hours data" });
    }
  });
  app2.get("/api/admin/content/velocity/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminContentVelocityStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get content velocity stats:", error);
      res.status(500).json({ message: "Failed to get content velocity stats" });
    }
  });
  app2.get("/api/admin/content/trending", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const timeframe = req.query.timeframe || "24h";
      const result = await storage.getAdminTrendingPosts({ page, limit, timeframe });
      res.json(result);
    } catch (error) {
      console.error("Failed to get trending posts:", error);
      res.status(500).json({ message: "Failed to get trending posts" });
    }
  });
  app2.get("/api/admin/content/daily-trends", requireAdmin, async (req, res) => {
    try {
      const days = parseInt(req.query.days) || 7;
      const trends = await storage.getAdminDailyTrends(days);
      res.json({ trends });
    } catch (error) {
      console.error("Failed to get daily trends:", error);
      res.status(500).json({ message: "Failed to get daily trends" });
    }
  });
  app2.get("/api/admin/content/velocity/:postId", requireAdmin, async (req, res) => {
    try {
      const { postId } = req.params;
      const velocity = await storage.getAdminPostVelocity(postId);
      if (!velocity) {
        return res.status(404).json({ message: "Post not found" });
      }
      res.json(velocity);
    } catch (error) {
      console.error("Failed to get post velocity:", error);
      res.status(500).json({ message: "Failed to get post velocity" });
    }
  });
  app2.get("/api/admin/users", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "users.view")) {
        return res.status(403).json({ message: "Missing permission: users.view" });
      }
      const users4 = await storage.getAllUsers();
      res.json(users4);
    } catch (error) {
      res.status(500).json({ message: "Failed to get users" });
    }
  });
  app2.get("/api/admin/users/wealth", requireAdmin, async (req, res) => {
    try {
      const search = req.query.search || "";
      const sortOrder = req.query.sortOrder || "desc";
      let query = db.select({
        id: users.id,
        username: users.username,
        displayName: users.displayName,
        avatarUrl: users.avatarUrl,
        netWorth: users.netWorth,
        netWorthTier: users.netWorthTier,
        isVerified: users.isVerified,
        createdAt: users.createdAt
      }).from(users);
      if (search) {
        query = query.where(
          or10(
            like2(users.username, `%${search}%`),
            like2(users.displayName, `%${search}%`)
          )
        );
      }
      if (sortOrder === "asc") {
        query = query.orderBy(asc4(users.netWorth));
      } else {
        query = query.orderBy(desc11(users.netWorth));
      }
      const userList = await query.limit(100);
      res.json(userList);
    } catch (error) {
      console.error("Failed to get user wealth data:", error);
      res.status(500).json({ message: "Failed to get user wealth data" });
    }
  });
  app2.get("/api/admin/users/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "users.view")) {
        return res.status(403).json({ message: "Missing permission: users.view" });
      }
      const user = await storage.getAdminUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const userRoles2 = await storage.getUserRoles(req.params.id);
      res.json({ ...user, roles: userRoles2 });
    } catch (error) {
      res.status(500).json({ message: "Failed to get user" });
    }
  });
  app2.patch("/api/admin/users/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "users.manage")) {
        return res.status(403).json({ message: "Missing permission: users.manage" });
      }
      const { displayName, username, bio, avatarUrl, coverUrl, category, linkUrl, location, pronouns, netWorth, influenceScore, isVerified, isAdmin } = req.body;
      const updateData = {};
      if (displayName !== void 0) updateData.displayName = displayName;
      if (username !== void 0) updateData.username = username;
      if (bio !== void 0) updateData.bio = bio;
      if (avatarUrl !== void 0) updateData.avatarUrl = avatarUrl;
      if (coverUrl !== void 0) updateData.coverUrl = coverUrl;
      if (category !== void 0) updateData.category = category;
      if (linkUrl !== void 0) updateData.linkUrl = linkUrl;
      if (location !== void 0) updateData.location = location;
      if (pronouns !== void 0) updateData.pronouns = pronouns;
      if (netWorth !== void 0) updateData.netWorth = netWorth;
      if (influenceScore !== void 0) updateData.influenceScore = influenceScore;
      if (isVerified !== void 0) {
        updateData.isVerified = isVerified;
        if (isVerified) updateData.verifiedAt = /* @__PURE__ */ new Date();
        else updateData.verifiedAt = null;
      }
      if (isAdmin !== void 0) updateData.isAdmin = isAdmin;
      const user = await storage.adminUpdateUser(req.params.id, updateData);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        "UPDATE",
        "user",
        req.params.id,
        { changes: updateData },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(user);
    } catch (error) {
      res.status(500).json({ message: "Failed to update user" });
    }
  });
  app2.post("/api/admin/users/:id/suspend", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "users.suspend")) {
        return res.status(403).json({ message: "Missing permission: users.suspend" });
      }
      const { reason, durationDays } = req.body;
      if (!reason) {
        return res.status(400).json({ message: "Reason is required" });
      }
      const user = await storage.suspendUser(
        req.params.id,
        req.session.userId,
        reason,
        durationDays
      );
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        "USER_SUSPENDED",
        "user",
        req.params.id,
        { reason, durationDays },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(user);
    } catch (error) {
      res.status(500).json({ message: "Failed to suspend user" });
    }
  });
  app2.post("/api/admin/users/:id/unsuspend", requireAdmin, async (req, res) => {
    try {
      const user = await storage.unsuspendUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        "USER_ACTIVATED",
        "user",
        req.params.id,
        {},
        req.ip,
        req.headers["user-agent"]
      );
      res.json(user);
    } catch (error) {
      res.status(500).json({ message: "Failed to unsuspend user" });
    }
  });
  app2.get("/api/admin/users/:id/settings", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      const canRead = await hasPermission2(adminUser, "users.settings.read");
      if (!canRead) {
        return res.status(403).json({ message: "Missing permission: users.settings.read" });
      }
      const settings = await storage.getUserSettings(req.params.id);
      if (!settings) {
        return res.json({ message: "No settings found for user", settings: null });
      }
      res.json(settings);
    } catch (error) {
      res.status(500).json({ message: "Failed to get user settings" });
    }
  });
  app2.patch("/api/admin/users/:id/settings", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      const canWrite = await hasPermission2(adminUser, "users.settings.write");
      if (!canWrite) {
        return res.status(403).json({ message: "Missing permission: users.settings.write" });
      }
      const { privateAccount, commentPolicy, messagePolicy, mentionPolicy } = req.body;
      const updateData = {};
      if (privateAccount !== void 0) updateData.privateAccount = privateAccount;
      if (commentPolicy !== void 0) updateData.commentPolicy = commentPolicy;
      if (messagePolicy !== void 0) updateData.messagePolicy = messagePolicy;
      if (mentionPolicy !== void 0) updateData.mentionPolicy = mentionPolicy;
      const settings = await storage.updateUserSettings(req.params.id, updateData);
      await storage.createAuditLog(
        req.session.userId,
        "UPDATE",
        "user_settings",
        req.params.id,
        { changes: updateData },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(settings);
    } catch (error) {
      res.status(500).json({ message: "Failed to update user settings" });
    }
  });
  app2.post("/api/admin/users/:id/force-logout", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      const canForce = await hasPermission2(adminUser, "users.force_logout");
      if (!canForce) {
        return res.status(403).json({ message: "Missing permission: users.force_logout" });
      }
      await db.execute(sql11`DELETE FROM session WHERE sess->>'userId' = ${req.params.id}`);
      await storage.createAuditLog(
        req.session.userId,
        "USER_FORCE_LOGOUT",
        "user",
        req.params.id,
        {},
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "User logged out from all sessions" });
    } catch (error) {
      res.status(500).json({ message: "Failed to force logout user" });
    }
  });
  app2.post("/api/admin/users/:id/deactivate", requireAdmin, async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.adminUpdateUser(req.params.id, { deactivatedAt: /* @__PURE__ */ new Date() });
      await db.execute(sql11`DELETE FROM session WHERE sess->>'userId' = ${req.params.id}`);
      await storage.createAuditLog(
        req.session.userId,
        "USER_DEACTIVATED",
        "user",
        req.params.id,
        {},
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "User deactivated" });
    } catch (error) {
      res.status(500).json({ message: "Failed to deactivate user" });
    }
  });
  app2.post("/api/admin/users/:id/reactivate", requireAdmin, async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.adminUpdateUser(req.params.id, { deactivatedAt: null });
      await storage.createAuditLog(
        req.session.userId,
        "USER_REACTIVATED",
        "user",
        req.params.id,
        {},
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "User reactivated" });
    } catch (error) {
      res.status(500).json({ message: "Failed to reactivate user" });
    }
  });
  app2.post("/api/admin/users/:id/roles", requireAdmin, async (req, res) => {
    try {
      const { roleId, action } = req.body;
      if (!roleId || !action) {
        return res.status(400).json({ message: "roleId and action are required" });
      }
      if (action !== "assign" && action !== "remove") {
        return res.status(400).json({ message: "action must be 'assign' or 'remove'" });
      }
      const adminUser = await storage.getUser(req.session.userId);
      if (!adminUser?.isAdmin) {
        return res.status(403).json({ message: "Insufficient permissions to manage roles" });
      }
      if (action === "assign") {
        await storage.assignRole(req.params.id, roleId, req.session.userId);
        await storage.createAuditLog(
          req.session.userId,
          "ROLE_ASSIGNED",
          "user",
          req.params.id,
          { roleId },
          req.ip,
          req.headers["user-agent"]
        );
      } else {
        await storage.removeRole(req.params.id, roleId);
        await storage.createAuditLog(
          req.session.userId,
          "ROLE_REMOVED",
          "user",
          req.params.id,
          { roleId },
          req.ip,
          req.headers["user-agent"]
        );
      }
      const updatedRoles = await storage.getUserRoles(req.params.id);
      res.json({ roles: updatedRoles });
    } catch (error) {
      res.status(500).json({ message: "Failed to manage roles" });
    }
  });
  app2.get("/api/admin/posts", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.view")) {
        return res.status(403).json({ message: "Missing permission: content.view" });
      }
      const { type, visibility, hidden, deleted, limit = "100", offset = "0" } = req.query;
      const filters = {};
      if (type && typeof type === "string" && ["TEXT", "PHOTO", "VIDEO", "VOICE"].includes(type)) {
        filters.type = type;
      }
      if (visibility && typeof visibility === "string" && ["PUBLIC", "FOLLOWERS", "PRIVATE"].includes(visibility)) {
        filters.visibility = visibility;
      }
      if (hidden === "true") filters.isHidden = true;
      if (hidden === "false") filters.isHidden = false;
      if (deleted === "true") filters.isDeleted = true;
      if (deleted === "false") filters.isDeleted = false;
      const posts3 = await storage.getAdminPosts(
        filters,
        parseInt(limit, 10),
        parseInt(offset, 10)
      );
      res.json(posts3);
    } catch (error) {
      res.status(500).json({ message: "Failed to get posts" });
    }
  });
  app2.patch("/api/admin/posts/:id", requireAdmin, async (req, res) => {
    try {
      const { action, reason } = req.body;
      const postId = req.params.id;
      if (!action) {
        return res.status(400).json({ message: "action is required" });
      }
      const adminUser = await storage.getUser(req.session.userId);
      let post;
      let auditAction = "UPDATE";
      switch (action) {
        case "hide":
          if (!await hasPermission2(adminUser, "content.hide")) {
            return res.status(403).json({ message: "Missing permission: content.hide" });
          }
          if (!reason) {
            return res.status(400).json({ message: "reason is required for hiding" });
          }
          post = await storage.hidePost(postId, req.session.userId, reason);
          auditAction = "CONTENT_HIDDEN";
          break;
        case "unhide":
          if (!await hasPermission2(adminUser, "content.unhide")) {
            return res.status(403).json({ message: "Missing permission: content.unhide" });
          }
          post = await storage.unhidePost(postId);
          auditAction = "CONTENT_UNHIDDEN";
          break;
        case "soft_delete":
          if (!await hasPermission2(adminUser, "content.soft_delete")) {
            return res.status(403).json({ message: "Missing permission: content.soft_delete" });
          }
          post = await storage.softDeletePost(postId, req.session.userId, reason);
          auditAction = "CONTENT_SOFT_DELETED";
          break;
        case "feature":
          post = await storage.featurePost(postId, true);
          break;
        case "unfeature":
          post = await storage.featurePost(postId, false);
          break;
        default:
          return res.status(400).json({ message: "Invalid action" });
      }
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        auditAction,
        "post",
        postId,
        { action, reason },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(post);
    } catch (error) {
      res.status(500).json({ message: "Failed to update post" });
    }
  });
  app2.delete("/api/admin/posts/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      const adminRoles = await storage.getUserRoles(req.session.userId);
      const isSuperAdmin = adminRoles.some((r) => r.name === "SUPER_ADMIN") || adminUser?.isAdmin;
      if (!isSuperAdmin) {
        return res.status(403).json({ message: "Only SUPER_ADMIN can hard delete posts" });
      }
      const post = await storage.getAdminPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      await storage.hardDeletePost(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "post",
        req.params.id,
        { content: (post.content || post.caption || "").substring(0, 100), authorId: post.authorId },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "Post deleted permanently" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete post" });
    }
  });
  app2.get("/api/admin/comments", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.view")) {
        return res.status(403).json({ message: "Missing permission: content.view" });
      }
      const comments3 = await storage.getAllCommentsWithAuthors();
      res.json(comments3);
    } catch (error) {
      res.status(500).json({ message: "Failed to get comments" });
    }
  });
  app2.patch("/api/admin/comments/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.hide")) {
        return res.status(403).json({ message: "Missing permission: content.hide" });
      }
      const { action, reason } = req.body;
      const commentId = req.params.id;
      if (!action) {
        return res.status(400).json({ message: "action is required" });
      }
      let comment;
      switch (action) {
        case "hide":
          if (!reason) {
            return res.status(400).json({ message: "reason is required for hiding" });
          }
          comment = await storage.hideComment(commentId, req.session.userId, reason);
          break;
        case "unhide":
          comment = await storage.unhideComment(commentId);
          break;
        default:
          return res.status(400).json({ message: "Invalid action" });
      }
      if (!comment) {
        return res.status(404).json({ message: "Comment not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        "UPDATE",
        "comment",
        commentId,
        { action, reason },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(comment);
    } catch (error) {
      res.status(500).json({ message: "Failed to update comment" });
    }
  });
  app2.delete("/api/admin/comments/:id", requireAdmin, async (req, res) => {
    try {
      const comment = await storage.getAdminComment(req.params.id);
      if (!comment) {
        return res.status(404).json({ message: "Comment not found" });
      }
      await storage.hardDeleteComment(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "comment",
        req.params.id,
        { content: comment.content.substring(0, 100), authorId: comment.authorId, postId: comment.postId },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "Comment deleted permanently" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete comment" });
    }
  });
  app2.get("/api/admin/playlists", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "playlists.view")) {
        return res.status(403).json({ message: "Missing permission: playlists.view" });
      }
      const { type, userId, limit = "100", offset = "0" } = req.query;
      const playlists2 = await storage.getAdminPlaylists(
        type,
        userId,
        parseInt(limit, 10),
        parseInt(offset, 10)
      );
      res.json(playlists2);
    } catch (error) {
      res.status(500).json({ message: "Failed to get playlists" });
    }
  });
  app2.delete("/api/admin/playlists/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "playlists.manage")) {
        return res.status(403).json({ message: "Missing permission: playlists.manage" });
      }
      const playlist = await storage.getPlaylistById(req.params.id);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      await storage.deletePlaylist(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "playlist",
        req.params.id,
        { title: playlist.title, userId: playlist.userId },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "Playlist deleted" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete playlist" });
    }
  });
  app2.get("/api/admin/featured-intros", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "featured.view")) {
        return res.status(403).json({ message: "Missing permission: featured.view" });
      }
      const featuredIntros2 = await storage.getAllFeaturedIntros();
      res.json(featuredIntros2);
    } catch (error) {
      res.status(500).json({ message: "Failed to get featured intros" });
    }
  });
  app2.delete("/api/admin/featured-intros/:id", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "featured.manage")) {
        return res.status(403).json({ message: "Missing permission: featured.manage" });
      }
      const featuredIntro = await storage.getFeaturedIntro(req.params.id);
      if (!featuredIntro) {
        return res.status(404).json({ message: "Featured intro not found" });
      }
      await storage.deleteFeaturedIntro(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "FEATURED_REMOVED",
        "featured_intro",
        req.params.id,
        { title: featuredIntro.title, userId: featuredIntro.userId },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "Featured intro deleted" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete featured intro" });
    }
  });
  app2.get("/api/admin/users/:id/profile-full", requireAdmin, async (req, res) => {
    try {
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const [highlights, note, links, interests, relationshipPartner] = await Promise.all([
        storage.getStoryHighlights(req.params.id),
        storage.getUserNote(req.params.id),
        storage.getUserLinks(req.params.id),
        storage.getUserInterests(req.params.id),
        user.relationshipPartnerId ? storage.getUser(user.relationshipPartnerId) : null
      ]);
      res.json({
        ...user,
        highlights,
        note,
        links,
        interests,
        relationshipPartner: relationshipPartner ? {
          id: relationshipPartner.id,
          username: relationshipPartner.username,
          displayName: relationshipPartner.displayName,
          avatarUrl: relationshipPartner.avatarUrl
        } : null
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get user profile" });
    }
  });
  app2.patch("/api/admin/users/:id/profile-enhancements", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "users.settings.write")) {
        return res.status(403).json({ message: "Missing permission: users.settings.write" });
      }
      const user = await storage.getUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const {
        birthday,
        profileSongUrl,
        profileSongTitle,
        profileSongArtist,
        avatarVideoUrl,
        voiceBioUrl,
        voiceBioDurationMs,
        contactEmail,
        contactPhone,
        contactAddress,
        relationshipStatus,
        relationshipPartnerId,
        themeColor,
        themeStyle
      } = req.body;
      const updated = await storage.updateProfileEnhancements(req.params.id, {
        birthday: birthday ? new Date(birthday) : void 0,
        profileSongUrl,
        profileSongTitle,
        profileSongArtist,
        avatarVideoUrl,
        voiceBioUrl,
        voiceBioDurationMs,
        contactEmail,
        contactPhone,
        contactAddress,
        relationshipStatus,
        relationshipPartnerId,
        themeColor,
        themeStyle
      });
      await storage.createAuditLog(
        req.session.userId,
        "UPDATE",
        "user",
        req.params.id,
        { profileEnhancements: req.body },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update user profile enhancements" });
    }
  });
  app2.delete("/api/admin/highlights/:highlightId", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.soft_delete")) {
        return res.status(403).json({ message: "Missing permission: content.soft_delete" });
      }
      const highlight = await storage.getStoryHighlight(req.params.highlightId);
      if (!highlight) {
        return res.status(404).json({ message: "Highlight not found" });
      }
      await storage.deleteStoryHighlight(req.params.highlightId);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "story_highlight",
        req.params.highlightId,
        { name: highlight.name, userId: highlight.userId },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "Highlight deleted" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete highlight" });
    }
  });
  app2.delete("/api/admin/users/:userId/note", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.soft_delete")) {
        return res.status(403).json({ message: "Missing permission: content.soft_delete" });
      }
      await storage.deleteUserNote(req.params.userId);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "user_note",
        req.params.userId,
        {},
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "User note deleted" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete user note" });
    }
  });
  app2.delete("/api/admin/links/:linkId", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.soft_delete")) {
        return res.status(403).json({ message: "Missing permission: content.soft_delete" });
      }
      const link = await storage.getUserLink(req.params.linkId);
      if (!link) {
        return res.status(404).json({ message: "Link not found" });
      }
      await storage.deleteUserLink(req.params.linkId);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "user_link",
        req.params.linkId,
        { title: link.title, userId: link.userId },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "Link deleted" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete link" });
    }
  });
  app2.delete("/api/admin/users/:userId/interests", requireAdmin, async (req, res) => {
    try {
      const adminUser = await storage.getUser(req.session.userId);
      if (!await hasPermission2(adminUser, "content.soft_delete")) {
        return res.status(403).json({ message: "Missing permission: content.soft_delete" });
      }
      await storage.setUserInterests(req.params.userId, []);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "user_interests",
        req.params.userId,
        {},
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "User interests cleared" });
    } catch (error) {
      res.status(500).json({ message: "Failed to clear user interests" });
    }
  });
  app2.get("/api/admin/analytics/platform", requireAdmin, async (req, res) => {
    try {
      const analytics = await storage.getAdminPlatformAnalytics();
      res.json(analytics);
    } catch (error) {
      console.error("Failed to get platform analytics:", error);
      res.status(500).json({ message: "Failed to get platform analytics" });
    }
  });
  app2.get("/api/admin/analytics/trends", requireAdmin, async (req, res) => {
    try {
      const days = parseInt(req.query.days) || 30;
      const trends = await storage.getAdminUsageTrends(days);
      res.json(trends);
    } catch (error) {
      console.error("Failed to get usage trends:", error);
      res.status(500).json({ message: "Failed to get usage trends" });
    }
  });
  app2.get("/api/admin/analytics/retention", requireAdmin, async (req, res) => {
    try {
      const retention = await storage.getAdminRetentionMetrics();
      res.json(retention);
    } catch (error) {
      console.error("Failed to get retention metrics:", error);
      res.status(500).json({ message: "Failed to get retention metrics" });
    }
  });
  app2.get("/api/admin/threads/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminThreadStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get thread stats:", error);
      res.status(500).json({ message: "Failed to get thread statistics" });
    }
  });
  app2.get("/api/admin/threads", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search;
      const result = await storage.getAdminPostThreads({ page, limit, search });
      res.json(result);
    } catch (error) {
      console.error("Failed to get threads:", error);
      res.status(500).json({ message: "Failed to get threads" });
    }
  });
  app2.get("/api/admin/duet-stitch", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const type = req.query.type;
      const result = await storage.getAdminDuetStitchPosts({ page, limit, type });
      res.json(result);
    } catch (error) {
      console.error("Failed to get duet/stitch posts:", error);
      res.status(500).json({ message: "Failed to get duet/stitch posts" });
    }
  });
  app2.delete("/api/admin/threads/:id", requireAdmin, async (req, res) => {
    try {
      await storage.adminDeleteThread(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "thread",
        req.params.id,
        { action: "admin_delete_thread" }
      );
      res.json({ message: "Thread deleted successfully" });
    } catch (error) {
      console.error("Failed to delete thread:", error);
      res.status(error.message === "Thread not found" ? 404 : 500).json({
        message: error.message || "Failed to delete thread"
      });
    }
  });
  app2.delete("/api/admin/duet-stitch/:id", requireAdmin, async (req, res) => {
    try {
      await storage.adminDeleteDuetStitch(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "duet_stitch",
        req.params.id,
        { action: "admin_delete_duet_stitch" }
      );
      res.json({ message: "Duet/Stitch deleted successfully" });
    } catch (error) {
      console.error("Failed to delete duet/stitch:", error);
      res.status(error.message === "Duet/Stitch not found" ? 404 : 500).json({
        message: error.message || "Failed to delete duet/stitch"
      });
    }
  });
  app2.get("/api/admin/roles", requireAdmin, async (req, res) => {
    try {
      const roles2 = await storage.getAllRolesWithPermissions();
      res.json(roles2);
    } catch (error) {
      res.status(500).json({ message: "Failed to get roles" });
    }
  });
  app2.get("/api/admin/roles/:id", requireAdmin, async (req, res) => {
    try {
      const role = await storage.getRoleWithPermissions(req.params.id);
      if (!role) {
        return res.status(404).json({ message: "Role not found" });
      }
      res.json(role);
    } catch (error) {
      res.status(500).json({ message: "Failed to get role" });
    }
  });
  app2.post("/api/admin/roles", requireAdmin, async (req, res) => {
    try {
      const { name, displayName, description, level } = req.body;
      if (!name || !displayName) {
        return res.status(400).json({ message: "Name and display name are required" });
      }
      const existing = await storage.getRoleByName(name.toUpperCase().replace(/\s+/g, "_"));
      if (existing) {
        return res.status(400).json({ message: "A role with this name already exists" });
      }
      const role = await storage.createRole({ name, displayName, description, level });
      await storage.createAuditLog(
        req.session.userId,
        "CREATE",
        "role",
        role.id,
        { name: role.name, displayName: role.displayName },
        req.ip,
        req.headers["user-agent"]
      );
      res.status(201).json(role);
    } catch (error) {
      res.status(500).json({ message: "Failed to create role" });
    }
  });
  app2.patch("/api/admin/roles/:id", requireAdmin, async (req, res) => {
    try {
      const { displayName, description, level } = req.body;
      const existing = await storage.getRoleById(req.params.id);
      if (!existing) {
        return res.status(404).json({ message: "Role not found" });
      }
      if (existing.isSystem && level !== void 0 && level !== existing.level) {
        return res.status(403).json({ message: "Cannot change level of system roles" });
      }
      const role = await storage.updateRole(req.params.id, { displayName, description, level });
      await storage.createAuditLog(
        req.session.userId,
        "UPDATE",
        "role",
        req.params.id,
        { displayName, description, level },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(role);
    } catch (error) {
      res.status(500).json({ message: "Failed to update role" });
    }
  });
  app2.delete("/api/admin/roles/:id", requireAdmin, async (req, res) => {
    try {
      const role = await storage.getRoleById(req.params.id);
      if (!role) {
        return res.status(404).json({ message: "Role not found" });
      }
      if (role.isSystem) {
        return res.status(403).json({ message: "Cannot delete system roles" });
      }
      if (role.name === "SUPER_ADMIN") {
        return res.status(403).json({ message: "Cannot delete SUPER_ADMIN role" });
      }
      await storage.deleteRole(req.params.id);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "role",
        req.params.id,
        { name: role.name, displayName: role.displayName },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "Role deleted" });
    } catch (error) {
      res.status(500).json({ message: "Failed to delete role" });
    }
  });
  app2.get("/api/admin/permissions", requireAdmin, async (req, res) => {
    try {
      const byGroup = req.query.grouped === "true";
      if (byGroup) {
        const permissions2 = await storage.getPermissionsByGroup();
        res.json(permissions2);
      } else {
        const permissions2 = await storage.getAllPermissions();
        res.json(permissions2);
      }
    } catch (error) {
      res.status(500).json({ message: "Failed to get permissions" });
    }
  });
  app2.post("/api/admin/roles/:id/permissions", requireAdmin, async (req, res) => {
    try {
      const { permissionIds } = req.body;
      const role = await storage.getRoleById(req.params.id);
      if (!role) {
        return res.status(404).json({ message: "Role not found" });
      }
      if (!Array.isArray(permissionIds)) {
        return res.status(400).json({ message: "permissionIds must be an array" });
      }
      const previousPermissions = await storage.getRolePermissions(req.params.id);
      await storage.setRolePermissions(req.params.id, permissionIds);
      await storage.createAuditLog(
        req.session.userId,
        "PERMISSION_GRANTED",
        "role",
        req.params.id,
        {
          previousCount: previousPermissions.length,
          newCount: permissionIds.length,
          permissionIds
        },
        req.ip,
        req.headers["user-agent"]
      );
      const updated = await storage.getRoleWithPermissions(req.params.id);
      res.json(updated);
    } catch (error) {
      res.status(500).json({ message: "Failed to update role permissions" });
    }
  });
  app2.get("/api/admin/security/2fa/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdmin2FAStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get 2FA stats:", error);
      res.status(500).json({ message: "Failed to get 2FA statistics" });
    }
  });
  app2.get("/api/admin/security/2fa", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search || "";
      const result = await storage.getAdminTotpSecrets({ page, limit, search });
      res.json(result);
    } catch (error) {
      console.error("Failed to get 2FA users:", error);
      res.status(500).json({ message: "Failed to get 2FA users" });
    }
  });
  app2.post("/api/admin/security/2fa/:userId/reset", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.adminReset2FA(userId);
      await storage.createAuditLog(
        req.session.userId,
        "UPDATE",
        "user",
        userId,
        { action: "reset_2fa", targetUsername: user.username },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "2FA reset successfully", userId, username: user.username });
    } catch (error) {
      console.error("Failed to reset 2FA:", error);
      res.status(500).json({ message: "Failed to reset 2FA" });
    }
  });
  app2.get("/api/admin/security/sessions/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminSessionStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get session stats:", error);
      res.status(500).json({ message: "Failed to get session statistics" });
    }
  });
  app2.get("/api/admin/security/sessions", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search || "";
      const activeOnly = req.query.activeOnly === "true";
      const result = await storage.getAdminLoginSessions({ page, limit, search, activeOnly });
      res.json(result);
    } catch (error) {
      console.error("Failed to get sessions:", error);
      res.status(500).json({ message: "Failed to get sessions" });
    }
  });
  app2.post("/api/admin/security/sessions/:sessionId/terminate", requireAdmin, async (req, res) => {
    try {
      const { sessionId } = req.params;
      await storage.adminTerminateSession(sessionId);
      await storage.createAuditLog(
        req.session.userId,
        "UPDATE",
        "login_session",
        sessionId,
        { action: "terminate_session" },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "Session terminated successfully", sessionId });
    } catch (error) {
      console.error("Failed to terminate session:", error);
      res.status(500).json({ message: "Failed to terminate session" });
    }
  });
  app2.post("/api/admin/security/sessions/user/:userId/terminate-all", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const count5 = await storage.adminTerminateAllUserSessions(userId);
      await storage.createAuditLog(
        req.session.userId,
        "UPDATE",
        "user",
        userId,
        { action: "terminate_all_sessions", sessionsTerminated: count5, targetUsername: user.username },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "All sessions terminated", userId, username: user.username, count: count5 });
    } catch (error) {
      console.error("Failed to terminate all sessions:", error);
      res.status(500).json({ message: "Failed to terminate all sessions" });
    }
  });
  app2.get("/api/admin/security/devices/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminDeviceStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get device stats:", error);
      res.status(500).json({ message: "Failed to get device stats" });
    }
  });
  app2.get("/api/admin/security/devices", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search || "";
      const result = await storage.getAdminTrustedDevices({ page, limit, search });
      res.json(result);
    } catch (error) {
      console.error("Failed to get devices:", error);
      res.status(500).json({ message: "Failed to get devices" });
    }
  });
  app2.delete("/api/admin/security/devices/:deviceId", requireAdmin, async (req, res) => {
    try {
      const { deviceId } = req.params;
      const device = await storage.getTrustedDevice(deviceId);
      if (!device) {
        return res.status(404).json({ message: "Device not found" });
      }
      const user = await storage.getUser(device.userId);
      await storage.adminRemoveTrustedDevice(deviceId);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "trusted_device",
        deviceId,
        { action: "remove_device", deviceName: device.deviceName, targetUserId: device.userId, targetUsername: user?.username },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "Device removed", deviceId, deviceName: device.deviceName });
    } catch (error) {
      console.error("Failed to remove device:", error);
      res.status(500).json({ message: "Failed to remove device" });
    }
  });
  app2.delete("/api/admin/security/devices/user/:userId", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const count5 = await storage.adminRemoveAllUserDevices(userId);
      await storage.createAuditLog(
        req.session.userId,
        "DELETE",
        "trusted_device",
        userId,
        { action: "remove_all_user_devices", devicesRemoved: count5, targetUsername: user.username },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "All devices removed", userId, username: user.username, count: count5 });
    } catch (error) {
      console.error("Failed to remove all devices:", error);
      res.status(500).json({ message: "Failed to remove all devices" });
    }
  });
  app2.get("/api/admin/algorithm", requireAdmin, async (req, res) => {
    try {
      const algorithmInfo = getAlgorithmDescription();
      res.json(algorithmInfo);
    } catch (error) {
      res.status(500).json({ message: "Failed to get algorithm config" });
    }
  });
  app2.patch("/api/admin/algorithm", requireAdmin, async (req, res) => {
    try {
      const { weights } = req.body;
      if (!weights || typeof weights !== "object") {
        return res.status(400).json({ message: "Weights object required" });
      }
      const updated = updateAlgorithmWeights(weights);
      await storage.createAuditLog(
        req.session.userId,
        "SETTING_CHANGED",
        "algorithm",
        "algorithm_weights",
        { newValue: JSON.stringify(updated) }
      );
      res.json({ message: "Algorithm weights updated", weights: updated });
    } catch (error) {
      res.status(500).json({ message: "Failed to update algorithm config" });
    }
  });
  app2.post("/api/admin/algorithm/reset", requireAdmin, async (req, res) => {
    try {
      const defaults = resetAlgorithmWeights();
      await storage.createAuditLog(
        req.session.userId,
        "SETTING_CHANGED",
        "algorithm",
        "algorithm_weights",
        { action: "reset_to_defaults" }
      );
      res.json({ message: "Algorithm weights reset to defaults", weights: defaults });
    } catch (error) {
      res.status(500).json({ message: "Failed to reset algorithm config" });
    }
  });
  app2.get("/api/admin/settings", requireAdmin, async (req, res) => {
    try {
      const settings = await storage.getAppSettings();
      res.json(settings);
    } catch (error) {
      res.status(500).json({ message: "Failed to get settings" });
    }
  });
  app2.patch("/api/admin/settings", requireAdmin, async (req, res) => {
    try {
      const { settings } = req.body;
      if (!Array.isArray(settings)) {
        return res.status(400).json({ message: "Settings must be an array" });
      }
      const previousSettings = await storage.getAppSettings();
      const previousMap = new Map(previousSettings.map((s) => [s.key, s.value]));
      const results = await storage.updateAppSettings(settings, req.session.userId);
      for (const setting of settings) {
        const previousValue = previousMap.get(setting.key);
        await storage.createAuditLog(
          req.session.userId,
          "SETTING_CHANGED",
          "setting",
          setting.key,
          {
            key: setting.key,
            previousValue,
            newValue: typeof setting.value === "object" ? JSON.stringify(setting.value) : String(setting.value),
            type: setting.type
          },
          req.ip,
          req.headers["user-agent"]
        );
      }
      res.json(results);
    } catch (error) {
      console.error("Failed to update settings:", error);
      res.status(500).json({ message: "Failed to update settings" });
    }
  });
  app2.get("/api/settings/flags", async (req, res) => {
    try {
      const maintenanceMode = await storage.getAppSettingValue("maintenanceMode", false);
      const signupEnabled = await storage.getAppSettingValue("signupEnabled", true);
      const chatEnabled = await storage.getAppSettingValue("chatEnabled", true);
      const maxPostLength = await storage.getAppSettingValue("maxPostLength", 500);
      res.json({
        maintenanceMode,
        signupEnabled,
        chatEnabled,
        maxPostLength
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to get feature flags" });
    }
  });
  app2.get("/api/admin/audit", requireAdmin, async (req, res) => {
    try {
      const { actorId, action, targetType, startDate, endDate, limit, offset } = req.query;
      const filters = {};
      if (actorId && typeof actorId === "string") filters.actorId = actorId;
      if (action && typeof action === "string") filters.action = action;
      if (targetType && typeof targetType === "string") filters.targetType = targetType;
      if (startDate && typeof startDate === "string") filters.startDate = new Date(startDate);
      if (endDate && typeof endDate === "string") filters.endDate = new Date(endDate);
      if (limit && typeof limit === "string") filters.limit = parseInt(limit, 10);
      if (offset && typeof offset === "string") filters.offset = parseInt(offset, 10);
      const result = await storage.getAuditLogs(filters);
      res.json(result);
    } catch (error) {
      console.error("Failed to get audit logs:", error);
      res.status(500).json({ message: "Failed to get audit logs" });
    }
  });
  app2.get("/api/admin/overview", requireAdmin, async (req, res) => {
    try {
      const overview = await storage.getAnalyticsOverview();
      res.json(overview);
    } catch (error) {
      console.error("Failed to get overview:", error);
      res.status(500).json({ message: "Failed to get overview" });
    }
  });
  app2.post("/api/admin/users/:id/ban", requireAdmin, async (req, res) => {
    try {
      const user = await storage.suspendUser(req.params.id, req.session.userId, "Banned by admin");
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        "USER_BANNED",
        "user",
        req.params.id,
        { reason: "Banned by admin" },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "User banned successfully" });
    } catch (error) {
      console.error("Failed to ban user:", error);
      res.status(500).json({ message: "Failed to ban user" });
    }
  });
  app2.post("/api/admin/users/:id/unban", requireAdmin, async (req, res) => {
    try {
      const user = await storage.unsuspendUser(req.params.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        "USER_UNBANNED",
        "user",
        req.params.id,
        {},
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "User unbanned successfully" });
    } catch (error) {
      console.error("Failed to unban user:", error);
      res.status(500).json({ message: "Failed to unban user" });
    }
  });
  app2.get("/api/admin/activity", requireAdmin, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 10;
      const logs = await storage.getAuditLogs({ limit });
      res.json(logs.logs || []);
    } catch (error) {
      console.error("Failed to get activity:", error);
      res.status(500).json({ message: "Failed to get activity" });
    }
  });
  app2.get("/api/admin/analytics", requireAdmin, async (req, res) => {
    try {
      const sevenDaysAgo = /* @__PURE__ */ new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      const overview = await storage.getAnalyticsOverview();
      const stats = await storage.getAdminStats();
      res.json({
        totalUsers: overview?.totalUsers || 0,
        totalPosts: overview?.totalPosts || 0,
        totalMessages: overview?.totalMessages || 0,
        newUsers7d: overview?.newUsers7d || 0,
        posts7d: overview?.posts7d || 0,
        messages7d: overview?.messages7d || 0,
        openReports: overview?.openReports || 0,
        stats: {
          users: stats?.users || 0,
          posts: stats?.posts || 0,
          comments: stats?.comments || 0,
          reports: stats?.reports || 0
        }
      });
    } catch (error) {
      console.error("Failed to get analytics:", error);
      res.status(500).json({ message: "Failed to get analytics" });
    }
  });
  app2.get("/api/admin/audit-logs", requireAdmin, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const logs = await storage.getAuditLogs({ limit });
      res.json(logs.logs || []);
    } catch (error) {
      console.error("Failed to get audit logs:", error);
      res.status(500).json({ message: "Failed to get audit logs" });
    }
  });
  app2.post("/api/admin/settings", requireAdmin, async (req, res) => {
    try {
      await storage.createAuditLog(
        req.session.userId,
        "SETTINGS_UPDATED",
        "settings",
        "app",
        req.body,
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "Settings updated" });
    } catch (error) {
      console.error("Failed to update settings:", error);
      res.status(500).json({ message: "Failed to update settings" });
    }
  });
  app2.get("/api/admin/ar-filters/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminARFilterStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get AR filter stats:", error);
      res.status(500).json({ message: "Failed to get AR filter stats" });
    }
  });
  app2.get("/api/admin/ar-filters", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search;
      const featured = req.query.featured === "true" ? true : req.query.featured === "false" ? false : void 0;
      const result = await storage.getAdminARFilters({ page, limit, search, featured });
      res.json(result);
    } catch (error) {
      console.error("Failed to get AR filters:", error);
      res.status(500).json({ message: "Failed to get AR filters" });
    }
  });
  app2.post("/api/admin/ar-filters", requireAdmin, async (req, res) => {
    try {
      const { name, description, previewUrl, filterUrl, category } = req.body;
      if (!name || !previewUrl || !filterUrl) {
        return res.status(400).json({ message: "Name, preview URL, and filter URL are required" });
      }
      const filter = await storage.adminCreateARFilter({
        name,
        description,
        previewUrl,
        filterUrl,
        category
      });
      await storage.createAuditLog(
        req.session.userId,
        "AR_FILTER_CREATED",
        "ar_filter",
        filter.id,
        { name, category },
        req.ip,
        req.headers["user-agent"]
      );
      res.status(201).json(filter);
    } catch (error) {
      console.error("Failed to create AR filter:", error);
      res.status(500).json({ message: "Failed to create AR filter" });
    }
  });
  app2.put("/api/admin/ar-filters/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, description, previewUrl, filterUrl, category } = req.body;
      const updateData = {};
      if (name !== void 0) updateData.name = name;
      if (description !== void 0) updateData.description = description;
      if (previewUrl !== void 0) updateData.thumbnailUrl = previewUrl;
      if (filterUrl !== void 0) updateData.filterUrl = filterUrl;
      if (category !== void 0) updateData.category = category;
      const filter = await storage.adminUpdateARFilter(id, updateData);
      if (!filter) {
        return res.status(404).json({ message: "AR filter not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        "AR_FILTER_UPDATED",
        "ar_filter",
        id,
        updateData,
        req.ip,
        req.headers["user-agent"]
      );
      res.json(filter);
    } catch (error) {
      console.error("Failed to update AR filter:", error);
      res.status(500).json({ message: "Failed to update AR filter" });
    }
  });
  app2.post("/api/admin/ar-filters/:id/feature", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { featured } = req.body;
      const filter = await storage.adminFeatureARFilter(id, !!featured);
      if (!filter) {
        return res.status(404).json({ message: "AR filter not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        featured ? "AR_FILTER_FEATURED" : "AR_FILTER_UNFEATURED",
        "ar_filter",
        id,
        { featured },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(filter);
    } catch (error) {
      console.error("Failed to feature AR filter:", error);
      res.status(500).json({ message: "Failed to feature AR filter" });
    }
  });
  app2.post("/api/admin/ar-filters/:id/toggle", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { active } = req.body;
      const filter = await storage.adminToggleARFilter(id, !!active);
      if (!filter) {
        return res.status(404).json({ message: "AR filter not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        active ? "AR_FILTER_ENABLED" : "AR_FILTER_DISABLED",
        "ar_filter",
        id,
        { active },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(filter);
    } catch (error) {
      console.error("Failed to toggle AR filter:", error);
      res.status(500).json({ message: "Failed to toggle AR filter" });
    }
  });
  app2.delete("/api/admin/ar-filters/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.adminDeleteARFilter(id);
      await storage.createAuditLog(
        req.session.userId,
        "AR_FILTER_DELETED",
        "ar_filter",
        id,
        {},
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "AR filter deleted" });
    } catch (error) {
      console.error("Failed to delete AR filter:", error);
      res.status(500).json({ message: "Failed to delete AR filter" });
    }
  });
  app2.get("/api/admin/ai/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminAIContentStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get AI content stats:", error);
      res.status(500).json({ message: "Failed to get AI content stats" });
    }
  });
  app2.get("/api/admin/ai/avatars", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const status = req.query.status;
      const result = await storage.getAdminAIAvatars({ page, limit, status });
      res.json(result);
    } catch (error) {
      console.error("Failed to get AI avatars:", error);
      res.status(500).json({ message: "Failed to get AI avatars" });
    }
  });
  app2.post("/api/admin/ai/avatars/:id/review", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { status, reason } = req.body;
      if (!status || !["approved", "rejected"].includes(status)) {
        return res.status(400).json({ message: "Invalid status. Must be 'approved' or 'rejected'" });
      }
      const avatar = await storage.adminReviewAIAvatar(id, status, reason);
      if (!avatar) {
        return res.status(404).json({ message: "Avatar not found" });
      }
      await storage.createAuditLog(
        req.session.userId,
        status === "approved" ? "AI_AVATAR_APPROVED" : "AI_AVATAR_REJECTED",
        "ai_avatar",
        id,
        { status, reason },
        req.ip,
        req.headers["user-agent"]
      );
      res.json(avatar);
    } catch (error) {
      console.error("Failed to review AI avatar:", error);
      res.status(500).json({ message: "Failed to review AI avatar" });
    }
  });
  app2.delete("/api/admin/ai/avatars/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const avatar = await storage.getAIAvatarById(id);
      if (!avatar) {
        return res.status(404).json({ message: "Avatar not found" });
      }
      await storage.adminDeleteAIAvatar(id);
      await storage.createAuditLog(
        req.session.userId,
        "AI_AVATAR_DELETED",
        "ai_avatar",
        id,
        { name: avatar.name },
        req.ip,
        req.headers["user-agent"]
      );
      res.json({ message: "AI avatar deleted" });
    } catch (error) {
      console.error("Failed to delete AI avatar:", error);
      res.status(500).json({ message: "Failed to delete AI avatar" });
    }
  });
  app2.get("/api/admin/ai/translations", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const result = await storage.getAdminAITranslations({ page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to get AI translations:", error);
      res.status(500).json({ message: "Failed to get AI translations" });
    }
  });
  app2.get("/api/admin/explore/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminExploreCategoryStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get explore category stats:", error);
      res.status(500).json({ message: "Failed to get explore category stats" });
    }
  });
  app2.get("/api/admin/explore/categories", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 50;
      const result = await storage.getAdminExploreCategories({ page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to get explore categories:", error);
      res.status(500).json({ message: "Failed to get explore categories" });
    }
  });
  app2.post("/api/admin/explore/categories", requireAdmin, async (req, res) => {
    try {
      const { name, slug, description, iconUrl, color, order } = req.body;
      if (!name || !slug) {
        return res.status(400).json({ message: "Name and slug are required" });
      }
      const category = await storage.adminCreateExploreCategory({
        name,
        slug,
        description,
        iconUrl,
        color,
        order
      });
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "create",
        targetType: "explore_category",
        targetId: category.id,
        details: { name, slug }
      });
      res.status(201).json(category);
    } catch (error) {
      console.error("Failed to create explore category:", error);
      if (error.code === "23505") {
        return res.status(400).json({ message: "A category with this slug already exists" });
      }
      res.status(500).json({ message: "Failed to create explore category" });
    }
  });
  app2.put("/api/admin/explore/categories/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, slug, description, iconUrl, color, order, isActive } = req.body;
      const existing = await storage.getExploreCategoryById(id);
      if (!existing) {
        return res.status(404).json({ message: "Category not found" });
      }
      const updated = await storage.adminUpdateExploreCategory(id, {
        name,
        slug,
        description,
        iconUrl,
        color,
        order,
        isActive
      });
      await storage.createAuditLog({
        action: "update",
        targetType: "explore_category",
        targetId: id,
        actorId: req.session.userId,
        details: { name, slug }
      });
      res.json(updated);
    } catch (error) {
      console.error("Failed to update explore category:", error);
      if (error.code === "23505") {
        return res.status(400).json({ message: "A category with this slug already exists" });
      }
      res.status(500).json({ message: "Failed to update explore category" });
    }
  });
  app2.post("/api/admin/explore/categories/reorder", requireAdmin, async (req, res) => {
    try {
      const { categoryIds } = req.body;
      if (!Array.isArray(categoryIds) || categoryIds.length === 0) {
        return res.status(400).json({ message: "categoryIds array is required" });
      }
      await storage.adminReorderExploreCategories(categoryIds);
      await storage.createAuditLog({
        action: "update",
        targetType: "explore_category",
        targetId: "bulk",
        actorId: req.session.userId,
        details: { action: "reorder", count: categoryIds.length }
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to reorder explore categories:", error);
      res.status(500).json({ message: "Failed to reorder explore categories" });
    }
  });
  app2.delete("/api/admin/explore/categories/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getExploreCategoryById(id);
      if (!existing) {
        return res.status(404).json({ message: "Category not found" });
      }
      await storage.adminDeleteExploreCategory(id);
      await storage.createAuditLog({
        action: "delete",
        targetType: "explore_category",
        targetId: id,
        actorId: req.session.userId,
        details: { name: existing.name, slug: existing.slug }
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete explore category:", error);
      res.status(500).json({ message: "Failed to delete explore category" });
    }
  });
  app2.get("/api/admin/profiles/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminUserProfileStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get profile stats:", error);
      res.status(500).json({ message: "Failed to get profile stats" });
    }
  });
  app2.get("/api/admin/profiles/intros", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const status = req.query.status;
      const result = await storage.getAdminFeaturedIntros({ page, limit, status });
      res.json(result);
    } catch (error) {
      console.error("Failed to get featured intros:", error);
      res.status(500).json({ message: "Failed to get featured intros" });
    }
  });
  app2.delete("/api/admin/profiles/intros/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.adminDeleteFeaturedIntro(id);
      await storage.createAuditLog({
        action: "delete",
        targetType: "featured_intro",
        targetId: id,
        actorId: req.session.userId,
        details: {}
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete featured intro:", error);
      res.status(500).json({ message: "Failed to delete featured intro" });
    }
  });
  app2.get("/api/admin/profiles/linked-accounts", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search;
      const result = await storage.getAdminLinkedAccounts({ page, limit, search });
      res.json(result);
    } catch (error) {
      console.error("Failed to get linked accounts:", error);
      res.status(500).json({ message: "Failed to get linked accounts" });
    }
  });
  app2.delete("/api/admin/profiles/linked-accounts/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.adminUnlinkAccount(id);
      await storage.createAuditLog({
        action: "delete",
        targetType: "linked_account",
        targetId: id,
        actorId: req.session.userId,
        details: {}
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to unlink account:", error);
      res.status(500).json({ message: "Failed to unlink account" });
    }
  });
  app2.get("/api/admin/profiles/notes", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const result = await storage.getAdminUserNotesList({ page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to get user notes:", error);
      res.status(500).json({ message: "Failed to get user notes" });
    }
  });
  app2.delete("/api/admin/profiles/notes/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.adminDeleteUserNote(id);
      await storage.createAuditLog({
        action: "delete",
        targetType: "user_note",
        targetId: id,
        actorId: req.session.userId,
        details: {}
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete user note:", error);
      res.status(500).json({ message: "Failed to delete user note" });
    }
  });
  app2.get("/api/me/settings", requireAuth4, async (req, res) => {
    try {
      const settings = await storage.getOrCreateUserSettings(req.session.userId);
      res.json(settings);
    } catch (error) {
      console.error("Failed to get settings:", error);
      res.status(500).json({ message: "Failed to get settings" });
    }
  });
  app2.patch("/api/me/settings", requireAuth4, validateBody(updateSettingsSchema), async (req, res) => {
    try {
      const userId = req.session.userId;
      const updates = req.body;
      const existingSettings = await storage.getOrCreateUserSettings(userId);
      const mergedUpdates = { ...updates };
      if (updates.notifications) {
        mergedUpdates.notifications = {
          ...existingSettings.notifications,
          ...updates.notifications
        };
      }
      if (updates.pushNotifications) {
        mergedUpdates.pushNotifications = {
          ...existingSettings.pushNotifications,
          ...updates.pushNotifications
        };
      }
      if (updates.emailNotifications) {
        mergedUpdates.emailNotifications = {
          ...existingSettings.emailNotifications,
          ...updates.emailNotifications
        };
      }
      if (updates.contentPreferences) {
        mergedUpdates.contentPreferences = {
          ...existingSettings.contentPreferences,
          ...updates.contentPreferences
        };
      }
      if (updates.mediaPrefs) {
        mergedUpdates.mediaPrefs = {
          ...existingSettings.mediaPrefs,
          ...updates.mediaPrefs
        };
      }
      const settings = await storage.updateUserSettings(userId, mergedUpdates);
      if (updates.privateAccount !== void 0) {
        await storage.createAuditLog({
          actorId: userId,
          action: "SETTING_CHANGED",
          targetType: "user",
          targetId: userId,
          details: { setting: "privateAccount", value: updates.privateAccount }
        });
      }
      res.json(settings);
    } catch (error) {
      console.error("Failed to update settings:", error);
      res.status(500).json({ message: "Failed to update settings" });
    }
  });
  app2.patch("/api/me/profile", requireAuth4, validateBody(updateFullProfileSchema), async (req, res) => {
    try {
      const userId = req.session.userId;
      const updates = req.body;
      const user = await storage.updateUser(userId, updates);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const { password: _, ...safeUser } = user;
      res.json(safeUser);
    } catch (error) {
      console.error("Failed to update profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });
  app2.post("/api/me/change-password", requireAuth4, validateBody(changePasswordSchema), async (req, res) => {
    try {
      const userId = req.session.userId;
      const { currentPassword, newPassword } = req.body;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const validPassword = await bcrypt2.compare(currentPassword, user.password);
      if (!validPassword) {
        return res.status(400).json({ message: "Current password is incorrect" });
      }
      const hashedPassword = await bcrypt2.hash(newPassword, 10);
      await storage.updateUser(userId, { password: hashedPassword });
      await storage.createAuditLog({
        actorId: userId,
        action: "settings.password_changed",
        targetType: "user",
        targetId: userId,
        details: {}
      });
      res.json({ success: true, message: "Password changed successfully" });
    } catch (error) {
      console.error("Failed to change password:", error);
      res.status(500).json({ message: "Failed to change password" });
    }
  });
  app2.get("/api/me/sessions", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const result = await pool.query(
        "SELECT sid, expire FROM user_sessions WHERE (sess->>'userId') = $1 AND expire > NOW()",
        [userId]
      );
      const sessions = result.rows.map((row) => ({
        id: row.sid,
        expiresAt: row.expire,
        isCurrent: row.sid === req.sessionID
      }));
      res.json(sessions);
    } catch (error) {
      console.error("Failed to get sessions:", error);
      res.status(500).json({ message: "Failed to get sessions" });
    }
  });
  app2.post("/api/me/sessions/revoke-all", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const currentSessionId = req.sessionID;
      await pool.query(
        "DELETE FROM user_sessions WHERE (sess->>'userId') = $1 AND sid != $2",
        [userId, currentSessionId]
      );
      await storage.createAuditLog({
        actorId: userId,
        action: "settings.sessions_revoked",
        targetType: "user",
        targetId: userId,
        details: {}
      });
      res.json({ success: true, message: "All other sessions revoked" });
    } catch (error) {
      console.error("Failed to revoke sessions:", error);
      res.status(500).json({ message: "Failed to revoke sessions" });
    }
  });
  app2.post("/api/me/block/:userId", requireAuth4, async (req, res) => {
    try {
      const blockerId = req.session.userId;
      const blockedId = req.params.userId;
      if (blockerId === blockedId) {
        return res.status(400).json({ message: "Cannot block yourself" });
      }
      const blockedUser = await storage.getUser(blockedId);
      if (!blockedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.blockUser(blockerId, blockedId);
      res.json({ success: true, message: "User blocked" });
    } catch (error) {
      console.error("Failed to block user:", error);
      res.status(500).json({ message: "Failed to block user" });
    }
  });
  app2.post("/api/me/unblock/:userId", requireAuth4, async (req, res) => {
    try {
      const blockerId = req.session.userId;
      const blockedId = req.params.userId;
      await storage.unblockUser(blockerId, blockedId);
      res.json({ success: true, message: "User unblocked" });
    } catch (error) {
      console.error("Failed to unblock user:", error);
      res.status(500).json({ message: "Failed to unblock user" });
    }
  });
  app2.get("/api/me/blocked", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const blockedUsers = await storage.getBlockedUsers(userId);
      const safeUsers = blockedUsers.map((u) => ({ ...u, password: void 0 }));
      res.json(safeUsers);
    } catch (error) {
      console.error("Failed to get blocked users:", error);
      res.status(500).json({ message: "Failed to get blocked users" });
    }
  });
  app2.post("/api/me/export", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const posts3 = await storage.getUserPosts(userId);
      const settings = await storage.getOrCreateUserSettings(userId);
      const exportData = {
        exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
        profile: {
          username: user.username,
          displayName: user.displayName,
          bio: user.bio,
          email: user.email,
          location: user.location,
          linkUrl: user.linkUrl,
          category: user.category,
          netWorth: user.netWorth,
          influenceScore: user.influenceScore,
          createdAt: user.createdAt
        },
        settings: {
          privateAccount: settings.privateAccount,
          commentPolicy: settings.commentPolicy,
          messagePolicy: settings.messagePolicy,
          mentionPolicy: settings.mentionPolicy,
          notifications: settings.notifications,
          mediaPrefs: settings.mediaPrefs
        },
        posts: posts3.map((p) => ({
          id: p.id,
          type: p.type,
          content: p.content,
          caption: p.caption,
          visibility: p.visibility,
          likesCount: p.likesCount,
          commentsCount: p.commentsCount,
          sharesCount: p.sharesCount,
          viewsCount: p.viewsCount,
          createdAt: p.createdAt
        })),
        postCount: posts3.length
      };
      await storage.createAuditLog({
        actorId: userId,
        action: "SETTING_CHANGED",
        targetType: "user",
        targetId: userId,
        details: { operation: "data_export" }
      });
      res.json(exportData);
    } catch (error) {
      console.error("Failed to export data:", error);
      res.status(500).json({ message: "Failed to export data" });
    }
  });
  app2.post("/api/me/deactivate", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const user = await storage.updateUser(userId, {
        deactivatedAt: /* @__PURE__ */ new Date()
      });
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      await storage.createAuditLog({
        actorId: userId,
        action: "USER_DEACTIVATED",
        targetType: "user",
        targetId: userId,
        details: { selfDeactivated: true }
      });
      req.session.destroy((err) => {
        if (err) {
          console.error("Session destroy error:", err);
        }
        res.json({ success: true, message: "Account deactivated" });
      });
    } catch (error) {
      console.error("Failed to deactivate account:", error);
      res.status(500).json({ message: "Failed to deactivate account" });
    }
  });
  app2.delete("/api/me", requireAuth4, validateBody(deleteAccountSchema), async (req, res) => {
    try {
      const userId = req.session.userId;
      const { password } = req.body;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const validPassword = await bcrypt2.compare(password, user.password);
      if (!validPassword) {
        return res.status(400).json({ message: "Password is incorrect" });
      }
      await storage.createAuditLog({
        actorId: userId,
        action: "DELETE",
        targetType: "user",
        targetId: userId,
        details: { username: user.username, selfDeleted: true }
      });
      await storage.deleteUser(userId);
      req.session.destroy((err) => {
        if (err) {
          console.error("Session destroy error:", err);
        }
        res.json({ success: true, message: "Account deleted permanently" });
      });
    } catch (error) {
      console.error("Failed to delete account:", error);
      res.status(500).json({ message: "Failed to delete account" });
    }
  });
  app2.post("/api/me/verification", requireAuth4, validateBody(submitVerificationSchema), async (req, res) => {
    try {
      const userId = req.session.userId;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      if (user.isVerified) {
        return res.status(400).json({ message: "You are already verified" });
      }
      const latestRequest = await storage.getLatestUserVerificationRequest(userId);
      if (latestRequest) {
        if (latestRequest.status === "SUBMITTED" || latestRequest.status === "UNDER_REVIEW") {
          return res.status(400).json({
            message: "You already have a pending verification request",
            status: latestRequest.status
          });
        }
        if (latestRequest.status === "DENIED" || latestRequest.status === "MORE_INFO_NEEDED") {
          const cooldownDays = 7;
          const cooldownEnd = new Date(latestRequest.updatedAt.getTime() + cooldownDays * 24 * 60 * 60 * 1e3);
          if (/* @__PURE__ */ new Date() < cooldownEnd) {
            const daysLeft = Math.ceil((cooldownEnd.getTime() - (/* @__PURE__ */ new Date()).getTime()) / (24 * 60 * 60 * 1e3));
            return res.status(400).json({
              message: `Please wait ${daysLeft} more day(s) before resubmitting`,
              cooldownEndsAt: cooldownEnd.toISOString()
            });
          }
        }
      }
      const request = await storage.createVerificationRequest({
        userId,
        fullName: req.body.fullName,
        category: req.body.category,
        documentUrls: req.body.documentUrls,
        links: req.body.links || [],
        reason: req.body.reason
      });
      await storage.createAuditLog({
        actorId: userId,
        action: "CREATE",
        targetType: "verification",
        targetId: request.id,
        details: { category: request.category }
      });
      res.status(201).json(request);
    } catch (error) {
      console.error("Failed to submit verification request:", error);
      res.status(500).json({ message: "Failed to submit verification request" });
    }
  });
  app2.get("/api/me/verification", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const latestRequest = await storage.getLatestUserVerificationRequest(userId);
      res.json({
        isVerified: user.isVerified,
        verifiedAt: user.verifiedAt,
        latestRequest: latestRequest || null
      });
    } catch (error) {
      console.error("Failed to get verification status:", error);
      res.status(500).json({ message: "Failed to get verification status" });
    }
  });
  app2.get("/api/me/verification/history", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const requests = await storage.getUserVerificationRequests(userId);
      res.json(requests);
    } catch (error) {
      console.error("Failed to get verification history:", error);
      res.status(500).json({ message: "Failed to get verification history" });
    }
  });
  app2.get("/api/admin/verification", requireAdmin, async (req, res) => {
    try {
      const viewer = await getViewerContext(req.session.userId);
      const canView = await hasPermission(viewer, "verification.view");
      if (!canView) {
        return res.status(403).json({ message: "Permission denied" });
      }
      const { status, category, limit, offset } = req.query;
      const filters = {};
      if (status && typeof status === "string") filters.status = status;
      if (category && typeof category === "string") filters.category = category;
      if (limit && typeof limit === "string") filters.limit = parseInt(limit, 10);
      if (offset && typeof offset === "string") filters.offset = parseInt(offset, 10);
      const requests = await storage.getVerificationRequests(filters);
      res.json(requests);
    } catch (error) {
      console.error("Failed to get verification requests:", error);
      res.status(500).json({ message: "Failed to get verification requests" });
    }
  });
  app2.get("/api/admin/verification/:id", requireAdmin, async (req, res) => {
    try {
      const viewer = await getViewerContext(req.session.userId);
      const canView = await hasPermission(viewer, "verification.view");
      if (!canView) {
        return res.status(403).json({ message: "Permission denied" });
      }
      const request = await storage.getVerificationRequest(req.params.id);
      if (!request) {
        return res.status(404).json({ message: "Verification request not found" });
      }
      res.json(request);
    } catch (error) {
      console.error("Failed to get verification request:", error);
      res.status(500).json({ message: "Failed to get verification request" });
    }
  });
  app2.post("/api/admin/verification/:id/action", requireAdmin, validateBody(verificationActionSchema), async (req, res) => {
    try {
      const viewer = await getViewerContext(req.session.userId);
      const canManage = await hasPermission(viewer, "verification.manage");
      if (!canManage) {
        return res.status(403).json({ message: "Permission denied" });
      }
      const adminId = req.session.userId;
      const requestId = req.params.id;
      const { action, reason, notes } = req.body;
      const existingRequest = await storage.getVerificationRequest(requestId);
      if (!existingRequest) {
        return res.status(404).json({ message: "Verification request not found" });
      }
      if (existingRequest.status === "APPROVED") {
        return res.status(400).json({ message: "This request has already been approved" });
      }
      let updatedRequest;
      let auditAction;
      switch (action) {
        case "approve":
          updatedRequest = await storage.approveVerification(requestId, adminId, notes);
          auditAction = "verification.approved";
          break;
        case "deny":
          if (!reason) {
            return res.status(400).json({ message: "Reason is required when denying a request" });
          }
          updatedRequest = await storage.denyVerification(requestId, adminId, reason, notes);
          auditAction = "verification.denied";
          break;
        case "request_info":
          if (!notes) {
            return res.status(400).json({ message: "Notes are required when requesting more info" });
          }
          updatedRequest = await storage.requestMoreInfo(requestId, adminId, notes);
          auditAction = "verification.info_requested";
          break;
        default:
          return res.status(400).json({ message: "Invalid action" });
      }
      await storage.createAuditLog({
        actorId: adminId,
        action: auditAction,
        targetType: "verification",
        targetId: requestId,
        details: {
          userId: existingRequest.userId,
          previousStatus: existingRequest.status,
          newStatus: updatedRequest?.status,
          reason
        }
      });
      if (updatedRequest) {
        await storage.createNotification(
          existingRequest.userId,
          adminId,
          action === "approve" ? "VERIFICATION_APPROVED" : action === "deny" ? "VERIFICATION_DENIED" : "VERIFICATION_INFO_NEEDED",
          requestId
        );
      }
      res.json(updatedRequest);
    } catch (error) {
      console.error("Failed to process verification action:", error);
      res.status(500).json({ message: "Failed to process verification action" });
    }
  });
  app2.get("/api/studio/overview", requireAuth4, async (req, res) => {
    try {
      const viewerContext = await getViewerContext(req.session.userId);
      const targetUserId = req.query.userId || req.session.userId;
      if (targetUserId !== req.session.userId) {
        if (!await hasPermission(viewerContext, "studio.view_others")) {
          return res.status(403).json({ message: "Not authorized to view other users' studio" });
        }
      }
      const startDate = req.query.startDate ? new Date(req.query.startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
      const endDate = req.query.endDate ? new Date(req.query.endDate) : /* @__PURE__ */ new Date();
      const overview = await storage.getStudioOverview(targetUserId, startDate, endDate);
      res.json(overview);
    } catch (error) {
      console.error("Failed to get studio overview:", error);
      res.status(500).json({ message: "Failed to get studio overview" });
    }
  });
  app2.get("/api/studio/content", requireAuth4, async (req, res) => {
    try {
      const viewerContext = await getViewerContext(req.session.userId);
      const targetUserId = req.query.userId || req.session.userId;
      if (targetUserId !== req.session.userId) {
        if (!await hasPermission(viewerContext, "studio.view_others")) {
          return res.status(403).json({ message: "Not authorized to view other users' studio" });
        }
      }
      const startDate = req.query.startDate ? new Date(req.query.startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
      const endDate = req.query.endDate ? new Date(req.query.endDate) : /* @__PURE__ */ new Date();
      const type = req.query.type;
      const sortBy = req.query.sortBy || "views";
      const content = await storage.getStudioContent(targetUserId, startDate, endDate, type, sortBy);
      res.json(content);
    } catch (error) {
      console.error("Failed to get studio content:", error);
      res.status(500).json({ message: "Failed to get studio content" });
    }
  });
  app2.get("/api/studio/posts/:postId", requireAuth4, async (req, res) => {
    try {
      const viewerContext = await getViewerContext(req.session.userId);
      const postId = req.params.postId;
      const post = await storage.getPost(postId);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      if (post.authorId !== req.session.userId) {
        if (!await hasPermission(viewerContext, "studio.view_others")) {
          return res.status(403).json({ message: "Not authorized to view this post's analytics" });
        }
      }
      const startDate = req.query.startDate ? new Date(req.query.startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
      const endDate = req.query.endDate ? new Date(req.query.endDate) : /* @__PURE__ */ new Date();
      const detail = await storage.getStudioPostDetail(postId, startDate, endDate);
      res.json(detail);
    } catch (error) {
      console.error("Failed to get post detail:", error);
      res.status(500).json({ message: "Failed to get post detail" });
    }
  });
  app2.get("/api/studio/audience", requireAuth4, async (req, res) => {
    try {
      const viewerContext = await getViewerContext(req.session.userId);
      const targetUserId = req.query.userId || req.session.userId;
      if (targetUserId !== req.session.userId) {
        if (!await hasPermission(viewerContext, "studio.view_others")) {
          return res.status(403).json({ message: "Not authorized to view other users' studio" });
        }
      }
      const startDate = req.query.startDate ? new Date(req.query.startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
      const endDate = req.query.endDate ? new Date(req.query.endDate) : /* @__PURE__ */ new Date();
      const audience = await storage.getStudioAudience(targetUserId, startDate, endDate);
      res.json(audience);
    } catch (error) {
      console.error("Failed to get studio audience:", error);
      res.status(500).json({ message: "Failed to get studio audience" });
    }
  });
  app2.post("/api/studio/profile-view", async (req, res) => {
    try {
      const { profileUserId, source } = req.body;
      if (!profileUserId) {
        return res.status(400).json({ message: "profileUserId is required" });
      }
      const viewerId = req.session.userId || void 0;
      if (viewerId && viewerId === profileUserId) {
        return res.json({ recorded: false });
      }
      await storage.recordProfileView(profileUserId, viewerId, source || "DIRECT");
      res.json({ recorded: true });
    } catch (error) {
      console.error("Failed to record profile view:", error);
      res.status(500).json({ message: "Failed to record profile view" });
    }
  });
  app2.post("/api/studio/watch-event", async (req, res) => {
    try {
      const { postId, watchTimeMs, completed, source } = req.body;
      if (!postId || typeof watchTimeMs !== "number") {
        return res.status(400).json({ message: "postId and watchTimeMs are required" });
      }
      const userId = req.session.userId || null;
      await storage.recordWatchEvent(postId, userId, watchTimeMs, completed || false, source || "FEED");
      res.json({ recorded: true });
    } catch (error) {
      console.error("Failed to record watch event:", error);
      res.status(500).json({ message: "Failed to record watch event" });
    }
  });
  app2.get("/api/users/:userId/highlights", async (req, res) => {
    try {
      const highlights = await storage.getStoryHighlights(req.params.userId);
      res.json(highlights);
    } catch (error) {
      console.error("Failed to get story highlights:", error);
      res.status(500).json({ message: "Failed to get story highlights" });
    }
  });
  app2.post("/api/me/highlights", requireAuth4, async (req, res) => {
    try {
      const { name, coverUrl } = req.body;
      if (!name) {
        return res.status(400).json({ message: "Highlight name is required" });
      }
      const highlight = await storage.createStoryHighlight(req.session.userId, name, coverUrl);
      res.status(201).json(highlight);
    } catch (error) {
      console.error("Failed to create story highlight:", error);
      res.status(500).json({ message: "Failed to create story highlight" });
    }
  });
  app2.get("/api/highlights/:highlightId", async (req, res) => {
    try {
      const highlight = await storage.getStoryHighlight(req.params.highlightId);
      if (!highlight) {
        return res.status(404).json({ message: "Highlight not found" });
      }
      const items = await storage.getHighlightItems(req.params.highlightId);
      res.json({ ...highlight, items });
    } catch (error) {
      console.error("Failed to get story highlight:", error);
      res.status(500).json({ message: "Failed to get story highlight" });
    }
  });
  app2.patch("/api/me/highlights/:highlightId", requireAuth4, async (req, res) => {
    try {
      const highlight = await storage.getStoryHighlight(req.params.highlightId);
      if (!highlight || highlight.userId !== req.session.userId) {
        return res.status(404).json({ message: "Highlight not found" });
      }
      const { name, coverUrl, order } = req.body;
      const updated = await storage.updateStoryHighlight(req.params.highlightId, { name, coverUrl, order });
      res.json(updated);
    } catch (error) {
      console.error("Failed to update story highlight:", error);
      res.status(500).json({ message: "Failed to update story highlight" });
    }
  });
  app2.delete("/api/me/highlights/:highlightId", requireAuth4, async (req, res) => {
    try {
      const highlight = await storage.getStoryHighlight(req.params.highlightId);
      if (!highlight || highlight.userId !== req.session.userId) {
        return res.status(404).json({ message: "Highlight not found" });
      }
      await storage.deleteStoryHighlight(req.params.highlightId);
      res.json({ message: "Highlight deleted" });
    } catch (error) {
      console.error("Failed to delete story highlight:", error);
      res.status(500).json({ message: "Failed to delete story highlight" });
    }
  });
  app2.post("/api/me/highlights/:highlightId/stories", requireAuth4, async (req, res) => {
    try {
      const highlight = await storage.getStoryHighlight(req.params.highlightId);
      if (!highlight || highlight.userId !== req.session.userId) {
        return res.status(404).json({ message: "Highlight not found" });
      }
      const { storyId } = req.body;
      if (!storyId) {
        return res.status(400).json({ message: "storyId is required" });
      }
      const item = await storage.addStoryToHighlight(req.params.highlightId, storyId);
      if (!item) {
        return res.status(400).json({ message: "Story already in highlight" });
      }
      res.status(201).json(item);
    } catch (error) {
      console.error("Failed to add story to highlight:", error);
      res.status(500).json({ message: "Failed to add story to highlight" });
    }
  });
  app2.delete("/api/me/highlights/:highlightId/stories/:storyId", requireAuth4, async (req, res) => {
    try {
      const highlight = await storage.getStoryHighlight(req.params.highlightId);
      if (!highlight || highlight.userId !== req.session.userId) {
        return res.status(404).json({ message: "Highlight not found" });
      }
      await storage.removeStoryFromHighlight(req.params.highlightId, req.params.storyId);
      res.json({ message: "Story removed from highlight" });
    } catch (error) {
      console.error("Failed to remove story from highlight:", error);
      res.status(500).json({ message: "Failed to remove story from highlight" });
    }
  });
  app2.get("/api/users/:userId/enhancements", async (req, res) => {
    try {
      const user = await storage.getUser(req.params.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      let relationshipPartner = null;
      if (user.relationshipPartnerId) {
        const partner = await storage.getUser(user.relationshipPartnerId);
        if (partner) {
          relationshipPartner = {
            id: partner.id,
            username: partner.username,
            displayName: partner.displayName,
            avatarUrl: partner.avatarUrl
          };
        }
      }
      res.json({
        birthday: user.birthday,
        profileSongUrl: user.profileSongUrl,
        profileSongTitle: user.profileSongTitle,
        profileSongArtist: user.profileSongArtist,
        avatarVideoUrl: user.avatarVideoUrl,
        voiceBioUrl: user.voiceBioUrl,
        voiceBioDurationMs: user.voiceBioDurationMs,
        contactEmail: user.contactEmail,
        contactPhone: user.contactPhone,
        contactAddress: user.contactAddress,
        relationshipStatus: user.relationshipStatus,
        relationshipPartnerId: user.relationshipPartnerId,
        relationshipPartner,
        themeColor: user.themeColor,
        themeStyle: user.themeStyle,
        category: user.category,
        avatarUrl: user.avatarUrl
      });
    } catch (error) {
      console.error("Failed to get user enhancements:", error);
      res.status(500).json({ message: "Failed to get user enhancements" });
    }
  });
  app2.get("/api/users/:userId/note", async (req, res) => {
    try {
      const note = await storage.getUserNote(req.params.userId);
      res.json(note || null);
    } catch (error) {
      console.error("Failed to get user note:", error);
      res.status(500).json({ message: "Failed to get user note" });
    }
  });
  app2.post("/api/me/note", requireAuth4, async (req, res) => {
    try {
      const { content } = req.body;
      if (!content || content.length > 60) {
        return res.status(400).json({ message: "Note content is required and max 60 characters" });
      }
      const note = await storage.createUserNote(req.session.userId, content);
      res.status(201).json(note);
    } catch (error) {
      console.error("Failed to create user note:", error);
      res.status(500).json({ message: "Failed to create user note" });
    }
  });
  app2.delete("/api/me/note", requireAuth4, async (req, res) => {
    try {
      await storage.deleteUserNote(req.session.userId);
      res.json({ message: "Note deleted" });
    } catch (error) {
      console.error("Failed to delete user note:", error);
      res.status(500).json({ message: "Failed to delete user note" });
    }
  });
  app2.get("/api/users/:userId/links", async (req, res) => {
    try {
      const links = await storage.getUserLinks(req.params.userId);
      res.json(links.filter((l) => l.isActive));
    } catch (error) {
      console.error("Failed to get user links:", error);
      res.status(500).json({ message: "Failed to get user links" });
    }
  });
  app2.get("/api/me/links", requireAuth4, async (req, res) => {
    try {
      const links = await storage.getUserLinks(req.session.userId);
      res.json(links);
    } catch (error) {
      console.error("Failed to get user links:", error);
      res.status(500).json({ message: "Failed to get user links" });
    }
  });
  app2.post("/api/me/links", requireAuth4, async (req, res) => {
    try {
      const { title, url, iconType } = req.body;
      if (!title || !url) {
        return res.status(400).json({ message: "Title and URL are required" });
      }
      const link = await storage.createUserLink(req.session.userId, { title, url, iconType });
      res.status(201).json(link);
    } catch (error) {
      console.error("Failed to create user link:", error);
      res.status(500).json({ message: "Failed to create user link" });
    }
  });
  app2.patch("/api/me/links/:linkId", requireAuth4, async (req, res) => {
    try {
      const link = await storage.getUserLink(req.params.linkId);
      if (!link || link.userId !== req.session.userId) {
        return res.status(404).json({ message: "Link not found" });
      }
      const { title, url, iconType, order, isActive } = req.body;
      const updated = await storage.updateUserLink(req.params.linkId, { title, url, iconType, order, isActive });
      res.json(updated);
    } catch (error) {
      console.error("Failed to update user link:", error);
      res.status(500).json({ message: "Failed to update user link" });
    }
  });
  app2.delete("/api/me/links/:linkId", requireAuth4, async (req, res) => {
    try {
      const link = await storage.getUserLink(req.params.linkId);
      if (!link || link.userId !== req.session.userId) {
        return res.status(404).json({ message: "Link not found" });
      }
      await storage.deleteUserLink(req.params.linkId);
      res.json({ message: "Link deleted" });
    } catch (error) {
      console.error("Failed to delete user link:", error);
      res.status(500).json({ message: "Failed to delete user link" });
    }
  });
  app2.post("/api/links/:linkId/click", apiLimiter, async (req, res) => {
    try {
      await storage.incrementLinkClicks(req.params.linkId);
      res.json({ tracked: true });
    } catch (error) {
      console.error("Failed to track link click:", error);
      res.status(500).json({ message: "Failed to track link click" });
    }
  });
  app2.get("/api/users/:userId/interests", async (req, res) => {
    try {
      const interests = await storage.getUserInterests(req.params.userId);
      res.json(interests);
    } catch (error) {
      console.error("Failed to get user interests:", error);
      res.status(500).json({ message: "Failed to get user interests" });
    }
  });
  app2.get("/api/me/interests", requireAuth4, async (req, res) => {
    try {
      const interests = await storage.getUserInterests(req.session.userId);
      res.json(interests);
    } catch (error) {
      console.error("Failed to get user interests:", error);
      res.status(500).json({ message: "Failed to get user interests" });
    }
  });
  app2.post("/api/me/interests", requireAuth4, async (req, res) => {
    try {
      const { interest } = req.body;
      if (!interest) {
        return res.status(400).json({ message: "Interest is required" });
      }
      const item = await storage.addUserInterest(req.session.userId, interest);
      if (!item) {
        return res.status(400).json({ message: "Interest already exists" });
      }
      res.status(201).json(item);
    } catch (error) {
      console.error("Failed to add user interest:", error);
      res.status(500).json({ message: "Failed to add user interest" });
    }
  });
  app2.put("/api/me/interests", requireAuth4, async (req, res) => {
    try {
      const { interests } = req.body;
      if (!Array.isArray(interests)) {
        return res.status(400).json({ message: "Interests array is required" });
      }
      const items = await storage.setUserInterests(req.session.userId, interests);
      res.json(items);
    } catch (error) {
      console.error("Failed to set user interests:", error);
      res.status(500).json({ message: "Failed to set user interests" });
    }
  });
  app2.delete("/api/me/interests/:interest", requireAuth4, async (req, res) => {
    try {
      await storage.removeUserInterest(req.session.userId, decodeURIComponent(req.params.interest));
      res.json({ message: "Interest removed" });
    } catch (error) {
      console.error("Failed to remove user interest:", error);
      res.status(500).json({ message: "Failed to remove user interest" });
    }
  });
  app2.patch("/api/me/profile-enhancements", requireAuth4, async (req, res) => {
    try {
      const {
        birthday,
        profileSongUrl,
        profileSongTitle,
        profileSongArtist,
        avatarVideoUrl,
        voiceBioUrl,
        voiceBioDurationMs,
        contactEmail,
        contactPhone,
        contactAddress,
        relationshipStatus,
        relationshipPartnerId,
        themeColor,
        themeStyle
      } = req.body;
      const updated = await storage.updateProfileEnhancements(req.session.userId, {
        birthday: birthday ? new Date(birthday) : void 0,
        profileSongUrl,
        profileSongTitle,
        profileSongArtist,
        avatarVideoUrl,
        voiceBioUrl,
        voiceBioDurationMs,
        contactEmail,
        contactPhone,
        contactAddress,
        relationshipStatus,
        relationshipPartnerId,
        themeColor,
        themeStyle
      });
      res.json(updated);
    } catch (error) {
      console.error("Failed to update profile enhancements:", error);
      res.status(500).json({ message: "Failed to update profile enhancements" });
    }
  });
  app2.get("/api/users/:userId/profile-full", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.params.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const viewer = await getViewerContext(req.session.userId);
      const profileAccess = await canViewProfile(viewer, user);
      if (!profileAccess.allowed) {
        return res.status(403).json({
          message: profileAccess.reason || "Cannot view this profile",
          restricted: profileAccess.restricted
        });
      }
      const [highlights, note, links, interests, relationshipPartner] = await Promise.all([
        storage.getStoryHighlights(req.params.userId),
        storage.getUserNote(req.params.userId),
        storage.getUserLinks(req.params.userId),
        storage.getUserInterests(req.params.userId),
        user.relationshipPartnerId ? storage.getUser(user.relationshipPartnerId) : null
      ]);
      const { password: _, ...safeUser } = user;
      res.json({
        ...safeUser,
        highlights,
        note,
        links: links.filter((l) => l.isActive),
        interests,
        relationshipPartner: relationshipPartner ? {
          id: relationshipPartner.id,
          username: relationshipPartner.username,
          displayName: relationshipPartner.displayName,
          avatarUrl: relationshipPartner.avatarUrl
        } : null
      });
    } catch (error) {
      console.error("Failed to get full profile:", error);
      res.status(500).json({ message: "Failed to get full profile" });
    }
  });
  app2.get("/api/users/:userId/qr", async (req, res) => {
    try {
      const user = await storage.getUser(req.params.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const profileUrl = `${process.env.EXPO_PUBLIC_DOMAIN || "rabitchat.app"}/profile/${user.username}`;
      res.json({
        qrData: profileUrl,
        username: user.username,
        displayName: user.displayName,
        avatarUrl: user.avatarUrl
      });
    } catch (error) {
      console.error("Failed to generate QR data:", error);
      res.status(500).json({ message: "Failed to generate QR data" });
    }
  });
  app2.get("/api/security/sessions", requireAuth4, async (req, res) => {
    try {
      const sessions = await storage.getLoginSessions(req.session.userId);
      res.json(sessions);
    } catch (error) {
      console.error("Failed to get login sessions:", error);
      res.status(500).json({ message: "Failed to get login sessions" });
    }
  });
  app2.delete("/api/security/sessions/:sessionId", requireAuth4, async (req, res) => {
    try {
      const session2 = await storage.getLoginSession(req.params.sessionId);
      if (!session2 || session2.userId !== req.session.userId) {
        return res.status(404).json({ message: "Session not found" });
      }
      await storage.invalidateLoginSession(req.params.sessionId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to invalidate session:", error);
      res.status(500).json({ message: "Failed to invalidate session" });
    }
  });
  app2.post("/api/security/sessions/logout-all", requireAuth4, async (req, res) => {
    try {
      await storage.invalidateAllLoginSessions(req.session.userId, req.session.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to logout all sessions:", error);
      res.status(500).json({ message: "Failed to logout all sessions" });
    }
  });
  app2.get("/api/security/devices", requireAuth4, async (req, res) => {
    try {
      const devices = await storage.getTrustedDevices(req.session.userId);
      res.json(devices);
    } catch (error) {
      console.error("Failed to get trusted devices:", error);
      res.status(500).json({ message: "Failed to get trusted devices" });
    }
  });
  app2.post("/api/security/devices", requireAuth4, async (req, res) => {
    try {
      const { deviceId, deviceName, deviceType, browser, os } = req.body;
      if (!deviceId || !deviceName) {
        return res.status(400).json({ message: "Device ID and name are required" });
      }
      const device = await storage.addTrustedDevice(req.session.userId, {
        deviceId,
        deviceName,
        deviceType,
        browser,
        os
      });
      res.json(device);
    } catch (error) {
      console.error("Failed to add trusted device:", error);
      res.status(500).json({ message: "Failed to add trusted device" });
    }
  });
  app2.delete("/api/security/devices/:deviceId", requireAuth4, async (req, res) => {
    try {
      const device = await storage.getTrustedDevice(req.params.deviceId);
      if (!device || device.userId !== req.session.userId) {
        return res.status(404).json({ message: "Device not found" });
      }
      await storage.removeTrustedDevice(req.params.deviceId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to remove trusted device:", error);
      res.status(500).json({ message: "Failed to remove trusted device" });
    }
  });
  app2.get("/api/privacy/restricted", requireAuth4, async (req, res) => {
    try {
      const restricted = await storage.getRestrictedAccounts(req.session.userId);
      res.json(restricted);
    } catch (error) {
      console.error("Failed to get restricted accounts:", error);
      res.status(500).json({ message: "Failed to get restricted accounts" });
    }
  });
  app2.post("/api/privacy/restricted/:userId", requireAuth4, async (req, res) => {
    try {
      const { reason } = req.body;
      const restricted = await storage.restrictAccount(req.session.userId, req.params.userId, reason);
      res.json(restricted);
    } catch (error) {
      console.error("Failed to restrict account:", error);
      res.status(500).json({ message: "Failed to restrict account" });
    }
  });
  app2.delete("/api/privacy/restricted/:userId", requireAuth4, async (req, res) => {
    try {
      await storage.unrestrictAccount(req.session.userId, req.params.userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to unrestrict account:", error);
      res.status(500).json({ message: "Failed to unrestrict account" });
    }
  });
  app2.get("/api/privacy/muted", requireAuth4, async (req, res) => {
    try {
      const muted = await storage.getMutedAccounts(req.session.userId);
      res.json(muted);
    } catch (error) {
      console.error("Failed to get muted accounts:", error);
      res.status(500).json({ message: "Failed to get muted accounts" });
    }
  });
  app2.post("/api/privacy/muted/:userId", requireAuth4, async (req, res) => {
    try {
      const { mutePosts, muteStories, muteMessages } = req.body;
      const muted = await storage.muteAccount(req.session.userId, req.params.userId, {
        mutePosts,
        muteStories,
        muteMessages
      });
      res.json(muted);
    } catch (error) {
      console.error("Failed to mute account:", error);
      res.status(500).json({ message: "Failed to mute account" });
    }
  });
  app2.delete("/api/privacy/muted/:userId", requireAuth4, async (req, res) => {
    try {
      await storage.unmuteAccount(req.session.userId, req.params.userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to unmute account:", error);
      res.status(500).json({ message: "Failed to unmute account" });
    }
  });
  app2.get("/api/privacy/keyword-filters", requireAuth4, async (req, res) => {
    try {
      const filters = await storage.getKeywordFilters(req.session.userId);
      res.json(filters);
    } catch (error) {
      console.error("Failed to get keyword filters:", error);
      res.status(500).json({ message: "Failed to get keyword filters" });
    }
  });
  app2.post("/api/privacy/keyword-filters", requireAuth4, async (req, res) => {
    try {
      const { keyword, filterComments, filterMessages, filterPosts } = req.body;
      if (!keyword) {
        return res.status(400).json({ message: "Keyword is required" });
      }
      const filter = await storage.addKeywordFilter(req.session.userId, keyword, {
        filterComments,
        filterMessages,
        filterPosts
      });
      res.json(filter);
    } catch (error) {
      console.error("Failed to add keyword filter:", error);
      res.status(500).json({ message: "Failed to add keyword filter" });
    }
  });
  app2.patch("/api/privacy/keyword-filters/:filterId", requireAuth4, async (req, res) => {
    try {
      const filter = await storage.getKeywordFilter(req.params.filterId);
      if (!filter || filter.userId !== req.session.userId) {
        return res.status(404).json({ message: "Filter not found" });
      }
      const updated = await storage.updateKeywordFilter(req.params.filterId, req.body);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update keyword filter:", error);
      res.status(500).json({ message: "Failed to update keyword filter" });
    }
  });
  app2.delete("/api/privacy/keyword-filters/:filterId", requireAuth4, async (req, res) => {
    try {
      const filter = await storage.getKeywordFilter(req.params.filterId);
      if (!filter || filter.userId !== req.session.userId) {
        return res.status(404).json({ message: "Filter not found" });
      }
      await storage.removeKeywordFilter(req.params.filterId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to remove keyword filter:", error);
      res.status(500).json({ message: "Failed to remove keyword filter" });
    }
  });
  app2.get("/api/privacy/close-friends", requireAuth4, async (req, res) => {
    try {
      const friends = await storage.getCloseFriends(req.session.userId);
      res.json(friends);
    } catch (error) {
      console.error("Failed to get close friends:", error);
      res.status(500).json({ message: "Failed to get close friends" });
    }
  });
  app2.post("/api/privacy/close-friends/:userId", requireAuth4, async (req, res) => {
    try {
      const friend = await storage.addCloseFriend(req.session.userId, req.params.userId);
      res.json(friend);
    } catch (error) {
      console.error("Failed to add close friend:", error);
      res.status(500).json({ message: "Failed to add close friend" });
    }
  });
  app2.delete("/api/privacy/close-friends/:userId", requireAuth4, async (req, res) => {
    try {
      await storage.removeCloseFriend(req.session.userId, req.params.userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to remove close friend:", error);
      res.status(500).json({ message: "Failed to remove close friend" });
    }
  });
  app2.get("/api/privacy/story-restrictions", requireAuth4, async (req, res) => {
    try {
      const restricted = await storage.getStoryViewerRestrictions(req.session.userId);
      res.json(restricted);
    } catch (error) {
      console.error("Failed to get story restrictions:", error);
      res.status(500).json({ message: "Failed to get story restrictions" });
    }
  });
  app2.post("/api/privacy/story-restrictions/:userId", requireAuth4, async (req, res) => {
    try {
      const restriction = await storage.addStoryViewerRestriction(req.session.userId, req.params.userId);
      res.json(restriction);
    } catch (error) {
      console.error("Failed to add story restriction:", error);
      res.status(500).json({ message: "Failed to add story restriction" });
    }
  });
  app2.delete("/api/privacy/story-restrictions/:userId", requireAuth4, async (req, res) => {
    try {
      await storage.removeStoryViewerRestriction(req.session.userId, req.params.userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to remove story restriction:", error);
      res.status(500).json({ message: "Failed to remove story restriction" });
    }
  });
  app2.get("/api/drafts", requireAuth4, async (req, res) => {
    try {
      const drafts2 = await storage.getUserDrafts(req.session.userId);
      res.json(drafts2);
    } catch (error) {
      console.error("Failed to get drafts:", error);
      res.status(500).json({ message: "Failed to get drafts" });
    }
  });
  app2.post("/api/drafts", requireAuth4, async (req, res) => {
    try {
      const draft = await storage.createDraft(req.session.userId, req.body);
      res.json(draft);
    } catch (error) {
      console.error("Failed to create draft:", error);
      res.status(500).json({ message: "Failed to create draft" });
    }
  });
  app2.get("/api/drafts/:draftId", requireAuth4, async (req, res) => {
    try {
      const draft = await storage.getDraft(req.params.draftId);
      if (!draft || draft.userId !== req.session.userId) {
        return res.status(404).json({ message: "Draft not found" });
      }
      res.json(draft);
    } catch (error) {
      console.error("Failed to get draft:", error);
      res.status(500).json({ message: "Failed to get draft" });
    }
  });
  app2.patch("/api/drafts/:draftId", requireAuth4, async (req, res) => {
    try {
      const draft = await storage.getDraft(req.params.draftId);
      if (!draft || draft.userId !== req.session.userId) {
        return res.status(404).json({ message: "Draft not found" });
      }
      const updated = await storage.updateDraft(req.params.draftId, req.body);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update draft:", error);
      res.status(500).json({ message: "Failed to update draft" });
    }
  });
  app2.delete("/api/drafts/:draftId", requireAuth4, async (req, res) => {
    try {
      const draft = await storage.getDraft(req.params.draftId);
      if (!draft || draft.userId !== req.session.userId) {
        return res.status(404).json({ message: "Draft not found" });
      }
      await storage.deleteDraft(req.params.draftId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete draft:", error);
      res.status(500).json({ message: "Failed to delete draft" });
    }
  });
  app2.get("/api/scheduled-posts", requireAuth4, async (req, res) => {
    try {
      const posts3 = await storage.getUserScheduledPosts(req.session.userId);
      res.json(posts3);
    } catch (error) {
      console.error("Failed to get scheduled posts:", error);
      res.status(500).json({ message: "Failed to get scheduled posts" });
    }
  });
  app2.post("/api/scheduled-posts", requireAuth4, postLimiter, async (req, res) => {
    try {
      const { scheduledFor, ...postData } = req.body;
      if (!scheduledFor) {
        return res.status(400).json({ message: "Scheduled time is required" });
      }
      const scheduledDate = new Date(scheduledFor);
      if (isNaN(scheduledDate.getTime()) || scheduledDate <= /* @__PURE__ */ new Date()) {
        return res.status(400).json({ message: "Scheduled time must be a valid future date" });
      }
      const scheduled = await storage.createScheduledPost(req.session.userId, {
        ...postData,
        scheduledFor: scheduledDate
      });
      res.json(scheduled);
    } catch (error) {
      console.error("Failed to create scheduled post:", error);
      res.status(500).json({ message: "Failed to create scheduled post" });
    }
  });
  app2.patch("/api/scheduled-posts/:postId", requireAuth4, postLimiter, async (req, res) => {
    try {
      const scheduled = await storage.getScheduledPost(req.params.postId);
      if (!scheduled || scheduled.userId !== req.session.userId) {
        return res.status(404).json({ message: "Scheduled post not found" });
      }
      if (scheduled.status !== "PENDING") {
        return res.status(400).json({ message: "Can only edit pending posts" });
      }
      if (req.body.scheduledFor) {
        const scheduledDate = new Date(req.body.scheduledFor);
        if (isNaN(scheduledDate.getTime()) || scheduledDate <= /* @__PURE__ */ new Date()) {
          return res.status(400).json({ message: "Scheduled time must be a valid future date" });
        }
        req.body.scheduledFor = scheduledDate;
      }
      const updated = await storage.updateScheduledPost(req.params.postId, req.body);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update scheduled post:", error);
      res.status(500).json({ message: "Failed to update scheduled post" });
    }
  });
  app2.delete("/api/scheduled-posts/:postId", requireAuth4, apiLimiter, async (req, res) => {
    try {
      const scheduled = await storage.getScheduledPost(req.params.postId);
      if (!scheduled || scheduled.userId !== req.session.userId) {
        return res.status(404).json({ message: "Scheduled post not found" });
      }
      await storage.deleteScheduledPost(req.params.postId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete scheduled post:", error);
      res.status(500).json({ message: "Failed to delete scheduled post" });
    }
  });
  app2.get("/api/data-export", requireAuth4, async (req, res) => {
    try {
      const requests = await storage.getUserDataExportRequests(req.session.userId);
      res.json(requests);
    } catch (error) {
      console.error("Failed to get data export requests:", error);
      res.status(500).json({ message: "Failed to get data export requests" });
    }
  });
  app2.post("/api/data-export", requireAuth4, async (req, res) => {
    try {
      const { includeProfile, includePosts, includeMessages, includeMedia } = req.body;
      const request = await storage.createDataExportRequest(req.session.userId, {
        includeProfile,
        includePosts,
        includeMessages,
        includeMedia
      });
      res.json(request);
    } catch (error) {
      console.error("Failed to create data export request:", error);
      res.status(500).json({ message: "Failed to create data export request" });
    }
  });
  app2.get("/api/admin/users/:userId/notes", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const hasNotePermission = await hasPermission2(user, "users.notes.read");
      if (!hasNotePermission) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const notes = await storage.getAdminUserNotes(req.params.userId);
      res.json(notes);
    } catch (error) {
      console.error("Failed to get admin user notes:", error);
      res.status(500).json({ message: "Failed to get admin user notes" });
    }
  });
  app2.post("/api/admin/users/:userId/notes", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const hasNoteWritePermission = await hasPermission2(user, "users.notes.write");
      if (!hasNoteWritePermission) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const { content } = req.body;
      if (!content) {
        return res.status(400).json({ message: "Content is required" });
      }
      const note = await storage.addAdminUserNote(req.params.userId, req.session.userId, content);
      res.json(note);
    } catch (error) {
      console.error("Failed to add admin user note:", error);
      res.status(500).json({ message: "Failed to add admin user note" });
    }
  });
  app2.patch("/api/admin/notes/:noteId", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const hasNoteUpdatePermission = await hasPermission2(user, "users.notes.write");
      if (!hasNoteUpdatePermission) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const updated = await storage.updateAdminUserNote(req.params.noteId, req.body);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update admin user note:", error);
      res.status(500).json({ message: "Failed to update admin user note" });
    }
  });
  app2.delete("/api/admin/notes/:noteId", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const hasNoteDeletePermission = await hasPermission2(user, "users.notes.write");
      if (!hasNoteDeletePermission) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.deleteAdminUserNote(req.params.noteId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete admin user note:", error);
      res.status(500).json({ message: "Failed to delete admin user note" });
    }
  });
  app2.post("/api/admin/users/:userId/data-export", requireAuth4, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const hasExportPermission = await hasPermission2(user, "users.data.export");
      if (!hasExportPermission && !user.isAdmin) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const targetUser = await storage.getUser(req.params.userId);
      if (!targetUser) {
        return res.status(404).json({ message: "Target user not found" });
      }
      const exportRequest = await storage.triggerDataExport(req.params.userId, req.session.userId);
      await storage.createAuditLog({
        action: "USER_DATA_EXPORT_TRIGGERED",
        actorId: req.session.userId,
        targetId: req.params.userId,
        targetType: "user",
        details: { triggeredBy: user.displayName }
      });
      res.json({ success: true, exportId: exportRequest?.id || null });
    } catch (error) {
      console.error("Failed to trigger admin data export:", error);
      res.status(500).json({ message: "Failed to trigger data export" });
    }
  });
  app2.get("/api/gossip", requireAuth4, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const posts3 = await storage.getGossipPosts(limit, offset);
      const userId = req.session.userId;
      const postsWithInteractions = await Promise.all(posts3.map(async (post) => {
        const [hasLiked, hasRetweeted] = await Promise.all([
          storage.hasUserLikedGossipPost(userId, post.id),
          storage.hasUserRetweetedGossipPost(userId, post.id)
        ]);
        const { authorUserId, ...safePost } = post;
        return { ...safePost, hasLiked, hasRetweeted };
      }));
      res.json(postsWithInteractions);
    } catch (error) {
      console.error("Failed to get gossip posts:", error);
      res.status(500).json({ message: "Failed to get gossip posts" });
    }
  });
  app2.post("/api/gossip", requireAuth4, async (req, res) => {
    try {
      const { type, text: text3, mediaUrl, thumbnailUrl, durationMs } = req.body;
      if (!type || type !== "TEXT" && type !== "VOICE") {
        return res.status(400).json({ message: "Invalid gossip type" });
      }
      if (type === "TEXT" && !text3) {
        return res.status(400).json({ message: "Text is required for text gossip" });
      }
      if (type === "VOICE" && !mediaUrl) {
        return res.status(400).json({ message: "Media URL is required for voice gossip" });
      }
      const post = await storage.createGossipPost(req.session.userId, type, {
        text: text3,
        mediaUrl,
        thumbnailUrl,
        durationMs
      });
      const { authorUserId, ...safePost } = post;
      res.status(201).json(safePost);
    } catch (error) {
      console.error("Failed to create gossip post:", error);
      res.status(500).json({ message: "Failed to create gossip post" });
    }
  });
  app2.get("/api/gossip/:id", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getGossipPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Gossip post not found" });
      }
      const userId = req.session.userId;
      const [hasLiked, hasRetweeted] = await Promise.all([
        storage.hasUserLikedGossipPost(userId, post.id),
        storage.hasUserRetweetedGossipPost(userId, post.id)
      ]);
      const { authorUserId, ...safePost } = post;
      res.json({ ...safePost, hasLiked, hasRetweeted });
    } catch (error) {
      console.error("Failed to get gossip post:", error);
      res.status(500).json({ message: "Failed to get gossip post" });
    }
  });
  app2.post("/api/gossip/:id/like", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getGossipPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Gossip post not found" });
      }
      const hasLiked = await storage.hasUserLikedGossipPost(req.session.userId, req.params.id);
      if (hasLiked) {
        return res.status(400).json({ message: "Already liked" });
      }
      await storage.likeGossipPost(req.session.userId, req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to like gossip post:", error);
      res.status(500).json({ message: "Failed to like gossip post" });
    }
  });
  app2.delete("/api/gossip/:id/like", requireAuth4, async (req, res) => {
    try {
      await storage.unlikeGossipPost(req.session.userId, req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to unlike gossip post:", error);
      res.status(500).json({ message: "Failed to unlike gossip post" });
    }
  });
  app2.get("/api/gossip/:id/comments", requireAuth4, async (req, res) => {
    try {
      const comments3 = await storage.getGossipComments(req.params.id);
      res.json(comments3);
    } catch (error) {
      console.error("Failed to get gossip comments:", error);
      res.status(500).json({ message: "Failed to get gossip comments" });
    }
  });
  app2.post("/api/gossip/:id/comments", requireAuth4, async (req, res) => {
    try {
      const { body } = req.body;
      if (!body) {
        return res.status(400).json({ message: "Comment body is required" });
      }
      const comment = await storage.createGossipComment(req.session.userId, req.params.id, body);
      const { userId, ...safeComment } = comment;
      res.status(201).json(safeComment);
    } catch (error) {
      console.error("Failed to create gossip comment:", error);
      res.status(500).json({ message: "Failed to create gossip comment" });
    }
  });
  app2.post("/api/gossip/:id/retweet", requireAuth4, async (req, res) => {
    try {
      const post = await storage.getGossipPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Gossip post not found" });
      }
      const hasRetweeted = await storage.hasUserRetweetedGossipPost(req.session.userId, req.params.id);
      if (hasRetweeted) {
        return res.status(400).json({ message: "Already retweeted" });
      }
      await storage.retweetGossipPost(req.session.userId, req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to retweet gossip post:", error);
      res.status(500).json({ message: "Failed to retweet gossip post" });
    }
  });
  app2.delete("/api/gossip/:id/retweet", requireAuth4, async (req, res) => {
    try {
      await storage.unretweetGossipPost(req.session.userId, req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to unretweet gossip post:", error);
      res.status(500).json({ message: "Failed to unretweet gossip post" });
    }
  });
  async function seedMallItems() {
    const existingCategories = await storage.getMallCategories();
    const existingItems = await storage.getMallItems();
    const itemsMissingImages = existingItems.filter((i) => !i.imageUrl).length;
    if (existingItems.length >= 10 && itemsMissingImages === 0) {
      return { categoriesCreated: 0, itemsCreated: 0 };
    }
    console.log(`[Mall] Checking items: ${existingItems.length} total, ${itemsMissingImages} missing images`);
    const categoryData = [
      {
        name: "Luxury Watches",
        description: "Premium timepieces from world-renowned manufacturers",
        items: [
          { name: "Rolex Submariner", description: "Iconic diving watch with oyster perpetual movement", value: 15e3, imageUrl: "https://images.unsplash.com/photo-1523170335258-f5ed11844a49?w=400" },
          { name: "Patek Philippe Nautilus", description: "Legendary sports watch with blue dial", value: 85e3, imageUrl: "https://images.unsplash.com/photo-1587836374828-4dbafa94cf0e?w=400" },
          { name: "Audemars Piguet Royal Oak", description: "Iconic octagonal bezel design", value: 45e3, imageUrl: "https://images.unsplash.com/photo-1594534475808-b18fc33b045e?w=400" },
          { name: "Richard Mille RM 011", description: "Innovative titanium racing chronograph", value: 25e4, imageUrl: "https://images.unsplash.com/photo-1612817159949-195b6eb9e31a?w=400" },
          { name: "Omega Speedmaster", description: "The Moonwatch that went to space", value: 8500, imageUrl: "https://images.unsplash.com/photo-1547996160-81dfa63595aa?w=400" }
        ]
      },
      {
        name: "Supercars",
        description: "The world's most exclusive automobiles",
        items: [
          { name: "Ferrari LaFerrari", description: "Hybrid hypercar masterpiece", value: 25e5, imageUrl: "https://images.unsplash.com/photo-1583121274602-3e2820c69888?w=400" },
          { name: "Lamborghini Aventador SVJ", description: "V12 powered Italian beast", value: 55e4, imageUrl: "https://images.unsplash.com/photo-1544636331-e26879cd4d9b?w=400" },
          { name: "Bugatti Chiron", description: "1500 horsepower engineering marvel", value: 35e5, imageUrl: "https://images.unsplash.com/photo-1503376780353-7e6692767b70?w=400" },
          { name: "McLaren P1", description: "British hybrid hypercar", value: 15e5, imageUrl: "https://images.unsplash.com/photo-1621135802920-133df287f89c?w=400" },
          { name: "Porsche 918 Spyder", description: "German hybrid precision", value: 12e5, imageUrl: "https://images.unsplash.com/photo-1614162692292-7ac56d7f7f1e?w=400" }
        ]
      },
      {
        name: "Private Jets",
        description: "Ultimate in air travel luxury",
        items: [
          { name: "Gulfstream G700", description: "Ultra-long-range business jet", value: 75e6, imageUrl: "https://images.unsplash.com/photo-1540962351504-03099e0a754b?w=400" },
          { name: "Bombardier Global 7500", description: "Largest purpose-built business jet", value: 73e6, imageUrl: "https://images.unsplash.com/photo-1559329007-40df8a9345d8?w=400" },
          { name: "Dassault Falcon 8X", description: "Tri-jet long range excellence", value: 58e6, imageUrl: "https://images.unsplash.com/photo-1474302770737-173ee21bab63?w=400" },
          { name: "Embraer Praetor 600", description: "Super-midsize efficiency", value: 21e6, imageUrl: "https://images.unsplash.com/photo-1436491865332-7a61a109cc05?w=400" }
        ]
      },
      {
        name: "Mega Yachts",
        description: "Floating palaces for the elite",
        items: [
          { name: "Azzam 180m Superyacht", description: "World's longest private yacht", value: 6e8, imageUrl: "https://images.unsplash.com/photo-1567899378494-47b22a2ae96a?w=400" },
          { name: "Eclipse 162m Yacht", description: "Luxury with submarine capability", value: 5e8, imageUrl: "https://images.unsplash.com/photo-1569263979104-865ab7cd8d13?w=400" },
          { name: "Dilbar 156m Yacht", description: "Largest pool on any yacht", value: 256e6, imageUrl: "https://images.unsplash.com/photo-1605281317010-fe5ffe798166?w=400" },
          { name: "Custom 100m Explorer", description: "Ice-class expedition vessel", value: 15e7, imageUrl: "https://images.unsplash.com/photo-1544551763-46a013bb70d5?w=400" }
        ]
      },
      {
        name: "Real Estate",
        description: "Premier properties worldwide",
        items: [
          { name: "Manhattan Penthouse", description: "Central Park views, 15,000 sqft", value: 95e6, imageUrl: "https://images.unsplash.com/photo-1512917774080-9991f1c4c750?w=400" },
          { name: "Malibu Beach Estate", description: "Private beach, 20,000 sqft", value: 125e6, imageUrl: "https://images.unsplash.com/photo-1613490493576-7fde63acd811?w=400" },
          { name: "Monaco Apartment", description: "Casino Square views, ultra-exclusive", value: 85e6, imageUrl: "https://images.unsplash.com/photo-1600596542815-ffad4c1539a9?w=400" },
          { name: "Private Island Caribbean", description: "100-acre paradise retreat", value: 2e8, imageUrl: "https://images.unsplash.com/photo-1559128010-7c1ad6e1b6a5?w=400" },
          { name: "London Mayfair Mansion", description: "Historic Georgian townhouse", value: 75e6, imageUrl: "https://images.unsplash.com/photo-1600585154340-be6161a56a0c?w=400" }
        ]
      },
      {
        name: "Fine Art",
        description: "Museum-quality masterpieces",
        items: [
          { name: "Picasso Original", description: "Blue Period masterwork", value: 45e6, imageUrl: "https://images.unsplash.com/photo-1579783902614-a3fb3927b6a5?w=400" },
          { name: "Warhol Pop Art Print", description: "Iconic pop art piece", value: 15e6, imageUrl: "https://images.unsplash.com/photo-1578301978693-85fa9c0320b9?w=400" },
          { name: "Basquiat Canvas", description: "Neo-expressionist masterpiece", value: 35e6, imageUrl: "https://images.unsplash.com/photo-1561214115-f2f134cc4912?w=400" },
          { name: "Monet Water Lilies", description: "Impressionist garden series", value: 55e6, imageUrl: "https://images.unsplash.com/photo-1578926288207-a90a5366759d?w=400" }
        ]
      },
      {
        name: "Jewelry",
        description: "Extraordinary gems and precious metals",
        items: [
          { name: "Blue Diamond Ring 10ct", description: "Rare fancy blue diamond", value: 25e6, imageUrl: "https://images.unsplash.com/photo-1605100804763-247f67b3557e?w=400" },
          { name: "Emerald Necklace Set", description: "Colombian emerald suite", value: 8e6, imageUrl: "https://images.unsplash.com/photo-1599643478518-a784e5dc4c8f?w=400" },
          { name: "Ruby Tiara", description: "Burmese ruby crown piece", value: 12e6, imageUrl: "https://images.unsplash.com/photo-1515562141207-7a88fb7ce338?w=400" },
          { name: "Diamond Tennis Bracelet", description: "50 carat D-flawless", value: 5e6, imageUrl: "https://images.unsplash.com/photo-1611591437281-460bfbe1220a?w=400" }
        ]
      },
      {
        name: "Premium Memberships",
        description: "Exclusive access and privileges",
        items: [
          { name: "Elite Club Lifetime", description: "Unlimited premium features forever", value: 5e4, imageUrl: "https://images.unsplash.com/photo-1553729459-efe14ef6055d?w=400" },
          { name: "VIP Badge", description: "Distinguished member status", value: 1e4, imageUrl: "https://images.unsplash.com/photo-1606326608606-aa0b62935f2b?w=400" },
          { name: "Founder Status", description: "Original supporter recognition", value: 25e3, imageUrl: "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=400" },
          { name: "Diamond Tier Access", description: "Highest privilege level", value: 1e5, imageUrl: "https://images.unsplash.com/photo-1551836022-4c4c79ecde51?w=400" }
        ]
      },
      {
        name: "Digital Assets",
        description: "Virtual luxury items",
        items: [
          { name: "Verified Badge", description: "Official verification status", value: 500, imageUrl: "https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=400" },
          { name: "Custom Profile Theme", description: "Exclusive design options", value: 1e3, imageUrl: "https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?w=400" },
          { name: "Premium Emoji Pack", description: "Luxury emoji collection", value: 250, imageUrl: "https://images.unsplash.com/photo-1584824486509-112e4181ff6b?w=400" },
          { name: "Animated Avatar Frame", description: "Moving profile border", value: 750, imageUrl: "https://images.unsplash.com/photo-1618005198919-d3d4b5a92ead?w=400" },
          { name: "Custom Username Color", description: "Stand out with unique colors", value: 300, imageUrl: "https://images.unsplash.com/photo-1557672172-298e090bd0f1?w=400" }
        ]
      },
      {
        name: "Exotic Experiences",
        description: "Once-in-a-lifetime adventures",
        items: [
          { name: "Space Flight Ticket", description: "Sub-orbital space journey", value: 45e4, imageUrl: "https://images.unsplash.com/photo-1446776811953-b23d57bd21aa?w=400" },
          { name: "Antarctic Expedition", description: "Private polar exploration", value: 15e4, imageUrl: "https://images.unsplash.com/photo-1589139225227-29a00deec92e?w=400" },
          { name: "Everest Summit Guide", description: "Full expedition support", value: 85e3, imageUrl: "https://images.unsplash.com/photo-1469521669194-babb45599def?w=400" },
          { name: "F1 Racing Experience", description: "Drive a real F1 car", value: 5e4, imageUrl: "https://images.unsplash.com/photo-1568605117036-5fe5e7bab0b7?w=400" }
        ]
      }
    ];
    let categoriesCreated = 0;
    let itemsCreated = 0;
    for (const cat of categoryData) {
      let category = existingCategories.find((c) => c.name === cat.name);
      if (!category) {
        category = await storage.createMallCategory({ name: cat.name, description: cat.description });
        categoriesCreated++;
      }
      for (const item of cat.items) {
        const allItems = await storage.getMallItems();
        const existingItem = allItems.find((i) => i.name === item.name);
        if (!existingItem) {
          await storage.createMallItem({
            name: item.name,
            description: item.description,
            value: item.value,
            imageUrl: item.imageUrl || null,
            categoryId: category.id
          });
          itemsCreated++;
        } else if (!existingItem.imageUrl && item.imageUrl) {
          await storage.updateMallItem(existingItem.id, {
            imageUrl: item.imageUrl,
            description: item.description
          });
          console.log(`[Mall] Updated image for ${item.name}`);
        }
      }
    }
    console.log(`[Mall] Seeded ${categoriesCreated} categories and ${itemsCreated} items`);
    return { categoriesCreated, itemsCreated };
  }
  const openai2 = new OpenAI2({
    apiKey: process.env.AI_INTEGRATIONS_OPENAI_API_KEY,
    baseURL: process.env.AI_INTEGRATIONS_OPENAI_BASE_URL
  });
  async function generateAIDescription(itemName, itemValue) {
    try {
      const priceFormatted = itemValue >= 1e6 ? `$${(itemValue / 1e6).toFixed(1)}M` : itemValue >= 1e3 ? `$${(itemValue / 1e3).toFixed(0)}K` : `$${itemValue}`;
      const response = await openai2.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "system",
            content: "You are a luxury goods copywriter. Write elegant, compelling 1-2 sentence descriptions for high-end products. Be sophisticated and aspirational. Focus on craftsmanship, exclusivity, and status. Do not use quotes or special characters."
          },
          {
            role: "user",
            content: `Write a luxury description for: ${itemName} (valued at ${priceFormatted})`
          }
        ],
        max_tokens: 100,
        temperature: 0.7
      });
      const description = response.choices[0]?.message?.content?.trim() || "";
      return description || `Exclusive ${itemName} - a symbol of refined taste and uncompromising luxury.`;
    } catch (error) {
      console.error(`[AI] Failed to generate description for ${itemName}:`, error);
      return `Exclusive ${itemName} - a symbol of refined taste and uncompromising luxury.`;
    }
  }
  async function forceRefreshMallItems() {
    const itemPatterns = [
      // Watches
      { keywords: ["rolex", "submariner"], imageUrl: "https://images.unsplash.com/photo-1523170335258-f5ed11844a49?w=400", description: "Iconic diving watch with oyster perpetual movement" },
      { keywords: ["patek", "nautilus"], imageUrl: "https://images.unsplash.com/photo-1587836374828-4dbafa94cf0e?w=400", description: "Legendary sports watch with blue dial" },
      { keywords: ["audemars", "royal oak"], imageUrl: "https://images.unsplash.com/photo-1594534475808-b18fc33b045e?w=400", description: "Iconic octagonal bezel design" },
      { keywords: ["richard mille", "rm 011", "rm011"], imageUrl: "https://images.unsplash.com/photo-1612817159949-195b6eb9e31a?w=400", description: "Innovative titanium racing chronograph" },
      { keywords: ["omega", "speedmaster"], imageUrl: "https://images.unsplash.com/photo-1547996160-81dfa63595aa?w=400", description: "The Moonwatch that went to space" },
      { keywords: ["jacob", "billionaire", "tourbillon"], imageUrl: "https://images.unsplash.com/photo-1587836374828-4dbafa94cf0e?w=400", description: "Tourbillon with 260 carats of diamonds" },
      { keywords: ["graff", "diamonds", "fantasy"], imageUrl: "https://images.unsplash.com/photo-1587836374828-4dbafa94cf0e?w=400", description: "Ultimate diamond timepiece" },
      { keywords: ["breguet", "marie"], imageUrl: "https://images.unsplash.com/photo-1587836374828-4dbafa94cf0e?w=400", description: "Royal heritage masterpiece" },
      // Cars
      { keywords: ["ferrari", "laferrari"], imageUrl: "https://images.unsplash.com/photo-1583121274602-3e2820c69888?w=400", description: "Hybrid hypercar masterpiece" },
      { keywords: ["lamborghini", "aventador"], imageUrl: "https://images.unsplash.com/photo-1544636331-e26879cd4d9b?w=400", description: "V12 powered Italian beast" },
      { keywords: ["bugatti", "chiron"], imageUrl: "https://images.unsplash.com/photo-1503376780353-7e6692767b70?w=400", description: "1500 horsepower engineering marvel" },
      { keywords: ["mclaren", "p1"], imageUrl: "https://images.unsplash.com/photo-1621135802920-133df287f89c?w=400", description: "British hybrid hypercar" },
      { keywords: ["porsche", "918"], imageUrl: "https://images.unsplash.com/photo-1614162692292-7ac56d7f7f1e?w=400", description: "German hybrid precision" },
      { keywords: ["koenigsegg", "jesko"], imageUrl: "https://images.unsplash.com/photo-1503376780353-7e6692767b70?w=400", description: "Targeting 330mph top speed" },
      { keywords: ["pagani", "huayra"], imageUrl: "https://images.unsplash.com/photo-1544636331-e26879cd4d9b?w=400", description: "Italian art on wheels" },
      { keywords: ["rolls", "royce", "phantom"], imageUrl: "https://images.unsplash.com/photo-1503376780353-7e6692767b70?w=400", description: "Ultimate luxury sedan" },
      { keywords: ["aston martin", "valkyrie"], imageUrl: "https://images.unsplash.com/photo-1583121274602-3e2820c69888?w=400", description: "F1 tech for the road" },
      // Jets
      { keywords: ["gulfstream", "g700", "g650"], imageUrl: "https://images.unsplash.com/photo-1540962351504-03099e0a754b?w=400", description: "Ultra-long-range business jet" },
      { keywords: ["bombardier", "global"], imageUrl: "https://images.unsplash.com/photo-1559329007-40df8a9345d8?w=400", description: "Largest purpose-built business jet" },
      { keywords: ["dassault", "falcon"], imageUrl: "https://images.unsplash.com/photo-1474302770737-173ee21bab63?w=400", description: "Tri-jet long range excellence" },
      { keywords: ["embraer", "praetor"], imageUrl: "https://images.unsplash.com/photo-1436491865332-7a61a109cc05?w=400", description: "Super-midsize efficiency" },
      { keywords: ["cessna", "citation"], imageUrl: "https://images.unsplash.com/photo-1540962351504-03099e0a754b?w=400", description: "Light jet perfection" },
      { keywords: ["boeing", "bbj", "business jet"], imageUrl: "https://images.unsplash.com/photo-1540962351504-03099e0a754b?w=400", description: "VIP Boeing aircraft" },
      // Yachts
      { keywords: ["azzam", "180m", "yacht"], imageUrl: "https://images.unsplash.com/photo-1567899378494-47b22a2ae96a?w=400", description: "World's longest private yacht" },
      { keywords: ["eclipse", "162m", "yacht"], imageUrl: "https://images.unsplash.com/photo-1569263979104-865ab7cd8d13?w=400", description: "Luxury with submarine capability" },
      { keywords: ["dilbar", "156m", "yacht"], imageUrl: "https://images.unsplash.com/photo-1605281317010-fe5ffe798166?w=400", description: "Largest pool on any yacht" },
      { keywords: ["flying fox", "136m"], imageUrl: "https://images.unsplash.com/photo-1567899378494-47b22a2ae96a?w=400", description: "Largest charter yacht in the world" },
      { keywords: ["explorer", "yacht", "100m"], imageUrl: "https://images.unsplash.com/photo-1544551763-46a013bb70d5?w=400", description: "Ice-class expedition vessel" },
      { keywords: ["serene", "superyacht"], imageUrl: "https://images.unsplash.com/photo-1567899378494-47b22a2ae96a?w=400", description: "Floating palace" },
      // Real Estate
      { keywords: ["manhattan", "penthouse"], imageUrl: "https://images.unsplash.com/photo-1512917774080-9991f1c4c750?w=400", description: "Central Park views, 15,000 sqft" },
      { keywords: ["malibu", "beach", "estate"], imageUrl: "https://images.unsplash.com/photo-1613490493576-7fde63acd811?w=400", description: "Private beach, 20,000 sqft" },
      { keywords: ["monaco", "apartment"], imageUrl: "https://images.unsplash.com/photo-1600596542815-ffad4c1539a9?w=400", description: "Casino Square views, ultra-exclusive" },
      { keywords: ["private island", "caribbean"], imageUrl: "https://images.unsplash.com/photo-1559128010-7c1ad6e1b6a5?w=400", description: "100-acre paradise retreat" },
      { keywords: ["london", "mayfair", "mansion"], imageUrl: "https://images.unsplash.com/photo-1600585154340-be6161a56a0c?w=400", description: "Historic Georgian townhouse" },
      { keywords: ["beverly hills", "estate"], imageUrl: "https://images.unsplash.com/photo-1512917774080-9991f1c4c750?w=400", description: "Celebrity compound living" },
      { keywords: ["dubai", "palm", "villa"], imageUrl: "https://images.unsplash.com/photo-1600596542815-ffad4c1539a9?w=400", description: "Palm Jumeirah signature" },
      { keywords: ["aspen", "ski", "chalet"], imageUrl: "https://images.unsplash.com/photo-1600585154340-be6161a56a0c?w=400", description: "Ultimate ski retreat" },
      { keywords: ["motu", "polynesia", "island"], imageUrl: "https://images.unsplash.com/photo-1486427944544-d2c6e5bda2a5?w=400", description: "Ultimate tropical hideaway" },
      { keywords: ["pipe cay", "bahamas"], imageUrl: "https://images.unsplash.com/photo-1548574505-5e239809ee19?w=400", description: "38 acre private island paradise" },
      { keywords: ["cave cay", "bahamas"], imageUrl: "https://images.unsplash.com/photo-1548574505-5e239809ee19?w=400", description: "222 acre private island with airstrip" },
      // Art
      { keywords: ["picasso", "original"], imageUrl: "https://images.unsplash.com/photo-1579783902614-a3fb3927b6a5?w=400", description: "Blue Period masterwork" },
      { keywords: ["warhol", "pop art"], imageUrl: "https://images.unsplash.com/photo-1578301978693-85fa9c0320b9?w=400", description: "Iconic pop art piece" },
      { keywords: ["basquiat", "canvas"], imageUrl: "https://images.unsplash.com/photo-1561214115-f2f134cc4912?w=400", description: "Neo-expressionist masterpiece" },
      { keywords: ["monet", "water lilies"], imageUrl: "https://images.unsplash.com/photo-1578926288207-a90a5366759d?w=400", description: "Impressionist garden series" },
      { keywords: ["van gogh", "starry"], imageUrl: "https://images.unsplash.com/photo-1579783902614-a3fb3927b6a5?w=400", description: "Post-impressionist icon" },
      { keywords: ["banksy", "artwork"], imageUrl: "https://images.unsplash.com/photo-1578301978693-85fa9c0320b9?w=400", description: "Street art legend" },
      { keywords: ["koons", "balloon"], imageUrl: "https://images.unsplash.com/photo-1561214115-f2f134cc4912?w=400", description: "Contemporary pop sculpture" },
      { keywords: ["audubon", "birds"], imageUrl: "https://images.unsplash.com/photo-1507842217343-583bb7270b66?w=400", description: "Original elephant folio" },
      { keywords: ["harry potter", "1st edition"], imageUrl: "https://images.unsplash.com/photo-1507842217343-583bb7270b66?w=400", description: "Philosophers Stone rare" },
      // Jewelry
      { keywords: ["blue diamond", "ring"], imageUrl: "https://images.unsplash.com/photo-1605100804763-247f67b3557e?w=400", description: "Rare fancy blue diamond" },
      { keywords: ["emerald", "necklace"], imageUrl: "https://images.unsplash.com/photo-1599643478518-a784e5dc4c8f?w=400", description: "Colombian emerald suite" },
      { keywords: ["ruby", "tiara"], imageUrl: "https://images.unsplash.com/photo-1515562141207-7a88fb7ce338?w=400", description: "Burmese ruby crown piece" },
      { keywords: ["diamond", "tennis", "bracelet"], imageUrl: "https://images.unsplash.com/photo-1611591437281-460bfbe1220a?w=400", description: "50 carat D-flawless" },
      { keywords: ["pink star", "diamond"], imageUrl: "https://images.unsplash.com/photo-1605100804763-247f67b3557e?w=400", description: "World's most expensive gem" },
      { keywords: ["hope diamond", "replica"], imageUrl: "https://images.unsplash.com/photo-1605100804763-247f67b3557e?w=400", description: "Legendary cursed diamond" },
      { keywords: ["cartier", "panther"], imageUrl: "https://images.unsplash.com/photo-1599643478518-a784e5dc4c8f?w=400", description: "Iconic jeweled bracelet" },
      // Memberships
      { keywords: ["elite", "club", "lifetime"], imageUrl: "https://images.unsplash.com/photo-1553729459-efe14ef6055d?w=400", description: "Unlimited premium features forever" },
      { keywords: ["vip", "badge"], imageUrl: "https://images.unsplash.com/photo-1606326608606-aa0b62935f2b?w=400", description: "Distinguished member status" },
      { keywords: ["founder", "status"], imageUrl: "https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?w=400", description: "Original supporter recognition" },
      { keywords: ["diamond", "tier", "access"], imageUrl: "https://images.unsplash.com/photo-1551836022-4c4c79ecde51?w=400", description: "Highest privilege level" },
      // Digital
      { keywords: ["verified", "badge"], imageUrl: "https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=400", description: "Official verification status" },
      { keywords: ["custom", "profile", "theme"], imageUrl: "https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?w=400", description: "Exclusive design options" },
      { keywords: ["premium", "emoji", "pack"], imageUrl: "https://images.unsplash.com/photo-1584824486509-112e4181ff6b?w=400", description: "Luxury emoji collection" },
      { keywords: ["animated", "avatar", "frame"], imageUrl: "https://images.unsplash.com/photo-1618005198919-d3d4b5a92ead?w=400", description: "Moving profile border" },
      { keywords: ["custom", "username", "color"], imageUrl: "https://images.unsplash.com/photo-1557672172-298e090bd0f1?w=400", description: "Stand out with unique colors" },
      // Experiences
      { keywords: ["space", "flight", "ticket"], imageUrl: "https://images.unsplash.com/photo-1446776811953-b23d57bd21aa?w=400", description: "Sub-orbital space journey" },
      { keywords: ["antarctic", "expedition"], imageUrl: "https://images.unsplash.com/photo-1589139225227-29a00deec92e?w=400", description: "Private polar exploration" },
      { keywords: ["everest", "summit", "guide"], imageUrl: "https://images.unsplash.com/photo-1469521669194-babb45599def?w=400", description: "Full expedition support" },
      { keywords: ["f1", "racing", "experience"], imageUrl: "https://images.unsplash.com/photo-1568605117036-5fe5e7bab0b7?w=400", description: "Drive a real F1 car" },
      { keywords: ["safari", "luxury"], imageUrl: "https://images.unsplash.com/photo-1589139225227-29a00deec92e?w=400", description: "Ultimate African adventure" },
      { keywords: ["submarine", "tour"], imageUrl: "https://images.unsplash.com/photo-1446776811953-b23d57bd21aa?w=400", description: "Deep sea exploration" }
    ];
    function findMatchingTemplate(itemName) {
      const nameLower = itemName.toLowerCase();
      for (const pattern of itemPatterns) {
        const allMatch = pattern.keywords.every((keyword) => nameLower.includes(keyword.toLowerCase()));
        if (allMatch) return { imageUrl: pattern.imageUrl, description: pattern.description };
      }
      for (const pattern of itemPatterns) {
        const anyMatch = pattern.keywords.some((keyword) => nameLower.includes(keyword.toLowerCase()));
        if (anyMatch) return { imageUrl: pattern.imageUrl, description: pattern.description };
      }
      return null;
    }
    const allItems = await storage.getAllMallItemsIncludingInactive();
    let updatedCount = 0;
    console.log(`[Mall Refresh] Processing ${allItems.length} items (including inactive)...`);
    for (const item of allItems) {
      const template = findMatchingTemplate(item.name);
      const updateData = {
        isActive: true
        // ALWAYS ensure item is active
      };
      if (template) {
        updateData.imageUrl = template.imageUrl;
        updateData.description = template.description;
        console.log(`[Mall Refresh] Matched: ${item.name} -> ${template.description.substring(0, 30)}...`);
      } else {
        if (!item.imageUrl) {
          updateData.imageUrl = "https://images.unsplash.com/photo-1553729459-efe14ef6055d?w=400";
        }
        if (!item.description || item.description.length < 20) {
          const aiDescription = await generateAIDescription(item.name, Number(item.value));
          updateData.description = aiDescription;
          console.log(`[Mall Refresh] AI Generated: ${item.name} -> ${aiDescription.substring(0, 40)}...`);
        } else {
          updateData.description = item.description;
          console.log(`[Mall Refresh] Keeping existing: ${item.name}`);
        }
      }
      await storage.updateMallItem(item.id, updateData);
      updatedCount++;
    }
    console.log(`[Mall] Force refreshed ${updatedCount} items with images, descriptions, and active status`);
    await seedMallItems();
    return updatedCount;
  }
  app2.get("/api/mall/categories", requireAuth4, async (req, res) => {
    try {
      const categories = await storage.getMallCategories();
      res.json(categories);
    } catch (error) {
      console.error("Failed to get mall categories:", error);
      res.status(500).json({ message: "Failed to get mall categories" });
    }
  });
  app2.post("/api/mall/refresh", requireAuth4, async (req, res) => {
    try {
      console.log("[Mall] Force refreshing all mall items...");
      await forceRefreshMallItems();
      const items = await storage.getMallItems();
      res.json({ message: "Mall refreshed successfully", itemCount: items.length });
    } catch (error) {
      console.error("Failed to refresh mall:", error);
      res.status(500).json({ message: "Failed to refresh mall" });
    }
  });
  app2.post("/api/mall/regenerate-descriptions", requireAuth4, async (req, res) => {
    try {
      console.log("[Mall] Regenerating ALL descriptions with AI...");
      const allItems = await storage.getAllMallItemsIncludingInactive();
      let regeneratedCount = 0;
      for (const item of allItems) {
        const aiDescription = await generateAIDescription(item.name, Number(item.value));
        await storage.updateMallItem(item.id, {
          description: aiDescription,
          isActive: true
        });
        regeneratedCount++;
        console.log(`[AI] Regenerated ${regeneratedCount}/${allItems.length}: ${item.name}`);
      }
      const items = await storage.getMallItems();
      res.json({
        message: "All descriptions regenerated with AI",
        regeneratedCount,
        itemCount: items.length
      });
    } catch (error) {
      console.error("Failed to regenerate descriptions:", error);
      res.status(500).json({ message: "Failed to regenerate descriptions" });
    }
  });
  app2.get("/api/mall/items", requireAuth4, async (req, res) => {
    try {
      const categoryId = req.query.categoryId;
      console.log("[Mall] Fetching items, categoryId:", categoryId || "all");
      let items = await storage.getMallItems(categoryId);
      const allItems = await storage.getAllMallItemsIncludingInactive();
      const itemsMissingImages = allItems.filter((i) => !i.imageUrl).length;
      const inactiveItems = allItems.filter((i) => !i.isActive).length;
      const itemsMissingDescriptions = allItems.filter((i) => !i.description || i.description.length < 5).length;
      if (!categoryId && (items.length === 0 || itemsMissingImages > 0 || inactiveItems > 0 || itemsMissingDescriptions > 0)) {
        console.log(`[Mall] Refreshing... ${items.length} active, ${allItems.length} total, ${inactiveItems} inactive, ${itemsMissingImages} missing images, ${itemsMissingDescriptions} missing descriptions`);
        await forceRefreshMallItems();
        items = await storage.getMallItems();
        console.log("[Mall] Refreshed, now have", items.length, "active items");
      }
      console.log("[Mall] Returning", items.length, "items");
      if (items.length > 0) {
        console.log("[Mall] Sample item:", JSON.stringify({ id: items[0].id, name: items[0].name, value: items[0].value, coinPrice: items[0].coinPrice }));
      }
      res.json(items);
    } catch (error) {
      console.error("Failed to get mall items:", error);
      res.status(500).json({ message: "Failed to get mall items" });
    }
  });
  app2.get("/api/mall/items/:id", requireAuth4, async (req, res) => {
    try {
      const item = await storage.getMallItem(req.params.id);
      if (!item) {
        return res.status(404).json({ message: "Mall item not found" });
      }
      res.json(item);
    } catch (error) {
      console.error("Failed to get mall item:", error);
      res.status(500).json({ message: "Failed to get mall item" });
    }
  });
  app2.post("/api/mall/purchase", requireAuth4, async (req, res) => {
    try {
      console.log("[Mall Purchase] Request body:", req.body);
      console.log("[Mall Purchase] User ID:", req.session.userId);
      const { itemId, quantity } = req.body;
      if (!itemId) {
        console.log("[Mall Purchase] Error: No itemId provided");
        return res.status(400).json({ message: "Item ID is required" });
      }
      if (quantity !== void 0 && (typeof quantity !== "number" || quantity < 1)) {
        return res.status(400).json({ message: "Quantity must be at least 1" });
      }
      const item = await storage.getMallItem(itemId);
      console.log("[Mall Purchase] Item found:", item?.name || "NOT FOUND");
      if (!item) {
        return res.status(404).json({ message: "Mall item not found" });
      }
      if (!item.isActive) {
        console.log("[Mall Purchase] Error: Item is inactive");
        return res.status(400).json({ message: "Item is not available for purchase" });
      }
      console.log("[Mall Purchase] Processing purchase for:", item.name, "qty:", quantity || 1);
      const purchase = await storage.purchaseMallItem(req.session.userId, itemId, quantity || 1);
      const user = await storage.getUser(req.session.userId);
      console.log("[Mall Purchase] Success! New net worth:", user?.netWorth);
      res.json({
        purchase,
        newNetWorth: user?.netWorth || 0,
        message: `Successfully purchased ${item.name}!`
      });
    } catch (error) {
      console.error("[Mall Purchase] Failed:", error);
      const errorMessage = error?.message || "Failed to purchase mall item";
      res.status(500).json({ message: errorMessage });
    }
  });
  app2.get("/api/mall/purchases", requireAuth4, async (req, res) => {
    try {
      const purchases = await storage.getUserPurchases(req.session.userId);
      res.json(purchases);
    } catch (error) {
      console.error("Failed to get user purchases:", error);
      res.status(500).json({ message: "Failed to get user purchases" });
    }
  });
  app2.get("/api/users/:userId/portfolio", requireAuth4, async (req, res) => {
    try {
      const targetUser = await storage.getUser(req.params.userId);
      if (!targetUser || targetUser.deactivatedAt) {
        return res.status(404).json({ message: "User not found" });
      }
      const purchases = await storage.getUserPurchases(req.params.userId);
      const wealthRank = await storage.getUserWealthRank(req.params.userId);
      const categoryBreakdown = {};
      let totalPurchaseValue = 0;
      let totalNetWorthGain = 0;
      for (const purchase of purchases) {
        const categoryId = purchase.item.categoryId;
        const purchaseValue = purchase.item.value * purchase.quantity;
        const netWorthGain = purchaseValue * 10;
        if (!categoryBreakdown[categoryId]) {
          categoryBreakdown[categoryId] = { count: 0, totalValue: 0, netWorthGain: 0 };
        }
        categoryBreakdown[categoryId].count += purchase.quantity;
        categoryBreakdown[categoryId].totalValue += purchaseValue;
        categoryBreakdown[categoryId].netWorthGain += netWorthGain;
        totalPurchaseValue += purchaseValue;
        totalNetWorthGain += netWorthGain;
      }
      res.json({
        user: {
          id: targetUser.id,
          username: targetUser.username,
          displayName: targetUser.displayName,
          avatarUrl: targetUser.avatarUrl,
          netWorth: targetUser.netWorth,
          isVerified: targetUser.isVerified
        },
        wealthRank,
        totalPurchaseValue,
        totalNetWorthGain,
        purchases: purchases.slice(0, 100),
        // Limit to most recent 100 purchases
        categoryBreakdown
      });
    } catch (error) {
      console.error("Failed to get user portfolio:", error);
      res.status(500).json({ message: "Failed to get user portfolio" });
    }
  });
  app2.get("/api/mall/top50", requireAuth4, async (req, res) => {
    try {
      const users4 = await storage.getTop50WealthyUsers();
      res.json(users4);
    } catch (error) {
      console.error("Failed to get top 50 wealthy users:", error);
      res.status(500).json({ message: "Failed to get top 50 wealthy users" });
    }
  });
  app2.get("/api/net-worth/history", requireAuth4, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const history = await storage.getNetWorthHistory(req.session.userId, limit);
      res.json(history);
    } catch (error) {
      console.error("Failed to get net worth history:", error);
      res.status(500).json({ message: "Failed to get net worth history" });
    }
  });
  app2.post("/api/admin/mall/categories", requireAdmin, async (req, res) => {
    try {
      const { name, description } = req.body;
      if (!name) {
        return res.status(400).json({ message: "Category name is required" });
      }
      const category = await storage.createMallCategory({ name, description });
      res.status(201).json(category);
    } catch (error) {
      console.error("Failed to create mall category:", error);
      res.status(500).json({ message: "Failed to create mall category" });
    }
  });
  app2.patch("/api/admin/mall/categories/:id", requireAdmin, async (req, res) => {
    try {
      const { name, description, isActive } = req.body;
      const category = await storage.updateMallCategory(req.params.id, { name, description, isActive });
      if (!category) {
        return res.status(404).json({ message: "Category not found" });
      }
      res.json(category);
    } catch (error) {
      console.error("Failed to update mall category:", error);
      res.status(500).json({ message: "Failed to update mall category" });
    }
  });
  app2.delete("/api/admin/mall/categories/:id", requireAdmin, async (req, res) => {
    try {
      await storage.deleteMallCategory(req.params.id);
      res.json({ message: "Category deleted" });
    } catch (error) {
      console.error("Failed to delete mall category:", error);
      res.status(500).json({ message: "Failed to delete mall category" });
    }
  });
  app2.post("/api/admin/mall/items", requireAdmin, async (req, res) => {
    try {
      const { name, description, value, imageUrl, categoryId } = req.body;
      if (!name || !value || !categoryId || !description) {
        return res.status(400).json({ message: "Name, description, value, and categoryId are required" });
      }
      const item = await storage.createMallItem({
        name,
        description,
        value: parseInt(value),
        imageUrl,
        categoryId
      });
      res.status(201).json(item);
    } catch (error) {
      console.error("Failed to create mall item:", error);
      res.status(500).json({ message: "Failed to create mall item" });
    }
  });
  app2.patch("/api/admin/mall/items/:id", requireAdmin, async (req, res) => {
    try {
      const { name, description, value, imageUrl, categoryId, isActive } = req.body;
      const item = await storage.updateMallItem(req.params.id, {
        name,
        description,
        value: value !== void 0 ? parseInt(value) : void 0,
        imageUrl,
        categoryId,
        isActive
      });
      if (!item) {
        return res.status(404).json({ message: "Item not found" });
      }
      res.json(item);
    } catch (error) {
      console.error("Failed to update mall item:", error);
      res.status(500).json({ message: "Failed to update mall item" });
    }
  });
  app2.delete("/api/admin/mall/items/:id", requireAdmin, async (req, res) => {
    try {
      await storage.deleteMallItem(req.params.id);
      res.json({ message: "Item deleted" });
    } catch (error) {
      console.error("Failed to delete mall item:", error);
      res.status(500).json({ message: "Failed to delete mall item" });
    }
  });
  app2.get("/api/admin/mall/purchases", requireAdmin, async (req, res) => {
    try {
      const purchases = await storage.getAllMallPurchases();
      res.json(purchases);
    } catch (error) {
      console.error("Failed to get all mall purchases:", error);
      res.status(500).json({ message: "Failed to get all mall purchases" });
    }
  });
  app2.post("/api/admin/mall/fix-prices", requireAdmin, async (req, res) => {
    try {
      const result = await storage.fixAllMallItemPrices();
      await storage.createAuditLog(
        req.session.userId,
        "SETTING_CHANGED",
        "mall",
        "fix_prices",
        { fixed: result.fixed, total: result.total }
      );
      res.json({
        message: `Fixed ${result.fixed} items out of ${result.total} total`,
        ...result
      });
    } catch (error) {
      console.error("Failed to fix mall item prices:", error);
      res.status(500).json({ message: "Failed to fix mall item prices" });
    }
  });
  app2.post("/api/admin/mall/seed", requireAdmin, async (req, res) => {
    try {
      const existingCategories = await storage.getMallCategories();
      const existingItems = await storage.getMallItems();
      if (existingItems.length >= 100) {
        return res.json({
          message: "Mall already has items",
          categories: existingCategories.length,
          items: existingItems.length
        });
      }
      console.log("[Admin] Seeding mall with luxury items...");
      const categoryData = [
        {
          name: "Luxury Watches",
          description: "Premium timepieces from world-renowned manufacturers",
          items: [
            { name: "Rolex Submariner", description: "Iconic diving watch with oyster perpetual movement", value: 15e3 },
            { name: "Patek Philippe Nautilus", description: "Legendary sports watch with blue dial", value: 85e3 },
            { name: "Audemars Piguet Royal Oak", description: "Iconic octagonal bezel design", value: 45e3 },
            { name: "Richard Mille RM 011", description: "Innovative titanium racing chronograph", value: 25e4 },
            { name: "Omega Speedmaster", description: "The Moonwatch that went to space", value: 8500 }
          ]
        },
        {
          name: "Supercars",
          description: "The world's most exclusive automobiles",
          items: [
            { name: "Ferrari LaFerrari", description: "Hybrid hypercar masterpiece", value: 25e5 },
            { name: "Lamborghini Aventador SVJ", description: "V12 powered Italian beast", value: 55e4 },
            { name: "Bugatti Chiron", description: "1500 horsepower engineering marvel", value: 35e5 },
            { name: "McLaren P1", description: "British hybrid hypercar", value: 15e5 },
            { name: "Porsche 918 Spyder", description: "German hybrid precision", value: 12e5 }
          ]
        },
        {
          name: "Private Jets",
          description: "Ultimate in air travel luxury",
          items: [
            { name: "Gulfstream G700", description: "Ultra-long-range business jet", value: 75e6 },
            { name: "Bombardier Global 7500", description: "Largest purpose-built business jet", value: 73e6 },
            { name: "Dassault Falcon 8X", description: "Tri-jet long range excellence", value: 58e6 },
            { name: "Embraer Praetor 600", description: "Super-midsize efficiency", value: 21e6 }
          ]
        },
        {
          name: "Mega Yachts",
          description: "Floating palaces for the elite",
          items: [
            { name: "Azzam 180m Superyacht", description: "World's longest private yacht", value: 6e8 },
            { name: "Eclipse 162m Yacht", description: "Luxury with submarine capability", value: 5e8 },
            { name: "Dilbar 156m Yacht", description: "Largest pool on any yacht", value: 256e6 },
            { name: "Custom 100m Explorer", description: "Ice-class expedition vessel", value: 15e7 }
          ]
        },
        {
          name: "Real Estate",
          description: "Premier properties worldwide",
          items: [
            { name: "Manhattan Penthouse", description: "Central Park views, 15,000 sqft", value: 95e6 },
            { name: "Malibu Beach Estate", description: "Private beach, 20,000 sqft", value: 125e6 },
            { name: "Monaco Apartment", description: "Casino Square views, ultra-exclusive", value: 85e6 },
            { name: "Private Island Caribbean", description: "100-acre paradise retreat", value: 2e8 },
            { name: "London Mayfair Mansion", description: "Historic Georgian townhouse", value: 75e6 }
          ]
        },
        {
          name: "Fine Art",
          description: "Museum-quality masterpieces",
          items: [
            { name: "Picasso Original", description: "Blue Period masterwork", value: 45e6 },
            { name: "Warhol Pop Art Print", description: "Iconic pop art piece", value: 15e6 },
            { name: "Basquiat Canvas", description: "Neo-expressionist masterpiece", value: 35e6 },
            { name: "Monet Water Lilies", description: "Impressionist garden series", value: 55e6 }
          ]
        },
        {
          name: "Jewelry",
          description: "Extraordinary gems and precious metals",
          items: [
            { name: "Blue Diamond Ring 10ct", description: "Rare fancy blue diamond", value: 25e6 },
            { name: "Emerald Necklace Set", description: "Colombian emerald suite", value: 8e6 },
            { name: "Ruby Tiara", description: "Burmese ruby crown piece", value: 12e6 },
            { name: "Diamond Tennis Bracelet", description: "50 carat D-flawless", value: 5e6 }
          ]
        },
        {
          name: "Premium Memberships",
          description: "Exclusive access and privileges",
          items: [
            { name: "Elite Club Lifetime", description: "Unlimited premium features forever", value: 5e4 },
            { name: "VIP Badge", description: "Distinguished member status", value: 1e4 },
            { name: "Founder Status", description: "Original supporter recognition", value: 25e3 },
            { name: "Diamond Tier Access", description: "Highest privilege level", value: 1e5 }
          ]
        },
        {
          name: "Digital Assets",
          description: "Virtual luxury items",
          items: [
            { name: "Verified Badge", description: "Official verification status", value: 500 },
            { name: "Custom Profile Theme", description: "Exclusive design options", value: 1e3 },
            { name: "Premium Emoji Pack", description: "Luxury emoji collection", value: 250 },
            { name: "Animated Avatar Frame", description: "Moving profile border", value: 750 },
            { name: "Custom Username Color", description: "Stand out with unique colors", value: 300 }
          ]
        },
        {
          name: "Exotic Experiences",
          description: "Once-in-a-lifetime adventures",
          items: [
            { name: "Space Flight Ticket", description: "Sub-orbital space journey", value: 45e4 },
            { name: "Antarctic Expedition", description: "Private polar exploration", value: 15e4 },
            { name: "Everest Summit Guide", description: "Full expedition support", value: 85e3 },
            { name: "F1 Racing Experience", description: "Drive a real F1 car", value: 5e4 }
          ]
        }
      ];
      let categoriesCreated = 0;
      let itemsCreated = 0;
      for (const cat of categoryData) {
        let category = existingCategories.find((c) => c.name === cat.name);
        if (!category) {
          category = await storage.createMallCategory({ name: cat.name, description: cat.description });
          categoriesCreated++;
        }
        for (const item of cat.items) {
          const existingItem = existingItems.find((i) => i.name === item.name);
          if (!existingItem) {
            await storage.createMallItem({
              name: item.name,
              description: item.description,
              value: item.value,
              categoryId: category.id
            });
            itemsCreated++;
          }
        }
      }
      console.log(`[Admin] Mall seeded: ${categoriesCreated} categories, ${itemsCreated} items created`);
      res.json({
        message: "Mall seeded successfully",
        categoriesCreated,
        itemsCreated
      });
    } catch (error) {
      console.error("Failed to seed mall:", error);
      res.status(500).json({ message: "Failed to seed mall" });
    }
  });
  app2.post("/api/admin/users/:userId/reset-networth", requireAdmin, async (req, res) => {
    try {
      const user = await storage.getUser(req.params.userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const oldNetWorth = user.netWorth;
      await storage.updateUser(req.params.userId, { netWorth: 0 });
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "RESET_USER_NETWORTH",
        targetType: "user",
        targetId: user.id,
        details: { username: user.username, oldNetWorth, newNetWorth: 0 },
        ipAddress: req.ip || "unknown"
      });
      console.log(`[Admin] Reset net worth for ${user.username}: ${oldNetWorth} -> 0`);
      res.json({
        message: "Net worth reset successfully",
        username: user.username,
        oldNetWorth,
        newNetWorth: 0
      });
    } catch (error) {
      console.error("Failed to reset net worth:", error);
      res.status(500).json({ message: "Failed to reset net worth" });
    }
  });
  app2.post("/api/admin/users/by-username/:username/reset-networth", requireAdmin, async (req, res) => {
    try {
      const user = await storage.getUserByUsername(req.params.username);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const oldNetWorth = user.netWorth;
      await storage.updateUser(user.id, { netWorth: 0 });
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "RESET_USER_NETWORTH",
        targetType: "user",
        targetId: user.id,
        details: { username: user.username, oldNetWorth, newNetWorth: 0 },
        ipAddress: req.ip || "unknown"
      });
      console.log(`[Admin] Reset net worth for ${user.username}: ${oldNetWorth} -> 0`);
      res.json({
        message: "Net worth reset successfully",
        username: user.username,
        oldNetWorth,
        newNetWorth: 0
      });
    } catch (error) {
      console.error("Failed to reset net worth:", error);
      res.status(500).json({ message: "Failed to reset net worth" });
    }
  });
  app2.post("/api/admin/users/:userId/mall-products/add", requireAdmin, async (req, res) => {
    try {
      const { itemId, quantity = 1 } = req.body;
      if (!itemId) {
        return res.status(400).json({ message: "itemId is required" });
      }
      const targetUser = await storage.getUser(req.params.userId);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const item = await storage.getMallItem(itemId);
      if (!item) {
        return res.status(404).json({ message: "Mall item not found" });
      }
      const purchase = await storage.adminAddMallProduct(
        req.params.userId,
        itemId,
        quantity,
        req.session.userId
      );
      const updatedUser = await storage.getUser(req.params.userId);
      const netWorthGained = item.value * 10 * quantity;
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_ADD_MALL_PRODUCT",
        targetType: "user",
        targetId: targetUser.id,
        details: {
          username: targetUser.username,
          itemName: item.name,
          itemId,
          quantity,
          netWorthGained,
          newNetWorth: updatedUser?.netWorth
        },
        ipAddress: req.ip || "unknown"
      });
      console.log(`[Admin] Added ${item.name} x${quantity} to ${targetUser.username}, net worth +${netWorthGained}`);
      res.json({
        message: "Product added successfully",
        purchase,
        item: { id: item.id, name: item.name, value: item.value },
        netWorthGained,
        newNetWorth: updatedUser?.netWorth || 0
      });
    } catch (error) {
      console.error("Failed to add mall product:", error);
      res.status(500).json({ message: error.message || "Failed to add mall product" });
    }
  });
  app2.post("/api/admin/users/:userId/mall-products/remove", requireAdmin, async (req, res) => {
    try {
      const { purchaseId } = req.body;
      if (!purchaseId) {
        return res.status(400).json({ message: "purchaseId is required" });
      }
      const targetUser = await storage.getUser(req.params.userId);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const result = await storage.adminRemoveMallProduct(
        req.params.userId,
        purchaseId,
        req.session.userId
      );
      const updatedUser = await storage.getUser(req.params.userId);
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_REMOVE_MALL_PRODUCT",
        targetType: "user",
        targetId: targetUser.id,
        details: {
          username: targetUser.username,
          purchaseId,
          netWorthReduced: result.netWorthReduced,
          newNetWorth: updatedUser?.netWorth
        },
        ipAddress: req.ip || "unknown"
      });
      console.log(`[Admin] Removed purchase ${purchaseId} from ${targetUser.username}, net worth -${result.netWorthReduced}`);
      res.json({
        message: "Product removed successfully",
        netWorthReduced: result.netWorthReduced,
        newNetWorth: updatedUser?.netWorth || 0
      });
    } catch (error) {
      console.error("Failed to remove mall product:", error);
      res.status(500).json({ message: error.message || "Failed to remove mall product" });
    }
  });
  app2.post("/api/admin/users/:userId/mall-products/remove-all", requireAdmin, async (req, res) => {
    try {
      const targetUser = await storage.getUser(req.params.userId);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const result = await storage.adminRemoveAllMallProducts(
        req.params.userId,
        req.session.userId
      );
      const updatedUser = await storage.getUser(req.params.userId);
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_REMOVE_ALL_MALL_PRODUCTS",
        targetType: "user",
        targetId: targetUser.id,
        details: {
          username: targetUser.username,
          productsRemoved: result.removed,
          netWorthReduced: result.netWorthReduced,
          newNetWorth: updatedUser?.netWorth
        },
        ipAddress: req.ip || "unknown"
      });
      console.log(`[Admin] Removed all ${result.removed} products from ${targetUser.username}, net worth -${result.netWorthReduced}`);
      res.json({
        message: `Removed ${result.removed} products successfully`,
        productsRemoved: result.removed,
        netWorthReduced: result.netWorthReduced,
        newNetWorth: updatedUser?.netWorth || 0
      });
    } catch (error) {
      console.error("Failed to remove all mall products:", error);
      res.status(500).json({ message: error.message || "Failed to remove all mall products" });
    }
  });
  app2.get("/api/admin/users/:userId/mall-products", requireAdmin, async (req, res) => {
    try {
      const targetUser = await storage.getUser(req.params.userId);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const purchases = await storage.getUserPurchases(req.params.userId);
      res.json({
        user: {
          id: targetUser.id,
          username: targetUser.username,
          displayName: targetUser.displayName,
          netWorth: targetUser.netWorth
        },
        purchases: purchases.map((p) => ({
          id: p.id,
          itemId: p.itemId,
          itemName: p.item.name,
          quantity: p.quantity,
          netWorthGained: p.netWorthGained,
          purchasedAt: p.createdAt
        })),
        totalPurchases: purchases.length,
        totalNetWorthFromPurchases: purchases.reduce((sum, p) => sum + (p.netWorthGained || 0), 0)
      });
    } catch (error) {
      console.error("Failed to get user mall products:", error);
      res.status(500).json({ message: error.message || "Failed to get user mall products" });
    }
  });
  app2.post("/api/admin/users/:userId/set-networth", requireAdmin, async (req, res) => {
    try {
      const { netWorth } = req.body;
      if (typeof netWorth !== "number" || netWorth < 0) {
        return res.status(400).json({ message: "netWorth must be a non-negative number" });
      }
      const targetUser = await storage.getUser(req.params.userId);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }
      const oldNetWorth = targetUser.netWorth || 0;
      await storage.updateUser(req.params.userId, { netWorth });
      const delta = netWorth - oldNetWorth;
      await storage.addNetWorthEntry(req.params.userId, delta, "ADMIN_ADJUST", "admin", req.session.userId);
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "UPDATE",
        targetType: "user",
        targetId: targetUser.id,
        details: {
          actionType: "set_networth",
          username: targetUser.username,
          oldNetWorth,
          newNetWorth: netWorth
        },
        ipAddress: req.ip || "unknown"
      });
      console.log(`[Admin] Set net worth for ${targetUser.username}: ${oldNetWorth} -> ${netWorth}`);
      res.json({
        message: "Net worth updated successfully",
        username: targetUser.username,
        oldNetWorth,
        newNetWorth: netWorth
      });
    } catch (error) {
      console.error("Failed to set net worth:", error);
      res.status(500).json({ message: error.message || "Failed to set net worth" });
    }
  });
  const {
    isPayFastConfigured: isPayFastConfigured2,
    getPayFastUrl: getPayFastUrl2,
    createPaymentData: createPaymentData2,
    validateITNSignature: validateITNSignature2,
    formatAmountCents: formatAmountCents2
  } = await Promise.resolve().then(() => (init_payfast(), payfast_exports));
  app2.post("/api/payments/payfast/create", requireAuth4, async (req, res) => {
    try {
      if (!isPayFastConfigured2()) {
        return res.status(500).json({ message: "PayFast is not configured" });
      }
      const { itemId, quantity = 1 } = req.body;
      if (!itemId) {
        return res.status(400).json({ message: "Item ID is required" });
      }
      const item = await storage.getMallItem(itemId);
      if (!item) {
        return res.status(404).json({ message: "Mall item not found" });
      }
      if (!item.isActive) {
        return res.status(400).json({ message: "Item is not available for purchase" });
      }
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      const totalValueCents = item.value * quantity * 100;
      const baseUrl = `https://${req.get("host")}`;
      const order = await storage.createPayfastOrder({
        userId: req.session.userId,
        mallItemId: itemId,
        quantity,
        amountCents: totalValueCents,
        itemName: item.name,
        itemDescription: item.description || void 0,
        emailAddress: user.email || void 0
      });
      const paymentData = createPaymentData2({
        orderId: order.id,
        amount: formatAmountCents2(totalValueCents),
        itemName: `${item.name}${quantity > 1 ? ` x${quantity}` : ""}`,
        itemDescription: item.description || void 0,
        email: user.email || void 0,
        firstName: user.displayName?.split(" ")[0] || user.username,
        lastName: user.displayName?.split(" ").slice(1).join(" ") || void 0,
        returnUrl: `${baseUrl}/api/payments/payfast/return?order_id=${order.id}`,
        cancelUrl: `${baseUrl}/api/payments/payfast/cancel?order_id=${order.id}`,
        notifyUrl: `${baseUrl}/api/payments/payfast/notify`,
        userId: req.session.userId
      });
      console.log("[PayFast] Created order:", order.id, "for item:", item.name);
      res.json({
        orderId: order.id,
        paymentUrl: getPayFastUrl2(),
        paymentData,
        item: {
          id: item.id,
          name: item.name,
          value: item.value,
          quantity,
          totalValue: item.value * quantity
        }
      });
    } catch (error) {
      console.error("[PayFast] Failed to create payment:", error);
      res.status(500).json({ message: error?.message || "Failed to create payment" });
    }
  });
  app2.post("/api/payments/payfast/notify", async (req, res) => {
    try {
      console.log("[PayFast ITN] Received notification:", JSON.stringify(req.body));
      const itnData = req.body;
      if (!validateITNSignature2(itnData)) {
        console.error("[PayFast ITN] Invalid signature");
        return res.status(400).send("Invalid signature");
      }
      const orderId = itnData.m_payment_id;
      const order = await storage.getPayfastOrder(orderId);
      if (!order) {
        console.error("[PayFast ITN] Order not found:", orderId);
        return res.status(404).send("Order not found");
      }
      if (order.status === "COMPLETE") {
        console.log("[PayFast ITN] Order already completed:", orderId);
        return res.status(200).send("OK");
      }
      if (itnData.payment_status === "COMPLETE") {
        await storage.completePayfastOrder(orderId, {
          pfPaymentId: itnData.pf_payment_id,
          paymentStatus: itnData.payment_status,
          amountGross: itnData.amount_gross,
          amountFee: itnData.amount_fee,
          amountNet: itnData.amount_net,
          signature: itnData.signature,
          itnPayload: JSON.stringify(itnData)
        });
        if (order.mallItemId) {
          const purchase = await storage.purchaseMallItem(order.userId, order.mallItemId, order.quantity);
          console.log("[PayFast ITN] Purchase completed:", purchase?.id, "Net worth updated for user:", order.userId);
        }
        console.log("[PayFast ITN] Order completed successfully:", orderId);
      } else {
        await storage.updatePayfastOrder(orderId, {
          status: "FAILED",
          paymentStatus: itnData.payment_status,
          itnPayload: JSON.stringify(itnData)
        });
        console.log("[PayFast ITN] Payment failed:", orderId, "Status:", itnData.payment_status);
      }
      res.status(200).send("OK");
    } catch (error) {
      console.error("[PayFast ITN] Error processing notification:", error);
      res.status(500).send("Error");
    }
  });
  app2.post("/api/payments/payfast/complete-purchase", requireAuth4, async (req, res) => {
    const { orderId } = req.body;
    console.log("[PayFast Complete] Starting purchase completion for order:", orderId);
    console.log("[PayFast Complete] User ID from session:", req.session.userId);
    try {
      if (!orderId) {
        console.log("[PayFast Complete] No order ID provided");
        return res.json({ success: false, message: "No order ID provided" });
      }
      const order = await storage.getPayfastOrder(orderId);
      console.log("[PayFast Complete] Order found:", order ? "yes" : "no");
      if (!order) {
        console.log("[PayFast Complete] Order not found:", orderId);
        return res.json({ success: false, message: "Order not found" });
      }
      console.log("[PayFast Complete] Order details:", {
        id: order.id,
        userId: order.userId,
        mallItemId: order.mallItemId,
        status: order.status,
        itemName: order.itemName,
        quantity: order.quantity
      });
      if (order.userId !== req.session.userId) {
        console.log("[PayFast Complete] User mismatch:", order.userId, "vs", req.session.userId);
        return res.json({ success: false, message: "Order does not belong to this user" });
      }
      const existingPurchases = await storage.getUserPurchases(order.userId);
      const alreadyPurchased = existingPurchases.some(
        (p) => p.itemId === order.mallItemId && new Date(p.createdAt).getTime() > new Date(order.createdAt).getTime() - 6e4
      );
      if (alreadyPurchased) {
        console.log("[PayFast Complete] Purchase already exists for this order");
        const user2 = await storage.getUser(order.userId);
        return res.json({
          success: true,
          message: "Purchase already completed",
          newNetWorth: user2?.netWorth || 0,
          alreadyCompleted: true
        });
      }
      if (order.status !== "COMPLETE") {
        console.log("[PayFast Complete] Marking order as COMPLETE");
        await storage.updatePayfastOrder(orderId, {
          status: "COMPLETE",
          completedAt: /* @__PURE__ */ new Date(),
          paymentStatus: "COMPLETE"
        });
      }
      if (order.mallItemId) {
        console.log("[PayFast Complete] Calling purchaseMallItem for:", order.mallItemId);
        const purchase = await storage.purchaseMallItem(order.userId, order.mallItemId, order.quantity);
        console.log("[PayFast Complete] Purchase created:", purchase?.id);
        console.log("[PayFast Complete] Net worth gained:", purchase?.netWorthGained);
      }
      const user = await storage.getUser(order.userId);
      console.log("[PayFast Complete] Final net worth:", user?.netWorth);
      res.json({
        success: true,
        message: "Purchase completed successfully",
        newNetWorth: user?.netWorth || 0,
        itemName: order.itemName
      });
    } catch (error) {
      console.error("[PayFast Complete] Error:", error);
      res.json({ success: false, message: error?.message || "An error occurred" });
    }
  });
  app2.get("/api/payments/payfast/return", async (req, res) => {
    const orderId = req.query.order_id;
    console.log("[PayFast] User returned from payment, order:", orderId);
    let success = false;
    let errorMessage = "";
    let itemName = "";
    let newNetWorth = 0;
    try {
      if (orderId) {
        const order = await storage.getPayfastOrder(orderId);
        if (order && order.status === "PENDING") {
          console.log("[PayFast Return] Order is PENDING, completing purchase...");
          await storage.updatePayfastOrder(orderId, {
            status: "COMPLETE",
            completedAt: /* @__PURE__ */ new Date(),
            paymentStatus: "COMPLETE"
          });
          if (order.mallItemId) {
            const purchase = await storage.purchaseMallItem(order.userId, order.mallItemId, order.quantity);
            console.log("[PayFast Return] Mall purchase completed:", purchase);
          }
          const user = await storage.getUser(order.userId);
          newNetWorth = user?.netWorth || 0;
          itemName = order.itemName;
          success = true;
          console.log("[PayFast Return] Order completed successfully, new net worth:", newNetWorth);
        } else if (order && order.status === "COMPLETE") {
          if (order.mallItemId) {
            const userPurchases = await storage.getUserPurchases(order.userId);
            const recentPurchase = userPurchases.find(
              (p) => p.itemId === order.mallItemId && new Date(p.createdAt).getTime() > (order.createdAt?.getTime() || 0) - 6e4
            );
            if (!recentPurchase) {
              console.log("[PayFast Return] Order was COMPLETE but purchase not found, making purchase now...");
              const purchase = await storage.purchaseMallItem(order.userId, order.mallItemId, order.quantity);
              console.log("[PayFast Return] Late purchase completed:", purchase?.id);
            } else {
              console.log("[PayFast Return] Purchase already exists:", recentPurchase.id);
            }
          }
          const user = await storage.getUser(order.userId);
          newNetWorth = user?.netWorth || 0;
          itemName = order.itemName;
          success = true;
          console.log("[PayFast Return] Order was already completed, net worth:", newNetWorth);
        } else if (!order) {
          errorMessage = "Order not found";
          console.log("[PayFast Return] Order not found:", orderId);
        } else {
          errorMessage = `Order status: ${order.status}`;
          console.log("[PayFast Return] Order in unexpected status:", order.status);
        }
      } else {
        errorMessage = "No order ID provided";
      }
    } catch (error) {
      console.error("[PayFast Return] Error completing order:", error);
      errorMessage = "An error occurred processing your payment";
    }
    if (success) {
      res.send(`
        <!DOCTYPE html>
        <html>
          <head>
            <title>Payment Successful</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
              .card { background: white; border-radius: 16px; padding: 40px; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.2); max-width: 400px; }
              h1 { color: #10B981; margin-bottom: 16px; }
              p { color: #666; margin-bottom: 16px; }
              .checkmark { width: 60px; height: 60px; border-radius: 50%; background: #10B981; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px; }
              .checkmark svg { width: 30px; height: 30px; fill: white; }
              .networth { font-size: 24px; color: #667eea; font-weight: bold; margin: 16px 0; }
            </style>
          </head>
          <body>
            <div class="card">
              <div class="checkmark">
                <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
              </div>
              <h1>Payment Successful!</h1>
              <p><strong>${itemName}</strong> has been added to your collection.</p>
              <p class="networth">Net Worth: R${newNetWorth.toLocaleString()}</p>
              <p style="font-size: 14px; color: #999;">You can now close this page and return to the app.</p>
            </div>
          </body>
        </html>
      `);
    } else {
      res.send(`
        <!DOCTYPE html>
        <html>
          <head>
            <title>Payment Issue</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
              .card { background: white; border-radius: 16px; padding: 40px; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.2); max-width: 400px; }
              h1 { color: #EF4444; margin-bottom: 16px; }
              p { color: #666; margin-bottom: 24px; }
            </style>
          </head>
          <body>
            <div class="card">
              <h1>Payment Issue</h1>
              <p>${errorMessage || "There was an issue processing your payment."}</p>
              <p style="font-size: 14px; color: #999;">Please contact support if you were charged.</p>
              <p style="font-size: 12px; color: #ccc;">Order ID: ${orderId || "N/A"}</p>
            </div>
          </body>
        </html>
      `);
    }
  });
  app2.get("/api/payments/payfast/cancel", async (req, res) => {
    const orderId = req.query.order_id;
    console.log("[PayFast] User cancelled payment, order:", orderId);
    if (orderId) {
      await storage.updatePayfastOrder(orderId, { status: "CANCELLED" });
    }
    res.send(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>Payment Cancelled</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
            .card { background: white; border-radius: 16px; padding: 40px; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.2); max-width: 400px; }
            h1 { color: #333; margin-bottom: 16px; }
            p { color: #666; }
          </style>
        </head>
        <body>
          <div class="card">
            <h1>Payment Cancelled</h1>
            <p>Your payment was cancelled. You can close this page and return to the app.</p>
          </div>
        </body>
      </html>
    `);
  });
  app2.get("/api/payments/payfast/status/:orderId", requireAuth4, async (req, res) => {
    try {
      const order = await storage.getPayfastOrder(req.params.orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      if (order.userId !== req.session.userId) {
        return res.status(403).json({ message: "Not authorized" });
      }
      res.json({
        orderId: order.id,
        status: order.status,
        completedAt: order.completedAt
      });
    } catch (error) {
      console.error("[PayFast] Failed to get order status:", error);
      res.status(500).json({ message: "Failed to get order status" });
    }
  });
  app2.get("/api/payments/payfast/orders", requireAuth4, async (req, res) => {
    try {
      const orders = await storage.getUserPayfastOrders(req.session.userId);
      res.json(orders);
    } catch (error) {
      console.error("[PayFast] Failed to get user orders:", error);
      res.status(500).json({ message: "Failed to get orders" });
    }
  });
  app2.get("/api/messages/inbox/:folder", requireAuth4, async (req, res) => {
    try {
      const folder = req.params.folder.toUpperCase();
      if (folder !== "PRIMARY" && folder !== "GENERAL") {
        return res.status(400).json({ message: "Invalid folder" });
      }
      const conversations3 = await storage.getUserConversationsByFolder(req.session.userId, folder);
      res.json(conversations3);
    } catch (error) {
      console.error("Failed to get inbox conversations:", error);
      res.status(500).json({ message: "Failed to get inbox conversations" });
    }
  });
  app2.get("/api/messages/requests", requireAuth4, async (req, res) => {
    try {
      const requests = await storage.getMessageRequests(req.session.userId);
      res.json(requests);
    } catch (error) {
      console.error("Failed to get message requests:", error);
      res.status(500).json({ message: "Failed to get message requests" });
    }
  });
  app2.post("/api/messages/requests/:conversationId/accept", requireAuth4, async (req, res) => {
    try {
      const conversation = await storage.getConversation(req.params.conversationId);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      const isParticipant = await storage.isConversationParticipant(req.params.conversationId, req.session.userId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const updated = await storage.acceptMessageRequest(req.params.conversationId, req.session.userId);
      res.json(updated);
    } catch (error) {
      console.error("Failed to accept message request:", error);
      res.status(500).json({ message: "Failed to accept message request" });
    }
  });
  app2.delete("/api/messages/requests/:conversationId", requireAuth4, async (req, res) => {
    try {
      const conversation = await storage.getConversation(req.params.conversationId);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      const isParticipant = await storage.isConversationParticipant(req.params.conversationId, req.session.userId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.declineMessageRequest(req.params.conversationId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to decline message request:", error);
      res.status(500).json({ message: "Failed to decline message request" });
    }
  });
  app2.patch("/api/messages/conversations/:conversationId/folder", requireAuth4, async (req, res) => {
    try {
      const { folder } = req.body;
      if (folder !== "PRIMARY" && folder !== "GENERAL") {
        return res.status(400).json({ message: "Invalid folder" });
      }
      const conversation = await storage.getConversation(req.params.conversationId);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }
      const isParticipant = await storage.isConversationParticipant(req.params.conversationId, req.session.userId);
      if (!isParticipant) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const updated = await storage.updateConversationFolder(req.params.conversationId, folder);
      res.json(updated);
    } catch (error) {
      console.error("Failed to update conversation folder:", error);
      res.status(500).json({ message: "Failed to update conversation folder" });
    }
  });
  app2.get("/api/discover/new-people", requireAuth4, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 20;
      const users4 = await storage.getNewPeopleToFollow(req.session.userId, limit);
      res.json(users4);
    } catch (error) {
      console.error("Failed to get new people to follow:", error);
      res.status(500).json({ message: "Failed to get new people to follow" });
    }
  });
  app2.get("/api/discover/reels", requireAuth4, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const posts3 = await storage.getAlgorithmReelsPosts(req.session.userId, limit, offset);
      res.json(posts3);
    } catch (error) {
      console.error("Failed to get reels:", error);
      res.status(500).json({ message: "Failed to get reels" });
    }
  });
  app2.get("/api/discover/explore", requireAuth4, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 30;
      const offset = parseInt(req.query.offset) || 0;
      const posts3 = await storage.getExplorePosts(req.session.userId, limit, offset);
      res.json(posts3);
    } catch (error) {
      console.error("Failed to get explore posts:", error);
      res.status(500).json({ message: "Failed to get explore posts" });
    }
  });
  app2.get("/api/discover/trends", requireAuth4, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 20;
      const trendingPosts = await storage.getTrendingPosts(limit);
      res.json(trendingPosts);
    } catch (error) {
      console.error("Failed to get trends:", error);
      res.status(500).json({ message: "Failed to get trends" });
    }
  });
  app2.get("/api/discover/voices", requireAuth4, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 30;
      const offset = parseInt(req.query.offset) || 0;
      const posts3 = await storage.getVoicePosts(req.session.userId, limit, offset);
      res.json(posts3);
    } catch (error) {
      console.error("Failed to get voice posts:", error);
      res.status(500).json({ message: "Failed to get voice posts" });
    }
  });
  app2.get("/api/discover/people", requireAuth4, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 30;
      const userId = req.session.userId;
      const sessionId = req.query.sessionId;
      const suggestedPeople = await storage.getSuggestedPeople(userId, limit);
      for (const person of suggestedPeople) {
        await storage.markProfileAsSeen(userId, person.id, sessionId);
      }
      const peopleWithFollowStatus = suggestedPeople.map((person) => ({
        ...person,
        isFollowing: false
      }));
      res.json(peopleWithFollowStatus);
    } catch (error) {
      console.error("Failed to get suggested people:", error?.message || error, error?.stack);
      res.status(500).json({ message: "Failed to get suggested people" });
    }
  });
  app2.post("/api/discover/interaction", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const {
        contentId,
        contentType,
        // REEL, VOICE, PHOTO, TEXT, STORY
        interactionType,
        // VIEW, LIKE, SAVE, SHARE, COMMENT, SKIP, REWATCH
        watchTimeMs,
        completionRate,
        rewatchCount,
        skippedAtMs,
        creatorId,
        sessionId
      } = req.body;
      if (!contentId || !contentType || !interactionType) {
        return res.status(400).json({ message: "Missing required fields" });
      }
      await storage.recordContentInteraction({
        userId,
        contentId,
        contentType: contentType.toUpperCase(),
        interactionType: interactionType.toUpperCase(),
        watchTimeMs,
        completionRate,
        rewatchCount,
        skippedAtMs,
        creatorId,
        sessionId
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to record interaction:", error);
      res.status(500).json({ message: "Failed to record interaction" });
    }
  });
  app2.get("/api/discover/feed", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const contentType = (req.query.type || "REEL").toUpperCase();
      const limit = parseInt(req.query.limit) || 20;
      const sessionId = req.query.sessionId;
      const excludeIds = req.query.exclude ? req.query.exclude.split(",") : [];
      const feed = await storage.getPersonalizedContentFeed(userId, contentType, {
        limit,
        sessionId,
        excludeIds
      });
      res.json(feed);
    } catch (error) {
      console.error("Failed to get personalized feed:", error);
      res.status(500).json({ message: "Failed to get personalized feed" });
    }
  });
  app2.get("/api/discover/preferences", requireAuth4, async (req, res) => {
    try {
      const preferences = await storage.getUserContentPreferences(req.session.userId);
      res.json(preferences || {
        reelPreference: 50,
        voicePreference: 50,
        photoPreference: 50,
        textPreference: 50
      });
    } catch (error) {
      console.error("Failed to get preferences:", error);
      res.status(500).json({ message: "Failed to get preferences" });
    }
  });
  app2.post("/api/discover/not-interested/profile/:profileId", requireAuth4, async (req, res) => {
    try {
      const { reason } = req.body;
      await storage.markDiscoveryNotInterested(
        req.session.userId,
        req.params.profileId,
        "CREATOR",
        reason
      );
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to mark profile as not interested:", error);
      res.status(500).json({ message: "Failed to mark as not interested" });
    }
  });
  app2.post("/api/discover/not-interested/content/:contentId", requireAuth4, async (req, res) => {
    try {
      const { reason } = req.body;
      await storage.markDiscoveryNotInterested(
        req.session.userId,
        req.params.contentId,
        "CONTENT",
        reason
      );
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to mark content as not interested:", error);
      res.status(500).json({ message: "Failed to mark as not interested" });
    }
  });
  app2.get("/api/discover/top-creators", requireAuth4, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 10;
      const creatorIds = await storage.getTopCreatorAffinities(req.session.userId, limit);
      res.json(creatorIds);
    } catch (error) {
      console.error("Failed to get top creators:", error);
      res.status(500).json({ message: "Failed to get top creators" });
    }
  });
  const httpServer = createServer(app2);
  const wss = new WebSocketServer({ server: httpServer, path: "/ws" });
  wss.on("connection", async (ws, req) => {
    let userId = null;
    const cookies = parseCookies(req.headers.cookie);
    const sessionId = cookies["connect.sid"];
    if (sessionId) {
      userId = await getSessionUserId(sessionId);
    }
    if (!userId && req.url) {
      const url = new URL(req.url, `http://${req.headers.host}`);
      const urlUserId = url.searchParams.get("userId");
      if (urlUserId) {
        const userExists = await storage.getUser(urlUserId);
        if (userExists) {
          userId = urlUserId;
          console.log("[WebSocket] Authenticated via URL param, userId:", userId);
        }
      }
    }
    if (!userId) {
      console.log("[WebSocket] Auth failed - no valid session or userId");
      ws.send(JSON.stringify({ type: "auth_error", message: "Authentication required" }));
      ws.close(1008, "Authentication required");
      return;
    }
    addClientToUser(userId, ws);
    ws.send(JSON.stringify({ type: "auth_success", userId }));
    ws.on("message", async (data) => {
      try {
        const message = JSON.parse(data.toString());
        if (message.type === "ping") {
          ws.send(JSON.stringify({ type: "pong" }));
        }
        if (message.type === "join_conversation" && message.conversationId) {
          ws.send(JSON.stringify({
            type: "joined_conversation",
            conversationId: message.conversationId
          }));
        }
        if (message.type === "call_offer" && message.targetUserId && message.callId) {
          console.log(`[VoiceCall][Server] call_offer: from=${userId} to=${message.targetUserId} callId=${message.callId}`);
          const callerProfile = await storage.getUser(userId);
          const success = broadcastToUser(message.targetUserId, {
            type: "incoming_call",
            callId: message.callId,
            callerId: userId,
            callType: message.callType || "AUDIO",
            caller: callerProfile ? {
              id: callerProfile.id,
              username: callerProfile.username,
              displayName: callerProfile.displayName || callerProfile.username,
              avatarUrl: callerProfile.avatarUrl
            } : null
          });
          console.log(`[VoiceCall][Server] call_offer relay success: ${success}`);
        }
        if (message.type === "call_answer" && message.targetUserId && message.callId) {
          console.log(`[VoiceCall][Server] call_answer: from=${userId} to=${message.targetUserId} callId=${message.callId}`);
          const success = broadcastToUser(message.targetUserId, {
            type: "call_answered",
            callId: message.callId,
            answererId: userId
          });
          console.log(`[VoiceCall][Server] call_answer relay success: ${success}`);
        }
        if (message.type === "call_decline" && message.targetUserId && message.callId) {
          console.log(`[VoiceCall][Server] call_decline: from=${userId} to=${message.targetUserId}`);
          broadcastToUser(message.targetUserId, {
            type: "call_declined",
            callId: message.callId,
            declinerId: userId
          });
        }
        if (message.type === "call_end" && message.targetUserId && message.callId) {
          console.log(`[VoiceCall][Server] call_end: from=${userId} to=${message.targetUserId}`);
          broadcastToUser(message.targetUserId, {
            type: "call_ended",
            callId: message.callId,
            enderId: userId
          });
        }
        if (message.type === "audio_data" && message.targetUserId && message.callId) {
          const audioSize = message.audioData?.length || 0;
          console.log(`[VoiceCall][Server] Relaying audio: from=${userId} to=${message.targetUserId} callId=${message.callId} size=${audioSize}`);
          const success = broadcastToUser(message.targetUserId, {
            type: "audio_data",
            callId: message.callId,
            senderId: userId,
            audioData: message.audioData,
            timestamp: message.timestamp
          });
          if (!success) {
            console.log(`[VoiceCall][Server] Failed to relay audio - target user ${message.targetUserId} not connected`);
          }
        }
        if (message.type === "ice_candidate" && message.targetUserId) {
          broadcastToUser(message.targetUserId, {
            type: "ice_candidate",
            candidate: message.candidate,
            senderId: userId
          });
        }
        if (message.type === "typing_start" && message.conversationId) {
          try {
            const conversation = await storage.getConversation(message.conversationId);
            if (!conversation) {
              console.log("[WebSocket] typing_start: conversation not found");
              return;
            }
            const isParticipant = await storage.isConversationParticipant(message.conversationId, userId);
            if (!isParticipant) {
              console.log("[WebSocket] typing_start: user not participant");
              return;
            }
            const timestamp3 = Date.now();
            const participants = getConversationParticipantIds(conversation);
            participants.forEach((participantId) => {
              if (participantId !== userId) {
                broadcastToUser(participantId, {
                  type: "typing_indicator",
                  conversationId: message.conversationId,
                  userId,
                  isTyping: true,
                  timestamp: timestamp3
                });
              }
            });
            setTypingState(message.conversationId, userId, () => {
              participants.forEach((participantId) => {
                if (participantId !== userId) {
                  broadcastToUser(participantId, {
                    type: "typing_indicator",
                    conversationId: message.conversationId,
                    userId,
                    isTyping: false,
                    timestamp: Date.now()
                  });
                }
              });
            });
          } catch (error) {
            console.error("[WebSocket] typing_start error:", error);
          }
        }
        if (message.type === "typing_stop" && message.conversationId) {
          try {
            const conversation = await storage.getConversation(message.conversationId);
            if (!conversation) return;
            const isParticipant = await storage.isConversationParticipant(message.conversationId, userId);
            if (!isParticipant) return;
            clearTypingState(message.conversationId, userId);
            const timestamp3 = Date.now();
            const participants = getConversationParticipantIds(conversation);
            participants.forEach((participantId) => {
              if (participantId !== userId) {
                broadcastToUser(participantId, {
                  type: "typing_indicator",
                  conversationId: message.conversationId,
                  userId,
                  isTyping: false,
                  timestamp: timestamp3
                });
              }
            });
          } catch (error) {
            console.error("[WebSocket] typing_stop error:", error);
          }
        }
        if (message.type === "message_delivered" && message.messageId && message.conversationId) {
          try {
            const isParticipant = await storage.isConversationParticipant(message.conversationId, userId);
            if (!isParticipant) {
              console.log("[WebSocket] message_delivered: user not participant");
              return;
            }
            const msg = await storage.getMessage(message.messageId);
            if (!msg || msg.conversationId !== message.conversationId) {
              console.log("[WebSocket] message_delivered: message not found or mismatch");
              return;
            }
            if (msg.receiverId !== userId) {
              console.log("[WebSocket] message_delivered: user not receiver");
              return;
            }
            const timestamp3 = /* @__PURE__ */ new Date();
            await db.update(messages).set({ status: "DELIVERED", deliveredAt: timestamp3 }).where(and16(
              eq17(messages.id, message.messageId),
              eq17(messages.status, "SENT")
            ));
            broadcastToUser(msg.senderId, {
              type: "status_update",
              messageId: message.messageId,
              conversationId: message.conversationId,
              userId,
              status: "DELIVERED",
              timestamp: timestamp3.getTime()
            });
          } catch (error) {
            console.error("[WebSocket] message_delivered error:", error);
          }
        }
        if (message.type === "message_read" && message.messageId && message.conversationId) {
          try {
            const isParticipant = await storage.isConversationParticipant(message.conversationId, userId);
            if (!isParticipant) {
              console.log("[WebSocket] message_read: user not participant");
              return;
            }
            const msg = await storage.getMessage(message.messageId);
            if (!msg || msg.conversationId !== message.conversationId) {
              console.log("[WebSocket] message_read: message not found or mismatch");
              return;
            }
            if (msg.receiverId !== userId) {
              console.log("[WebSocket] message_read: user not receiver");
              return;
            }
            const timestamp3 = /* @__PURE__ */ new Date();
            await db.update(messages).set({ status: "READ", read: true, readAt: timestamp3 }).where(eq17(messages.id, message.messageId));
            broadcastToUser(msg.senderId, {
              type: "status_update",
              messageId: message.messageId,
              conversationId: message.conversationId,
              userId,
              status: "READ",
              timestamp: timestamp3.getTime()
            });
          } catch (error) {
            console.error("[WebSocket] message_read error:", error);
          }
        }
        if (message.type === "add_reaction" && message.messageId && message.conversationId && message.emoji) {
          try {
            const isParticipant = await storage.isConversationParticipant(message.conversationId, userId);
            if (!isParticipant) {
              console.log("[WebSocket] add_reaction: user not participant");
              return;
            }
            const msg = await storage.getMessage(message.messageId);
            if (!msg || msg.conversationId !== message.conversationId) {
              console.log("[WebSocket] add_reaction: message not found or mismatch");
              return;
            }
            const conversation = await storage.getConversation(message.conversationId);
            if (!conversation) return;
            await storage.addMessageReaction(message.messageId, userId, message.emoji);
            const timestamp3 = Date.now();
            const participants = getConversationParticipantIds(conversation);
            participants.forEach((participantId) => {
              broadcastToUser(participantId, {
                type: "reaction_update",
                messageId: message.messageId,
                conversationId: message.conversationId,
                userId,
                emoji: message.emoji,
                action: "add",
                timestamp: timestamp3
              });
            });
          } catch (error) {
            console.error("[WebSocket] add_reaction error:", error);
          }
        }
        if (message.type === "remove_reaction" && message.messageId && message.conversationId && message.emoji) {
          try {
            const isParticipant = await storage.isConversationParticipant(message.conversationId, userId);
            if (!isParticipant) {
              console.log("[WebSocket] remove_reaction: user not participant");
              return;
            }
            const msg = await storage.getMessage(message.messageId);
            if (!msg || msg.conversationId !== message.conversationId) {
              console.log("[WebSocket] remove_reaction: message not found or mismatch");
              return;
            }
            const conversation = await storage.getConversation(message.conversationId);
            if (!conversation) return;
            await storage.removeMessageReaction(message.messageId, userId, message.emoji);
            const timestamp3 = Date.now();
            const participants = getConversationParticipantIds(conversation);
            participants.forEach((participantId) => {
              broadcastToUser(participantId, {
                type: "reaction_update",
                messageId: message.messageId,
                conversationId: message.conversationId,
                userId,
                emoji: message.emoji,
                action: "remove",
                timestamp: timestamp3
              });
            });
          } catch (error) {
            console.error("[WebSocket] remove_reaction error:", error);
          }
        }
      } catch (error) {
        console.error("WebSocket message error:", error);
      }
    });
    ws.on("close", () => {
      removeClientFromUser(userId, ws);
    });
    ws.on("error", (error) => {
      console.error("WebSocket error:", error);
      removeClientFromUser(userId, ws);
    });
  });
  app2.post("/api/ai/moderate-text", requireAuth4, async (req, res) => {
    try {
      const { content } = req.body;
      if (!content) {
        return res.status(400).json({ message: "Content is required" });
      }
      const result = await moderateText(content);
      res.json(result);
    } catch (error) {
      console.error("Text moderation error:", error);
      res.status(500).json({ message: "Failed to moderate content" });
    }
  });
  app2.post("/api/ai/analyze-image", requireAuth4, async (req, res) => {
    try {
      const { imageUrl } = req.body;
      if (!imageUrl) {
        return res.status(400).json({ message: "Image URL is required" });
      }
      const result = await analyzeImage(imageUrl);
      res.json(result);
    } catch (error) {
      console.error("Image analysis error:", error);
      res.status(500).json({ message: "Failed to analyze image" });
    }
  });
  app2.post("/api/ai/content-suggestions", requireAuth4, async (req, res) => {
    try {
      const { content, category, audience } = req.body;
      if (!content) {
        return res.status(400).json({ message: "Content is required" });
      }
      const result = await getContentSuggestions(content, { category, audience });
      res.json(result);
    } catch (error) {
      console.error("Content suggestions error:", error);
      res.status(500).json({ message: "Failed to get suggestions" });
    }
  });
  app2.post("/api/ai/detect-language", requireAuth4, async (req, res) => {
    try {
      const { content } = req.body;
      if (!content) {
        return res.status(400).json({ message: "Content is required" });
      }
      const result = await detectLanguage(content);
      res.json(result);
    } catch (error) {
      console.error("Language detection error:", error);
      res.status(500).json({ message: "Failed to detect language" });
    }
  });
  app2.post("/api/ai/summarize", requireAuth4, async (req, res) => {
    try {
      const { contents } = req.body;
      if (!contents || !Array.isArray(contents) || contents.length === 0) {
        return res.status(400).json({ message: "Contents array is required" });
      }
      const summary = await summarizeContent(contents);
      res.json({ summary });
    } catch (error) {
      console.error("Content summarization error:", error);
      res.status(500).json({ message: "Failed to summarize content" });
    }
  });
  app2.post("/api/ai/generate-caption", requireAuth4, async (req, res) => {
    try {
      const { description, mood, style, audience } = req.body;
      if (!description) {
        return res.status(400).json({ message: "Description is required" });
      }
      const result = await generateSmartCaption(description, { mood, style, audience });
      res.json(result);
    } catch (error) {
      console.error("Caption generation error:", error);
      res.status(500).json({ message: "Failed to generate caption" });
    }
  });
  app2.post("/api/ai/caption-image", requireAuth4, async (req, res) => {
    try {
      const { imageUrl } = req.body;
      if (!imageUrl) {
        return res.status(400).json({ message: "Image URL is required" });
      }
      const result = await generateImageCaption(imageUrl);
      res.json(result);
    } catch (error) {
      console.error("Image caption error:", error);
      res.status(500).json({ message: "Failed to caption image" });
    }
  });
  app2.post("/api/ai/transcribe", requireAuth4, async (req, res) => {
    try {
      const { audioUrl } = req.body;
      if (!audioUrl) {
        return res.status(400).json({ message: "Audio URL is required" });
      }
      const result = await transcribeVoiceMessage(audioUrl);
      res.json(result);
    } catch (error) {
      console.error("Transcription error:", error);
      res.status(500).json({ message: "Failed to transcribe audio" });
    }
  });
  app2.post("/api/ai/enhance-post", requireAuth4, async (req, res) => {
    try {
      const { content, targetTone, maxLength } = req.body;
      if (!content) {
        return res.status(400).json({ message: "Content is required" });
      }
      const result = await enhancePost(content, { targetTone, maxLength });
      res.json(result);
    } catch (error) {
      console.error("Post enhancement error:", error);
      res.status(500).json({ message: "Failed to enhance post" });
    }
  });
  app2.post("/api/ai/assistant", requireAuth4, async (req, res) => {
    try {
      const { query, topic, previousMessages } = req.body;
      if (!query) {
        return res.status(400).json({ message: "Query is required" });
      }
      const result = await getAIAssistance(query, { topic, previousMessages });
      res.json(result);
    } catch (error) {
      console.error("AI assistant error:", error);
      res.status(500).json({ message: "Failed to get AI assistance" });
    }
  });
  app2.post("/api/ai/voice-summary", requireAuth4, async (req, res) => {
    try {
      const { transcription } = req.body;
      if (!transcription) {
        return res.status(400).json({ message: "Transcription is required" });
      }
      const summary = await generateVoicePostSummary(transcription);
      res.json({ summary });
    } catch (error) {
      console.error("Voice summary error:", error);
      res.status(500).json({ message: "Failed to generate voice summary" });
    }
  });
  app2.post("/api/settings/email/request-change", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { newEmail } = req.body;
      if (!newEmail || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(newEmail)) {
        return res.status(400).json({ message: "Valid email address required" });
      }
      const existingUser = await storage.getUserByEmail(newEmail);
      if (existingUser && existingUser.id !== userId) {
        return res.status(400).json({ message: "Email already in use by another account" });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      const verificationCode = generateVerificationCode();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1e3);
      await db.insert(emailVerificationTokens).values({
        userId,
        email: newEmail,
        token: verificationCode,
        expiresAt
      });
      sendVerificationEmail(newEmail, user.displayName || user.username, verificationCode).catch((err) => {
        console.error("[Email] Failed to send email change verification:", err);
      });
      res.json({ message: "Verification code sent to your new email address", expiresIn: 600 });
    } catch (error) {
      console.error("Email change request error:", error);
      res.status(500).json({ message: "Failed to process email change request" });
    }
  });
  app2.post("/api/settings/email/verify-change", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { code, newEmail } = req.body;
      if (!code || !newEmail) {
        return res.status(400).json({ message: "Verification code and new email are required" });
      }
      const [token] = await db.select().from(emailVerificationTokens).where(
        and16(
          eq17(emailVerificationTokens.userId, userId),
          eq17(emailVerificationTokens.token, code),
          eq17(emailVerificationTokens.email, newEmail),
          isNull8(emailVerificationTokens.verifiedAt),
          gt6(emailVerificationTokens.expiresAt, /* @__PURE__ */ new Date())
        )
      ).limit(1);
      if (!token) {
        return res.status(400).json({ message: "Invalid or expired verification code" });
      }
      await db.update(emailVerificationTokens).set({ verifiedAt: /* @__PURE__ */ new Date() }).where(eq17(emailVerificationTokens.id, token.id));
      await storage.updateUser(userId, {
        email: newEmail,
        emailVerified: true
      });
      res.json({ message: "Email updated successfully" });
    } catch (error) {
      console.error("Email change verification error:", error);
      res.status(500).json({ message: "Failed to verify email change" });
    }
  });
  app2.get("/api/sms/status", requireAuth4, async (req, res) => {
    res.json({ configured: isSMSConfigured() });
  });
  app2.post("/api/phone/send-code", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { phoneNumber } = req.body;
      if (!phoneNumber || !/^\+[1-9]\d{1,14}$/.test(phoneNumber)) {
        return res.status(400).json({ message: "Valid phone number required (E.164 format: +1234567890)" });
      }
      if (!isSMSConfigured()) {
        return res.status(503).json({ message: "SMS service not configured" });
      }
      const code = generateVerificationCode();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1e3);
      await db.insert(phoneVerificationTokens).values({
        userId,
        phoneNumber,
        token: code,
        expiresAt
      });
      const result = await sendVerificationCode(phoneNumber, code);
      if (result.success) {
        res.json({ message: "Verification code sent", expiresIn: 600 });
      } else {
        res.status(500).json({ message: result.error || "Failed to send code" });
      }
    } catch (error) {
      console.error("Phone verification error:", error);
      res.status(500).json({ message: "Failed to send verification code" });
    }
  });
  app2.post("/api/phone/verify", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { code, phoneNumber } = req.body;
      if (!code || !phoneNumber) {
        return res.status(400).json({ message: "Code and phone number required" });
      }
      const [token] = await db.select().from(phoneVerificationTokens).where(
        and16(
          eq17(phoneVerificationTokens.userId, userId),
          eq17(phoneVerificationTokens.token, code),
          eq17(phoneVerificationTokens.phoneNumber, phoneNumber),
          isNull8(phoneVerificationTokens.verifiedAt),
          gt6(phoneVerificationTokens.expiresAt, /* @__PURE__ */ new Date())
        )
      ).limit(1);
      if (!token) {
        return res.status(400).json({ message: "Invalid or expired verification code" });
      }
      await db.update(phoneVerificationTokens).set({ verifiedAt: /* @__PURE__ */ new Date() }).where(eq17(phoneVerificationTokens.id, token.id));
      await storage.updateUser(userId, {
        phoneNumber,
        phoneVerified: true
      });
      res.json({ message: "Phone verified successfully" });
    } catch (error) {
      console.error("Phone verification error:", error);
      res.status(500).json({ message: "Failed to verify phone" });
    }
  });
  app2.patch("/api/phone/notifications", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { enabled } = req.body;
      if (typeof enabled !== "boolean") {
        return res.status(400).json({ message: "enabled must be a boolean" });
      }
      const user = await storage.getUser(userId);
      if (!user?.phoneVerified) {
        return res.status(400).json({ message: "Phone must be verified first" });
      }
      await storage.updateUser(userId, { smsNotificationsEnabled: enabled });
      res.json({ message: `SMS notifications ${enabled ? "enabled" : "disabled"}` });
    } catch (error) {
      console.error("SMS notification update error:", error);
      res.status(500).json({ message: "Failed to update SMS notifications" });
    }
  });
  app2.delete("/api/phone", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      await storage.updateUser(userId, {
        phoneNumber: null,
        phoneVerified: false,
        smsNotificationsEnabled: false
      });
      res.json({ message: "Phone number removed" });
    } catch (error) {
      console.error("Phone removal error:", error);
      res.status(500).json({ message: "Failed to remove phone number" });
    }
  });
  app2.get("/api/admin/messages/stats", requireAdmin, async (req, res) => {
    try {
      const allConversations = await db.select().from(conversations).limit(1e3);
      const allMessages = await db.select().from(messages).limit(5e3);
      const now = /* @__PURE__ */ new Date();
      const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
      const messages24h = allMessages.filter((m) => new Date(m.createdAt) > yesterday).length;
      const activeChats = allConversations.filter(
        (c) => c.lastMessageAt && new Date(c.lastMessageAt) > yesterday
      ).length;
      res.json({
        totalConversations: allConversations.length,
        messages24h,
        activeChats,
        reportedMessages: 0
        // Placeholder - would need reported messages table
      });
    } catch (error) {
      console.error("Failed to get messages stats:", error);
      res.status(500).json({ message: "Failed to get messages stats" });
    }
  });
  app2.get("/api/admin/messages/conversations", requireAdmin, async (req, res) => {
    try {
      const convos = await db.select().from(conversations).orderBy(desc11(conversations.lastMessageAt)).limit(100);
      const convoData = await Promise.all(convos.map(async (c) => {
        const p1 = await storage.getUser(c.participant1Id);
        const p2 = await storage.getUser(c.participant2Id);
        const msgCount = await db.select({ count: sql11`count(*)` }).from(messages).where(eq17(messages.conversationId, c.id));
        return {
          ...c,
          participant1: p1 ? { id: p1.id, username: p1.username } : null,
          participant2: p2 ? { id: p2.id, username: p2.username } : null,
          messageCount: msgCount[0]?.count || 0,
          isActive: c.lastMessageAt && new Date(c.lastMessageAt) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3)
        };
      }));
      res.json(convoData);
    } catch (error) {
      console.error("Failed to get conversations:", error);
      res.status(500).json({ message: "Failed to get conversations" });
    }
  });
  app2.get("/api/admin/messages/search", requireAdmin, async (req, res) => {
    try {
      const search = String(req.query.search || "");
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const result = await storage.adminSearchMessages({ search, page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to search messages:", error);
      res.status(500).json({ message: "Failed to search messages" });
    }
  });
  app2.delete("/api/admin/messages/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await storage.adminDeleteMessage(id);
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "MESSAGE_DELETED",
        targetType: "message",
        targetId: id,
        details: { messageId: id },
        ipAddress: req.ip || void 0
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete message:", error);
      res.status(500).json({ message: "Failed to delete message" });
    }
  });
  app2.get("/api/admin/conversations/:id/messages", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 50;
      const result = await storage.getAdminConversationMessages(id, { page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to get conversation messages:", error);
      res.status(500).json({ message: "Failed to get conversation messages" });
    }
  });
  app2.post("/api/admin/messages/:id/flag", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      if (!reason || typeof reason !== "string" || reason.trim().length === 0) {
        return res.status(400).json({ message: "Reason is required" });
      }
      await storage.adminFlagMessage(id, reason.trim(), req.session.userId);
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "MESSAGE_FLAGGED",
        targetType: "message",
        targetId: id,
        details: { messageId: id, reason: reason.trim() },
        ipAddress: req.ip || void 0
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to flag message:", error);
      res.status(500).json({ message: "Failed to flag message" });
    }
  });
  app2.get("/api/admin/messages/flagged", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const result = await storage.getAdminFlaggedMessages({ page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to get flagged messages:", error);
      res.status(500).json({ message: "Failed to get flagged messages" });
    }
  });
  app2.get("/api/admin/groups/stats", requireAdmin, async (req, res) => {
    try {
      const allGroups = await db.select().from(groups).limit(1e3);
      const allMembers = await db.select().from(groupMembers).limit(5e3);
      const now = /* @__PURE__ */ new Date();
      const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
      const newGroups7d = allGroups.filter((g) => new Date(g.createdAt) > weekAgo).length;
      const activeGroups = allGroups.length;
      res.json({
        totalGroups: allGroups.length,
        activeGroups,
        totalMembers: allMembers.length,
        newGroups7d
      });
    } catch (error) {
      console.error("Failed to get groups stats:", error);
      res.status(500).json({ message: "Failed to get groups stats" });
    }
  });
  app2.get("/api/admin/groups", requireAdmin, async (req, res) => {
    try {
      const allGroups = await db.select().from(groups).orderBy(desc11(groups.createdAt)).limit(100);
      const groupData = await Promise.all(allGroups.map(async (g) => {
        const owner = await storage.getUser(g.ownerId);
        const members = await db.select({ count: sql11`count(*)` }).from(groupMembers).where(eq17(groupMembers.groupId, g.id));
        return {
          ...g,
          owner: owner ? { id: owner.id, username: owner.username } : null,
          memberCount: members[0]?.count || 0
        };
      }));
      res.json(groupData);
    } catch (error) {
      console.error("Failed to get groups:", error);
      res.status(500).json({ message: "Failed to get groups" });
    }
  });
  app2.delete("/api/admin/groups/:id", requireAdmin, async (req, res) => {
    try {
      const groupId = req.params.id;
      await db.delete(groupMembers).where(eq17(groupMembers.groupId, groupId));
      await db.delete(groups).where(eq17(groups.id, groupId));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "DELETE_GROUP",
        targetType: "group",
        targetId: groupId,
        details: { groupId },
        ipAddress: req.ip || "unknown"
      });
      res.json({ message: "Group deleted" });
    } catch (error) {
      console.error("Failed to delete group:", error);
      res.status(500).json({ message: "Failed to delete group" });
    }
  });
  app2.get("/api/admin/groups/:id", requireAdmin, async (req, res) => {
    try {
      const groupId = req.params.id;
      const [group] = await db.select().from(groups).where(eq17(groups.id, groupId)).limit(1);
      if (!group) {
        return res.status(404).json({ message: "Group not found" });
      }
      const owner = await storage.getUser(group.ownerId);
      const memberCount = await db.select({ count: sql11`count(*)` }).from(groupMembers).where(eq17(groupMembers.groupId, groupId));
      const joinRequestCount = await db.select({ count: sql11`count(*)` }).from(groupJoinRequests).where(and16(eq17(groupJoinRequests.groupId, groupId), eq17(groupJoinRequests.status, "PENDING")));
      res.json({
        ...group,
        owner: owner ? { id: owner.id, username: owner.username, displayName: owner.displayName } : null,
        memberCount: Number(memberCount[0]?.count || 0),
        pendingJoinRequests: Number(joinRequestCount[0]?.count || 0)
      });
    } catch (error) {
      console.error("Failed to get group details:", error);
      res.status(500).json({ message: "Failed to get group details" });
    }
  });
  app2.get("/api/admin/groups/:id/members", requireAdmin, async (req, res) => {
    try {
      const groupId = req.params.id;
      const members = await db.select({
        id: groupMembers.id,
        userId: groupMembers.userId,
        role: groupMembers.role,
        joinedAt: groupMembers.joinedAt,
        username: users.username,
        displayName: users.displayName,
        avatarUrl: users.avatarUrl
      }).from(groupMembers).leftJoin(users, eq17(groupMembers.userId, users.id)).where(eq17(groupMembers.groupId, groupId)).orderBy(desc11(groupMembers.joinedAt));
      res.json(members);
    } catch (error) {
      console.error("Failed to get group members:", error);
      res.status(500).json({ message: "Failed to get group members" });
    }
  });
  app2.delete("/api/admin/groups/:id/members/:memberId", requireAdmin, async (req, res) => {
    try {
      const { id: groupId, memberId } = req.params;
      await db.delete(groupMembers).where(and16(eq17(groupMembers.groupId, groupId), eq17(groupMembers.id, memberId)));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_REMOVE_GROUP_MEMBER",
        targetType: "group_member",
        targetId: memberId,
        details: { groupId, memberId },
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to remove group member:", error);
      res.status(500).json({ message: "Failed to remove group member" });
    }
  });
  app2.put("/api/admin/groups/:id/settings", requireAdmin, async (req, res) => {
    try {
      const groupId = req.params.id;
      const { name, description, isPrivate } = req.body;
      await db.update(groups).set({
        name: name || void 0,
        description: description || void 0,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq17(groups.id, groupId));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_UPDATE_GROUP_SETTINGS",
        targetType: "group",
        targetId: groupId,
        details: { name, description, isPrivate },
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to update group settings:", error);
      res.status(500).json({ message: "Failed to update group settings" });
    }
  });
  app2.get("/api/admin/groups/:id/join-requests", requireAdmin, async (req, res) => {
    try {
      const groupId = req.params.id;
      const requests = await db.select({
        id: groupJoinRequests.id,
        userId: groupJoinRequests.userId,
        status: groupJoinRequests.status,
        createdAt: groupJoinRequests.createdAt,
        username: users.username,
        displayName: users.displayName,
        avatarUrl: users.avatarUrl
      }).from(groupJoinRequests).leftJoin(users, eq17(groupJoinRequests.userId, users.id)).where(eq17(groupJoinRequests.groupId, groupId)).orderBy(desc11(groupJoinRequests.createdAt));
      res.json(requests);
    } catch (error) {
      console.error("Failed to get join requests:", error);
      res.status(500).json({ message: "Failed to get join requests" });
    }
  });
  app2.post("/api/admin/groups/:id/join-requests/:requestId/:action", requireAdmin, async (req, res) => {
    try {
      const { id: groupId, requestId, action } = req.params;
      if (action !== "approve" && action !== "reject") {
        return res.status(400).json({ message: "Invalid action" });
      }
      const [request] = await db.select().from(groupJoinRequests).where(eq17(groupJoinRequests.id, requestId)).limit(1);
      if (!request) {
        return res.status(404).json({ message: "Request not found" });
      }
      if (action === "approve") {
        await db.insert(groupMembers).values({
          id: crypto.randomUUID(),
          groupId,
          userId: request.userId,
          role: "MEMBER",
          joinedAt: /* @__PURE__ */ new Date()
        });
        await db.update(groupJoinRequests).set({ status: "APPROVED" }).where(eq17(groupJoinRequests.id, requestId));
      } else {
        await db.update(groupJoinRequests).set({ status: "REJECTED" }).where(eq17(groupJoinRequests.id, requestId));
      }
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: action === "approve" ? "ADMIN_APPROVE_JOIN_REQUEST" : "ADMIN_REJECT_JOIN_REQUEST",
        targetType: "group_join_request",
        targetId: requestId,
        details: { groupId, userId: request.userId },
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to handle join request:", error);
      res.status(500).json({ message: "Failed to handle join request" });
    }
  });
  app2.get("/api/admin/livestreams/stats", requireAdmin, async (req, res) => {
    try {
      const allStreams = await db.select().from(liveStreams).limit(1e3);
      const now = /* @__PURE__ */ new Date();
      const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
      const liveNow = allStreams.filter((s) => s.status === "LIVE").length;
      const streams7d = allStreams.filter((s) => new Date(s.createdAt) > weekAgo).length;
      const totalViewers = allStreams.reduce((sum, s) => sum + (s.viewerCount || 0), 0);
      res.json({
        totalStreams: allStreams.length,
        liveNow,
        totalViewers,
        streams7d
      });
    } catch (error) {
      console.error("Failed to get livestreams stats:", error);
      res.status(500).json({ message: "Failed to get livestreams stats" });
    }
  });
  app2.get("/api/admin/livestreams", requireAdmin, async (req, res) => {
    try {
      const allStreams = await db.select().from(liveStreams).orderBy(desc11(liveStreams.createdAt)).limit(100);
      const streamData = await Promise.all(allStreams.map(async (s) => {
        const host = await storage.getUser(s.hostId);
        return {
          ...s,
          host: host ? { id: host.id, username: host.username } : null
        };
      }));
      res.json(streamData);
    } catch (error) {
      console.error("Failed to get livestreams:", error);
      res.status(500).json({ message: "Failed to get livestreams" });
    }
  });
  app2.post("/api/admin/livestreams/:id/end", requireAdmin, async (req, res) => {
    try {
      const streamId = req.params.id;
      await db.update(liveStreams).set({ status: "ENDED", endedAt: /* @__PURE__ */ new Date() }).where(eq17(liveStreams.id, streamId));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "END_LIVESTREAM",
        targetType: "livestream",
        targetId: streamId,
        details: { streamId },
        ipAddress: req.ip || "unknown"
      });
      res.json({ message: "Livestream ended" });
    } catch (error) {
      console.error("Failed to end livestream:", error);
      res.status(500).json({ message: "Failed to end livestream" });
    }
  });
  app2.get("/api/admin/livestreams/:id/viewers", requireAdmin, async (req, res) => {
    try {
      const streamId = req.params.id;
      const viewers = await db.select({
        id: liveStreamViewers.id,
        viewerId: liveStreamViewers.userId,
        joinedAt: liveStreamViewers.joinedAt,
        leftAt: liveStreamViewers.leftAt,
        username: users.username,
        displayName: users.displayName,
        avatarUrl: users.avatarUrl
      }).from(liveStreamViewers).leftJoin(users, eq17(liveStreamViewers.userId, users.id)).where(eq17(liveStreamViewers.streamId, streamId)).orderBy(desc11(liveStreamViewers.joinedAt)).limit(100);
      res.json(viewers);
    } catch (error) {
      console.error("Failed to get stream viewers:", error);
      res.status(500).json({ message: "Failed to get stream viewers" });
    }
  });
  app2.get("/api/wallet", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const wallet = await storage.getOrCreateWallet(userId);
      const user = await storage.getUser(userId);
      res.json({
        wallet,
        stats: {
          netWorth: user?.netWorth || 0,
          influenceScore: user?.influenceScore || 0
        }
      });
    } catch (error) {
      console.error("Failed to get wallet:", error);
      res.status(500).json({ message: "Failed to get wallet" });
    }
  });
  app2.get("/api/wallet/transactions", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const limit = Math.min(parseInt(req.query.limit) || 50, 100);
      const offset = parseInt(req.query.offset) || 0;
      const transactions = await storage.getCoinTransactions(userId, limit, offset);
      res.json(transactions);
    } catch (error) {
      console.error("Failed to get transactions:", error);
      res.status(500).json({ message: "Failed to get transactions" });
    }
  });
  app2.get("/api/coin-bundles", async (req, res) => {
    try {
      const bundles = await storage.getCoinBundles(true);
      res.json(bundles);
    } catch (error) {
      console.error("Failed to get coin bundles:", error);
      res.status(500).json({ message: "Failed to get coin bundles" });
    }
  });
  app2.post("/api/coin-bundles/:id/purchase", requireAuth4, async (req, res) => {
    try {
      const config = await storage.getEconomyConfig();
      if (config.purchases_enabled === "false") {
        return res.status(503).json({ message: "Coin purchases are temporarily disabled. Please try again later." });
      }
      const userId = req.session.userId;
      const bundleId = req.params.id;
      const bundle = await storage.getCoinBundle(bundleId);
      if (!bundle) {
        return res.status(404).json({ message: "Coin bundle not found" });
      }
      if (!bundle.isActive) {
        return res.status(400).json({ message: "This bundle is no longer available" });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      const {
        isPayFastConfigured: isPayFastConfigured3,
        getPayFastUrl: getPayFastUrl3,
        createPaymentData: createPaymentData3
      } = await Promise.resolve().then(() => (init_payfast(), payfast_exports));
      if (!isPayFastConfigured3()) {
        return res.status(500).json({ message: "Payment system is not configured" });
      }
      const orderId = crypto.randomUUID();
      const baseUrl = `https://${req.get("host")}`;
      const paymentData = createPaymentData3({
        orderId,
        amount: bundle.priceRands,
        itemName: `${bundle.name} - ${bundle.coinAmount} Coins`,
        itemDescription: bundle.description || void 0,
        email: user.email,
        firstName: user.displayName?.split(" ")[0],
        lastName: user.displayName?.split(" ").slice(1).join(" ") || void 0,
        returnUrl: `${baseUrl}/api/coin-bundles/purchase/return?order_id=${orderId}`,
        cancelUrl: `${baseUrl}/api/coin-bundles/purchase/cancel?order_id=${orderId}`,
        notifyUrl: `${baseUrl}/api/coin-bundles/purchase/notify`,
        userId
      });
      const purchase = await storage.createCoinPurchase(
        userId,
        bundleId,
        bundle.coinAmount + (bundle.bonusCoins || 0),
        bundle.priceRands,
        orderId
      );
      console.log("[CoinPurchase] Created purchase:", purchase.id, "for bundle:", bundle.name);
      res.json({
        purchaseId: purchase.id,
        orderId,
        paymentUrl: getPayFastUrl3(),
        paymentData,
        bundle
      });
    } catch (error) {
      console.error("Failed to initiate coin purchase:", error);
      res.status(500).json({ message: "Failed to initiate purchase" });
    }
  });
  app2.post("/api/coins/purchase", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { bundleId } = req.body;
      if (!bundleId) {
        return res.status(400).json({ message: "bundleId is required" });
      }
      const bundle = await storage.getCoinBundle(bundleId);
      if (!bundle) {
        return res.status(404).json({ message: "Coin bundle not found" });
      }
      if (!bundle.isActive) {
        return res.status(400).json({ message: "This bundle is no longer available" });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      const {
        isPayFastConfigured: isPayFastConfigured3,
        getPayFastUrl: getPayFastUrl3,
        generateSignature: generateSignature2
      } = await Promise.resolve().then(() => (init_payfast(), payfast_exports));
      if (!isPayFastConfigured3()) {
        return res.status(500).json({ message: "Payment system is not configured" });
      }
      const paymentReference = crypto.randomUUID();
      const baseUrl = `https://${req.get("host")}`;
      const totalCoins = bundle.coinAmount + (bundle.bonusCoins || 0);
      const purchase = await storage.createCoinPurchase(
        userId,
        bundleId,
        totalCoins,
        bundle.priceRands,
        paymentReference
      );
      const paymentData = {
        merchant_id: process.env.PAYFAST_MERCHANT_ID,
        merchant_key: process.env.PAYFAST_MERCHANT_KEY,
        return_url: `${baseUrl}/api/coins/purchase/return?purchase_id=${purchase.id}`,
        cancel_url: `${baseUrl}/api/coins/purchase/cancel?purchase_id=${purchase.id}`,
        notify_url: `${baseUrl}/api/coins/purchase/notify`,
        m_payment_id: paymentReference,
        amount: bundle.priceRands.toFixed(2),
        item_name: `Rabit Coins - ${bundle.name}`,
        item_description: bundle.description || `${bundle.coinAmount} coins + ${bundle.bonusCoins || 0} bonus`,
        email_address: user.email,
        name_first: user.displayName?.split(" ")[0],
        name_last: user.displayName?.split(" ").slice(1).join(" ") || void 0,
        custom_str1: purchase.id,
        custom_str2: userId
      };
      const signature = generateSignature2(paymentData, process.env.PAYFAST_PASSPHRASE);
      paymentData.signature = signature;
      console.log("[CoinPurchase] Created purchase:", purchase.id, "for bundle:", bundle.name, "user:", userId);
      res.json({
        purchaseId: purchase.id,
        paymentUrl: getPayFastUrl3(),
        paymentData,
        bundle: {
          id: bundle.id,
          name: bundle.name,
          coinAmount: bundle.coinAmount,
          bonusCoins: bundle.bonusCoins,
          priceRands: bundle.priceRands
        }
      });
    } catch (error) {
      console.error("Failed to initiate coin purchase:", error);
      res.status(500).json({ message: "Failed to initiate purchase" });
    }
  });
  app2.post("/api/coins/purchase-custom", requireAuth4, async (req, res) => {
    console.log("[CoinPurchase] Custom purchase request received, body:", req.body, "userId:", req.session.userId);
    try {
      const config = await storage.getEconomyConfig();
      if (config.purchases_enabled === "false") {
        return res.status(503).json({ message: "Coin purchases are temporarily disabled. Please try again later." });
      }
      const userId = req.session.userId;
      const { coinAmount } = req.body;
      if (!coinAmount || typeof coinAmount !== "number" || coinAmount < 10) {
        return res.status(400).json({ message: "Minimum purchase is 10 coins" });
      }
      if (coinAmount > 1e6) {
        return res.status(400).json({ message: "Maximum single purchase is 1,000,000 coins" });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }
      const {
        isPayFastConfigured: isPayFastConfigured3,
        getPayFastUrl: getPayFastUrl3,
        generateSignature: generateSignature2
      } = await Promise.resolve().then(() => (init_payfast(), payfast_exports));
      if (!isPayFastConfigured3()) {
        return res.status(500).json({ message: "Payment system is not configured" });
      }
      const paymentReference = crypto.randomUUID();
      const priceRands = coinAmount;
      const baseUrl = `https://${req.get("host")}`;
      const CUSTOM_PURCHASE_BUNDLE_ID = "custom-purchase-bundle";
      const purchase = await storage.createCoinPurchase(
        userId,
        CUSTOM_PURCHASE_BUNDLE_ID,
        coinAmount,
        priceRands,
        paymentReference
      );
      const paymentData = {
        merchant_id: process.env.PAYFAST_MERCHANT_ID,
        merchant_key: process.env.PAYFAST_MERCHANT_KEY,
        return_url: `${baseUrl}/api/coins/purchase/return?purchase_id=${purchase.id}`,
        cancel_url: `${baseUrl}/api/coins/purchase/cancel?purchase_id=${purchase.id}`,
        notify_url: `${baseUrl}/api/coins/purchase/notify`,
        m_payment_id: paymentReference,
        amount: priceRands.toFixed(2),
        item_name: `Rabit Coins - ${coinAmount.toLocaleString()} Coins`,
        item_description: `Custom purchase of ${coinAmount.toLocaleString()} Rabit Coins`,
        email_address: user.email,
        name_first: user.displayName?.split(" ")[0],
        name_last: user.displayName?.split(" ").slice(1).join(" ") || void 0,
        custom_str1: purchase.id,
        custom_str2: userId
      };
      const signature = generateSignature2(paymentData, process.env.PAYFAST_PASSPHRASE);
      paymentData.signature = signature;
      console.log("[CoinPurchase] Created custom purchase:", purchase.id, "for", coinAmount, "coins, user:", userId);
      res.json({
        purchaseId: purchase.id,
        paymentUrl: getPayFastUrl3(),
        paymentData,
        coinAmount,
        priceRands
      });
    } catch (error) {
      console.error("Failed to initiate custom coin purchase:", error?.message, error?.stack);
      res.status(500).json({ message: "Failed to initiate custom purchase", error: error?.message });
    }
  });
  app2.post("/api/coins/purchase/notify", async (req, res) => {
    try {
      const { validateITNSignature: validateITNSignature3 } = await Promise.resolve().then(() => (init_payfast(), payfast_exports));
      const itnData = req.body;
      console.log("[PayFast ITN] Received notification:", {
        m_payment_id: itnData.m_payment_id,
        payment_status: itnData.payment_status,
        custom_str1: itnData.custom_str1,
        custom_str2: itnData.custom_str2
      });
      if (!validateITNSignature3(itnData)) {
        console.error("[PayFast ITN] Invalid signature");
        return res.status(400).send("Invalid signature");
      }
      if (itnData.payment_status !== "COMPLETE") {
        console.log("[PayFast ITN] Payment not complete, status:", itnData.payment_status);
        return res.status(200).send("OK");
      }
      const purchaseId = itnData.custom_str1;
      const userId = itnData.custom_str2;
      if (!purchaseId || !userId) {
        console.error("[PayFast ITN] Missing purchaseId or userId");
        return res.status(400).send("Missing purchase data");
      }
      const purchase = await storage.getCoinPurchase(purchaseId);
      if (!purchase) {
        console.error("[PayFast ITN] Purchase not found:", purchaseId);
        return res.status(404).send("Purchase not found");
      }
      if (purchase.status === "completed") {
        console.log("[PayFast ITN] Purchase already completed:", purchaseId);
        return res.status(200).send("OK");
      }
      if (purchase.userId !== userId) {
        console.error("[PayFast ITN] User mismatch:", purchase.userId, "vs", userId);
        return res.status(400).send("User mismatch");
      }
      const result = await storage.completeCoinPurchase(purchase.paymentReference);
      if (!result) {
        console.error("[PayFast ITN] Failed to complete purchase:", purchaseId);
        return res.status(500).send("Failed to complete purchase");
      }
      console.log("[PayFast ITN] Purchase completed successfully:", {
        purchaseId,
        coinsReceived: result.purchase.coinsReceived,
        newBalance: result.wallet.coinBalance
      });
      res.status(200).send("OK");
    } catch (error) {
      console.error("[PayFast ITN] Error processing notification:", error);
      res.status(500).send("Internal server error");
    }
  });
  app2.get("/api/coins/purchase/return", async (req, res) => {
    const purchaseId = req.query.purchase_id;
    console.log("[CoinPurchase Return] User returned from PayFast, purchaseId:", purchaseId);
    let coinsReceived = 0;
    let completionStatus = "unknown";
    let errorMessage = "";
    if (purchaseId) {
      try {
        const purchase = await storage.getCoinPurchase(purchaseId);
        console.log("[CoinPurchase Return] Purchase found:", purchase ? { id: purchase.id, status: purchase.status, coins: purchase.coinsReceived } : "NOT FOUND");
        if (purchase) {
          coinsReceived = purchase.coinsReceived;
          if (purchase.status === "completed") {
            completionStatus = "completed";
            console.log("[CoinPurchase Return] Purchase already completed");
          } else if (purchase.status === "pending") {
            console.log("[CoinPurchase Return] Purchase still pending, completing now...");
            try {
              const result = await storage.completeCoinPurchase(purchase.paymentReference);
              if (result) {
                completionStatus = "completed";
                coinsReceived = result.purchase.coinsReceived;
                console.log("[CoinPurchase Return] Purchase completed successfully!", {
                  purchaseId,
                  coinsReceived: result.purchase.coinsReceived,
                  newBalance: result.wallet.coinBalance
                });
              } else {
                completionStatus = "error";
                errorMessage = "Failed to complete purchase - please contact support";
                console.error("[CoinPurchase Return] completeCoinPurchase returned null");
              }
            } catch (err) {
              completionStatus = "error";
              errorMessage = err?.message || "Unknown error completing purchase";
              console.error("[CoinPurchase Return] Error completing purchase:", err);
            }
          } else {
            completionStatus = purchase.status;
            console.log("[CoinPurchase Return] Purchase has status:", purchase.status);
          }
        } else {
          completionStatus = "not_found";
          errorMessage = "Purchase record not found";
          console.error("[CoinPurchase Return] Purchase not found:", purchaseId);
        }
      } catch (err) {
        completionStatus = "error";
        errorMessage = err?.message || "Database error";
        console.error("[CoinPurchase Return] Error fetching purchase:", err);
      }
    } else {
      completionStatus = "no_id";
      errorMessage = "No purchase ID provided";
      console.error("[CoinPurchase Return] No purchase_id in query");
    }
    const isSuccess = completionStatus === "completed";
    const iconColor = isSuccess ? "#10b981" : "#ef4444";
    const iconPath = isSuccess ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/>' : '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12"/>';
    const title = isSuccess ? "Payment Successful!" : "Payment Issue";
    const message = isSuccess ? `${coinsReceived.toLocaleString()} Rabit Coins have been added to your wallet.` : `There was an issue with your payment. ${errorMessage}`;
    const infoMessage = isSuccess ? "Your coins are ready to spend in the Mall!" : "Please try again or contact support if the issue persists.";
    res.send(`
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>${title} - RabitChat</title>
        <style>
          * { margin: 0; padding: 0; box-sizing: border-box; }
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a24 0%, #2d1f47 50%, #1a1a24 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
          }
          .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.2);
          }
          .icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, ${iconColor} 0%, ${iconColor}dd 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 24px;
            animation: pulse 1.5s ease-in-out infinite;
          }
          @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
          }
          .icon svg { width: 40px; height: 40px; }
          h1 { color: #fff; font-size: 24px; margin-bottom: 12px; }
          p { color: rgba(255, 255, 255, 0.7); font-size: 16px; margin-bottom: 16px; line-height: 1.5; }
          .coin-icon { display: inline-block; width: 24px; height: 24px; background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); border-radius: 50%; vertical-align: middle; margin-right: 4px; }
          .info { background: rgba(139, 92, 246, 0.2); border-radius: 12px; padding: 16px; margin-bottom: 24px; }
          .info p { color: rgba(255, 255, 255, 0.9); margin: 0; font-size: 14px; }
          .redirect-text { color: rgba(255, 255, 255, 0.5); font-size: 14px; margin-top: 16px; }
          .btn {
            display: inline-block;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: #fff;
            padding: 14px 32px;
            border-radius: 12px;
            text-decoration: none;
            font-weight: 600;
            font-size: 16px;
            margin-top: 16px;
            transition: transform 0.2s, box-shadow 0.2s;
          }
          .btn:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(139, 92, 246, 0.4); }
          .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
            vertical-align: middle;
          }
          @keyframes spin { to { transform: rotate(360deg); } }
          .debug { margin-top: 20px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; font-size: 12px; color: rgba(255,255,255,0.5); }
        </style>
        <script>
          var purchaseId = '${purchaseId || ""}';
          var serverCompletionStatus = '${completionStatus}';
          var coinsReceived = ${coinsReceived || 0};
          
          // Try to complete the purchase via API as a fallback
          async function tryCompleteViaApi() {
            if (!purchaseId || purchaseId === 'none') {
              console.log('[Return] No purchase ID to complete');
              return false;
            }
            
            try {
              console.log('[Return] Trying to complete purchase via API:', purchaseId);
              var response = await fetch('/api/coins/complete-by-id/' + purchaseId);
              var data = await response.json();
              console.log('[Return] API response:', data);
              
              if (data.success) {
                console.log('[Return] Purchase completed via API!');
                coinsReceived = data.purchase?.coinsReceived || coinsReceived;
                return true;
              }
            } catch (err) {
              console.error('[Return] API call failed:', err);
            }
            return false;
          }
          
          async function handlePageLoad() {
            var isSuccess = serverCompletionStatus === 'completed';
            
            // If server-side completion failed, try via API
            if (!isSuccess && purchaseId) {
              console.log('[Return] Server-side completion failed, trying API...');
              var apiSuccess = await tryCompleteViaApi();
              if (apiSuccess) {
                isSuccess = true;
                // Update the UI
                document.querySelector('h1').textContent = 'Payment Successful!';
                document.querySelector('.icon').style.background = 'linear-gradient(135deg, #10b981 0%, #10b981dd 100%)';
                document.querySelector('.icon svg path').setAttribute('d', 'M5 13l4 4L19 7');
                document.querySelector('.debug').textContent = 'Status: completed (via API) | ID: ' + purchaseId;
              }
            }
            
            if (isSuccess) {
              // Auto-redirect to app after 2 seconds
              setTimeout(function() {
                window.location.href = 'rabitchat://mall?payment=success&coins=' + coinsReceived;
              }, 2000);
              
              // Fallback: If deep link doesn't work after 3.5 seconds, show manual button
              setTimeout(function() {
                var btn = document.getElementById('manual-btn');
                var redirect = document.getElementById('auto-redirect');
                if (btn) btn.style.display = 'inline-block';
                if (redirect) redirect.style.display = 'none';
              }, 3500);
            } else {
              // Show retry button immediately for errors
              document.getElementById('manual-btn').style.display = 'inline-block';
            }
          }
          
          document.addEventListener('DOMContentLoaded', handlePageLoad);
        </script>
      </head>
      <body>
        <div class="container">
          <div class="icon">
            <svg fill="none" stroke="#fff" viewBox="0 0 24 24">
              ${iconPath}
            </svg>
          </div>
          <h1>${title}</h1>
          <p>${message}</p>
          <div class="info">
            <p>${isSuccess ? '<span class="coin-icon"></span> ' : ""}${infoMessage}</p>
          </div>
          <p id="auto-redirect" class="redirect-text" style="display: ${isSuccess ? "block" : "none"};">
            <span class="spinner"></span> Redirecting to Mall...
          </p>
          <a id="manual-btn" href="rabitchat://mall?payment=success" class="btn" style="display: none;">
            Open Mall
          </a>
          <div class="debug">Status: ${completionStatus} | ID: ${purchaseId || "none"} | Coins: ${coinsReceived}</div>
        </div>
      </body>
      </html>
    `);
  });
  app2.get("/api/coins/purchase/cancel", async (req, res) => {
    const purchaseId = req.query.purchase_id;
    res.send(`
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Payment Cancelled - RabitChat</title>
        <style>
          * { margin: 0; padding: 0; box-sizing: border-box; }
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a24 0%, #2d1f47 50%, #1a1a24 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
          }
          .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.2);
          }
          .icon { width: 80px; height: 80px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 24px; }
          .icon svg { width: 40px; height: 40px; }
          h1 { color: #fff; font-size: 24px; margin-bottom: 12px; }
          p { color: rgba(255, 255, 255, 0.7); font-size: 16px; margin-bottom: 24px; line-height: 1.5; }
          .close-text { color: rgba(255, 255, 255, 0.5); font-size: 14px; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="icon">
            <svg fill="none" stroke="#fff" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12"/>
            </svg>
          </div>
          <h1>Payment Cancelled</h1>
          <p>Your payment was cancelled. No charges were made to your account.</p>
          <p class="close-text">You can close this page and return to the RabitChat app to try again.</p>
        </div>
      </body>
      </html>
    `);
  });
  app2.get("/api/coins/purchase/:purchaseId", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { purchaseId } = req.params;
      const purchase = await storage.getCoinPurchase(purchaseId);
      if (!purchase) {
        return res.status(404).json({ message: "Purchase not found" });
      }
      if (purchase.userId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      const bundle = await storage.getCoinBundle(purchase.bundleId);
      res.json({
        purchase: {
          id: purchase.id,
          bundleId: purchase.bundleId,
          coinsReceived: purchase.coinsReceived,
          amountPaidRands: purchase.amountPaidRands,
          paymentMethod: purchase.paymentMethod,
          status: purchase.status,
          createdAt: purchase.createdAt,
          completedAt: purchase.completedAt
        },
        bundle: bundle ? {
          id: bundle.id,
          name: bundle.name,
          coinAmount: bundle.coinAmount,
          bonusCoins: bundle.bonusCoins
        } : null
      });
    } catch (error) {
      console.error("Failed to get purchase status:", error);
      res.status(500).json({ message: "Failed to get purchase status" });
    }
  });
  app2.post("/api/coins/purchase/complete", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { purchaseId } = req.body;
      console.log("[CoinPurchase Complete] Manual completion request, purchaseId:", purchaseId, "userId:", userId);
      if (!purchaseId) {
        return res.status(400).json({ message: "Purchase ID is required" });
      }
      const purchase = await storage.getCoinPurchase(purchaseId);
      if (!purchase) {
        console.error("[CoinPurchase Complete] Purchase not found:", purchaseId);
        return res.status(404).json({ message: "Purchase not found" });
      }
      if (purchase.userId !== userId) {
        console.error("[CoinPurchase Complete] User mismatch:", purchase.userId, "vs", userId);
        return res.status(403).json({ message: "Access denied" });
      }
      console.log("[CoinPurchase Complete] Purchase found:", { id: purchase.id, status: purchase.status, coins: purchase.coinsReceived });
      if (purchase.status === "completed") {
        const wallet = await storage.getWallet(userId);
        console.log("[CoinPurchase Complete] Purchase already completed");
        return res.json({
          success: true,
          alreadyCompleted: true,
          purchase: {
            id: purchase.id,
            coinsReceived: purchase.coinsReceived,
            status: purchase.status
          },
          wallet: wallet ? { coinBalance: wallet.coinBalance } : null
        });
      }
      if (purchase.status !== "pending") {
        console.error("[CoinPurchase Complete] Purchase has invalid status:", purchase.status);
        return res.status(400).json({ message: `Purchase has status: ${purchase.status}` });
      }
      console.log("[CoinPurchase Complete] Completing pending purchase...");
      const result = await storage.completeCoinPurchase(purchase.paymentReference);
      if (!result) {
        console.error("[CoinPurchase Complete] completeCoinPurchase returned null");
        return res.status(500).json({ message: "Failed to complete purchase" });
      }
      console.log("[CoinPurchase Complete] Purchase completed successfully!", {
        purchaseId,
        coinsReceived: result.purchase.coinsReceived,
        newBalance: result.wallet.coinBalance
      });
      res.json({
        success: true,
        alreadyCompleted: false,
        purchase: {
          id: result.purchase.id,
          coinsReceived: result.purchase.coinsReceived,
          status: result.purchase.status
        },
        wallet: { coinBalance: result.wallet.coinBalance }
      });
    } catch (error) {
      console.error("[CoinPurchase Complete] Error:", error);
      res.status(500).json({ message: error?.message || "Failed to complete purchase" });
    }
  });
  app2.get("/api/coins/pending", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3);
      const pendingPurchases = await db.select().from(coinPurchases).where(and16(
        eq17(coinPurchases.userId, userId),
        eq17(coinPurchases.status, "pending"),
        sql11`${coinPurchases.createdAt} > ${oneDayAgo.toISOString()}`
      )).orderBy(sql11`${coinPurchases.createdAt} DESC`).limit(5);
      res.json({
        pendingPurchases: pendingPurchases.map((p) => ({
          id: p.id,
          bundleId: p.bundleId,
          coinsReceived: p.coinsReceived,
          amountPaidRands: p.amountPaidRands,
          paymentReference: p.paymentReference,
          createdAt: p.createdAt
        }))
      });
    } catch (error) {
      console.error("[Pending Purchases] Error:", error);
      res.status(500).json({ message: "Failed to get pending purchases" });
    }
  });
  app2.post("/api/coins/recover/:id", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const purchaseId = req.params.id;
      console.log("[CoinPurchase Recover] Request for purchaseId:", purchaseId, "userId:", userId);
      const purchase = await storage.getCoinPurchase(purchaseId);
      if (!purchase) {
        return res.status(404).json({ success: false, message: "Purchase not found" });
      }
      if (purchase.userId !== userId) {
        return res.status(403).json({ success: false, message: "Not authorized" });
      }
      if (purchase.status === "completed") {
        const wallet = await storage.getWallet(userId);
        return res.json({
          success: true,
          alreadyCompleted: true,
          message: "Purchase was already completed",
          purchase: {
            id: purchase.id,
            coinsReceived: purchase.coinsReceived,
            status: purchase.status
          },
          wallet: wallet ? { coinBalance: wallet.coinBalance } : null
        });
      }
      if (purchase.status !== "pending") {
        return res.status(400).json({ success: false, message: `Purchase has status: ${purchase.status}` });
      }
      console.log("[CoinPurchase Recover] Completing purchase...");
      const result = await storage.completeCoinPurchase(purchase.paymentReference);
      if (!result) {
        return res.status(500).json({ success: false, message: "Failed to complete purchase" });
      }
      console.log("[CoinPurchase Recover] Purchase completed!", {
        purchaseId,
        coinsReceived: result.purchase.coinsReceived,
        newBalance: result.wallet.coinBalance
      });
      res.json({
        success: true,
        alreadyCompleted: false,
        message: "Purchase completed successfully!",
        purchase: {
          id: result.purchase.id,
          coinsReceived: result.purchase.coinsReceived,
          status: result.purchase.status
        },
        wallet: { coinBalance: result.wallet.coinBalance }
      });
    } catch (error) {
      console.error("[CoinPurchase Recover] Error:", error);
      res.status(500).json({ success: false, message: error?.message || "Failed to recover purchase" });
    }
  });
  app2.get("/api/coins/debug", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const purchases = await db.select().from(coinPurchases).where(eq17(coinPurchases.userId, userId)).orderBy(sql11`${coinPurchases.createdAt} DESC`).limit(10);
      const wallet = await storage.getWallet(userId);
      let transactions = [];
      if (wallet) {
        transactions = await db.select().from(coinTransactions).where(eq17(coinTransactions.walletId, wallet.id)).orderBy(sql11`${coinTransactions.createdAt} DESC`).limit(10);
      }
      res.json({
        userId,
        wallet: wallet ? {
          id: wallet.id,
          coinBalance: wallet.coinBalance,
          lifetimeEarned: wallet.lifetimeEarned,
          lifetimeSpent: wallet.lifetimeSpent,
          isFrozen: wallet.isFrozen
        } : null,
        recentPurchases: purchases.map((p) => ({
          id: p.id,
          bundleId: p.bundleId,
          status: p.status,
          coinsReceived: p.coinsReceived,
          amountPaidRands: p.amountPaidRands,
          paymentReference: p.paymentReference,
          createdAt: p.createdAt,
          completedAt: p.completedAt
        })),
        recentTransactions: transactions.map((t) => ({
          id: t.id,
          type: t.type,
          amount: t.amount,
          description: t.description,
          balanceAfter: t.balanceAfter,
          createdAt: t.createdAt
        }))
      });
    } catch (error) {
      console.error("[Debug] Error:", error);
      res.status(500).json({ message: "Debug failed" });
    }
  });
  app2.get("/api/coins/complete-by-id/:id", async (req, res) => {
    try {
      const purchaseId = req.params.id;
      console.log("[CoinPurchase Complete-By-ID] Request for purchaseId:", purchaseId);
      const purchase = await storage.getCoinPurchase(purchaseId);
      if (!purchase) {
        console.error("[CoinPurchase Complete-By-ID] Purchase not found:", purchaseId);
        return res.status(404).json({ success: false, message: "Purchase not found" });
      }
      console.log("[CoinPurchase Complete-By-ID] Found purchase:", {
        id: purchase.id,
        status: purchase.status,
        coins: purchase.coinsReceived,
        paymentReference: purchase.paymentReference
      });
      if (purchase.status === "completed") {
        const wallet = await storage.getWallet(purchase.userId);
        console.log("[CoinPurchase Complete-By-ID] Purchase already completed");
        return res.json({
          success: true,
          alreadyCompleted: true,
          purchase: {
            id: purchase.id,
            coinsReceived: purchase.coinsReceived,
            status: purchase.status
          },
          wallet: wallet ? { coinBalance: wallet.coinBalance } : null
        });
      }
      if (purchase.status !== "pending") {
        console.error("[CoinPurchase Complete-By-ID] Invalid status:", purchase.status);
        return res.status(400).json({ success: false, message: `Purchase has status: ${purchase.status}` });
      }
      console.log("[CoinPurchase Complete-By-ID] Completing pending purchase...");
      const result = await storage.completeCoinPurchase(purchase.paymentReference);
      if (!result) {
        console.error("[CoinPurchase Complete-By-ID] completeCoinPurchase returned null");
        return res.status(500).json({ success: false, message: "Failed to complete purchase" });
      }
      console.log("[CoinPurchase Complete-By-ID] Purchase completed successfully!", {
        purchaseId,
        coinsReceived: result.purchase.coinsReceived,
        newBalance: result.wallet.coinBalance
      });
      res.json({
        success: true,
        alreadyCompleted: false,
        purchase: {
          id: result.purchase.id,
          coinsReceived: result.purchase.coinsReceived,
          status: result.purchase.status
        },
        wallet: { coinBalance: result.wallet.coinBalance }
      });
    } catch (error) {
      console.error("[CoinPurchase Complete-By-ID] Error:", error);
      res.status(500).json({ success: false, message: error?.message || "Failed to complete purchase" });
    }
  });
  app2.post("/api/daily-reward/claim", requireAuth4, async (req, res) => {
    try {
      const config = await storage.getEconomyConfig();
      if (config.daily_rewards_enabled === "false") {
        return res.status(503).json({ message: "Daily rewards are temporarily disabled. Please try again later." });
      }
      const userId = req.session.userId;
      const result = await storage.claimDailyReward(userId);
      res.json({
        success: true,
        reward: result.reward,
        coinsEarned: result.coinsEarned,
        wallet: result.wallet,
        streak: result.reward.currentStreak
      });
    } catch (error) {
      if (error.message?.includes("already claimed")) {
        return res.status(400).json({ message: "Daily reward already claimed today" });
      }
      console.error("Failed to claim daily reward:", error);
      res.status(500).json({ message: "Failed to claim daily reward" });
    }
  });
  app2.get("/api/daily-reward/status", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const status = await storage.getDailyRewardStatus(userId);
      const config = await storage.getDailyRewardConfig();
      let canClaimToday = true;
      let currentStreak = 0;
      let lastClaimedAt = null;
      if (status) {
        currentStreak = status.currentStreak;
        lastClaimedAt = status.lastClaimDate;
        if (status.lastClaimDate) {
          const lastClaim = new Date(status.lastClaimDate);
          const today = /* @__PURE__ */ new Date();
          const isSameDay = lastClaim.getFullYear() === today.getFullYear() && lastClaim.getMonth() === today.getMonth() && lastClaim.getDate() === today.getDate();
          canClaimToday = !isSameDay;
        }
      }
      const nextDayConfig = config.find((c) => c.dayNumber === currentStreak % 7 + 1) || config[0];
      res.json({
        canClaimToday,
        currentStreak,
        lastClaimedAt,
        nextReward: nextDayConfig,
        rewardConfig: config
      });
    } catch (error) {
      console.error("Failed to get daily reward status:", error);
      res.status(500).json({ message: "Failed to get daily reward status" });
    }
  });
  app2.get("/api/gifts/types", async (req, res) => {
    try {
      const types = await storage.getGiftTypes(true);
      res.json(types);
    } catch (error) {
      console.error("Failed to get gift types:", error);
      res.status(500).json({ message: "Failed to get gift types" });
    }
  });
  app2.post("/api/gifts/send", requireAuth4, async (req, res) => {
    try {
      const config = await storage.getEconomyConfig();
      if (config.gifts_enabled === "false") {
        return res.status(503).json({ message: "Gifts are temporarily disabled. Please try again later." });
      }
      const senderId = req.session.userId;
      const { recipientId, giftTypeId, quantity, contextType, contextId, message } = req.body;
      if (!recipientId || !giftTypeId) {
        return res.status(400).json({ message: "recipientId and giftTypeId are required" });
      }
      if (recipientId === senderId) {
        return res.status(400).json({ message: "You cannot send a gift to yourself" });
      }
      const recipient = await storage.getUser(recipientId);
      if (!recipient) {
        return res.status(404).json({ message: "Recipient not found" });
      }
      const qty = Math.max(1, parseInt(quantity) || 1);
      const result = await storage.sendGift(
        senderId,
        recipientId,
        giftTypeId,
        qty,
        contextType,
        contextId,
        message
      );
      const sender = await storage.getUser(senderId);
      broadcastToUser(recipientId, {
        type: "gift:received",
        payload: {
          transaction: result.transaction,
          sender: sender ? { id: sender.id, username: sender.username, displayName: sender.displayName, avatarUrl: sender.avatarUrl } : null
        }
      });
      res.json({
        success: true,
        transaction: result.transaction,
        wallet: result.senderWallet
      });
    } catch (error) {
      if (error.message?.includes("Insufficient")) {
        return res.status(400).json({ message: "Insufficient coin balance" });
      }
      if (error.message?.includes("not found")) {
        return res.status(404).json({ message: error.message });
      }
      console.error("Failed to send gift:", error);
      res.status(500).json({ message: "Failed to send gift" });
    }
  });
  app2.post("/api/mall/wishlist/:itemId", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const itemId = req.params.itemId;
      const item = await db.select().from(mallItems).where(eq17(mallItems.id, itemId)).limit(1);
      if (!item.length) {
        return res.status(404).json({ message: "Item not found" });
      }
      const wishlistItem = await storage.addToWishlist(userId, itemId);
      res.json({ success: true, wishlistItem });
    } catch (error) {
      if (error.message?.includes("duplicate") || error.code === "23505") {
        return res.status(400).json({ message: "Item already in wishlist" });
      }
      console.error("Failed to add to wishlist:", error);
      res.status(500).json({ message: "Failed to add to wishlist" });
    }
  });
  app2.delete("/api/mall/wishlist/:itemId", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const itemId = req.params.itemId;
      await storage.removeFromWishlist(userId, itemId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to remove from wishlist:", error);
      res.status(500).json({ message: "Failed to remove from wishlist" });
    }
  });
  app2.get("/api/mall/wishlist", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const wishlist = await storage.getWishlist(userId);
      const itemIds = wishlist.map((w) => w.itemId);
      const items = itemIds.length > 0 ? await db.select().from(mallItems).where(inArray10(mallItems.id, itemIds)) : [];
      const wishlistWithItems = wishlist.map((w) => ({
        ...w,
        item: items.find((i) => i.id === w.itemId) || null
      }));
      res.json(wishlistWithItems);
    } catch (error) {
      console.error("Failed to get wishlist:", error);
      res.status(500).json({ message: "Failed to get wishlist" });
    }
  });
  app2.post("/api/mall/:itemId/review", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const itemId = req.params.itemId;
      const { rating, review } = req.body;
      if (!rating || rating < 1 || rating > 5) {
        return res.status(400).json({ message: "Rating must be between 1 and 5" });
      }
      const item = await db.select().from(mallItems).where(eq17(mallItems.id, itemId)).limit(1);
      if (!item.length) {
        return res.status(404).json({ message: "Item not found" });
      }
      const newReview = await storage.createReview(userId, itemId, rating, review);
      res.json({ success: true, review: newReview });
    } catch (error) {
      if (error.message?.includes("duplicate") || error.code === "23505") {
        return res.status(400).json({ message: "You have already reviewed this item" });
      }
      console.error("Failed to create review:", error);
      res.status(500).json({ message: "Failed to create review" });
    }
  });
  app2.get("/api/mall/:itemId/reviews", async (req, res) => {
    try {
      const itemId = req.params.itemId;
      const reviews = await storage.getItemReviews(itemId);
      const userIds = reviews.map((r) => r.userId);
      const reviewUsers = userIds.length > 0 ? await db.select({
        id: users.id,
        username: users.username,
        displayName: users.displayName,
        avatarUrl: users.avatarUrl
      }).from(users).where(inArray10(users.id, userIds)) : [];
      const reviewsWithUsers = reviews.map((r) => ({
        ...r,
        user: reviewUsers.find((u) => u.id === r.userId) || null
      }));
      res.json(reviewsWithUsers);
    } catch (error) {
      console.error("Failed to get reviews:", error);
      res.status(500).json({ message: "Failed to get reviews" });
    }
  });
  app2.get("/api/admin/wallet/stats", requireAdmin, async (req, res) => {
    try {
      const allWallets = await db.select().from(wallets).limit(1e3);
      const allTransactions = await db.select().from(coinTransactions).limit(5e3);
      const allGifts = await db.select().from(giftTransactions).limit(1e3);
      const now = /* @__PURE__ */ new Date();
      const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
      const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
      const totalCoins = allWallets.reduce((sum, w) => sum + (w.coinBalance || 0), 0);
      const transactions24h = allTransactions.filter((t) => new Date(t.createdAt) > yesterday).length;
      const giftsSent7d = allGifts.filter((g) => new Date(g.createdAt) > weekAgo).length;
      const avgBalance = allWallets.length > 0 ? Math.round(totalCoins / allWallets.length) : 0;
      res.json({
        totalCoins,
        transactions24h,
        giftsSent7d,
        avgBalance
      });
    } catch (error) {
      console.error("Failed to get wallet stats:", error);
      res.status(500).json({ message: "Failed to get wallet stats" });
    }
  });
  app2.get("/api/admin/wallet/transactions", requireAdmin, async (req, res) => {
    try {
      const transactions = await db.select().from(coinTransactions).orderBy(desc11(coinTransactions.createdAt)).limit(100);
      const txData = await Promise.all(transactions.map(async (t) => {
        const wallet = await db.select().from(wallets).where(eq17(wallets.id, t.walletId)).limit(1);
        const user = wallet[0] ? await storage.getUser(wallet[0].userId) : null;
        return {
          ...t,
          user: user ? { id: user.id, username: user.username } : null
        };
      }));
      res.json(txData);
    } catch (error) {
      console.error("Failed to get transactions:", error);
      res.status(500).json({ message: "Failed to get transactions" });
    }
  });
  app2.get("/api/admin/wallet/gift-types", requireAdmin, async (req, res) => {
    try {
      const types = await db.select().from(giftTypes).orderBy(giftTypes.name);
      res.json(types);
    } catch (error) {
      console.error("Failed to get gift types:", error);
      res.status(500).json({ message: "Failed to get gift types" });
    }
  });
  app2.get("/api/admin/payments/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminPaymentStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get payment stats:", error);
      res.status(500).json({ message: "Failed to get payment stats" });
    }
  });
  app2.get("/api/admin/payments", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search || "";
      const status = req.query.status || "";
      const result = await storage.getAdminPayfastOrders({ page, limit, search, status });
      res.json(result);
    } catch (error) {
      console.error("Failed to get payments:", error);
      res.status(500).json({ message: "Failed to get payments" });
    }
  });
  app2.get("/api/admin/payments/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const order = await storage.getAdminPayfastOrder(id);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      res.json(order);
    } catch (error) {
      console.error("Failed to get payment:", error);
      res.status(500).json({ message: "Failed to get payment" });
    }
  });
  app2.post("/api/admin/payments/:id/status", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { status, notes } = req.body;
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }
      const order = await storage.adminUpdateOrderStatus(id, status, notes);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_UPDATE_ORDER_STATUS",
        targetType: "order",
        targetId: id,
        details: { status, notes },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json(order);
    } catch (error) {
      console.error("Failed to update payment status:", error);
      res.status(500).json({ message: "Failed to update payment status" });
    }
  });
  app2.get("/api/admin/users/:userId/portfolio", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const purchases = await db.select({
        id: mallPurchases.id,
        itemId: mallPurchases.itemId,
        quantity: mallPurchases.quantity,
        netWorthGained: mallPurchases.netWorthGained,
        createdAt: mallPurchases.createdAt,
        itemName: mallItems.name,
        itemValue: mallItems.value,
        itemImageUrl: mallItems.imageUrl,
        categoryId: mallItems.categoryId
      }).from(mallPurchases).leftJoin(mallItems, eq17(mallPurchases.itemId, mallItems.id)).where(eq17(mallPurchases.userId, userId)).orderBy(desc11(mallPurchases.createdAt));
      res.json({
        user: {
          id: user.id,
          username: user.username,
          displayName: user.displayName,
          avatarUrl: user.avatarUrl,
          netWorth: user.netWorth,
          netWorthTier: user.netWorthTier
        },
        purchases,
        totalItems: purchases.reduce((sum, p) => sum + p.quantity, 0),
        portfolioValue: purchases.reduce((sum, p) => sum + (p.netWorthGained || 0), 0)
      });
    } catch (error) {
      console.error("Failed to get user portfolio:", error);
      res.status(500).json({ message: "Failed to get user portfolio" });
    }
  });
  app2.post("/api/admin/users/:userId/portfolio", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { itemId, quantity = 1 } = req.body;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const [item] = await db.select().from(mallItems).where(eq17(mallItems.id, itemId)).limit(1);
      if (!item) {
        return res.status(404).json({ message: "Item not found" });
      }
      const netWorthGained = item.value * quantity;
      const [purchase] = await db.insert(mallPurchases).values({
        userId,
        itemId,
        quantity,
        netWorthGained
      }).returning();
      const newNetWorth = (user.netWorth || 0) + netWorthGained;
      await db.update(users).set({ netWorth: newNetWorth }).where(eq17(users.id, userId));
      await db.insert(netWorthLedger).values({
        userId,
        delta: netWorthGained,
        reason: "ADMIN_ADJUST",
        refType: "mall_item",
        refId: itemId
      });
      await storage.createAuditLog({
        actorId: req.session?.userId || null,
        action: "ADMIN_GRANT_ITEM",
        targetType: "user",
        targetId: userId,
        details: { itemId, itemName: item.name, quantity, netWorthGained },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({
        purchase,
        newNetWorth,
        message: `Added ${item.name} x${quantity} to ${user.username}'s portfolio`
      });
    } catch (error) {
      console.error("Failed to add item to portfolio:", error);
      res.status(500).json({ message: "Failed to add item to portfolio" });
    }
  });
  app2.delete("/api/admin/users/:userId/portfolio/:purchaseId", requireAdmin, async (req, res) => {
    try {
      const { userId, purchaseId } = req.params;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const [purchase] = await db.select().from(mallPurchases).where(and16(eq17(mallPurchases.id, purchaseId), eq17(mallPurchases.userId, userId))).limit(1);
      if (!purchase) {
        return res.status(404).json({ message: "Purchase not found" });
      }
      const [item] = await db.select().from(mallItems).where(eq17(mallItems.id, purchase.itemId)).limit(1);
      await db.delete(mallPurchases).where(eq17(mallPurchases.id, purchaseId));
      const netWorthReduction = purchase.netWorthGained || 0;
      const newNetWorth = Math.max(0, (user.netWorth || 0) - netWorthReduction);
      await db.update(users).set({ netWorth: newNetWorth }).where(eq17(users.id, userId));
      await db.insert(netWorthLedger).values({
        userId,
        delta: -netWorthReduction,
        reason: "ADMIN_ADJUST",
        refType: "mall_item",
        refId: purchase.itemId
      });
      await storage.createAuditLog({
        actorId: req.session?.userId || null,
        action: "ADMIN_REMOVE_ITEM",
        targetType: "user",
        targetId: userId,
        details: { purchaseId, itemName: item?.name, netWorthReduction },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({
        message: `Removed item from ${user.username}'s portfolio`,
        newNetWorth
      });
    } catch (error) {
      console.error("Failed to remove item from portfolio:", error);
      res.status(500).json({ message: "Failed to remove item from portfolio" });
    }
  });
  app2.post("/api/admin/users/:userId/networth/adjust", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { amount, reason } = req.body;
      if (typeof amount !== "number") {
        return res.status(400).json({ message: "Amount must be a number" });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const newNetWorth = Math.max(0, (user.netWorth || 0) + amount);
      await db.update(users).set({ netWorth: newNetWorth }).where(eq17(users.id, userId));
      await db.insert(netWorthLedger).values({
        userId,
        delta: amount,
        reason: "ADMIN_ADJUST",
        refType: "admin_adjustment"
      });
      await storage.createAuditLog({
        actorId: req.session?.userId || null,
        action: "ADMIN_ADJUST_NETWORTH",
        targetType: "user",
        targetId: userId,
        details: { amount, reason, previousNetWorth: user.netWorth, newNetWorth },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({
        message: `Adjusted ${user.username}'s net worth by R${amount.toLocaleString()}`,
        previousNetWorth: user.netWorth,
        newNetWorth
      });
    } catch (error) {
      console.error("Failed to adjust net worth:", error);
      res.status(500).json({ message: "Failed to adjust net worth" });
    }
  });
  app2.get("/api/admin/mall/items-list", requireAdmin, async (req, res) => {
    try {
      const items = await db.select({
        id: mallItems.id,
        name: mallItems.name,
        value: mallItems.value,
        imageUrl: mallItems.imageUrl,
        categoryId: mallItems.categoryId,
        categoryName: mallCategories.name,
        isActive: mallItems.isActive
      }).from(mallItems).leftJoin(mallCategories, eq17(mallItems.categoryId, mallCategories.id)).where(eq17(mallItems.isActive, true)).orderBy(mallItems.name).limit(500);
      res.json(items);
    } catch (error) {
      console.error("Failed to get mall items list:", error);
      res.status(500).json({ message: "Failed to get mall items list" });
    }
  });
  app2.get("/api/admin/notifications/stats", requireAdmin, async (req, res) => {
    try {
      const totalNotifications = await db.select({ count: sql11`count(*)` }).from(notifications);
      const unreadCount = await db.select({ count: sql11`count(*)` }).from(notifications).where(isNull8(notifications.readAt));
      const last24h = await db.select({ count: sql11`count(*)` }).from(notifications).where(gte8(notifications.createdAt, new Date(Date.now() - 24 * 60 * 60 * 1e3)));
      res.json({
        totalNotifications: Number(totalNotifications[0]?.count || 0),
        unreadNotifications: Number(unreadCount[0]?.count || 0),
        last24hNotifications: Number(last24h[0]?.count || 0)
      });
    } catch (error) {
      console.error("Failed to get notification stats:", error);
      res.status(500).json({ message: "Failed to get notification stats" });
    }
  });
  app2.post("/api/admin/notifications/broadcast", requireAdmin, async (req, res) => {
    try {
      const { message, type = "SYSTEM", targetUserIds } = req.body;
      if (!message) {
        return res.status(400).json({ message: "Message is required" });
      }
      let usersToNotify;
      if (targetUserIds && Array.isArray(targetUserIds) && targetUserIds.length > 0) {
        usersToNotify = targetUserIds;
      } else {
        const allUsers = await db.select({ id: users.id }).from(users);
        usersToNotify = allUsers.map((u) => u.id);
      }
      let sent = 0;
      for (const userId of usersToNotify) {
        await storage.createNotification(
          userId,
          req.session.userId,
          type,
          void 0
        );
        sent++;
      }
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_BROADCAST_NOTIFICATION",
        targetType: "system",
        targetId: "broadcast",
        details: { message, recipientCount: sent, type },
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true, sentTo: sent });
    } catch (error) {
      console.error("Failed to send broadcast:", error);
      res.status(500).json({ message: "Failed to send broadcast" });
    }
  });
  app2.get("/api/admin/events/stats", requireAdmin, async (req, res) => {
    try {
      const totalEvents = await db.select({ count: sql11`count(*)` }).from(events);
      const upcomingEvents = await db.select({ count: sql11`count(*)` }).from(events).where(gte8(events.startsAt, /* @__PURE__ */ new Date()));
      const totalRsvps = await db.select({ count: sql11`count(*)` }).from(eventRsvps);
      res.json({
        totalEvents: Number(totalEvents[0]?.count || 0),
        upcomingEvents: Number(upcomingEvents[0]?.count || 0),
        totalRsvps: Number(totalRsvps[0]?.count || 0)
      });
    } catch (error) {
      console.error("Failed to get event stats:", error);
      res.status(500).json({ message: "Failed to get event stats" });
    }
  });
  app2.get("/api/admin/events", requireAdmin, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const allEvents = await db.select({
        id: events.id,
        title: events.title,
        description: events.description,
        startsAt: events.startsAt,
        endsAt: events.endsAt,
        locationName: events.locationName,
        hostId: events.hostId,
        status: events.status,
        createdAt: events.createdAt,
        hostName: users.displayName,
        hostUsername: users.username
      }).from(events).leftJoin(users, eq17(events.hostId, users.id)).orderBy(desc11(events.startsAt)).limit(limit);
      res.json(allEvents);
    } catch (error) {
      console.error("Failed to get events:", error);
      res.status(500).json({ message: "Failed to get events" });
    }
  });
  app2.delete("/api/admin/events/:id", requireAdmin, async (req, res) => {
    try {
      await db.delete(eventRsvps).where(eq17(eventRsvps.eventId, req.params.id));
      await db.delete(events).where(eq17(events.id, req.params.id));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_DELETE_EVENT",
        targetType: "event",
        targetId: req.params.id,
        details: {},
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete event:", error);
      res.status(500).json({ message: "Failed to delete event" });
    }
  });
  app2.post("/api/admin/events/:id/status", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;
      if (!["SCHEDULED", "ACTIVE", "CANCELLED", "COMPLETED"].includes(status)) {
        return res.status(400).json({ message: "Invalid status" });
      }
      await db.update(events).set({ status }).where(eq17(events.id, id));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_UPDATE_EVENT_STATUS",
        targetType: "event",
        targetId: id,
        details: { status },
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to update event status:", error);
      res.status(500).json({ message: "Failed to update event status" });
    }
  });
  app2.get("/api/admin/events/:id/attendees", requireAdmin, async (req, res) => {
    try {
      const eventId = req.params.id;
      const attendees = await db.select({
        id: eventRsvps.id,
        userId: eventRsvps.userId,
        status: eventRsvps.status,
        createdAt: eventRsvps.createdAt,
        username: users.username,
        displayName: users.displayName,
        avatarUrl: users.avatarUrl
      }).from(eventRsvps).leftJoin(users, eq17(eventRsvps.userId, users.id)).where(eq17(eventRsvps.eventId, eventId)).orderBy(desc11(eventRsvps.createdAt));
      res.json(attendees);
    } catch (error) {
      console.error("Failed to get event attendees:", error);
      res.status(500).json({ message: "Failed to get event attendees" });
    }
  });
  app2.delete("/api/admin/events/:id/attendees/:attendeeId", requireAdmin, async (req, res) => {
    try {
      const { id: eventId, attendeeId } = req.params;
      await db.delete(eventRsvps).where(eq17(eventRsvps.id, attendeeId));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_REMOVE_EVENT_ATTENDEE",
        targetType: "event_rsvp",
        targetId: attendeeId,
        details: { eventId },
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to remove attendee:", error);
      res.status(500).json({ message: "Failed to remove attendee" });
    }
  });
  app2.get("/api/admin/subscriptions/stats", requireAdmin, async (req, res) => {
    try {
      const totalTiers = await db.select({ count: sql11`count(*)` }).from(subscriptionTiers);
      const activeSubscriptions = await db.select({ count: sql11`count(*)` }).from(subscriptions).where(eq17(subscriptions.status, "ACTIVE"));
      const creators = await db.select({ count: sql11`count(distinct ${subscriptionTiers.creatorId})` }).from(subscriptionTiers);
      res.json({
        totalTiers: Number(totalTiers[0]?.count || 0),
        activeSubscriptions: Number(activeSubscriptions[0]?.count || 0),
        creatorsWithTiers: Number(creators[0]?.count || 0)
      });
    } catch (error) {
      console.error("Failed to get subscription stats:", error);
      res.status(500).json({ message: "Failed to get subscription stats" });
    }
  });
  app2.get("/api/admin/subscriptions", requireAdmin, async (req, res) => {
    try {
      const tiers = await db.select({
        id: subscriptionTiers.id,
        creatorId: subscriptionTiers.creatorId,
        name: subscriptionTiers.name,
        monthlyPriceCoins: subscriptionTiers.monthlyPriceCoins,
        description: subscriptionTiers.description,
        subscriberCount: subscriptionTiers.subscriberCount,
        isActive: subscriptionTiers.isActive,
        createdAt: subscriptionTiers.createdAt,
        creatorName: users.displayName,
        creatorUsername: users.username
      }).from(subscriptionTiers).leftJoin(users, eq17(subscriptionTiers.creatorId, users.id)).orderBy(desc11(subscriptionTiers.createdAt)).limit(100);
      res.json(tiers);
    } catch (error) {
      console.error("Failed to get subscriptions:", error);
      res.status(500).json({ message: "Failed to get subscriptions" });
    }
  });
  app2.post("/api/admin/subscriptions/:id/toggle-active", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { isActive } = req.body;
      await db.update(subscriptionTiers).set({ isActive: isActive !== void 0 ? isActive : false }).where(eq17(subscriptionTiers.id, id));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: isActive ? "ADMIN_ENABLE_SUBSCRIPTION_TIER" : "ADMIN_DISABLE_SUBSCRIPTION_TIER",
        targetType: "subscription_tier",
        targetId: id,
        details: { isActive },
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to toggle subscription tier:", error);
      res.status(500).json({ message: "Failed to toggle subscription tier" });
    }
  });
  app2.get("/api/admin/subscriptions/:id/subscribers", requireAdmin, async (req, res) => {
    try {
      const tierId = req.params.id;
      const subs = await db.select({
        id: subscriptions.id,
        subscriberId: subscriptions.subscriberId,
        status: subscriptions.status,
        startedAt: subscriptions.currentPeriodStart,
        expiresAt: subscriptions.currentPeriodEnd,
        username: users.username,
        displayName: users.displayName,
        avatarUrl: users.avatarUrl
      }).from(subscriptions).leftJoin(users, eq17(subscriptions.subscriberId, users.id)).where(eq17(subscriptions.tierId, tierId)).orderBy(desc11(subscriptions.currentPeriodStart)).limit(100);
      res.json(subs);
    } catch (error) {
      console.error("Failed to get subscribers:", error);
      res.status(500).json({ message: "Failed to get subscribers" });
    }
  });
  app2.get("/api/admin/broadcasts/stats", requireAdmin, async (req, res) => {
    try {
      const totalChannels = await db.select({ count: sql11`count(*)` }).from(broadcastChannels);
      const totalMessages = await db.select({ count: sql11`count(*)` }).from(broadcastMessages);
      const totalSubscribers = await db.select({ count: sql11`count(*)` }).from(broadcastChannelSubscribers);
      res.json({
        totalChannels: Number(totalChannels[0]?.count || 0),
        totalMessages: Number(totalMessages[0]?.count || 0),
        totalSubscribers: Number(totalSubscribers[0]?.count || 0)
      });
    } catch (error) {
      console.error("Failed to get broadcast stats:", error);
      res.status(500).json({ message: "Failed to get broadcast stats" });
    }
  });
  app2.get("/api/admin/broadcasts/channels", requireAdmin, async (req, res) => {
    try {
      const channels = await db.select({
        id: broadcastChannels.id,
        name: broadcastChannels.name,
        description: broadcastChannels.description,
        ownerId: broadcastChannels.ownerId,
        subscriberCount: broadcastChannels.subscriberCount,
        createdAt: broadcastChannels.createdAt,
        ownerName: users.displayName,
        ownerUsername: users.username
      }).from(broadcastChannels).leftJoin(users, eq17(broadcastChannels.ownerId, users.id)).orderBy(desc11(broadcastChannels.createdAt)).limit(100);
      res.json(channels);
    } catch (error) {
      console.error("Failed to get broadcast channels:", error);
      res.status(500).json({ message: "Failed to get broadcast channels" });
    }
  });
  app2.get("/api/admin/broadcasts/channels/:id/messages", requireAdmin, async (req, res) => {
    try {
      const channelId = req.params.id;
      const msgs = await db.select({
        id: broadcastMessages.id,
        content: broadcastMessages.content,
        mediaType: broadcastMessages.mediaType,
        mediaUrl: broadcastMessages.mediaUrl,
        createdAt: broadcastMessages.createdAt
      }).from(broadcastMessages).where(eq17(broadcastMessages.channelId, channelId)).orderBy(desc11(broadcastMessages.createdAt)).limit(50);
      res.json(msgs);
    } catch (error) {
      console.error("Failed to get broadcast messages:", error);
      res.status(500).json({ message: "Failed to get broadcast messages" });
    }
  });
  app2.post("/api/admin/broadcasts/channels/:id/verify", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { isVerified } = req.body;
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: isVerified ? "ADMIN_VERIFY_BROADCAST_CHANNEL" : "ADMIN_UNVERIFY_BROADCAST_CHANNEL",
        targetType: "broadcast_channel",
        targetId: id,
        details: { isVerified },
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to verify broadcast channel:", error);
      res.status(500).json({ message: "Failed to verify broadcast channel" });
    }
  });
  app2.delete("/api/admin/broadcasts/channels/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await db.delete(broadcastMessages).where(eq17(broadcastMessages.channelId, id));
      await db.delete(broadcastChannelSubscribers).where(eq17(broadcastChannelSubscribers.channelId, id));
      await db.delete(broadcastChannels).where(eq17(broadcastChannels.id, id));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_DELETE_BROADCAST_CHANNEL",
        targetType: "broadcast_channel",
        targetId: id,
        details: {},
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete broadcast channel:", error);
      res.status(500).json({ message: "Failed to delete broadcast channel" });
    }
  });
  app2.get("/api/admin/hashtags/stats", requireAdmin, async (req, res) => {
    try {
      const totalHashtags = await db.select({ count: sql11`count(*)` }).from(hashtags);
      const trendingCount = await db.select({ count: sql11`count(*)` }).from(hashtags).where(gt6(hashtags.weeklyPostCount, 0));
      res.json({
        totalHashtags: Number(totalHashtags[0]?.count || 0),
        trendingHashtags: Number(trendingCount[0]?.count || 0)
      });
    } catch (error) {
      console.error("Failed to get hashtag stats:", error);
      res.status(500).json({ message: "Failed to get hashtag stats" });
    }
  });
  app2.get("/api/admin/hashtags", requireAdmin, async (req, res) => {
    try {
      const allHashtags = await db.select().from(hashtags).orderBy(desc11(hashtags.postCount)).limit(100);
      res.json(allHashtags);
    } catch (error) {
      console.error("Failed to get hashtags:", error);
      res.status(500).json({ message: "Failed to get hashtags" });
    }
  });
  app2.patch("/api/admin/hashtags/:id/trending", requireAdmin, async (req, res) => {
    try {
      const { isTrending } = req.body;
      await db.update(hashtags).set({ updatedAt: /* @__PURE__ */ new Date() }).where(eq17(hashtags.id, req.params.id));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: isTrending ? "ADMIN_SET_HASHTAG_TRENDING" : "ADMIN_UNSET_HASHTAG_TRENDING",
        targetType: "hashtag",
        targetId: req.params.id,
        details: { isTrending },
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to update hashtag:", error);
      res.status(500).json({ message: "Failed to update hashtag" });
    }
  });
  app2.get("/api/admin/blocks/stats", requireAdmin, async (req, res) => {
    try {
      const totalBlocks = await db.select({ count: sql11`count(*)` }).from(blocks);
      const totalMutes = await db.select({ count: sql11`count(*)` }).from(mutedAccounts);
      const restrictedCount = await db.select({ count: sql11`count(*)` }).from(restrictedAccounts);
      res.json({
        totalBlocks: Number(totalBlocks[0]?.count || 0),
        totalMutes: Number(totalMutes[0]?.count || 0),
        restrictedAccounts: Number(restrictedCount[0]?.count || 0)
      });
    } catch (error) {
      console.error("Failed to get block stats:", error);
      res.status(500).json({ message: "Failed to get block stats" });
    }
  });
  app2.get("/api/admin/blocks", requireAdmin, async (req, res) => {
    try {
      const blocksData = await db.select({
        id: blocks.id,
        blockerId: blocks.blockerId,
        blockedId: blocks.blockedId,
        createdAt: blocks.createdAt
      }).from(blocks).orderBy(desc11(blocks.createdAt)).limit(100);
      const blocksWithUsers = await Promise.all(blocksData.map(async (b) => {
        const blocker = await storage.getUser(b.blockerId);
        const blocked = await storage.getUser(b.blockedId);
        return {
          ...b,
          blockerUsername: blocker?.username || "Unknown",
          blockedUsername: blocked?.username || "Unknown"
        };
      }));
      res.json(blocksWithUsers);
    } catch (error) {
      console.error("Failed to get blocks:", error);
      res.status(500).json({ message: "Failed to get blocks" });
    }
  });
  app2.delete("/api/admin/blocks/:id", requireAdmin, async (req, res) => {
    try {
      await db.delete(blocks).where(eq17(blocks.id, req.params.id));
      await storage.createAuditLog({
        actorId: req.session.userId,
        action: "ADMIN_REMOVE_BLOCK",
        targetType: "block",
        targetId: req.params.id,
        details: {},
        ipAddress: req.ip || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to remove block:", error);
      res.status(500).json({ message: "Failed to remove block" });
    }
  });
  app2.get("/api/admin/reels/stats", requireAdmin, async (req, res) => {
    try {
      const totalReels = await db.select({ count: sql11`count(*)` }).from(posts).where(eq17(posts.type, "VIDEO"));
      const last24h = await db.select({ count: sql11`count(*)` }).from(posts).where(and16(
        eq17(posts.type, "VIDEO"),
        gte8(posts.createdAt, new Date(Date.now() - 24 * 60 * 60 * 1e3))
      ));
      res.json({
        totalReels: Number(totalReels[0]?.count || 0),
        last24hReels: Number(last24h[0]?.count || 0)
      });
    } catch (error) {
      console.error("Failed to get reels stats:", error);
      res.status(500).json({ message: "Failed to get reels stats" });
    }
  });
  app2.get("/api/admin/reels", requireAdmin, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit) || 50;
      const reels = await db.select({
        id: posts.id,
        authorId: posts.authorId,
        content: posts.content,
        mediaUrl: posts.mediaUrl,
        visibility: posts.visibility,
        likesCount: posts.likesCount,
        commentsCount: posts.commentsCount,
        createdAt: posts.createdAt,
        authorName: users.displayName,
        authorUsername: users.username
      }).from(posts).leftJoin(users, eq17(posts.authorId, users.id)).where(eq17(posts.type, "VIDEO")).orderBy(desc11(posts.createdAt)).limit(limit);
      res.json(reels);
    } catch (error) {
      console.error("Failed to get reels:", error);
      res.status(500).json({ message: "Failed to get reels" });
    }
  });
  app2.get("/api/admin/discovery/stats", requireAdmin, async (req, res) => {
    try {
      const exploreCatCount = await db.select({ count: sql11`count(*)` }).from(exploreCategories);
      const userInterestCount = await db.select({ count: sql11`count(*)` }).from(userInterests);
      const interestCatCount = await db.select({ count: sql11`count(distinct ${userInterests.interest})` }).from(userInterests);
      res.json({
        exploreCategories: Number(exploreCatCount[0]?.count || 0),
        totalUserInterests: Number(userInterestCount[0]?.count || 0),
        uniqueInterestCategories: Number(interestCatCount[0]?.count || 0)
      });
    } catch (error) {
      console.error("Failed to get discovery stats:", error);
      res.status(500).json({ message: "Failed to get discovery stats" });
    }
  });
  app2.get("/api/admin/discovery/categories", requireAdmin, async (req, res) => {
    try {
      const categories = await db.select().from(exploreCategories).orderBy(exploreCategories.name);
      res.json(categories);
    } catch (error) {
      console.error("Failed to get explore categories:", error);
      res.status(500).json({ message: "Failed to get explore categories" });
    }
  });
  app2.get("/api/admin/group-chats/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminGroupChatStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get group chat stats:", error);
      res.status(500).json({ message: "Failed to get group chat stats" });
    }
  });
  app2.get("/api/admin/group-chats", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search || "";
      const result = await storage.getAdminGroupConversations({ page, limit, search });
      res.json(result);
    } catch (error) {
      console.error("Failed to get group conversations:", error);
      res.status(500).json({ message: "Failed to get group conversations" });
    }
  });
  app2.get("/api/admin/group-chats/:id", requireAdmin, async (req, res) => {
    try {
      const result = await storage.getAdminGroupConversationDetails(req.params.id);
      if (!result) {
        return res.status(404).json({ message: "Group not found" });
      }
      res.json(result);
    } catch (error) {
      console.error("Failed to get group details:", error);
      res.status(500).json({ message: "Failed to get group details" });
    }
  });
  app2.get("/api/admin/group-chats/:id/messages", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 50;
      const result = await storage.getAdminGroupMessages(req.params.id, { page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to get group messages:", error);
      res.status(500).json({ message: "Failed to get group messages" });
    }
  });
  app2.delete("/api/admin/group-chats/:id/messages/:messageId", requireAdmin, async (req, res) => {
    try {
      await storage.adminDeleteGroupMessage(req.params.messageId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete group message:", error);
      res.status(500).json({ message: "Failed to delete group message" });
    }
  });
  app2.delete("/api/admin/group-chats/:id/members/:userId", requireAdmin, async (req, res) => {
    try {
      await storage.adminRemoveGroupMember(req.params.id, req.params.userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to remove group member:", error);
      res.status(500).json({ message: "Failed to remove group member" });
    }
  });
  app2.get("/api/admin/video-calls/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminVideoCallStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get video call stats:", error);
      res.status(500).json({ message: "Failed to get video call stats" });
    }
  });
  app2.get("/api/admin/video-calls", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search || "";
      const status = req.query.status || "";
      const result = await storage.getAdminVideoCalls({ page, limit, search, status });
      res.json(result);
    } catch (error) {
      console.error("Failed to get video calls:", error);
      res.status(500).json({ message: "Failed to get video calls" });
    }
  });
  app2.get("/api/admin/video-calls/:id", requireAdmin, async (req, res) => {
    try {
      const call = await storage.getAdminVideoCallDetails(req.params.id);
      if (!call) {
        return res.status(404).json({ message: "Call not found" });
      }
      res.json({ call });
    } catch (error) {
      console.error("Failed to get video call details:", error);
      res.status(500).json({ message: "Failed to get video call details" });
    }
  });
  app2.post("/api/admin/video-calls/:id/end", requireAdmin, async (req, res) => {
    try {
      await storage.adminEndVideoCall(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to end video call:", error);
      res.status(500).json({ message: "Failed to end video call" });
    }
  });
  app2.get("/api/admin/locations/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminLocationStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get location stats:", error);
      res.status(500).json({ message: "Failed to get location stats" });
    }
  });
  app2.get("/api/admin/venues", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search;
      const verified = req.query.verified === "true" ? true : req.query.verified === "false" ? false : void 0;
      const result = await storage.getAdminVenues({ page, limit, search, verified });
      res.json(result);
    } catch (error) {
      console.error("Failed to get venues:", error);
      res.status(500).json({ message: "Failed to get venues" });
    }
  });
  app2.post("/api/admin/venues", requireAdmin, async (req, res) => {
    try {
      const { name, address, lat, lng, category, city, country } = req.body;
      if (!name || !address || lat === void 0 || lng === void 0) {
        return res.status(400).json({ message: "Name, address, latitude, and longitude are required" });
      }
      const venue = await storage.adminCreateVenue({
        name,
        address,
        lat: parseFloat(lat),
        lng: parseFloat(lng),
        category,
        city,
        country
      });
      res.json(venue);
    } catch (error) {
      console.error("Failed to create venue:", error);
      res.status(500).json({ message: "Failed to create venue" });
    }
  });
  app2.put("/api/admin/venues/:id", requireAdmin, async (req, res) => {
    try {
      const venue = await storage.adminUpdateVenue(req.params.id, req.body);
      if (!venue) {
        return res.status(404).json({ message: "Venue not found" });
      }
      res.json(venue);
    } catch (error) {
      console.error("Failed to update venue:", error);
      res.status(500).json({ message: "Failed to update venue" });
    }
  });
  app2.post("/api/admin/venues/:id/verify", requireAdmin, async (req, res) => {
    try {
      const { verified } = req.body;
      const venue = await storage.adminVerifyVenue(req.params.id, verified === true);
      if (!venue) {
        return res.status(404).json({ message: "Venue not found" });
      }
      res.json(venue);
    } catch (error) {
      console.error("Failed to verify venue:", error);
      res.status(500).json({ message: "Failed to verify venue" });
    }
  });
  app2.delete("/api/admin/venues/:id", requireAdmin, async (req, res) => {
    try {
      await storage.adminDeleteVenue(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete venue:", error);
      res.status(500).json({ message: "Failed to delete venue" });
    }
  });
  app2.get("/api/admin/check-ins", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const venueId = req.query.venueId;
      const result = await storage.getAdminCheckIns({ page, limit, venueId });
      res.json(result);
    } catch (error) {
      console.error("Failed to get check-ins:", error);
      res.status(500).json({ message: "Failed to get check-ins" });
    }
  });
  app2.delete("/api/admin/check-ins/:id", requireAdmin, async (req, res) => {
    try {
      await storage.adminDeleteCheckIn(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete check-in:", error);
      res.status(500).json({ message: "Failed to delete check-in" });
    }
  });
  app2.get("/api/admin/developer/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminDevApiStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get developer API stats:", error);
      res.status(500).json({ message: "Failed to get developer API stats" });
    }
  });
  app2.get("/api/admin/developer/webhooks", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search;
      const result = await storage.getAdminWebhooks({ page, limit, search });
      res.json(result);
    } catch (error) {
      console.error("Failed to get webhooks:", error);
      res.status(500).json({ message: "Failed to get webhooks" });
    }
  });
  app2.post("/api/admin/developer/webhooks/:id/toggle", requireAdmin, async (req, res) => {
    try {
      const { enabled } = req.body;
      if (typeof enabled !== "boolean") {
        return res.status(400).json({ message: "enabled field is required and must be boolean" });
      }
      const webhook = await storage.adminToggleWebhook(req.params.id, enabled);
      if (!webhook) {
        return res.status(404).json({ message: "Webhook not found" });
      }
      res.json(webhook);
    } catch (error) {
      console.error("Failed to toggle webhook:", error);
      res.status(500).json({ message: "Failed to toggle webhook" });
    }
  });
  app2.delete("/api/admin/developer/webhooks/:id", requireAdmin, async (req, res) => {
    try {
      await storage.adminDeleteWebhook(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete webhook:", error);
      res.status(500).json({ message: "Failed to delete webhook" });
    }
  });
  app2.get("/api/admin/developer/webhook-logs", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const webhookId = req.query.webhookId;
      const status = req.query.status;
      const result = await storage.getAdminWebhookDeliveryLogs({ page, limit, webhookId, status });
      res.json(result);
    } catch (error) {
      console.error("Failed to get webhook logs:", error);
      res.status(500).json({ message: "Failed to get webhook logs" });
    }
  });
  app2.get("/api/admin/developer/api-tokens", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const search = req.query.search;
      const result = await storage.getAdminApiAccessTokens({ page, limit, search });
      res.json(result);
    } catch (error) {
      console.error("Failed to get API tokens:", error);
      res.status(500).json({ message: "Failed to get API tokens" });
    }
  });
  app2.delete("/api/admin/developer/api-tokens/:id", requireAdmin, async (req, res) => {
    try {
      await storage.adminRevokeApiToken(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to revoke API token:", error);
      res.status(500).json({ message: "Failed to revoke API token" });
    }
  });
  app2.get("/api/admin/privacy/stats", requireAdmin, async (req, res) => {
    try {
      const stats = await storage.getAdminDataPrivacyStats();
      res.json(stats);
    } catch (error) {
      console.error("Failed to get data privacy stats:", error);
      res.status(500).json({ message: "Failed to get data privacy stats" });
    }
  });
  app2.get("/api/admin/privacy/exports", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const status = req.query.status;
      const result = await storage.getAdminExportRequests({ page, limit, status });
      res.json(result);
    } catch (error) {
      console.error("Failed to get export requests:", error);
      res.status(500).json({ message: "Failed to get export requests" });
    }
  });
  app2.post("/api/admin/privacy/exports/:id/status", requireAdmin, async (req, res) => {
    try {
      const { status } = req.body;
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      }
      const updated = await storage.adminUpdateExportRequestStatus(req.params.id, status);
      if (!updated) {
        return res.status(404).json({ message: "Export request not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Failed to update export request status:", error);
      res.status(500).json({ message: "Failed to update export request status" });
    }
  });
  app2.post("/api/admin/privacy/exports/:id/process", requireAdmin, async (req, res) => {
    try {
      await storage.adminProcessExportRequest(req.params.id);
      res.json({ success: true, message: "Export request is being processed" });
    } catch (error) {
      console.error("Failed to process export request:", error);
      res.status(500).json({ message: "Failed to process export request" });
    }
  });
  app2.get("/api/admin/privacy/backups", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const result = await storage.getAdminAccountBackups({ page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to get account backups:", error);
      res.status(500).json({ message: "Failed to get account backups" });
    }
  });
  app2.get("/api/admin/privacy/imports", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const result = await storage.getAdminPlatformImports({ page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to get platform imports:", error);
      res.status(500).json({ message: "Failed to get platform imports" });
    }
  });
  app2.get("/api/admin/settings/word-filters", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 50;
      const result = await storage.getAdminWordFilters({ page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to get word filters:", error);
      res.status(500).json({ message: "Failed to get word filters" });
    }
  });
  app2.post("/api/admin/settings/word-filters", requireAdmin, async (req, res) => {
    try {
      const { word, action, replacement } = req.body;
      if (!word || !action) {
        return res.status(400).json({ message: "Word and action are required" });
      }
      const filter = await storage.adminCreateWordFilter({
        word,
        action,
        replacement,
        createdBy: req.session.userId
      });
      res.status(201).json(filter);
    } catch (error) {
      console.error("Failed to create word filter:", error);
      if (error.code === "23505") {
        return res.status(400).json({ message: "Word already exists in filters" });
      }
      res.status(500).json({ message: "Failed to create word filter" });
    }
  });
  app2.put("/api/admin/settings/word-filters/:id", requireAdmin, async (req, res) => {
    try {
      const { word, action, replacement, isActive } = req.body;
      const updated = await storage.adminUpdateWordFilter(req.params.id, {
        word,
        action,
        replacement,
        isActive
      });
      if (!updated) {
        return res.status(404).json({ message: "Word filter not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Failed to update word filter:", error);
      if (error.code === "23505") {
        return res.status(400).json({ message: "Word already exists in filters" });
      }
      res.status(500).json({ message: "Failed to update word filter" });
    }
  });
  app2.delete("/api/admin/settings/word-filters/:id", requireAdmin, async (req, res) => {
    try {
      await storage.adminDeleteWordFilter(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete word filter:", error);
      res.status(500).json({ message: "Failed to delete word filter" });
    }
  });
  app2.get("/api/admin/settings/keyword-filters", requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 50;
      const result = await storage.getAdminKeywordFilters({ page, limit });
      res.json(result);
    } catch (error) {
      console.error("Failed to get keyword filters:", error);
      res.status(500).json({ message: "Failed to get keyword filters" });
    }
  });
  app2.post("/api/admin/settings/keyword-filters", requireAdmin, async (req, res) => {
    try {
      const { keyword, action } = req.body;
      if (!keyword || !action) {
        return res.status(400).json({ message: "Keyword and action are required" });
      }
      const filter = await storage.adminCreateKeywordFilter({
        keyword,
        action,
        createdBy: req.session.userId
      });
      res.status(201).json(filter);
    } catch (error) {
      console.error("Failed to create keyword filter:", error);
      if (error.code === "23505") {
        return res.status(400).json({ message: "Keyword already exists in filters" });
      }
      res.status(500).json({ message: "Failed to create keyword filter" });
    }
  });
  app2.put("/api/admin/settings/keyword-filters/:id", requireAdmin, async (req, res) => {
    try {
      const { keyword, action, filterComments, filterMessages, filterPosts, filterUsernames, filterBios, isActive } = req.body;
      const updated = await storage.adminUpdateKeywordFilter(req.params.id, {
        keyword,
        action,
        filterComments,
        filterMessages,
        filterPosts,
        filterUsernames,
        filterBios,
        isActive
      });
      if (!updated) {
        return res.status(404).json({ message: "Keyword filter not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Failed to update keyword filter:", error);
      if (error.code === "23505") {
        return res.status(400).json({ message: "Keyword already exists in filters" });
      }
      res.status(500).json({ message: "Failed to update keyword filter" });
    }
  });
  app2.delete("/api/admin/settings/keyword-filters/:id", requireAdmin, async (req, res) => {
    try {
      await storage.adminDeleteKeywordFilter(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete keyword filter:", error);
      res.status(500).json({ message: "Failed to delete keyword filter" });
    }
  });
  app2.get("/api/admin/settings/app", requireAdmin, async (req, res) => {
    try {
      const settings = await storage.getAdminAppSettings();
      res.json(settings);
    } catch (error) {
      console.error("Failed to get app settings:", error);
      res.status(500).json({ message: "Failed to get app settings" });
    }
  });
  app2.put("/api/admin/settings/app/:key", requireAdmin, async (req, res) => {
    try {
      const { value } = req.body;
      if (value === void 0) {
        return res.status(400).json({ message: "Value is required" });
      }
      const updated = await storage.adminUpdateAppSetting(req.params.key, String(value), req.session.userId);
      if (!updated) {
        return res.status(404).json({ message: "App setting not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Failed to update app setting:", error);
      res.status(500).json({ message: "Failed to update app setting" });
    }
  });
  app2.post("/api/admin/settings/app", requireAdmin, async (req, res) => {
    try {
      const { key, value, type, description } = req.body;
      if (!key || value === void 0) {
        return res.status(400).json({ message: "Key and value are required" });
      }
      const setting = await storage.adminCreateAppSetting({
        key,
        value: String(value),
        type,
        description,
        updatedBy: req.session.userId
      });
      res.status(201).json(setting);
    } catch (error) {
      console.error("Failed to create app setting:", error);
      if (error.code === "23505") {
        return res.status(400).json({ message: "Setting key already exists" });
      }
      res.status(500).json({ message: "Failed to create app setting" });
    }
  });
  app2.get("/api/admin/settings/notifications", requireAdmin, async (req, res) => {
    try {
      const defaults = await storage.getAdminNotificationDefaults();
      res.json(defaults);
    } catch (error) {
      console.error("Failed to get notification defaults:", error);
      res.status(500).json({ message: "Failed to get notification defaults" });
    }
  });
  app2.put("/api/admin/settings/notifications/:id", requireAdmin, async (req, res) => {
    try {
      const { enabled } = req.body;
      if (enabled === void 0) {
        return res.status(400).json({ message: "Enabled status is required" });
      }
      const updated = await storage.adminUpdateNotificationDefault(req.params.id, enabled, req.session.userId);
      if (!updated) {
        return res.status(404).json({ message: "Notification default not found" });
      }
      res.json(updated);
    } catch (error) {
      console.error("Failed to update notification default:", error);
      res.status(500).json({ message: "Failed to update notification default" });
    }
  });
  app2.post("/api/admin/settings/notifications", requireAdmin, async (req, res) => {
    try {
      const { key, name, description, category, defaultEnabled, canUserDisable } = req.body;
      if (!key || !name || !category) {
        return res.status(400).json({ message: "Key, name, and category are required" });
      }
      const setting = await storage.adminCreateNotificationDefault({
        key,
        name,
        description,
        category,
        defaultEnabled,
        canUserDisable,
        updatedBy: req.session.userId
      });
      res.status(201).json(setting);
    } catch (error) {
      console.error("Failed to create notification default:", error);
      if (error.code === "23505") {
        return res.status(400).json({ message: "Notification key already exists" });
      }
      res.status(500).json({ message: "Failed to create notification default" });
    }
  });
  app2.delete("/api/admin/settings/notifications/:id", requireAdmin, async (req, res) => {
    try {
      await storage.adminDeleteNotificationDefault(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete notification default:", error);
      res.status(500).json({ message: "Failed to delete notification default" });
    }
  });
  app2.get("/api/admin/wallets", requireAdmin, async (req, res) => {
    try {
      const search = req.query.search || "";
      const frozen = req.query.frozen;
      const limit = Math.min(parseInt(req.query.limit) || 50, 100);
      const offset = parseInt(req.query.offset) || 0;
      let userConditions = [];
      if (search) {
        userConditions.push(
          or10(
            ilike4(users.username, `%${search}%`),
            ilike4(users.email, `%${search}%`),
            ilike4(users.displayName, `%${search}%`)
          )
        );
      }
      const matchingUsers = await db.select({ id: users.id, username: users.username, displayName: users.displayName, email: users.email, avatarUrl: users.avatarUrl }).from(users).where(userConditions.length > 0 ? and16(...userConditions) : void 0);
      const userIds = matchingUsers.map((u) => u.id);
      if (userIds.length === 0 && search) {
        return res.json({ wallets: [], total: 0 });
      }
      let walletConditions = [];
      if (userIds.length > 0 && search) {
        walletConditions.push(inArray10(wallets.userId, userIds));
      }
      if (frozen === "true") {
        walletConditions.push(eq17(wallets.isFrozen, true));
      } else if (frozen === "false") {
        walletConditions.push(eq17(wallets.isFrozen, false));
      }
      const walletsData = await db.select().from(wallets).where(walletConditions.length > 0 ? and16(...walletConditions) : void 0).orderBy(desc11(wallets.updatedAt)).limit(limit).offset(offset);
      const totalResult = await db.select({ count: sql11`count(*)` }).from(wallets).where(walletConditions.length > 0 ? and16(...walletConditions) : void 0);
      const walletsWithUsers = await Promise.all(walletsData.map(async (w) => {
        const user = matchingUsers.find((u) => u.id === w.userId) || await storage.getUser(w.userId);
        return {
          ...w,
          user: user ? { id: user.id, username: user.username, displayName: user.displayName, email: user.email, avatarUrl: user.avatarUrl } : null
        };
      }));
      res.json({ wallets: walletsWithUsers, total: Number(totalResult[0]?.count || 0) });
    } catch (error) {
      console.error("Failed to get wallets:", error);
      res.status(500).json({ message: "Failed to get wallets" });
    }
  });
  app2.get("/api/admin/wallets/:userId", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const wallet = await storage.getWallet(userId);
      const transactions = await storage.getCoinTransactions(userId, 50);
      res.json({
        wallet: wallet || { userId, coinBalance: 0, lifetimeEarned: 0, lifetimeSpent: 0, isFrozen: false },
        user: { id: user.id, username: user.username, displayName: user.displayName, email: user.email, avatarUrl: user.avatarUrl },
        transactions
      });
    } catch (error) {
      console.error("Failed to get wallet:", error);
      res.status(500).json({ message: "Failed to get wallet" });
    }
  });
  app2.post("/api/admin/wallets/:userId/adjust", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { amount, reason } = req.body;
      const adminId = req.session.userId;
      if (typeof amount !== "number" || amount === 0) {
        return res.status(400).json({ message: "Amount must be a non-zero number" });
      }
      if (!reason || typeof reason !== "string") {
        return res.status(400).json({ message: "Reason is required" });
      }
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const wallet = await storage.adminAdjustWallet(userId, amount, reason, adminId);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_ADJUST_WALLET",
        targetType: "wallet",
        targetId: userId,
        details: { amount, reason, newBalance: wallet.coinBalance },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, wallet });
    } catch (error) {
      console.error("Failed to adjust wallet:", error);
      res.status(500).json({ message: error.message || "Failed to adjust wallet" });
    }
  });
  app2.post("/api/admin/wallets/:userId/freeze", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const adminId = req.session.userId;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const wallet = await storage.freezeWallet(userId, true);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_FREEZE_WALLET",
        targetType: "wallet",
        targetId: userId,
        details: { frozen: true },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, wallet });
    } catch (error) {
      console.error("Failed to freeze wallet:", error);
      res.status(500).json({ message: "Failed to freeze wallet" });
    }
  });
  app2.post("/api/admin/wallets/:userId/unfreeze", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const adminId = req.session.userId;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const wallet = await storage.freezeWallet(userId, false);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_UNFREEZE_WALLET",
        targetType: "wallet",
        targetId: userId,
        details: { frozen: false },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, wallet });
    } catch (error) {
      console.error("Failed to unfreeze wallet:", error);
      res.status(500).json({ message: "Failed to unfreeze wallet" });
    }
  });
  app2.get("/api/admin/gift-types", requireAdmin, async (req, res) => {
    try {
      const types = await storage.getGiftTypes(false);
      res.json(types);
    } catch (error) {
      console.error("Failed to get gift types:", error);
      res.status(500).json({ message: "Failed to get gift types" });
    }
  });
  app2.post("/api/admin/gift-types", requireAdmin, async (req, res) => {
    try {
      const { name, description, iconUrl, animationUrl, coinCost, netWorthValue, category, sortOrder } = req.body;
      if (!name || !iconUrl || typeof coinCost !== "number") {
        return res.status(400).json({ message: "Name, iconUrl, and coinCost are required" });
      }
      const [giftType] = await db.insert(giftTypes).values({
        name,
        description,
        iconUrl,
        animationUrl,
        coinCost,
        netWorthValue: netWorthValue || 0,
        category,
        sortOrder: sortOrder || 0,
        isActive: true
      }).returning();
      res.status(201).json(giftType);
    } catch (error) {
      console.error("Failed to create gift type:", error);
      res.status(500).json({ message: "Failed to create gift type" });
    }
  });
  app2.put("/api/admin/gift-types/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, description, iconUrl, animationUrl, coinCost, netWorthValue, category, sortOrder, isActive } = req.body;
      const [existing] = await db.select().from(giftTypes).where(eq17(giftTypes.id, id)).limit(1);
      if (!existing) {
        return res.status(404).json({ message: "Gift type not found" });
      }
      const updateData = {};
      if (name !== void 0) updateData.name = name;
      if (description !== void 0) updateData.description = description;
      if (iconUrl !== void 0) updateData.iconUrl = iconUrl;
      if (animationUrl !== void 0) updateData.animationUrl = animationUrl;
      if (coinCost !== void 0) updateData.coinCost = coinCost;
      if (netWorthValue !== void 0) updateData.netWorthValue = netWorthValue;
      if (category !== void 0) updateData.category = category;
      if (sortOrder !== void 0) updateData.sortOrder = sortOrder;
      if (isActive !== void 0) updateData.isActive = isActive;
      const [updated] = await db.update(giftTypes).set(updateData).where(eq17(giftTypes.id, id)).returning();
      res.json(updated);
    } catch (error) {
      console.error("Failed to update gift type:", error);
      res.status(500).json({ message: "Failed to update gift type" });
    }
  });
  app2.delete("/api/admin/gift-types/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const [existing] = await db.select().from(giftTypes).where(eq17(giftTypes.id, id)).limit(1);
      if (!existing) {
        return res.status(404).json({ message: "Gift type not found" });
      }
      await db.update(giftTypes).set({ isActive: false }).where(eq17(giftTypes.id, id));
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete gift type:", error);
      res.status(500).json({ message: "Failed to delete gift type" });
    }
  });
  app2.get("/api/admin/coin-bundles", requireAdmin, async (req, res) => {
    try {
      const bundles = await storage.getCoinBundles(false);
      res.json(bundles);
    } catch (error) {
      console.error("Failed to get coin bundles:", error);
      res.status(500).json({ message: "Failed to get coin bundles" });
    }
  });
  app2.post("/api/admin/coin-bundles", requireAdmin, async (req, res) => {
    try {
      const { name, description, coinAmount, priceRands, bonusCoins, iconUrl, sortOrder, isActive, isFeatured } = req.body;
      if (!name || typeof coinAmount !== "number" || typeof priceRands !== "number") {
        return res.status(400).json({ message: "Name, coinAmount, and priceRands are required" });
      }
      const bundle = await storage.createCoinBundle({
        name,
        description,
        coinAmount,
        priceRands,
        bonusCoins: bonusCoins || 0,
        iconUrl,
        sortOrder: sortOrder || 0,
        isActive: isActive !== false,
        isFeatured: isFeatured || false
      });
      res.status(201).json(bundle);
    } catch (error) {
      console.error("Failed to create coin bundle:", error);
      res.status(500).json({ message: "Failed to create coin bundle" });
    }
  });
  app2.put("/api/admin/coin-bundles/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { name, description, coinAmount, priceRands, bonusCoins, iconUrl, sortOrder, isActive, isFeatured } = req.body;
      const existing = await storage.getCoinBundle(id);
      if (!existing) {
        return res.status(404).json({ message: "Coin bundle not found" });
      }
      const updateData = {};
      if (name !== void 0) updateData.name = name;
      if (description !== void 0) updateData.description = description;
      if (coinAmount !== void 0) updateData.coinAmount = coinAmount;
      if (priceRands !== void 0) updateData.priceRands = priceRands;
      if (bonusCoins !== void 0) updateData.bonusCoins = bonusCoins;
      if (iconUrl !== void 0) updateData.iconUrl = iconUrl;
      if (sortOrder !== void 0) updateData.sortOrder = sortOrder;
      if (isActive !== void 0) updateData.isActive = isActive;
      if (isFeatured !== void 0) updateData.isFeatured = isFeatured;
      updateData.updatedAt = /* @__PURE__ */ new Date();
      const bundle = await storage.updateCoinBundle(id, updateData);
      res.json(bundle);
    } catch (error) {
      console.error("Failed to update coin bundle:", error);
      res.status(500).json({ message: "Failed to update coin bundle" });
    }
  });
  app2.delete("/api/admin/coin-bundles/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const existing = await storage.getCoinBundle(id);
      if (!existing) {
        return res.status(404).json({ message: "Coin bundle not found" });
      }
      await storage.updateCoinBundle(id, { isActive: false, updatedAt: /* @__PURE__ */ new Date() });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete coin bundle:", error);
      res.status(500).json({ message: "Failed to delete coin bundle" });
    }
  });
  app2.get("/api/admin/withdrawals", requireAdmin, async (req, res) => {
    try {
      const status = req.query.status;
      const limit = Math.min(parseInt(req.query.limit) || 50, 100);
      const offset = parseInt(req.query.offset) || 0;
      let conditions = [];
      if (status) {
        conditions.push(eq17(withdrawalRequests.status, status));
      }
      const requests = await db.select().from(withdrawalRequests).where(conditions.length > 0 ? and16(...conditions) : void 0).orderBy(desc11(withdrawalRequests.createdAt)).limit(limit).offset(offset);
      const totalResult = await db.select({ count: sql11`count(*)` }).from(withdrawalRequests).where(conditions.length > 0 ? and16(...conditions) : void 0);
      const requestsWithUsers = await Promise.all(requests.map(async (r) => {
        const user = await storage.getUser(r.userId);
        return {
          ...r,
          user: user ? { id: user.id, username: user.username, displayName: user.displayName, avatarUrl: user.avatarUrl } : null
        };
      }));
      res.json({ withdrawals: requestsWithUsers, total: Number(totalResult[0]?.count || 0) });
    } catch (error) {
      console.error("Failed to get withdrawals:", error);
      res.status(500).json({ message: "Failed to get withdrawals" });
    }
  });
  app2.post("/api/admin/withdrawals/:id/approve", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { paymentReference } = req.body;
      const adminId = req.session.userId;
      const request = await storage.approveWithdrawal(id, adminId, paymentReference);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_APPROVE_WITHDRAWAL",
        targetType: "withdrawal",
        targetId: id,
        details: { paymentReference },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, withdrawal: request });
    } catch (error) {
      console.error("Failed to approve withdrawal:", error);
      res.status(500).json({ message: error.message || "Failed to approve withdrawal" });
    }
  });
  app2.post("/api/admin/withdrawals/:id/reject", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const adminId = req.session.userId;
      if (!reason) {
        return res.status(400).json({ message: "Rejection reason is required" });
      }
      const request = await storage.rejectWithdrawal(id, adminId, reason);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_REJECT_WITHDRAWAL",
        targetType: "withdrawal",
        targetId: id,
        details: { reason },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, withdrawal: request });
    } catch (error) {
      console.error("Failed to reject withdrawal:", error);
      res.status(500).json({ message: error.message || "Failed to reject withdrawal" });
    }
  });
  app2.put("/api/admin/withdrawals/:id/approve", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { paymentReference } = req.body;
      const adminId = req.session.userId;
      const request = await storage.approveWithdrawal(id, adminId, paymentReference);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_APPROVE_WITHDRAWAL",
        targetType: "withdrawal",
        targetId: id,
        details: { paymentReference },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, withdrawal: request });
    } catch (error) {
      console.error("Failed to approve withdrawal:", error);
      res.status(500).json({ message: error.message || "Failed to approve withdrawal" });
    }
  });
  app2.put("/api/admin/withdrawals/:id/reject", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const adminId = req.session.userId;
      if (!reason) {
        return res.status(400).json({ message: "Rejection reason is required" });
      }
      const request = await storage.rejectWithdrawal(id, adminId, reason);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_REJECT_WITHDRAWAL",
        targetType: "withdrawal",
        targetId: id,
        details: { reason },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, withdrawal: request });
    } catch (error) {
      console.error("Failed to reject withdrawal:", error);
      res.status(500).json({ message: error.message || "Failed to reject withdrawal" });
    }
  });
  app2.put("/api/admin/withdrawals/:id/process", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { paymentReference } = req.body;
      const adminId = req.session.userId;
      if (!paymentReference) {
        return res.status(400).json({ message: "Payment reference is required" });
      }
      const request = await storage.processWithdrawal(id, adminId, paymentReference);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_PROCESS_WITHDRAWAL",
        targetType: "withdrawal",
        targetId: id,
        details: { paymentReference },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, withdrawal: request });
    } catch (error) {
      console.error("Failed to process withdrawal:", error);
      res.status(500).json({ message: error.message || "Failed to process withdrawal" });
    }
  });
  app2.get("/api/admin/kyc", requireAdmin, async (req, res) => {
    try {
      const status = req.query.status;
      const limit = Math.min(parseInt(req.query.limit) || 50, 100);
      const offset = parseInt(req.query.offset) || 0;
      let conditions = [];
      if (status) {
        conditions.push(eq17(userKyc.status, status));
      }
      const submissions = await db.select().from(userKyc).where(conditions.length > 0 ? and16(...conditions) : void 0).orderBy(desc11(userKyc.submittedAt)).limit(limit).offset(offset);
      const totalResult = await db.select({ count: sql11`count(*)` }).from(userKyc).where(conditions.length > 0 ? and16(...conditions) : void 0);
      const submissionsWithUsers = await Promise.all(submissions.map(async (s) => {
        const user = await storage.getUser(s.userId);
        return {
          ...s,
          user: user ? { id: user.id, username: user.username, displayName: user.displayName, email: user.email, avatarUrl: user.avatarUrl } : null
        };
      }));
      res.json({ submissions: submissionsWithUsers, total: Number(totalResult[0]?.count || 0) });
    } catch (error) {
      console.error("Failed to get KYC submissions:", error);
      res.status(500).json({ message: "Failed to get KYC submissions" });
    }
  });
  app2.get("/api/admin/kyc/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const [submission] = await db.select().from(userKyc).where(eq17(userKyc.id, id)).limit(1);
      if (!submission) {
        return res.status(404).json({ message: "KYC submission not found" });
      }
      const user = await storage.getUser(submission.userId);
      const reviewer = submission.reviewedBy ? await storage.getUser(submission.reviewedBy) : null;
      res.json({
        ...submission,
        user: user ? { id: user.id, username: user.username, displayName: user.displayName, email: user.email, avatarUrl: user.avatarUrl } : null,
        reviewer: reviewer ? { id: reviewer.id, username: reviewer.username, displayName: reviewer.displayName } : null
      });
    } catch (error) {
      console.error("Failed to get KYC details:", error);
      res.status(500).json({ message: "Failed to get KYC details" });
    }
  });
  app2.post("/api/admin/kyc/:id/approve", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const adminId = req.session.userId;
      const [submission] = await db.select().from(userKyc).where(eq17(userKyc.id, id)).limit(1);
      if (!submission) {
        return res.status(404).json({ message: "KYC submission not found" });
      }
      const kyc = await storage.reviewKyc(submission.userId, "APPROVED", adminId);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_APPROVE_KYC",
        targetType: "kyc",
        targetId: id,
        details: { userId: submission.userId },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, kyc });
    } catch (error) {
      console.error("Failed to approve KYC:", error);
      res.status(500).json({ message: error.message || "Failed to approve KYC" });
    }
  });
  app2.post("/api/admin/kyc/:id/reject", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const adminId = req.session.userId;
      if (!reason) {
        return res.status(400).json({ message: "Rejection reason is required" });
      }
      const [submission] = await db.select().from(userKyc).where(eq17(userKyc.id, id)).limit(1);
      if (!submission) {
        return res.status(404).json({ message: "KYC submission not found" });
      }
      const kyc = await storage.reviewKyc(submission.userId, "REJECTED", adminId, reason);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_REJECT_KYC",
        targetType: "kyc",
        targetId: id,
        details: { userId: submission.userId, reason },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, kyc });
    } catch (error) {
      console.error("Failed to reject KYC:", error);
      res.status(500).json({ message: error.message || "Failed to reject KYC" });
    }
  });
  app2.get("/api/admin/achievements", requireAdmin, async (req, res) => {
    try {
      const achievementsList = await db.select({
        id: achievements.id,
        name: achievements.name,
        description: achievements.description,
        category: achievements.category,
        iconUrl: achievements.iconUrl,
        requirement: achievements.requirement,
        rewardCoins: achievements.rewardCoins,
        rewardBadge: achievements.rewardBadge,
        sortOrder: achievements.sortOrder,
        isActive: achievements.isActive,
        isSecret: achievements.isSecret,
        createdAt: achievements.createdAt,
        awardedCount: sql11`(SELECT COUNT(*) FROM user_achievements WHERE achievement_id = ${achievements.id} AND is_completed = true)`
      }).from(achievements).orderBy(achievements.sortOrder);
      res.json(achievementsList);
    } catch (error) {
      console.error("Failed to get achievements:", error);
      res.status(500).json({ message: "Failed to get achievements" });
    }
  });
  app2.post("/api/admin/achievements", requireAdmin, async (req, res) => {
    try {
      const { name, description, category, requirement, rewardCoins, isSecret } = req.body;
      const [maxOrder] = await db.select({ max: sql11`COALESCE(MAX(sort_order), 0)` }).from(achievements);
      const [achievement] = await db.insert(achievements).values({
        id: crypto.randomUUID(),
        name,
        description,
        category,
        requirement,
        rewardCoins: parseInt(rewardCoins) || 0,
        isSecret: isSecret || false,
        sortOrder: (maxOrder?.max || 0) + 1,
        isActive: true
      }).returning();
      res.json({ success: true, achievement });
    } catch (error) {
      console.error("Failed to create achievement:", error);
      res.status(500).json({ message: error.message || "Failed to create achievement" });
    }
  });
  app2.put("/api/admin/achievements/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = {};
      if (req.body.name !== void 0) updates.name = req.body.name;
      if (req.body.description !== void 0) updates.description = req.body.description;
      if (req.body.category !== void 0) updates.category = req.body.category;
      if (req.body.requirement !== void 0) updates.requirement = req.body.requirement;
      if (req.body.rewardCoins !== void 0) updates.rewardCoins = parseInt(req.body.rewardCoins);
      if (req.body.isActive !== void 0) updates.isActive = req.body.isActive;
      if (req.body.isSecret !== void 0) updates.isSecret = req.body.isSecret;
      const [achievement] = await db.update(achievements).set(updates).where(eq17(achievements.id, id)).returning();
      if (!achievement) {
        return res.status(404).json({ message: "Achievement not found" });
      }
      res.json({ success: true, achievement });
    } catch (error) {
      console.error("Failed to update achievement:", error);
      res.status(500).json({ message: error.message || "Failed to update achievement" });
    }
  });
  app2.delete("/api/admin/achievements/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      await db.delete(userAchievements).where(eq17(userAchievements.achievementId, id));
      await db.delete(achievements).where(eq17(achievements.id, id));
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete achievement:", error);
      res.status(500).json({ message: error.message || "Failed to delete achievement" });
    }
  });
  app2.get("/api/admin/economy/stats", requireAdmin, async (req, res) => {
    try {
      const now = /* @__PURE__ */ new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1e3);
      const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1e3);
      const monthAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1e3);
      const [totalCoinsResult] = await db.select({
        totalCoins: sql11`COALESCE(SUM(coin_balance), 0)`,
        totalWallets: sql11`COUNT(*)`,
        frozenWallets: sql11`COUNT(*) FILTER (WHERE is_frozen = true)`
      }).from(wallets);
      const [todayTxResult] = await db.select({
        count: sql11`COUNT(*)`,
        earned: sql11`COALESCE(SUM(CASE WHEN amount > 0 THEN amount ELSE 0 END), 0)`,
        spent: sql11`COALESCE(SUM(CASE WHEN amount < 0 THEN ABS(amount) ELSE 0 END), 0)`
      }).from(coinTransactions).where(gte8(coinTransactions.createdAt, today));
      const [weekTxResult] = await db.select({
        count: sql11`COUNT(*)`
      }).from(coinTransactions).where(gte8(coinTransactions.createdAt, weekAgo));
      const [giftsResult] = await db.select({
        todayCount: sql11`COUNT(*) FILTER (WHERE created_at >= ${today})`,
        weekCount: sql11`COUNT(*) FILTER (WHERE created_at >= ${weekAgo})`,
        totalValue: sql11`COALESCE(SUM(total_coins), 0)`
      }).from(giftTransactions);
      const [withdrawalResult] = await db.select({
        pendingCount: sql11`COUNT(*) FILTER (WHERE status = 'PENDING')`,
        pendingAmount: sql11`COALESCE(SUM(CASE WHEN status = 'PENDING' THEN amount_coins ELSE 0 END), 0)`,
        approvedThisMonth: sql11`COUNT(*) FILTER (WHERE status = 'APPROVED' AND processed_at >= ${monthAgo})`
      }).from(withdrawalRequests);
      const [kycResult] = await db.select({
        pendingCount: sql11`COUNT(*) FILTER (WHERE status = 'PENDING')`,
        approvedCount: sql11`COUNT(*) FILTER (WHERE status = 'APPROVED')`,
        totalCount: sql11`COUNT(*)`
      }).from(userKyc);
      const [revenueResult] = await db.select({
        todayRevenue: sql11`COALESCE(SUM(CASE WHEN created_at >= ${today} THEN amount_rands ELSE 0 END), 0)`,
        weekRevenue: sql11`COALESCE(SUM(CASE WHEN created_at >= ${weekAgo} THEN amount_rands ELSE 0 END), 0)`,
        monthRevenue: sql11`COALESCE(SUM(CASE WHEN created_at >= ${monthAgo} THEN amount_rands ELSE 0 END), 0)`
      }).from(platformRevenue);
      const [bundlePurchases] = await db.select({
        todayCount: sql11`COUNT(*) FILTER (WHERE created_at >= ${today})`,
        weekCount: sql11`COUNT(*) FILTER (WHERE created_at >= ${weekAgo})`
      }).from(coinPurchases).where(eq17(coinPurchases.status, "COMPLETED"));
      res.json({
        circulation: {
          totalCoins: Number(totalCoinsResult?.totalCoins || 0),
          totalWallets: Number(totalCoinsResult?.totalWallets || 0),
          frozenWallets: Number(totalCoinsResult?.frozenWallets || 0)
        },
        transactions: {
          today: {
            count: Number(todayTxResult?.count || 0),
            earned: Number(todayTxResult?.earned || 0),
            spent: Number(todayTxResult?.spent || 0)
          },
          weekCount: Number(weekTxResult?.count || 0)
        },
        gifts: {
          todayCount: Number(giftsResult?.todayCount || 0),
          weekCount: Number(giftsResult?.weekCount || 0),
          totalValue: Number(giftsResult?.totalValue || 0)
        },
        withdrawals: {
          pendingCount: Number(withdrawalResult?.pendingCount || 0),
          pendingAmount: Number(withdrawalResult?.pendingAmount || 0),
          approvedThisMonth: Number(withdrawalResult?.approvedThisMonth || 0)
        },
        kyc: {
          pendingCount: Number(kycResult?.pendingCount || 0),
          approvedCount: Number(kycResult?.approvedCount || 0),
          totalCount: Number(kycResult?.totalCount || 0)
        },
        revenue: {
          today: Number(revenueResult?.todayRevenue || 0),
          week: Number(revenueResult?.weekRevenue || 0),
          month: Number(revenueResult?.monthRevenue || 0)
        },
        purchases: {
          todayCount: Number(bundlePurchases?.todayCount || 0),
          weekCount: Number(bundlePurchases?.weekCount || 0)
        }
      });
    } catch (error) {
      console.error("Failed to get economy stats:", error);
      res.status(500).json({ message: "Failed to get economy stats" });
    }
  });
  app2.get("/api/wealth-clubs", requireAuth4, async (req, res) => {
    try {
      const clubs = await storage.getWealthClubs();
      res.json(clubs);
    } catch (error) {
      console.error("Failed to get wealth clubs:", error);
      res.status(500).json({ message: error.message || "Failed to get wealth clubs" });
    }
  });
  app2.get("/api/my/wealth-club", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const userClub = await storage.getUserWealthClub(userId);
      res.json(userClub);
    } catch (error) {
      console.error("Failed to get user wealth club:", error);
      res.status(500).json({ message: error.message || "Failed to get user wealth club" });
    }
  });
  app2.post("/api/my/wealth-club/refresh", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      await storage.updateUserWealthClub(userId);
      const userClub = await storage.getUserWealthClub(userId);
      res.json({ success: true, wealthClub: userClub });
    } catch (error) {
      console.error("Failed to refresh wealth club:", error);
      res.status(500).json({ message: error.message || "Failed to refresh wealth club" });
    }
  });
  app2.get("/api/staking-tiers", requireAuth4, async (req, res) => {
    try {
      const tiers = await storage.getStakingTiers();
      res.json(tiers);
    } catch (error) {
      console.error("Failed to get staking tiers:", error);
      res.status(500).json({ message: error.message || "Failed to get staking tiers" });
    }
  });
  app2.get("/api/my/stakes", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const stakes = await storage.getUserStakes(userId);
      res.json(stakes);
    } catch (error) {
      console.error("Failed to get user stakes:", error);
      res.status(500).json({ message: error.message || "Failed to get user stakes" });
    }
  });
  app2.get("/api/staking/active", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const stakes = await storage.getUserStakes(userId);
      const activeStakes = stakes.map((stake) => ({
        id: stake.id,
        amount: stake.stakedCoins,
        bonusPercent: stake.bonusPercent,
        startDate: stake.stakedAt,
        endDate: stake.maturesAt,
        matured: new Date(stake.maturesAt) <= /* @__PURE__ */ new Date(),
        claimed: stake.status === "CLAIMED"
      }));
      res.json(activeStakes);
    } catch (error) {
      console.error("Failed to get active stakes:", error);
      res.status(500).json({ message: error.message || "Failed to get active stakes" });
    }
  });
  app2.post("/api/my/stakes", requireAuth4, async (req, res) => {
    try {
      const config = await storage.getEconomyConfig();
      if (config.staking_enabled === "false") {
        return res.status(503).json({ message: "Staking is temporarily disabled. Please try again later." });
      }
      const userId = req.session.userId;
      const { giftTransactionId, tierId } = req.body;
      if (!giftTransactionId || !tierId) {
        return res.status(400).json({ message: "giftTransactionId and tierId are required" });
      }
      const stake = await storage.createGiftStake(userId, giftTransactionId, tierId);
      res.json({ success: true, stake });
    } catch (error) {
      console.error("Failed to create stake:", error);
      res.status(400).json({ message: error.message || "Failed to create stake" });
    }
  });
  app2.post("/api/my/stakes/:stakeId/claim", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { stakeId } = req.params;
      const result = await storage.claimMaturedStake(stakeId, userId);
      res.json({ success: true, stake: result.stake, coinsEarned: result.coinsEarned });
    } catch (error) {
      console.error("Failed to claim stake:", error);
      res.status(400).json({ message: error.message || "Failed to claim stake" });
    }
  });
  app2.get("/api/achievements", requireAuth4, async (req, res) => {
    try {
      const achievements2 = await storage.getAchievements();
      res.json(achievements2);
    } catch (error) {
      console.error("Failed to get achievements:", error);
      res.status(500).json({ message: error.message || "Failed to get achievements" });
    }
  });
  app2.get("/api/my/achievements", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const userAchievements2 = await storage.getUserAchievements(userId);
      res.json(userAchievements2);
    } catch (error) {
      console.error("Failed to get user achievements:", error);
      res.status(500).json({ message: error.message || "Failed to get user achievements" });
    }
  });
  app2.post("/api/my/achievements/check", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const newlyCompleted = await storage.checkAndAwardAchievements(userId);
      res.json({ success: true, newlyCompleted });
    } catch (error) {
      console.error("Failed to check achievements:", error);
      res.status(500).json({ message: error.message || "Failed to check achievements" });
    }
  });
  app2.post("/api/my/achievements/:achievementId/claim", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { achievementId } = req.params;
      const coinsEarned = await storage.claimAchievementReward(userId, achievementId);
      res.json({ success: true, coinsEarned });
    } catch (error) {
      console.error("Failed to claim achievement:", error);
      res.status(400).json({ message: error.message || "Failed to claim achievement" });
    }
  });
  app2.get("/api/my/earnings", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const earnings = await storage.getOrCreateCreatorEarnings(userId);
      res.json(earnings);
    } catch (error) {
      console.error("Failed to get creator earnings:", error);
      res.status(500).json({ message: error.message || "Failed to get creator earnings" });
    }
  });
  app2.get("/api/my/earnings/history", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const history = await storage.getCreatorEarningsHistory(userId, limit, offset);
      res.json(history);
    } catch (error) {
      console.error("Failed to get earnings history:", error);
      res.status(500).json({ message: error.message || "Failed to get earnings history" });
    }
  });
  app2.get("/api/my/bank-accounts", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const accounts = await storage.getUserBankAccounts(userId);
      res.json(accounts);
    } catch (error) {
      console.error("Failed to get bank accounts:", error);
      res.status(500).json({ message: error.message || "Failed to get bank accounts" });
    }
  });
  app2.post("/api/my/bank-accounts", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { bankName, accountNumber, branchCode, accountType, accountHolderName } = req.body;
      if (!bankName || !accountNumber || !accountHolderName) {
        return res.status(400).json({ message: "bankName, accountNumber, and accountHolderName are required" });
      }
      const account = await storage.addBankAccount(userId, {
        bankName,
        accountNumber,
        branchCode: branchCode || null,
        accountType: accountType || "savings",
        accountHolderName
      });
      res.json({ success: true, account });
    } catch (error) {
      console.error("Failed to add bank account:", error);
      res.status(400).json({ message: error.message || "Failed to add bank account" });
    }
  });
  app2.delete("/api/my/bank-accounts/:bankAccountId", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { bankAccountId } = req.params;
      const deleted = await storage.deleteBankAccount(userId, bankAccountId);
      if (!deleted) {
        return res.status(404).json({ message: "Bank account not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to delete bank account:", error);
      res.status(400).json({ message: error.message || "Failed to delete bank account" });
    }
  });
  app2.put("/api/my/bank-accounts/:bankAccountId/primary", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { bankAccountId } = req.params;
      const account = await storage.setPrimaryBankAccount(userId, bankAccountId);
      res.json({ success: true, account });
    } catch (error) {
      console.error("Failed to set primary bank account:", error);
      res.status(400).json({ message: error.message || "Failed to set primary bank account" });
    }
  });
  app2.get("/api/my/kyc", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const kyc = await storage.getOrCreateKyc(userId);
      res.json(kyc);
    } catch (error) {
      console.error("Failed to get KYC status:", error);
      res.status(500).json({ message: error.message || "Failed to get KYC status" });
    }
  });
  app2.post("/api/my/kyc", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { idType, idNumber, idDocumentUrl, proofOfAddressUrl, selfieUrl, fullLegalName, dateOfBirth, nationality, address } = req.body;
      if (!idType || !idNumber || !idDocumentUrl) {
        return res.status(400).json({ message: "idType, idNumber, and idDocumentUrl are required" });
      }
      await storage.getOrCreateKyc(userId);
      const kyc = await storage.submitKyc(userId, {
        idType,
        idNumber,
        idDocumentUrl,
        proofOfAddressUrl: proofOfAddressUrl || null,
        selfieUrl: selfieUrl || null,
        fullLegalName: fullLegalName || null,
        dateOfBirth: dateOfBirth || null,
        nationality: nationality || null,
        address: address || null
      });
      res.json({ success: true, kyc });
    } catch (error) {
      console.error("Failed to submit KYC:", error);
      res.status(400).json({ message: error.message || "Failed to submit KYC" });
    }
  });
  app2.get("/api/my/withdrawals", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const status = req.query.status;
      const limit = Math.min(parseInt(req.query.limit) || 50, 100);
      const withdrawals = await storage.getWithdrawalRequests(userId, status, limit);
      res.json(withdrawals);
    } catch (error) {
      console.error("Failed to get withdrawals:", error);
      res.status(500).json({ message: error.message || "Failed to get withdrawals" });
    }
  });
  app2.post("/api/my/withdrawals", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { amountCoins, bankAccountId } = req.body;
      if (!amountCoins || !bankAccountId) {
        return res.status(400).json({ message: "amountCoins and bankAccountId are required" });
      }
      const config = await storage.getEconomyConfig();
      if (config.withdrawals_enabled === "false") {
        return res.status(503).json({ message: "Withdrawals are temporarily disabled. Please try again later." });
      }
      const minWithdrawalCoins = parseInt(config.minWithdrawalCoins || "1000");
      const kycRequiredForWithdrawal = config.kycRequiredForWithdrawal !== "false";
      if (parseInt(amountCoins) < minWithdrawalCoins) {
        return res.status(400).json({ message: `Minimum withdrawal is ${minWithdrawalCoins} coins` });
      }
      if (kycRequiredForWithdrawal) {
        const kyc = await storage.getOrCreateKyc(userId);
        if (kyc.status !== "APPROVED") {
          return res.status(400).json({ message: "KYC verification required before withdrawal" });
        }
      }
      const bankAccount = await storage.getBankAccountById(bankAccountId);
      if (!bankAccount || bankAccount.userId !== userId) {
        return res.status(400).json({ message: "Invalid bank account" });
      }
      const withdrawal = await storage.createWithdrawalRequest(userId, bankAccountId, parseInt(amountCoins));
      res.json({ success: true, withdrawal });
    } catch (error) {
      console.error("Failed to create withdrawal request:", error);
      res.status(400).json({ message: error.message || "Failed to create withdrawal request" });
    }
  });
  app2.get("/api/my/withdrawals/:withdrawalId", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { withdrawalId } = req.params;
      const withdrawal = await storage.getWithdrawalById(withdrawalId);
      if (!withdrawal || withdrawal.userId !== userId) {
        return res.status(404).json({ message: "Withdrawal not found" });
      }
      const bankAccount = await storage.getBankAccountById(withdrawal.bankAccountId);
      res.json({
        ...withdrawal,
        bankAccount: bankAccount ? {
          id: bankAccount.id,
          bankName: bankAccount.bankName,
          accountNumber: bankAccount.accountNumber.slice(-4).padStart(bankAccount.accountNumber.length, "*"),
          accountType: bankAccount.accountType
        } : null
      });
    } catch (error) {
      console.error("Failed to get withdrawal details:", error);
      res.status(500).json({ message: error.message || "Failed to get withdrawal details" });
    }
  });
  app2.post("/api/my/accept-terms", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { acceptTerms, acceptPrivacy, acceptCommunityGuidelines, marketingOptIn, legalVersion } = req.body;
      if (!acceptTerms || !acceptPrivacy || !acceptCommunityGuidelines) {
        return res.status(400).json({ message: "You must accept terms, privacy policy, and community guidelines" });
      }
      const updateData = {
        legalVersion: legalVersion || "1.0"
      };
      if (acceptTerms) updateData.termsAcceptedAt = /* @__PURE__ */ new Date();
      if (acceptPrivacy) updateData.privacyAcceptedAt = /* @__PURE__ */ new Date();
      if (acceptCommunityGuidelines) updateData.communityGuidelinesAcceptedAt = /* @__PURE__ */ new Date();
      if (typeof marketingOptIn === "boolean") updateData.marketingOptIn = marketingOptIn;
      await db.update(users).set(updateData).where(eq17(users.id, userId));
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to accept terms:", error);
      res.status(500).json({ message: error.message || "Failed to accept terms" });
    }
  });
  app2.get("/api/battles", requireAuth4, async (req, res) => {
    try {
      const battles = await storage.getActiveBattles();
      res.json(battles);
    } catch (error) {
      console.error("Failed to get battles:", error);
      res.status(500).json({ message: error.message || "Failed to get battles" });
    }
  });
  app2.post("/api/battles", requireAuth4, async (req, res) => {
    try {
      const config = await storage.getEconomyConfig();
      if (config.battles_enabled === "false") {
        return res.status(503).json({ message: "Platform battles are temporarily disabled. Please try again later." });
      }
      const creatorId = req.session.userId;
      const { name, description, entryFeeCoins, startsAt, endsAt, maxParticipants } = req.body;
      if (!name || !startsAt || !endsAt) {
        return res.status(400).json({ message: "name, startsAt, and endsAt are required" });
      }
      const battle = await storage.createBattle(creatorId, {
        name,
        description,
        entryFeeCoins: entryFeeCoins ? parseInt(entryFeeCoins) : 0,
        startsAt: new Date(startsAt),
        endsAt: new Date(endsAt),
        maxParticipants: maxParticipants ? parseInt(maxParticipants) : void 0
      });
      res.json({ success: true, battle });
    } catch (error) {
      console.error("Failed to create battle:", error);
      res.status(400).json({ message: error.message || "Failed to create battle" });
    }
  });
  app2.post("/api/battles/:battleId/join", requireAuth4, async (req, res) => {
    try {
      const userId = req.session.userId;
      const { battleId } = req.params;
      const participant = await storage.joinBattle(battleId, userId);
      res.json({ success: true, participant });
    } catch (error) {
      console.error("Failed to join battle:", error);
      res.status(400).json({ message: error.message || "Failed to join battle" });
    }
  });
  app2.post("/api/battles/:battleId/gift", requireAuth4, async (req, res) => {
    try {
      const { battleId } = req.params;
      const { recipientId, coins } = req.body;
      if (!recipientId || !coins) {
        return res.status(400).json({ message: "recipientId and coins are required" });
      }
      await storage.recordBattleGift(battleId, recipientId, parseInt(coins));
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to record battle gift:", error);
      res.status(400).json({ message: error.message || "Failed to record battle gift" });
    }
  });
  app2.get("/api/admin/economy-config", requireAdmin, async (req, res) => {
    try {
      const config = await storage.getEconomyConfig();
      res.json(config);
    } catch (error) {
      console.error("Failed to get economy config:", error);
      res.status(500).json({ message: error.message || "Failed to get economy config" });
    }
  });
  app2.put("/api/admin/economy-config/:key", requireAdmin, async (req, res) => {
    try {
      const adminId = req.session.userId;
      const { key } = req.params;
      const { value } = req.body;
      if (value === void 0) {
        return res.status(400).json({ message: "value is required" });
      }
      await storage.setEconomyConfig(key, String(value), adminId);
      await storage.createAuditLog({
        actorId: adminId,
        action: "UPDATE_SETTING",
        targetType: "economy_config",
        targetId: key,
        details: { key, value },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to set economy config:", error);
      res.status(500).json({ message: error.message || "Failed to set economy config" });
    }
  });
  app2.post("/api/admin/battles/:battleId/end", requireAdmin, async (req, res) => {
    try {
      const adminId = req.session.userId;
      const { battleId } = req.params;
      const battle = await storage.endBattle(battleId);
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_END_BATTLE",
        targetType: "battle",
        targetId: battleId,
        details: { winnerId: battle.winnerId, prizePoolCoins: battle.prizePoolCoins },
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, battle });
    } catch (error) {
      console.error("Failed to end battle:", error);
      res.status(400).json({ message: error.message || "Failed to end battle" });
    }
  });
  app2.get("/api/admin/wealth-clubs", requireAdmin, async (req, res) => {
    try {
      const clubs = await storage.getWealthClubs();
      const clubsWithCounts = await Promise.all(
        clubs.map(async (club) => {
          const [countResult] = await db.select({
            count: sql11`COUNT(*)::int`
          }).from(userWealthClub).where(eq17(userWealthClub.clubId, club.id));
          return {
            ...club,
            memberCount: countResult?.count || 0
          };
        })
      );
      res.json(clubsWithCounts);
    } catch (error) {
      console.error("Failed to get admin wealth clubs:", error);
      res.status(500).json({ message: error.message || "Failed to get wealth clubs" });
    }
  });
  app2.put("/api/admin/wealth-clubs/:clubId", requireAdmin, async (req, res) => {
    try {
      const adminId = req.session.userId;
      const { clubId } = req.params;
      const { name, description, iconUrl, color, minNetWorth, maxNetWorth, benefits, discountPercent, bonusCoinPercent, prioritySupport, exclusiveContent } = req.body;
      const updateData = {};
      if (name !== void 0) updateData.name = name;
      if (description !== void 0) updateData.description = description;
      if (iconUrl !== void 0) updateData.iconUrl = iconUrl;
      if (color !== void 0) updateData.color = color;
      if (minNetWorth !== void 0) updateData.minNetWorth = parseInt(minNetWorth);
      if (maxNetWorth !== void 0) updateData.maxNetWorth = maxNetWorth ? parseInt(maxNetWorth) : null;
      if (benefits !== void 0) updateData.benefits = benefits;
      if (discountPercent !== void 0) updateData.discountPercent = parseInt(discountPercent);
      if (bonusCoinPercent !== void 0) updateData.bonusCoinPercent = parseInt(bonusCoinPercent);
      if (prioritySupport !== void 0) updateData.prioritySupport = prioritySupport;
      if (exclusiveContent !== void 0) updateData.exclusiveContent = exclusiveContent;
      updateData.updatedAt = /* @__PURE__ */ new Date();
      const [updatedClub] = await db.update(wealthClubs).set(updateData).where(eq17(wealthClubs.id, clubId)).returning();
      if (!updatedClub) {
        return res.status(404).json({ message: "Wealth club not found" });
      }
      await storage.createAuditLog({
        actorId: adminId,
        action: "ADMIN_UPDATE_WEALTH_CLUB",
        targetType: "wealth_club",
        targetId: clubId,
        details: updateData,
        ipAddress: req.ip || "unknown",
        userAgent: req.headers["user-agent"] || "unknown"
      });
      res.json({ success: true, club: updatedClub });
    } catch (error) {
      console.error("Failed to update wealth club:", error);
      res.status(500).json({ message: error.message || "Failed to update wealth club" });
    }
  });
  app2.get("/api/admin/wealth-clubs/:clubId/members", requireAdmin, async (req, res) => {
    try {
      const { clubId } = req.params;
      const members = await db.select({
        id: userWealthClub.id,
        userId: userWealthClub.userId,
        clubId: userWealthClub.clubId,
        joinedAt: userWealthClub.joinedAt,
        user: {
          id: users.id,
          username: users.username,
          displayName: users.displayName,
          avatarUrl: users.avatarUrl,
          netWorth: users.netWorth
        }
      }).from(userWealthClub).innerJoin(users, eq17(userWealthClub.userId, users.id)).where(eq17(userWealthClub.clubId, clubId)).orderBy(desc11(users.netWorth)).limit(100);
      res.json(members);
    } catch (error) {
      console.error("Failed to get wealth club members:", error);
      res.status(500).json({ message: error.message || "Failed to get members" });
    }
  });
  app2.get("/api/admin/staking-tiers", requireAdmin, async (req, res) => {
    try {
      const tiers = await db.select().from(stakingTiers).orderBy(stakingTiers.sortOrder);
      res.json(tiers);
    } catch (error) {
      console.error("Failed to get staking tiers:", error);
      res.status(500).json({ message: error.message || "Failed to get staking tiers" });
    }
  });
  app2.get("/api/admin/battles", requireAdmin, async (req, res) => {
    try {
      const battles = await db.select({
        id: platformBattles.id,
        name: platformBattles.name,
        description: platformBattles.description,
        creatorId: platformBattles.creatorId,
        status: platformBattles.status,
        entryFeeCoins: platformBattles.entryFeeCoins,
        prizePoolCoins: platformBattles.prizePoolCoins,
        platformFeePercent: platformBattles.platformFeePercent,
        maxParticipants: platformBattles.maxParticipants,
        startsAt: platformBattles.startsAt,
        endsAt: platformBattles.endsAt,
        createdAt: platformBattles.createdAt
      }).from(platformBattles).orderBy(desc11(platformBattles.createdAt));
      const battlesWithCounts = await Promise.all(battles.map(async (battle) => {
        const [countResult] = await db.select({ count: sql11`count(*)` }).from(battleParticipants).where(eq17(battleParticipants.battleId, battle.id));
        return { ...battle, participantCount: Number(countResult?.count || 0) };
      }));
      res.json(battlesWithCounts);
    } catch (error) {
      console.error("Failed to get battles:", error);
      res.status(500).json({ message: error.message || "Failed to get battles" });
    }
  });
  app2.get("/api/admin/battles/:battleId", requireAdmin, async (req, res) => {
    try {
      const { battleId } = req.params;
      const [battle] = await db.select().from(platformBattles).where(eq17(platformBattles.id, battleId));
      if (!battle) {
        return res.status(404).json({ message: "Battle not found" });
      }
      const participants = await db.select({
        id: battleParticipants.id,
        battleId: battleParticipants.battleId,
        userId: battleParticipants.userId,
        totalGiftsReceived: battleParticipants.totalGiftsReceived,
        totalCoinsReceived: battleParticipants.totalCoinsReceived,
        rank: battleParticipants.rank,
        joinedAt: battleParticipants.joinedAt,
        user: {
          id: users.id,
          username: users.username,
          displayName: users.displayName,
          avatarUrl: users.avatarUrl
        }
      }).from(battleParticipants).innerJoin(users, eq17(battleParticipants.userId, users.id)).where(eq17(battleParticipants.battleId, battleId)).orderBy(desc11(battleParticipants.totalCoinsReceived));
      res.json({ ...battle, participants });
    } catch (error) {
      console.error("Failed to get battle details:", error);
      res.status(500).json({ message: error.message || "Failed to get battle details" });
    }
  });
  return httpServer;
}

// server/validate-env.ts
var REQUIRED_ENV_VARS = [
  {
    name: "DATABASE_URL",
    message: `
DATABASE_URL is not set!

How to fix on Replit:
  1. Open the "Database" tool in the left sidebar
  2. Click "Create Database" to provision PostgreSQL
  3. DATABASE_URL will be automatically set

How to fix locally:
  1. Install PostgreSQL
  2. Create a database: createdb rabitchat
  3. Set DATABASE_URL in your .env file:
     DATABASE_URL="postgresql://user:password@localhost:5432/rabitchat"

See /docs/SETUP.md for detailed instructions.
`
  },
  {
    name: "SESSION_SECRET",
    message: `
SESSION_SECRET is not set!

How to fix on Replit:
  1. Open the "Secrets" tab in the Tools panel
  2. Add a new secret with key: SESSION_SECRET
  3. Generate a secure value with:
     node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
  4. Paste the generated value

How to fix locally:
  1. Copy .env.example to .env
  2. Generate a secret: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
  3. Set SESSION_SECRET in your .env file

See /docs/SETUP.md for detailed instructions.
`
  }
];
function validateEnvironment() {
  const missing = [];
  for (const envVar of REQUIRED_ENV_VARS) {
    if (!process.env[envVar.name]) {
      console.error(`
${"=".repeat(60)}`);
      console.error(`ERROR: Missing required environment variable`);
      console.error(`${"=".repeat(60)}`);
      console.error(envVar.message);
      missing.push(envVar.name);
    }
  }
  if (missing.length > 0) {
    console.error(`
${"=".repeat(60)}`);
    console.error(`Missing ${missing.length} required variable(s): ${missing.join(", ")}`);
    console.error(`${"=".repeat(60)}
`);
    process.exit(1);
  }
  if (process.env.NODE_ENV === "production" && process.env.SESSION_SECRET === "rabitchat-secret-key") {
    console.warn(`
${"!".repeat(60)}
WARNING: Using default SESSION_SECRET in production!
This is a security risk. Please set a unique SESSION_SECRET.
${"!".repeat(60)}
`);
  }
  console.log("Environment validation passed");
}

// server/logger.ts
import crypto4 from "crypto";
function formatLog(log3) {
  const parts = [
    `[${log3.timestamp}]`,
    `[${log3.requestId}]`,
    log3.userId ? `[user:${log3.userId}]` : "[user:-]",
    `${log3.method} ${log3.path}`
  ];
  if (log3.statusCode !== void 0) {
    parts.push(`${log3.statusCode}`);
  }
  if (log3.duration !== void 0) {
    parts.push(`${log3.duration}ms`);
  }
  if (log3.error) {
    parts.push(`ERROR: ${log3.error}`);
  }
  return parts.join(" ");
}
function requestLogger(req, res, next) {
  req.requestId = crypto4.randomUUID().slice(0, 8);
  req.startTime = Date.now();
  const log3 = {
    requestId: req.requestId,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    method: req.method,
    path: req.path,
    userId: req.session?.userId,
    ip: req.ip || req.socket.remoteAddress,
    userAgent: req.get("user-agent")
  };
  res.on("finish", () => {
    log3.statusCode = res.statusCode;
    log3.duration = Date.now() - req.startTime;
    log3.userId = req.session?.userId;
    if (res.statusCode >= 400) {
      console.error(formatLog(log3));
    } else {
      console.log(formatLog(log3));
    }
  });
  next();
}
function log(level, message, context) {
  const timestamp3 = (/* @__PURE__ */ new Date()).toISOString();
  const contextStr = context ? ` ${JSON.stringify(context)}` : "";
  const output = `[${timestamp3}] [${level.toUpperCase()}] ${message}${contextStr}`;
  switch (level) {
    case "error":
      console.error(output);
      break;
    case "warn":
      console.warn(output);
      break;
    default:
      console.log(output);
  }
}

// server/sentry.ts
var sentryModule = null;
async function initSentry() {
  const dsn = process.env.SENTRY_DSN;
  if (!dsn) {
    log("info", "Sentry DSN not configured, error tracking disabled");
    return false;
  }
  try {
    const Sentry = await Function('return import("@sentry/node")')();
    sentryModule = Sentry;
    Sentry.init({
      dsn,
      environment: process.env.NODE_ENV || "development",
      tracesSampleRate: 0.1,
      beforeSend(event) {
        if (event.user && typeof event.user === "object") {
          delete event.user.ip_address;
        }
        return event;
      }
    });
    log("info", "Sentry initialized successfully");
    return true;
  } catch (error) {
    log("warn", "Sentry not installed or failed to initialize - run 'npm install @sentry/node' to enable", { error: String(error) });
    return false;
  }
}
function sentryRequestHandler() {
  if (sentryModule) {
    return sentryModule.Handlers.requestHandler();
  }
  return (_req, _res, next) => next();
}
function sentryErrorHandler() {
  if (sentryModule) {
    return sentryModule.Handlers.errorHandler();
  }
  return (err, _req, _res, next) => next(err);
}
function captureException(error, context) {
  if (sentryModule) {
    sentryModule.captureException(error, { extra: context });
  }
}

// server/health.ts
init_db();
import { Router } from "express";
import { sql as sql12 } from "drizzle-orm";
var router = Router();
var startTime = Date.now();
router.get("/api/health", async (_req, res) => {
  const health = {
    status: "healthy",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    version: "1.0.5",
    uptime: Math.floor((Date.now() - startTime) / 1e3),
    checks: {
      database: { status: "ok" },
      memory: { status: "ok", heapUsed: 0, heapTotal: 0, percentUsed: 0 }
    }
  };
  try {
    const dbStart = Date.now();
    await db.execute(sql12`SELECT 1`);
    health.checks.database.latency = Date.now() - dbStart;
  } catch (error) {
    health.checks.database = {
      status: "error",
      error: error instanceof Error ? error.message : "Database connection failed"
    };
    health.status = "unhealthy";
  }
  const memUsage = process.memoryUsage();
  const percentUsed = Math.round(memUsage.heapUsed / memUsage.heapTotal * 100);
  health.checks.memory = {
    status: percentUsed > 95 ? "warning" : "ok",
    heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),
    heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),
    percentUsed
  };
  if (percentUsed > 95) {
    health.status = health.status === "unhealthy" ? "unhealthy" : "degraded";
  }
  const statusCode = health.status === "healthy" ? 200 : health.status === "degraded" ? 200 : 503;
  res.status(statusCode).json(health);
});
router.get("/api/health/live", (_req, res) => {
  res.status(200).json({ status: "ok" });
});
router.get("/api/health/ready", async (_req, res) => {
  try {
    await db.execute(sql12`SELECT 1`);
    res.status(200).json({ status: "ready" });
  } catch {
    res.status(503).json({ status: "not ready" });
  }
});
var health_default = router;

// server/index.ts
import * as fs2 from "fs";
import * as path2 from "path";

// server/gossip-jobs.ts
import cron from "node-cron";
var jobsInitialized = false;
function initGossipJobs() {
  if (jobsInitialized) {
    console.log("Gossip jobs already initialized, skipping...");
    return;
  }
  console.log("Initializing gossip background jobs...");
  cron.schedule("*/5 * * * *", async () => {
    try {
      console.log("[Gossip Jobs] Running whisper cleanup...");
      const cleaned = await gossipStorage.cleanupExpiredWhispers();
      console.log(`[Gossip Jobs] Cleaned ${cleaned} expired whisper posts`);
    } catch (error) {
      console.error("[Gossip Jobs] Whisper cleanup failed:", error);
    }
  });
  cron.schedule("0 * * * *", async () => {
    try {
      console.log("[Gossip Jobs] Recalculating trending scores...");
      await gossipStorage.recalculateTrendingScores();
      console.log("[Gossip Jobs] Trending scores updated");
    } catch (error) {
      console.error("[Gossip Jobs] Trending recalculation failed:", error);
    }
  });
  cron.schedule("0 0 * * *", async () => {
    try {
      console.log("[Gossip Jobs] Updating daily streaks...");
      await gossipStorage.updateDailyStreaks();
      console.log("[Gossip Jobs] Streaks updated");
    } catch (error) {
      console.error("[Gossip Jobs] Streak update failed:", error);
    }
  });
  cron.schedule("0 0 * * 1", async () => {
    try {
      console.log("[Gossip Jobs] Resetting weekly stats...");
      await gossipStorage.resetWeeklyStats();
      console.log("[Gossip Jobs] Weekly stats reset");
    } catch (error) {
      console.error("[Gossip Jobs] Weekly reset failed:", error);
    }
  });
  jobsInitialized = true;
  console.log("Gossip background jobs initialized:");
  console.log("  - Whisper cleanup: every 5 minutes");
  console.log("  - Trending recalculation: every hour");
  console.log("  - Daily streaks: every day at midnight UTC");
  console.log("  - Weekly stats reset: every Monday at midnight UTC");
}

// server/index.ts
init_db();
validateEnvironment();
var app = express();
var log2 = console.log;
app.set("trust proxy", 1);
function setupCors(app2) {
  app2.use((req, res, next) => {
    const origins = /* @__PURE__ */ new Set();
    if (process.env.REPLIT_DEV_DOMAIN) {
      origins.add(`https://${process.env.REPLIT_DEV_DOMAIN}`);
    }
    if (process.env.REPLIT_DOMAINS) {
      process.env.REPLIT_DOMAINS.split(",").forEach((d) => {
        origins.add(`https://${d.trim()}`);
      });
    }
    const origin = req.header("origin");
    const isLocalhost = origin?.startsWith("http://localhost:") || origin?.startsWith("http://127.0.0.1:");
    if (origin && (origins.has(origin) || isLocalhost)) {
      res.header("Access-Control-Allow-Origin", origin);
      res.header(
        "Access-Control-Allow-Methods",
        "GET, POST, PUT, DELETE, OPTIONS"
      );
      res.header("Access-Control-Allow-Headers", "Content-Type, Content-Length, X-Requested-With");
      res.header("Access-Control-Allow-Credentials", "true");
      res.header("Access-Control-Expose-Headers", "Content-Length");
    }
    if (req.method === "OPTIONS") {
      return res.sendStatus(200);
    }
    next();
  });
}
function setupBodyParsing(app2) {
  app2.use((req, res, next) => {
    const contentType = req.headers["content-type"] || "";
    const isUploadRoute = req.path === "/api/upload" || req.path.startsWith("/api/upload/");
    const isMultipart = contentType.includes("multipart/form-data");
    if (isUploadRoute && isMultipart) {
      console.log(`[BodyParser] Skipping body parsing for upload: ${req.path}`);
      return next();
    }
    if (!isMultipart) {
      return express.json({
        limit: "100mb",
        verify: (req2, _res, buf) => {
          req2.rawBody = buf;
        }
      })(req, res, next);
    }
    next();
  });
  app2.use((req, res, next) => {
    const contentType = req.headers["content-type"] || "";
    if (!contentType.includes("multipart/form-data")) {
      return express.urlencoded({ extended: false, limit: "100mb" })(req, res, next);
    }
    next();
  });
}
function setupRequestLogging(app2) {
  app2.use((req, res, next) => {
    const start = Date.now();
    const path3 = req.path;
    let capturedJsonResponse = void 0;
    const originalResJson = res.json;
    res.json = function(bodyJson, ...args) {
      capturedJsonResponse = bodyJson;
      return originalResJson.apply(res, [bodyJson, ...args]);
    };
    res.on("finish", () => {
      if (!path3.startsWith("/api")) return;
      const duration = Date.now() - start;
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log2(logLine);
    });
    next();
  });
}
function getAppName() {
  try {
    const appJsonPath = path2.resolve(process.cwd(), "app.json");
    const appJsonContent = fs2.readFileSync(appJsonPath, "utf-8");
    const appJson = JSON.parse(appJsonContent);
    return appJson.expo?.name || "App Landing Page";
  } catch {
    return "App Landing Page";
  }
}
function serveExpoManifest(platform, res) {
  const manifestPath = path2.resolve(
    process.cwd(),
    "static-build",
    platform,
    "manifest.json"
  );
  if (!fs2.existsSync(manifestPath)) {
    return res.status(404).json({ error: `Manifest not found for platform: ${platform}` });
  }
  res.setHeader("expo-protocol-version", "1");
  res.setHeader("expo-sfv-version", "0");
  res.setHeader("content-type", "application/json");
  const manifest = fs2.readFileSync(manifestPath, "utf-8");
  res.send(manifest);
}
function serveLandingPage({
  req,
  res,
  landingPageTemplate,
  appName
}) {
  const forwardedProto = req.header("x-forwarded-proto");
  const protocol = forwardedProto || req.protocol || "https";
  const forwardedHost = req.header("x-forwarded-host");
  const host = forwardedHost || req.get("host");
  const baseUrl = `${protocol}://${host}`;
  const expsUrl = `${host}`;
  log2(`baseUrl`, baseUrl);
  log2(`expsUrl`, expsUrl);
  const html = landingPageTemplate.replace(/BASE_URL_PLACEHOLDER/g, baseUrl).replace(/EXPS_URL_PLACEHOLDER/g, expsUrl).replace(/APP_NAME_PLACEHOLDER/g, appName);
  res.setHeader("Content-Type", "text/html; charset=utf-8");
  res.status(200).send(html);
}
function configureExpoAndLanding(app2) {
  const templatePath = path2.resolve(
    process.cwd(),
    "server",
    "templates",
    "landing-page.html"
  );
  const landingPageTemplate = fs2.readFileSync(templatePath, "utf-8");
  const appName = getAppName();
  log2("Serving static Expo files with dynamic manifest routing");
  const adminPanelPath = path2.resolve(process.cwd(), "server", "admin", "index.html");
  app2.get("/admin", (req, res) => {
    res.sendFile(adminPanelPath);
  });
  app2.get("/admin/*", (req, res) => {
    res.sendFile(adminPanelPath);
  });
  app2.use((req, res, next) => {
    if (req.path.startsWith("/api")) {
      return next();
    }
    if (req.path !== "/" && req.path !== "/manifest") {
      return next();
    }
    const platform = req.header("expo-platform");
    if (platform && (platform === "ios" || platform === "android")) {
      return serveExpoManifest(platform, res);
    }
    if (req.path === "/") {
      return serveLandingPage({
        req,
        res,
        landingPageTemplate,
        appName
      });
    }
    next();
  });
  app2.use("/assets", express.static(path2.resolve(process.cwd(), "assets")));
  app2.use(express.static(path2.resolve(process.cwd(), "static-build")));
  log2("Expo routing: Checking expo-platform header on / and /manifest");
}
function setupSecurityHeaders(app2) {
  app2.use(
    helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
          fontSrc: ["'self'", "https://fonts.gstatic.com"],
          imgSrc: ["'self'", "data:", "https:", "blob:"],
          scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'", "https://cdn.jsdelivr.net"],
          scriptSrcAttr: ["'unsafe-inline'"],
          connectSrc: ["'self'", "https:", "wss:"],
          frameSrc: ["'none'"],
          objectSrc: ["'none'"],
          formAction: ["'self'", "javascript:"],
          upgradeInsecureRequests: process.env.NODE_ENV === "production" ? [] : null
        }
      },
      crossOriginEmbedderPolicy: false,
      crossOriginOpenerPolicy: { policy: "same-origin-allow-popups" },
      crossOriginResourcePolicy: { policy: "cross-origin" },
      hsts: {
        maxAge: 31536e3,
        includeSubDomains: true,
        preload: true
      },
      originAgentCluster: true,
      referrerPolicy: { policy: "strict-origin-when-cross-origin" },
      xContentTypeOptions: true,
      xDnsPrefetchControl: { allow: false },
      xDownloadOptions: true,
      xFrameOptions: { action: "deny" },
      xPermittedCrossDomainPolicies: { permittedPolicies: "none" },
      xPoweredBy: false,
      xXssProtection: true
    })
  );
}
function setupRateLimiting(app2) {
  app2.use("/api/", apiLimiter);
}
function setupErrorHandler(app2) {
  app2.use(sentryErrorHandler());
  app2.use((err, req, res, _next) => {
    const error = err;
    const status = error.status || error.statusCode || 500;
    const message = status === 500 ? "An unexpected error occurred" : error.message || "Internal Server Error";
    const errorCode = error.code || (status === 500 ? ErrorCodes.INTERNAL_ERROR : "ERROR");
    log("error", "Unhandled error", {
      requestId: req.requestId,
      userId: req.session?.userId,
      path: req.path,
      method: req.method,
      error: error.message,
      status
    });
    if (status === 500 && err instanceof Error) {
      captureException(err, {
        requestId: req.requestId,
        userId: req.session?.userId,
        path: req.path
      });
    }
    res.status(status).json(apiError(errorCode, message));
  });
}
(async () => {
  initSentry().catch((err) => console.error("Sentry init failed:", err));
  app.use((req, res, next) => {
    if (req.path.startsWith("/api/upload")) {
      console.log(`[EARLY] Upload request received: ${req.method} ${req.path}`);
      console.log(`[EARLY] Content-Length: ${req.headers["content-length"]}`);
      console.log(`[EARLY] Content-Type: ${req.headers["content-type"]?.substring(0, 60)}`);
    }
    next();
  });
  app.use(sentryRequestHandler());
  setupSecurityHeaders(app);
  setupCors(app);
  setupBodyParsing(app);
  setupRateLimiting(app);
  setupRequestLogging(app);
  app.use(requestLogger);
  app.use(health_default);
  configureExpoAndLanding(app);
  const server = await registerRoutes(app);
  setupErrorHandler(app);
  server.keepAliveTimeout = 6e5;
  server.headersTimeout = 61e4;
  server.timeout = 9e5;
  const port = parseInt(process.env.PORT || "5000", 10);
  server.listen(
    {
      port,
      host: "0.0.0.0",
      reusePort: true
    },
    async () => {
      log2(`express server serving on port ${port}`);
      log2(`Server timeouts configured: keepAlive=${server.keepAliveTimeout}ms, headers=${server.headersTimeout}ms, request=${server.timeout}ms`);
      try {
        await runStartupMigrations();
      } catch (err) {
        console.error("Startup migrations failed:", err);
      }
      initGossipJobs();
      if (fs2.existsSync(UPLOAD_TEMP_DIR)) {
        cleanupOldTempFiles(30 * 60 * 1e3);
      }
      setInterval(() => {
        cleanupOldTempFiles(30 * 60 * 1e3);
      }, 30 * 60 * 1e3);
    }
  );
})();
